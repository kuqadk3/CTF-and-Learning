/* This file was generated by the Hex-Rays decompiler version 8.4.0.240320.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

ULONG __fastcall _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<>(__int64 a1, unsigned __int8 *a2);
ULONG __fastcall _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapSid<_SID>,_tlgWrapSz<unsigned short>,_tlgWrapSz<unsigned short>,_tlgWrapSz<unsigned short>,_tlgWrapperByVal<4>>(__int64 a1, unsigned __int8 *a2, __int64 a3, __int64 a4, __int64 a5, const WCHAR **a6, const WCHAR **a7, const WCHAR **a8, __int64 a9);
ULONG __fastcall _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapSid<_SID>,_tlgWrapSz<unsigned short>,_tlgWrapSz<unsigned short>,_tlgWrapperByVal<4>>(__int64 a1, unsigned __int8 *a2, __int64 a3, __int64 a4, __int64 a5, const WCHAR **a6, const WCHAR **a7, __int64 a8);
ULONG __fastcall _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapSz<unsigned short>,_tlgWrapSz<unsigned short>,_tlgWrapSz<unsigned short>,_tlgWrapperByVal<4>>(__int64 a1, unsigned __int8 *a2, __int64 a3, __int64 a4, const WCHAR **a5, const WCHAR **a6, const WCHAR **a7, __int64 a8);
ULONG __fastcall _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapperByVal<4>,_tlgWrapSid<_SID>>(__int64 a1, unsigned __int8 *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
ULONG __fastcall _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapSz<unsigned short>,_tlgWrapperByVal<4>>(__int64 a1, unsigned __int8 *a2, __int64 a3, __int64 a4, const WCHAR **a5, __int64 a6);
ULONG __fastcall _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapSz<unsigned short>,_tlgWrapperByVal<4>,_tlgWrapSz<unsigned short>>(__int64 a1, unsigned __int8 *a2, __int64 a3, __int64 a4, const WCHAR **a5, __int64 a6, const WCHAR **a7);
ULONG __fastcall _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapSz<unsigned short>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>>(__int64 a1, unsigned __int8 *a2, __int64 a3, __int64 a4, const WCHAR **a5, __int64 a6, __int64 a7);
int __fastcall dynamic_initializer_for__g_PrivateHeap__(PrivateHeap *a1);
int dynamic_initializer_for__ShutdownMgr::s_hEvent__();
int __fastcall dynamic_initializer_for__ShutdownMgr::s_sync__(ShutdownMgr::Sync *a1);
int __fastcall dynamic_initializer_for__g_Idolater__(Idolater *a1);
int dynamic_initializer_for__std::_Error_objects_int_::_Generic_object__();
int dynamic_initializer_for__std::_Error_objects_int_::_Iostream_object__();
int dynamic_initializer_for__std::_Error_objects_int_::_System_object__();
int wil::details::_dynamic_initializer_for__g_enabledStateManager__();
int wil::details::_dynamic_initializer_for__g_featureStateManager__();
void (__fastcall __noreturn *wil::details::_dynamic_initializer_for__g_header_init_InitializeResultExceptions__())(wil::details *this, const struct wil::FailureInfo *a2);
void *wil::details::_dynamic_initializer_for__g_header_init_InitializeResultHeader__();
void (__fastcall *wil::details::_dynamic_initializer_for__g_header_init_InitializeStagingHeaderInternalApi__())(struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ *this, struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ *a2);
void (__fastcall *wil::details::_dynamic_initializer_for__g_header_init_InitializeStagingSRUMFeatureReporting__())(wil::details *this);
int wil::details::_dynamic_initializer_for__g_processLocalData__();
int wil::details::_dynamic_initializer_for__g_threadFailureCallbacks__();
int __fastcall dynamic_initializer_for__JobStore::m_hashObject__(HashCompute *a1);
int dynamic_initializer_for__RpcServer::s_singleton__();
int ATL::_dynamic_initializer_for__g_strheap__();
int __fastcall ATL::_dynamic_initializer_for__g_strmgr__(ATL::CAtlStringMgr *a1, struct ATL::IAtlMemMgr *a2);
int __fastcall dynamic_initializer_for__vtMissing__(_variant_t *a1);
__int64 __fastcall Triggers::BootTrigger::WriteXml(Triggers::BootTrigger *this, struct TaskXmlWriter *a2); // idb
__int64 __fastcall ItSpIsSystemIdle(struct _ITSRV_GLOBAL_CONTEXT *a1, struct _ITSRV_SYSTEM_SNAPSHOT *a2, struct _ITSRV_SYSTEM_SNAPSHOT *a3, enum _ITSRV_IDLE_DETECTION_RESULT *a4);
char __fastcall ItSpUpdateLastPerfTrackData(__int64 a1, __int64 a2, struct _ITSRV_SYSTEM_SNAPSHOT *a3, int a4, double a5, double a6, double a7);
__int64 __fastcall ItSpConvertToLogScale(double a1);
unsigned __int8 __fastcall ItSpBatteryLifePercent(struct _ITSRV_SYSTEM_SNAPSHOT *a1); // idb
__int64 __fastcall SchRpcEnableTask(__int64 a1, unsigned __int16 *a2, int a3);
__int64 __fastcall RpcServer::EnableTask(RTL_SRWLOCK *this, unsigned __int16 *a2, int a3);
__int64 __fastcall JobSecurity::AddRemovePrincipalAce(PSECURITY_DESCRIPTOR *this, void *a2, void *a3);
HLOCAL __fastcall tsched::AutoLocalPtr<unsigned short>::~AutoLocalPtr<unsigned short>(void **a1);
_QWORD *__fastcall Triggers::BootTrigger::BootTrigger(_QWORD *a1, const OLECHAR *a2, __int128 *a3, __int128 *a4, int a5, int a6, char a7, __int128 *a8);
__int64 __fastcall ATL::CAtlArray<ATL::CAutoPtr<ATL::CDacl::CAccessAce>,ATL::CAutoPtrElementTraits<ATL::CDacl::CAccessAce>>::CallDestructors(__int64 (__fastcall ****a1)(_QWORD, __int64), __int64 a2);
__int64 __fastcall JobStore::GenerateJobSecurity(HKEY *this, tsched *a2, LPCWSTR StringSecurityDescriptor, BOOLEAN IsDirectoryObject, HANDLE a5, PSECURITY_DESCRIPTOR *NewDescriptor);
int __fastcall JobSecurity::Generate(PSECURITY_DESCRIPTOR *NewDescriptor, PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CreatorDescriptor, BOOLEAN IsDirectoryObject, HANDLE Token);
__int64 __fastcall JobStore::RegContainerJobSecurityQuery(HKEY *this, wchar_t *a2, void **a3);
signed int __fastcall JobSecurity::SetSddl(PSECURITY_DESCRIPTOR *SecurityDescriptor, LPCWSTR StringSecurityDescriptor);
__int64 __fastcall ItSpUpdateSystemSnapshots(struct _ITSRV_GLOBAL_CONTEXT *a1);
void __fastcall ItSpCleanupSystemSnapshot(struct _ITSRV_SYSTEM_SNAPSHOT *a1); // idb
__int64 __fastcall ATL::CAutoPtr<ATL::CDacl::CAccessAce>::Free(__int64 (__fastcall ****a1)(_QWORD, __int64));
__int64 __fastcall Triggers::TriggerBase::StreamOut(Triggers::TriggerBase *this, __int64 a2, unsigned __int8 **a3, unsigned __int8 *a4);
const struct ATL::CAcl::CAce *__fastcall ATL::CDacl::GetAce(ATL::CDacl *this, unsigned int a2); // idb
__int64 __fastcall I_pSetTaskDisabledForCurrentUser(__int64 a1, char *a2, char a3);
__int64 __fastcall RpcServer::SetTaskDisabledForCurrentUser(RTL_SRWLOCK *this, char *a2, char a3);
__int64 __fastcall Triggers::TimeTrigger::GetStorageSize(Triggers::TimeTrigger *this);
__int64 __fastcall ExeTask::GetStorageSize(ExeTask *this);
ATL::CComBSTR *__fastcall ATL::CComBSTR::CComBSTR(ATL::CComBSTR *this, LPCSTR *a2);
bool __fastcall ATL::CDacl::CAccessAce::AceType(ATL::CDacl::CAccessAce *this);
__int64 __fastcall TaskXmlReader::LoadValue(TaskXmlReader *this, unsigned int *a2); // idb
__int64 __fastcall ComHandlerBase::GetStorageSize(ComHandlerBase *this);
__int64 __fastcall TaskXmlReader::LoadLogon(TaskXmlReader *this, enum JobFlags::JobFlag *a2); // idb
__int64 __fastcall UbpmProxySingleton::SetTaskDisabledForUser(UbpmProxySingleton *this, const wchar_t **a2, const struct User *a3, char a4);
__int64 __fastcall SchRpcScheduledRuntimes(__int64 a1, char *a2, struct _SYSTEMTIME *a3, struct _SYSTEMTIME *a4, unsigned int a5, int a6, unsigned int *a7, struct _SYSTEMTIME **a8);
__int64 __fastcall JobMoniker::SetExistingId(JobMoniker *this); // idb
void __fastcall CDLink::UnLink(CDLink *this); // idb
__int64 __fastcall Triggers::Trigulator::GetRunTimes(__int64 a1, __int128 *a2, __int128 *a3, __int64 a4, int a5);
__int64 __fastcall Scheduling::JobSchedule::GetRunTimes(__int64 a1, TSTime *a2, TSTime *a3, __int64 a4, int a5);
__int64 __fastcall RunList::Add(__int64 a1, FILETIME a2, int a3, int a4);
void __fastcall CDLink::LinkAfter(CDLink *this, struct CDLink *a2); // idb
CDLink *__fastcall CDLink::`vector deleting destructor'(CDLink *this, char a2);
__int64 __fastcall RpcServer::Runtimes(RTL_SRWLOCK *this, char *a2, struct _SYSTEMTIME *a3, struct _SYSTEMTIME *a4, unsigned int a5, int a6, unsigned int *a7, struct _SYSTEMTIME **a8);
ATL::CSid *__fastcall ATL::CSid::CSid(ATL::CSid *this, struct _SID *a2);
__int64 __fastcall JobStore::HammerAcl(JobStore *this, const struct JobMoniker *a2, const struct User *a3, const struct User *a4); // idb
void __fastcall ATL::CAcl::GetAclEntry(ATL::CAcl *this, __int64 a2, struct ATL::CSid *a3, unsigned int *a4, unsigned __int8 *a5);
__int64 __fastcall ATL::CSid::operator=(__int64 a1, __int64 a2);
bool __fastcall ATL::operator==(ATL::CSid *a1, ATL::CSid *a2);
void __fastcall ATL::CDacl::Copy(ATL::CDacl *this, struct _ACL *a2);
void **__fastcall ATL::CDacl::CAccessAce::`vector deleting destructor'(void **this, char a2);
void __fastcall ATL::CAcl::CAce::~CAce(void **this);
ATL::CSid *__fastcall ATL::CSid::CSid(ATL::CSid *this, const struct ATL::CSid *a2);
volatile signed __int32 *__fastcall ATL::CSimpleStringT<unsigned short,0>::CloneData(volatile signed __int32 *a1);
bool __fastcall ATL::CSid::IsValid(ATL::CSid *this); // idb
unsigned __int64 __fastcall ATL::CAtlArray<ATL::CAutoPtr<ATL::CDacl::CAccessAce>,ATL::CAutoPtrElementTraits<ATL::CDacl::CAccessAce>>::Add(__int64 *a1, __int64 *a2);
ATL::CSid *__fastcall ATL::CSid::operator=(ATL::CSid *this, struct _SID *a2);
void __fastcall ATL::CSid::Copy(ATL::CSid *this, struct _SID *a2);
char __fastcall ATL::CAtlArray<ATL::CAutoPtr<ATL::CDacl::CAccessAce>,ATL::CAutoPtrElementTraits<ATL::CDacl::CAccessAce>>::GrowBuffer(__int64 a1, size_t a2);
void __fastcall ATL::CDacl::~CDacl(ATL::CDacl *this); // idb
void __fastcall ATL::CDacl::RemoveAllAces(ATL::CDacl *this); // idb
__int64 __fastcall JobStore::SaveJobFile(JobStore *this, wchar_t *a2, const unsigned __int16 *a3, unsigned int a4, unsigned int a5, void *a6, unsigned int a7);
tsched::JobsAutoHandle *__fastcall tsched::JobsAutoHandle::operator=(tsched::JobsAutoHandle *this, __int64 a2);
void __fastcall tsched::JobsAutoHandle::Close(tsched::JobsAutoHandle *this); // idb
__int64 __fastcall tsched::CreateFileSafe(wchar_t *String2, const unsigned __int16 *a2, DWORD a3, struct _SECURITY_ATTRIBUTES *a4, struct _SECURITY_ATTRIBUTES *dwCreationDisposition, DWORD dwFlagsAndAttributes);
signed int __fastcall tsched::VerifyJobFilePath(wchar_t *String2, HANDLE hFile, void *a3);
__int64 __fastcall JobStore::GetXmlTaskPath(char **this, JobMoniker *a2, void **a3);
__int64 __fastcall Triggers::SessionChangeTrigger::StreamOutImpl(Triggers::SessionChangeTrigger *this, __int64 a2, unsigned __int8 **a3, unsigned __int8 *a4);
__int64 __fastcall Triggers::WnfStateChangeTrigger::StreamOutImpl(Triggers::WnfStateChangeTrigger *this, __int64 a2, unsigned __int8 **a3, unsigned __int8 *a4);
__int64 __fastcall ComHandlerBase::StreamOut(ComHandlerBase *this, __int64 a2, unsigned __int8 **a3, const unsigned __int8 *a4);
__int64 __fastcall JobStore::UpdateTaskEntry(HKEY *this, const struct JobMoniker *a2, const struct JobSecurity *a3, const struct Triggers::Trigulator *a4, const struct Actions::ActionCollection *a5, BYTE *lpData);
LSTATUS __fastcall JobStore::FlushTaskEntryP(JobStore *this, HKEY a2);
__int64 __fastcall Triggers::GenericTrigger::StreamOutImpl(Triggers::GenericTrigger *this, __int64 a2, unsigned __int8 **a3, unsigned __int8 *a4);
__int64 __fastcall Triggers::TimeTrigger::StreamOutImpl(Triggers::TimeTrigger *this, __int64 a2, unsigned __int8 **a3, unsigned __int8 *a4);
__int64 __fastcall Actions::ActionCollection::StreamOut(Actions::ActionCollection *this, HKEY a2);
__int64 __fastcall JobStore::StreamOutUSHORT(__int16 a1, unsigned __int8 **a2, unsigned __int8 *a3);
__int64 __fastcall Task::StreamOut(Task *this, __int64 a2, unsigned __int8 **a3, const unsigned __int8 *a4);
__int64 __fastcall ExeTask::StreamOut(ExeTask *this, __int64 a2, unsigned __int8 **a3, unsigned __int8 *a4);
__int64 __fastcall JobStore::StreamOutBSTR(_bstr_t *a1, _QWORD *a2, unsigned __int64 a3);
__int64 __fastcall Triggers::SessionChangeTrigger::GetStorageSize(Triggers::SessionChangeTrigger *this);
__int64 __fastcall Triggers::WnfStateChangeTrigger::GetStorageSize(Triggers::WnfStateChangeTrigger *this);
__int64 __fastcall Triggers::GenericTrigger::GetStorageSize(Triggers::GenericTrigger *this);
__int64 __fastcall User::StreamOutImpl(User *this, __int64 a2, unsigned __int8 **a3, const unsigned __int8 *a4);
__int64 __fastcall DataAligner::WriteFixedSize<bool>(__int64 a1, _BYTE *a2);
__int64 __fastcall JobBucket::StreamOutImpl(JobBucket *this, __int64 a2, unsigned __int8 **a3, const unsigned __int8 *a4);
__int64 __fastcall DataAligner::WriteVarSize(DataAligner *this, void *a2, int a3);
__int64 __fastcall DataAligner::WriteFixedSize<unsigned long>(__int64 a1, _DWORD *a2);
signed int __fastcall Triggers::Trigulator::StreamOut(Triggers::Trigulator *this, HKEY a2);
__int64 __fastcall JobBucket::GetStorageSize(JobBucket *this);
__int64 __fastcall User::GetStorageSize(User *this);
__int64 *__fastcall User::GetDomainAccount(User *a1, __int64 *a2);
__int64 __fastcall Triggers::Trigulator::WritePackageAndCapabilities(Triggers::Trigulator *this, HKEY a2);
__int64 __fastcall JobBucket::GetCapabilities(__int64 a1, void **a2, unsigned int *a3);
LSTATUS __fastcall Triggers::Trigulator::WriteRegistrationData(Triggers::Trigulator *this, HKEY a2);
LSTATUS __fastcall Triggers::Trigulator::WriteString(Triggers::Trigulator *this, HKEY a2, const unsigned __int16 *a3, const BYTE *lpData);
__int64 __fastcall JobStore::CreateIndexEntryP(__int64 a1, int a2, const unsigned __int16 *a3, struct _SECURITY_ATTRIBUTES *a4);
__int64 __fastcall JobStore::RegOpenTaskEntryForUpdate(HKEY *this, const struct JobMoniker *a2, const struct JobSecurity *a3, const enum JobStore::TaskIndex *a4, int a5, HKEY *a6);
__int64 __fastcall JobStore::RemoveIndexEntryP(__int64 a1, int a2, const wchar_t *a3);
__int64 __fastcall JobStore::ComputeHash(struct JobMoniker *a1, unsigned __int8 *a2);
__int64 __fastcall HashCompute::ComputeHash(HashCompute *this, unsigned __int8 *const a2, ULONG a3, unsigned __int8 *a4, unsigned int *a5);
User::UserEntry **__fastcall wmi::AutoRef<User::UserEntry>::operator=(User::UserEntry **a1, User::UserEntry *a2);
// __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD); weak
__int64 __fastcall User::UserEntry::Release(User::UserEntry *this);
__int64 __fastcall ServerXMLUpdateHandler::NetworkOutputHandler::Process(__int64 a1, __int64 a2, int a3, __int64 a4);
void __fastcall wmi::AutoRegKey::Close(HKEY *this);
__int64 __fastcall _Read__QIStream__StringReader__EEAAJPEAXKPEAK_Z(__int64 a1, _WORD *a2, unsigned int a3, char *a4);
__int64 __fastcall UbpmParams::NewHostedObject<std::vector<_DAB_WNF_STATE_CHANGE_TRIGGER_PARAMS *>,_DAB_WNF_STATE_CHANGE_TRIGGER_PARAMS>(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10);
void __fastcall tsched::DeleteMe<_UBPM_ACTION_EXE_LAUNCH_PARAMS>::~DeleteMe<_UBPM_ACTION_EXE_LAUNCH_PARAMS>(__int64 a1);
__int64 __fastcall std::vector<_DAB_TRIGGER_PARAMS *>::_Reserve(_QWORD *a1);
char *__fastcall std::vector<_DAB_SESSION_STATE_CHANGE_TRIGGER_PARAMS *>::_Reallocate(__int64 a1, unsigned __int64 a2);
__int64 __fastcall ServerXMLUpdateHandler::RegistrationInfoHandler::EndElement(__int64 a1, const struct Schema *a2, int a3);
__int64 __fastcall ServerXMLUpdateHandler::ContextHandler::EndElement(__int64 a1, int *a2);
__int64 __fastcall _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::~_com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>(__int64 *a1);
void __fastcall std::vector<_bstr_t>::_Tidy(__int64 a1);
const unsigned __int16 *__fastcall ComHandlerBase::GetName(ComHandlerBase *this); // idb
void __fastcall ComHandlerBase::SetDefaultName(ComHandlerBase *this); // idb
__int64 __fastcall JobStore::SetSchedulingEngineFlag(JobStore *this, struct JobMoniker *a2, struct Triggers::Trigulator *a3, struct Actions::ActionCollection *a4, bool *a5, int *a6); // idb
_QWORD *__fastcall std::_List_alloc<0,std::_List_base_types<std::vector<unsigned char> *,std::allocator<std::vector<unsigned char> *>>>::_Buynode0(__int64 a1, _QWORD *a2, _QWORD *a3);
__int64 __fastcall ServerXMLUpdateHandler::NetworkOutputHandler::EndElement(__int64 a1, const struct Schema *a2, int a3);
__int64 __fastcall Triggers::TimeTrigger::StreamIn(Triggers::TimeTrigger *this, unsigned __int64 a2, unsigned __int8 **a3, unsigned __int8 *a4);
__int64 __fastcall StringStream::Release(StringStream *this);
char __fastcall tsched::IsErrorNotFound(tsched *this);
int __fastcall ComHandlerBase::WriteXml(ComHandlerBase *this, struct TaskXmlWriter *a2);
int __fastcall TaskXmlWriter::ElementGUID(__int64 a1, int a2, GUID *a3);
__int64 __fastcall TaskXmlWriter::ElementCData(__int64 a1, int a2, __int64 a3);
Triggers::TimeTrigger *__fastcall Triggers::TimeTrigger::TimeTrigger(Triggers::TimeTrigger *this, const unsigned __int16 *a2, const struct Scheduling::JobSchedule *a3);
ExeTask *__fastcall ExeTask::ExeTask(ExeTask *this, const struct _bstr_t *a2, const struct _bstr_t *a3, __int64 a4, struct _bstr_t *a5, struct _bstr_t *a6, struct _bstr_t *a7);
ExeTask *__fastcall ExeTask::`scalar deleting destructor'(ExeTask *this, char a2);
void __fastcall ExeTask::~ExeTask(ExeTask *this); // idb
__int64 __fastcall _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::_AddRef(__int64 *a1);
__int64 __fastcall UbpmParams::NewHostedObject<std::vector<_DAB_ETW_EVENT_TRIGGER_DATA_ITEM *>,_DAB_ETW_EVENT_TRIGGER_DATA_ITEM>(__int64 *a1, _OWORD *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10);
__int64 __fastcall ComHandlerBase::StreamIn(ComHandlerBase *this, __int64 a2, unsigned __int8 **a3, unsigned __int8 *a4);
Triggers::IdleTrigger *__fastcall Triggers::IdleTrigger::`vector deleting destructor'(Triggers::IdleTrigger *this, char a2);
void __fastcall wmi::AutoHandle::Close(void **this);
__int64 __fastcall JobStore::SaveJobFile(JobStore *this, wchar_t *a2, const unsigned __int16 *a3, unsigned int a4, ULONG SecurityDescriptorSize, LPCWSTR StringSecurityDescriptor);
void __fastcall Idolater::IdleEndCallback(void *a1);
void __fastcall Idolater::IdleEnd(Idolater *this); // idb
bool __fastcall JobStore::GetUseXmlStore(JobStore *this);
void __fastcall JobStore::WaitForConfiguration(JobStore *this); // idb
__int64 __fastcall TaskXmlReader::LoadValue(TaskXmlReader *this, struct _GUID *a2);
__int64 __fastcall ComHandlerBase::ExportToUbpmFormat(ComHandlerBase *this, struct IUbpmRegistrationParams *a2); // idb
char __fastcall IsOnList(wchar_t *String2, const unsigned __int16 **a2, int a3);
__int64 __fastcall TaskXmlReader::LoadValue(TaskXmlReader *this, unsigned __int16 *a2); // idb
HKEY *__fastcall FolderEnumerator::`vector deleting destructor'(HKEY *this, char a2);
__int64 __fastcall ServerXMLUpdateHandler::NetworkInputHandler::Process(__int64 a1, __int64 a2, int a3, __int64 a4);
__int64 __fastcall TaskXmlReader::LoadPeriod(const unsigned __int16 **this, unsigned int *a2, unsigned int *a3, unsigned int *a4, unsigned int *a5, unsigned int *a6, unsigned int *a7, unsigned int *a8);
__int64 __fastcall UbpmParams::NewHostedObject<std::vector<_DAB_ETW_EVENT_TRIGGER_PARAMS *>,_DAB_ETW_EVENT_TRIGGER_PARAMS>(__int64 *a1, _OWORD *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10);
void __fastcall ItSpIdleDetectionCallback(char *a1);
void __fastcall ItSpLogPerfTrackData(__int64 a1, int a2);
bool __fastcall ItSpAttendedResumeTimeoutIsOver(struct _ITSRV_GLOBAL_CONTEXT *a1, struct _FILETIME *a2);
__int64 __fastcall PubSebLevelEvent(__int64 a1, char a2);
__int64 __fastcall ItSpSendIdleEntryPerftrackNotification(__int64 a1, int a2);
__int64 __fastcall ServerXMLUpdateHandler::PrincipalHandler::Process(__int64 a1, __int64 a2, int a3);
__int64 __fastcall ExeTask::WriteXml(ExeTask *this, struct TaskXmlWriter *a2); // idb
UINT __fastcall _bstr_t::length(BSTR **this);
void __fastcall std::list<std::vector<unsigned char> *,std::allocator<std::vector<unsigned char> *>>::clear(__int64 a1);
__int64 __fastcall Triggers::SessionChangeTrigger::SessionChangeTrigger(__int64 a1, const OLECHAR *a2, User::UserEntry **a3, __int128 *a4, __int128 *a5, int a6, int a7, char a8, int a9, __int128 *a10);
_QWORD *__fastcall Triggers::LogonTrigger::LogonTrigger(_QWORD *a1, const OLECHAR *a2, User::UserEntry **a3, __int128 *a4, __int128 *a5, int a6, int a7, char a8, __int128 *a9);
_QWORD *__fastcall Triggers::SessionBasedTrigger::SessionBasedTrigger(_QWORD *a1, const OLECHAR *a2, User::UserEntry **a3, __int128 *a4, __int128 *a5, int a6, int a7, char a8, __int128 *a9);
Triggers::SessionBasedTrigger *__fastcall Triggers::SessionBasedTrigger::SessionBasedTrigger(Triggers::SessionBasedTrigger *this);
const unsigned __int16 *__fastcall ExeTask::GetName(ExeTask *this); // idb
__int64 __fastcall TaskXmlWriter::ElementTSDuration(__int64 a1, int a2, unsigned __int16 *a3);
bool __fastcall TSTime::operator==(__int64 a1, __int128 *a2);
void __fastcall operator delete(void *lpMem); // idb
__int64 __fastcall Triggers::ImmediateTrigger::ToUbpmFormat(Triggers::ImmediateTrigger *this, const struct Triggers::TriggerExportOptions *a2, struct IUbpmRegistrationParams *a3); // idb
_QWORD *__fastcall wmi::AutoRef<TaskXmlReader>::operator=(_QWORD *a1, __int64 a2);
// __int64 __fastcall wmi::AutoRef<FolderEnumerator>::~AutoRef<FolderEnumerator>(_QWORD); weak
Triggers::SessionChangeTrigger *__fastcall Triggers::SessionChangeTrigger::`vector deleting destructor'(Triggers::SessionChangeTrigger *this, char a2);
char __fastcall Triggers::Trigulator::HasTrigger(__int64 a1, int a2);
__int64 __fastcall SchRpcHighestVersion(__int64 a1, _DWORD *a2);
_QWORD *__fastcall std::_Tree<std::_Tmap_traits<_bstr_t,void *,ValidationXmlHandler::stringless,std::allocator<std::pair<_bstr_t const,void *>>,0>>::_Rrotate(__int64 a1, _QWORD *a2);
void __fastcall ATL::CSid::Clear(ATL::CSid *this); // idb
void __fastcall ATL::CSimpleStringT<unsigned short,0>::Empty(__int64 *a1);
_QWORD *__fastcall std::_Tree<std::_Tmap_traits<_bstr_t,void *,ValidationXmlHandler::stringless,std::allocator<std::pair<_bstr_t const,void *>>,0>>::_Lrotate(__int64 a1, __int64 a2);
__int64 __fastcall UbpmParams::NewHostedObject<std::vector<_DAB_SCHEDULE_BY_DAY *>,_DAB_SCHEDULE_BY_DAY>(__int64 *a1, _WORD *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10);
__int64 __fastcall std::vector<_UBPM_ACTION_EXE_LAUNCH_PARAMS *>::_Reserve(_QWORD *a1);
char *__fastcall std::vector<_CSebiSystemEventCreationParameter *>::_Reallocate(__int64 a1, unsigned __int64 a2);
__int64 __fastcall Auditor::AuditJobOperation(__int64 *a1, int a2, __int64 a3, char *a4);
__int64 __fastcall Auditor::GetTokenUserAndStatistics(Auditor *this, struct _TOKEN_USER *a2, struct _TOKEN_STATISTICS *a3);
void __fastcall TaskXmlWriter::~TaskXmlWriter(TaskXmlWriter *this); // idb
__int64 __fastcall ServerXMLUpdateHandler::PrincipalHandler::EndElement(__int64 a1, const struct Schema *a2, int a3);
void __fastcall ServerXMLUpdateHandler::WritePrincipal(ServerXMLUpdateHandler *this, const struct Schema *a2, char a3, const unsigned __int16 *a4, const unsigned __int16 *a5, int a6, bool a7, bool a8);
__int64 __fastcall TaskXmlWriter::ElementInt(__int64 a1, int a2, unsigned int a3);
__int64 __fastcall ItSpCopySystemSnapshot(struct _ITSRV_SYSTEM_SNAPSHOT *a1, struct _ITSRV_SYSTEM_SNAPSHOT *a2);
__int64 __fastcall SchRpcGetTaskInfo(__int64 a1, char *a2, int a3, _DWORD *a4, _DWORD *a5);
__int64 __fastcall RpcServer::GetState(RTL_SRWLOCK *this, char *a2, enum tsched::InternalTaskState *a3, int *a4);
BSTR *__fastcall JobStore::GetIndexKeyPath(__int64 a1, int a2, BSTR *a3);
BSTR *__fastcall ATL::CComBSTR::operator=(BSTR *a1, const OLECHAR *a2);
BSTR __fastcall ATL::CComBSTR::Copy(LPCSTR *this);
void __fastcall AutoThreadUIPreferredLanguages::~AutoThreadUIPreferredLanguages(WCHAR **this);
__int64 __fastcall TSTimePeriod::IsLessThen(TSTimePeriod *this, const struct TSTimePeriod *a2, bool *a3); // idb
bool __fastcall JobMoniker::HasEqualTaskHardeningSettings(JobMoniker *this, const struct JobMoniker *a2); // idb
__int64 __fastcall ServerXMLUpdateHandler::NetworkInputHandler::EndElement(__int64 a1, const struct Schema *a2, int a3);
__int64 __fastcall Triggers::LogonTrigger::WriteXml(Triggers::LogonTrigger *this, struct TaskXmlWriter *a2); // idb
__int64 __fastcall Triggers::LogXTrigger::StreamIn(User::UserEntry **this, unsigned __int64 a2, unsigned __int8 **a3, unsigned __int8 *a4);
char RpcServer::CheckIntegrityLevel(void);
char __fastcall User::IsLocalSystem(wchar_t *String1);
__int64 __fastcall JobSecurity::GetSddl(PSECURITY_DESCRIPTOR *this, SECURITY_INFORMATION a2, unsigned __int16 **a3);
__int64 __fastcall Triggers::SessionChangeTrigger::StreamIn(User::UserEntry **this, unsigned __int64 a2, unsigned __int8 **a3, unsigned __int8 *a4);
__int64 __fastcall RpcServer::SecurityCallback(RPC_IF_HANDLE InterfaceUuid, void *Context);
__int64 __fastcall _delayLoadHelper2(__int64 a1, __int64 a2);
NTSTATUS __fastcall LUAIsElevatedToken(HANDLE TokenHandle, _DWORD *a2, _DWORD *a3);
__int64 __fastcall Triggers::TimeTrigger::ToUbpmFormat(Triggers::TimeTrigger *this, const struct Triggers::TriggerExportOptions *a2, struct IUbpmRegistrationParams *a3); // idb
void __fastcall ItSpPowerNotificationWorker(PTP_CALLBACK_INSTANCE Instance, char *Context, PTP_WORK Work);
char *__fastcall tsched::PathCopy(tsched *this, const unsigned __int16 *a2);
__int64 __fastcall SchRpcRegisterTask(__int64 a1, unsigned __int16 *a2, struct _EVENT_DESCRIPTOR *a3, unsigned int a4, unsigned __int16 *a5, unsigned int a6, unsigned int a7, const struct _TASK_USER_CRED *a8, unsigned __int16 **a9, struct _TASK_XML_ERROR_INFO **a10);
__int64 __fastcall UbpmProxySingleton::OpenConsumer(UbpmProxySingleton *this, const struct JobMoniker *a2, struct AutoUbpmConsumerHandle *a3); // idb
bool __fastcall TSTime::operator<=(__int64 a1, __int128 *a2);
User *__fastcall User::User(User *this, User::UserEntry **a2);
ATL::CSid *__fastcall ATL::CSid::CSid(ATL::CSid *this);
void __fastcall ATL::CSid::~CSid(ATL::CSid *this); // idb
void __fastcall ATL::CStringData::Release(ATL::CStringData *this); // idb
__int64 __fastcall _Unregister__QEventTriggerRegistrar__EventTrapMap__UEAAJAEBVJobMoniker___Z(__int64 a1, JobMoniker *a2);
__int64 __fastcall _bstr_t::_Compare(BSTR **this, BSTR **a2);
__int64 __fastcall _bstr_t::Data_t::Compare(BSTR *this, BSTR *a2);
void __fastcall SelfDestructingTraps::~SelfDestructingTraps(EVT_HANDLE ***this);
__int64 __fastcall ItSpGetSystemSnapshot(struct _ITSRV_GLOBAL_CONTEXT *a1, struct _ITSRV_SYSTEM_SNAPSHOT *a2);
__int64 __fastcall ItSpQueryCPUAvailableTime(void *a1, unsigned __int64 *a2); // idb
__int64 __fastcall ItSpGetWmiDiskPerformanceData(void *a1, struct _ITSRV_DISK_PERFORMANCE_DATA **a2, unsigned int *a3, void **a4, unsigned int *a5);
bool __fastcall ItSpIsPhysicalDrive(struct _DISK_PERFORMANCE *const a1);
__int64 __fastcall tsched::IsUserAdmin(tsched *this); // idb
__int64 __fastcall IsPrincipalAllowed(User *a1, unsigned int a2);
char __fastcall User::IsServiceSid(User *this);
__int64 __fastcall JobStore::GetXmlFileSystemPath(char **this, char *a2, void **a3);
bool __fastcall JobStore::RealPathIsValid(char **this, const unsigned __int16 *a2);
__int64 __fastcall TaskXmlReader::LoadTranslatedString(const wchar_t **a1);
unsigned __int16 *__fastcall UbpmParams::CreateHostedVirtualUserName(UbpmParams *this, const struct JobMoniker *a2);
AutoThreadUIPreferredLanguages *__fastcall AutoThreadUIPreferredLanguages::AutoThreadUIPreferredLanguages(AutoThreadUIPreferredLanguages *this, const unsigned __int16 *a2, unsigned int *a3);
void **__fastcall wmi::AutoVectorPtr<unsigned char>::operator=(void **a1, void *a2);
const struct User *User::GetLocalAdmin(void); // idb
__int64 __fastcall JobBucket::GetDeadline(__int64 a1, __int64 a2);
struct _DAB_SID_INFO *UbpmParams::CreateHostedSidInfo(UbpmParams *__hidden this, void *const); // idb
__int64 __fastcall UbpmParams::NewHostedObject<std::vector<_DAB_SID_INFO *>,_DAB_SID_INFO>(__int64 *a1, _OWORD *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10);
__int64 *__fastcall _com_ptr_t<_com_IIID<IStream,&__s_GUID const _GUID_0000000c_0000_0000_c000_000000000046>>::_com_ptr_t<_com_IIID<IStream,&__s_GUID const _GUID_0000000c_0000_0000_c000_000000000046>>(__int64 *a1, _QWORD *a2);
__int64 __fastcall _com_ptr_t<_com_IIID<IStream,&__s_GUID const _GUID_0000000c_0000_0000_c000_000000000046>>::_QueryInterface<ATL::CComPtr<IStream>>(__int64 *a1, _QWORD *a2);
bool __fastcall User::operator==(User *this, User *a2);
__int64 __fastcall UbpmParams::GetUbpmLogonType(UbpmParams *this, const struct JobMoniker *a2);
ServerXMLUpdateHandler *__fastcall ServerXMLUpdateHandler::ServerXMLUpdateHandler(ServerXMLUpdateHandler *this, char a2, char a3, const unsigned __int16 *a4, unsigned __int16 *a5, const struct _TASK_USER_CRED *a6, unsigned int a7, const struct JobMoniker *a8, User::UserEntry **a9, struct Triggers::Trigulator *a10, struct Actions::ActionCollection *a11, bool a12, struct ATL::CComBSTR *a13, struct ATL::CComBSTR *a14, unsigned int a15);
__int64 __fastcall std::vector<ServerXMLUpdateHandler::ISubHandler *>::push_back(__int64 *a1, __int64 *a2);
__int64 __fastcall StringReader::CreateStream(__int64 a1, __int64 *a2);
StringReader *__fastcall StringReader::`scalar deleting destructor'(StringReader *this, char a2);
__int64 *__fastcall _com_ptr_t<_com_IIID<IStream,&__s_GUID const _GUID_0000000c_0000_0000_c000_000000000046>>::operator=<StringReader *>(__int64 *a1, _QWORD *a2);
TriggersXmlHandler *__fastcall TriggersXmlHandler::TriggersXmlHandler(TriggersXmlHandler *this, const struct JobMoniker *a2, User::UserEntry **a3, struct Triggers::Trigulator *a4, struct Actions::ActionCollection *a5, unsigned int a6, struct ATL::CComBSTR *a7, struct ATL::CComBSTR *a8);
JobMoniker *__fastcall JobMoniker::JobMoniker(JobMoniker *this, const struct JobMoniker *a2, __int64 a3);
ValidationXmlHandler *__fastcall ValidationXmlHandler::ValidationXmlHandler(ValidationXmlHandler *this, const struct JobMoniker *a2, __int64 a3, struct ATL::CComBSTR *a4, struct ATL::CComBSTR *a5);
__int64 __fastcall StringCchCopyExW(STRSAFE_LPWSTR pszDest, size_t a2, const unsigned __int16 *a3, unsigned __int16 **a4, unsigned __int64 *a5);
static HRESULT __stdcall StringCopyWorkerW(STRSAFE_LPWSTR pszDest, size_t cchDest, size_t *pcchNewDestLength, STRSAFE_PCNZWCH pszSrc, size_t cchToCopy);
__int64 __fastcall SchRpcEnumTasks(__int64 a1, char *a2, int a3, unsigned int *a4, unsigned int a5, unsigned int *a6, unsigned __int16 ***a7);
FolderEnumerator *__fastcall FolderEnumerator::FolderEnumerator(FolderEnumerator *this, const unsigned __int16 *a2, char a3);
__int64 __fastcall JobStore::RegFolderEntryOpen(HKEY *this, const unsigned __int16 *a2, HKEY *a3);
__int64 __fastcall UbpmParams::NewHostedObject<std::vector<_CSebiSystemEventCreationParameter *>,_CSebiSystemEventCreationParameter>(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10);
unsigned __int16 **__fastcall UbpmParams::GetActionIdArray(UbpmParams *this); // idb
__int64 __fastcall UbpmParams::AddCSEBTrigger(__int64 *a1, int a2, __int64 a3, __int64 a4, int a5);
__int64 __fastcall JobBucket::GetExpiration(JobBucket *this);
__int64 __fastcall Actions::ActionCollection::ExportToUbpmFormat(__int64 **this, struct IUbpmRegistrationParams *a2);
char __fastcall std::vector<_UBPM_ACTION_PARAMS>::push_back(__int64 *a1, unsigned __int64 a2);
__int64 __fastcall std::vector<_UBPM_ACTION_PARAMS>::_Reallocate(__int64 *a1, unsigned __int64 a2);
__int64 __fastcall std::_Uninit_move<_UBPM_ACTION_PARAMS *,_UBPM_ACTION_PARAMS *,std::allocator<_UBPM_ACTION_PARAMS>,_UBPM_ACTION_PARAMS>(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall UbpmParams::GetPtr(UbpmParams *this, unsigned __int8 **a2); // idb
__int64 __fastcall std::vector<_UBPM_ACTION_PARAMS>::_Reserve(__int64 *a1);
unsigned __int8 __fastcall std::vector<_UBPM_TRIGGER_PARAMS>::push_back(__int64 *a1, _OWORD *a2);
_OWORD *__fastcall std::vector<_UBPM_TRIGGER_PARAMS>::_Reallocate(void **a1, unsigned __int64 a2);
_OWORD *__fastcall std::_Uninit_move<_UBPM_TRIGGER_PARAMS *,_UBPM_TRIGGER_PARAMS *,std::allocator<_UBPM_TRIGGER_PARAMS>,_UBPM_TRIGGER_PARAMS>(_OWORD *a1, _OWORD *a2, _OWORD *a3);
_OWORD *__fastcall std::vector<_UBPM_TRIGGER_PARAMS>::_Reserve(__int64 a1);
__int64 __fastcall UbpmProxySingleton::RegisterTask(UbpmProxySingleton *this, int a2, const wchar_t **a3, int a4, JobBucket **a5, __int64 **a6, unsigned int a7, unsigned int a8, unsigned __int64 a9, unsigned __int16 *a10);
__int64 __fastcall UbpmParams::GetUbpmAccountType(UbpmParams *this, const struct JobMoniker *a2);
char __fastcall User::SupportsTaskHardening(User *this);
bool __fastcall User::IsNetworkService(User *this); // idb
bool __fastcall User::IsLocalService(User *this); // idb
__int64 __fastcall User::LookupSid(User *this, void **a2); // idb
char __fastcall User::IsAlias(User *this);
__int64 __fastcall Triggers::Trigulator::ExportToUbpmFormat(__int64 **this, const wchar_t **a2, const struct Triggers::TriggerExportOptions *a3, struct IUbpmRegistrationParams *a4);
struct _GUID *__fastcall JobBucket::GetNetworkId(JobBucket *this, struct _GUID *__return_ptr retstr); // idb
__int64 __fastcall UbpmProxySingleton::IsUbpmCompatible(UbpmProxySingleton *this, const wchar_t **a2, __int64 **a3, int *a4);
UbpmParams *__fastcall UbpmParams::UbpmParams(UbpmParams *this, const struct JobMoniker *a2, int a3); // idb
__int64 __fastcall JobStore::SetTaskCreationTime(JobStore *this, struct JobMoniker *a2, struct DynamicTaskInfo *a3); // idb
bool __fastcall TSTimePeriod::IsEmpty(TSTimePeriod *this); // idb
__int64 __fastcall UbpmParams::Init(UbpmParams *this, const struct JobMoniker *a2, const unsigned __int16 *a3); // idb
__int64 __fastcall JobBucket::GetPeriodicity(__int64 a1, __int64 a2);
__int64 __fastcall JobStore::GetDynamicTaskInfo(JobStore *this, struct JobMoniker *a2, struct DynamicTaskInfo *a3, unsigned int a4, HKEY *a5);
int __fastcall DynamicTaskInfo::StreamIn(DynamicTaskInfo *this, HKEY a2);
ITaskXmlHandler::Data *__fastcall ITaskXmlHandler::Data::Data(ITaskXmlHandler::Data *this);
__int64 __fastcall Triggers::Trigulator::operator=(__int64 a1, __int64 a2);
__int64 *__fastcall std::list<Triggers::Trigger *>::operator=(__int64 *a1, __int64 *a2);
__int64 __fastcall Triggers::Trigulator::StreamInWithOverrides(HKEY a1, HKEY a2, char a3, char a4, __int64 a5, _QWORD *a6);
__int64 __fastcall Triggers::Trigulator::WriteXml(Triggers::Trigulator *this, struct TaskXmlWriter *a2); // idb
struct _FILETIME *__fastcall Triggers::Trigulator::Trigulator(struct _FILETIME *this);
void __fastcall Triggers::Trigulator::~Trigulator(Triggers::Trigulator *this); // idb
void __fastcall Triggers::Trigulator::Clear(Triggers::Trigulator *this); // idb
void __fastcall std::list<Triggers::Trigger *>::clear(__int64 a1);
ValidationXmlHandler::CurrentTrigger *__fastcall ValidationXmlHandler::CurrentTrigger::CurrentTrigger(ValidationXmlHandler::CurrentTrigger *this);
TSTime *__fastcall TSTime::TSTime(TSTime *this);
__int64 __fastcall Triggers::WnfStateChangeTrigger::WnfStateChangeTrigger(__int64 a1, const OLECHAR *a2, __int128 *a3, __int128 *a4, int a5, int a6, char a7, __int128 *a8, __int64 a9, int a10, void *Src, unsigned int dwBytes);
char __fastcall FolderEnumerator::FindNext(FolderEnumerator *this);
__int64 __fastcall RpcServer::EnumFolder(RpcServer *this, char *a2, char a3, int a4, unsigned int *a5, unsigned int a6, unsigned int *a7, unsigned __int16 ***a8);
__int64 __fastcall JobStore::RegOpenTaskKey(HKEY *this, struct JobMoniker *a2, HKEY *a3, REGSAM a4);
__int64 __fastcall JobStore::RegOpenTaskKeyP(HKEY *this, unsigned __int8 a2, struct JobMoniker *a3, HKEY *a4, REGSAM samDesired);
const void **__fastcall ATL::CComBSTR::operator+=(const void **a1, const unsigned __int16 *a2);
__int64 __fastcall ATL::CComBSTR::Append(const void **this, const unsigned __int16 *a2, int a3);
ATL::CComBSTR *__fastcall ATL::CComBSTR::CComBSTR(ATL::CComBSTR *this, const unsigned __int16 *a2);
__int64 __fastcall JobStore::RegGetTaskIdWithRecovery(HKEY *a1, JobMoniker *a2, struct _GUID *a3, int a4, _DWORD *a5);
__int64 __fastcall StringStream::QueryInterface(StringStream *this, const struct _GUID *a2, void **a3); // idb
const unsigned __int16 *__fastcall JobMoniker::GetPath(JobMoniker *this); // idb
__int64 __fastcall ExeTask::StreamIn(ExeTask *this, unsigned __int16 a2, unsigned __int8 **a3, unsigned __int8 *a4);
ComHandlerTask *__fastcall ComHandlerTask::`vector deleting destructor'(ComHandlerTask *this, char a2);
void __fastcall ComHandlerBase::~ComHandlerBase(ComHandlerBase *this); // idb
Task *__fastcall Task::Task(Task *this, const struct _bstr_t *a2, const struct _bstr_t *a3); // idb
void __fastcall Task::~Task(Task *this); // idb
__int64 __fastcall Triggers::Trigulator::ReadDWORD(Triggers::Trigulator *this, HKEY a2, const unsigned __int16 *a3, __int64 a4, unsigned int *a5);
__int64 __fastcall Triggers::Trigulator::ReadHashData(JobBucket **this, HKEY a2, unsigned __int8 *a3, DWORD a4);
__int64 __fastcall Triggers::Trigulator::ReadTriggerBlobData(__int64 a1, HKEY a2, BYTE *lpData, _DWORD *a4, BYTE **a5, BYTE **a6);
__int64 __fastcall Triggers::Trigulator::StreamIn(wmi::RefBase **this, HKEY a2, char a3, unsigned __int64 *a4);
__int64 __fastcall Triggers::Trigulator::ReadPackageAndCapabilities(_bstr_t ***this, HKEY a2, unsigned __int8 *a3, DWORD a4);
void __fastcall JobBucket::SetCapabilities(_bstr_t **this, const unsigned __int16 *a2, unsigned int a3);
__int64 __fastcall Triggers::Trigulator::ReadMultiString(__int64 a1, HKEY a2, __int64 a3, BYTE *lpData, DWORD cbData, void **a6, DWORD Type, _QWORD *a8, DWORD *a9);
__int64 __fastcall Triggers::Trigulator::ReadRegistrationData(Triggers::Trigulator *this, HKEY a2, unsigned __int16 *a3, __int64 a4);
__int64 __fastcall Triggers::Trigulator::ReadString(__int64 a1, HKEY a2, const WCHAR *a3, BYTE *lpData, DWORD cbData, void **a6, DWORD Type, _QWORD *a8);
__int64 __fastcall Triggers::Trigulator::GetBucket(Triggers::Trigulator *this, struct JobMoniker *a2); // idb
__int64 __fastcall JobMoniker::operator=(__int64 a1, __int64 a2);
JobMoniker *__fastcall JobMoniker::JobMoniker(JobMoniker *this, const struct JobMoniker *a2, struct JobBucket *a3); // idb
__int64 __fastcall Triggers::WnfStateChangeTrigger::StreamIn(Triggers::WnfStateChangeTrigger *this, unsigned __int64 a2, unsigned __int8 **a3, unsigned __int8 *a4);
CBstrWriter *__fastcall CBstrWriter::CBstrWriter(CBstrWriter *this); // idb
CBstrWriter *__fastcall CBstrWriter::`scalar deleting destructor'(CBstrWriter *this, char a2);
void __fastcall CBstrWriter::~CBstrWriter(CBstrWriter *this); // idb
Triggers::TimeTrigger *__fastcall Triggers::TimeTrigger::`vector deleting destructor'(Triggers::TimeTrigger *this, char a2);
__int64 __fastcall _ProcessElement__QITaskXmlHandler__ServerXMLUpdateHandler__UEAAJAEBUSchema__W4TaskXmlNodeId___Z(__int64 a1, int *a2, unsigned int a3);
__int64 __fastcall _ProcessElement__QITaskXmlHandler__TriggersXmlHandler__MEAAJAEBUSchema__W4TaskXmlNodeId___Z(__int64 a1, int *a2, int a3);
__int64 __fastcall _ProcessElement__QITaskXmlHandler__ValidationXmlHandler__MEAAJAEBUSchema__W4TaskXmlNodeId___Z(ValidationXmlHandler *this, int *a2, int a3);
__int64 __fastcall ServerXMLUpdateHandler::ProcessSubHandlers(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, char a5);
__int64 __fastcall Triggers::GenericTrigger::StreamIn(Triggers::GenericTrigger *this, unsigned __int64 a2, unsigned __int8 **a3, unsigned __int8 *a4);
void __fastcall UbpmParams::~UbpmParams(UbpmParams *this); // idb
Triggers::WnfStateChangeTrigger *__fastcall Triggers::WnfStateChangeTrigger::`vector deleting destructor'(Triggers::WnfStateChangeTrigger *this, char a2);
__int64 __fastcall JobStore::RegGetTreeInfo(HKEY *this, const unsigned __int16 *a2, struct _GUID *a3, enum JobStore::TaskIndex *a4);
__int64 __fastcall JobStore::RegJobSecurityQuery(HKEY *this, const unsigned __int16 *a2, void **a3);
void __fastcall _bstr_t::_Free(_bstr_t *this); // idb
void __fastcall ValidationXmlHandler::ResetActionFields(ValidationXmlHandler *this); // idb
__int64 __fastcall _bstr_t::Data_t::Release(_bstr_t::Data_t *this);
__int64 __fastcall Triggers::Trigulator::ParseTriggerBlobData(__int64 a1, unsigned __int64 *a2, unsigned int a3, __int128 *a4, __int128 *a5, char a6, unsigned __int64 *a7);
__int64 (__fastcall ****__fastcall tsched::DeleteMe<Triggers::Trigger>::~DeleteMe<Triggers::Trigger>(__int64 a1))(_QWORD, __int64);
__int64 __fastcall _ProcessElementEnd__QITaskXmlHandler__ServerXMLUpdateHandler__UEAAJAEBUSchema__W4TaskXmlNodeId___Z(__int64 a1, int *a2, unsigned int a3);
__int64 __fastcall _ProcessElementEnd__QITaskXmlHandler__TriggersXmlHandler__MEAAJAEBUSchema__W4TaskXmlNodeId___Z(__int64 a1, int *a2, int a3);
__int64 __fastcall _ProcessElementEnd__QITaskXmlHandler__ValidationXmlHandler__MEAAJAEBUSchema__W4TaskXmlNodeId___Z(__int64 a1, int *a2, int a3);
bool __fastcall TSTime::operator!=(__int64 a1, __int128 *a2);
void __fastcall Triggers::Trigulator::AddTrigger(Triggers::Trigulator *this, struct Triggers::Trigger *a2); // idb
_QWORD *__fastcall std::_List_buy<Triggers::Trigger *>::_Buynode<Triggers::Trigger * const &>(__int64 a1, _QWORD *a2, _QWORD *a3, _QWORD *a4);
_QWORD *__fastcall std::_List_alloc<0,std::_List_base_types<Triggers::Trigger *>>::_Buynode0(__int64 a1, _QWORD *a2, _QWORD *a3);
bool __fastcall TSTime::operator>(__int64 a1, __int128 *a2);
bool __fastcall TSTime::operator<(__int64 a1, __int128 *a2);
__int128 *__fastcall TSTime::EqualizeLocality(char *a1, __int128 *a2, __int128 *a3);
wmi::RefBase **__fastcall wmi::AutoRef<JobBucket>::operator=(wmi::RefBase **a1, volatile signed __int32 *a2);
void **__fastcall CBstrWriter::BufferBlock::`scalar deleting destructor'(void **this);
void **__fastcall tsched::ClearList<std::vector<unsigned short *>>(void ***a1);
JobMoniker *__fastcall JobMoniker::JobMoniker(JobMoniker *this, const unsigned __int16 *a2, LPCOLESTR lpsz); // idb
__int64 __fastcall wmi::AutoRef<JobBucket>::Release(wmi::RefBase **a1);
__int64 __fastcall wmi::RefBase::Release(wmi::RefBase *this);
void __fastcall JobBucket::SetHash(JobBucket *this, const unsigned __int8 *a2); // idb
void __fastcall JobMoniker::_SetPath(_bstr_t::Data_t **this, const unsigned __int16 *a2);
JobBucket *__fastcall JobBucket::`vector deleting destructor'(JobBucket *this, char a2);
void __fastcall JobBucket::~JobBucket(JobBucket *this); // idb
JobBucket *__fastcall JobBucket::JobBucket(JobBucket *this); // idb
__int64 __fastcall JobStore::StreamInBSTR(_bstr_t::Data_t **a1, unsigned __int8 **a2, unsigned __int8 *a3);
_bstr_t::Data_t **__fastcall _bstr_t::operator=(_bstr_t::Data_t **a1, const OLECHAR *a2);
__int64 __fastcall _ProcessValue__QITaskXmlHandler__ServerXMLUpdateHandler__UEAAJAEBUSchema__W4TaskXmlNodeId__AEBUData_1__N_Z(TriggersXmlHandler *this, int *a2, unsigned int a3, __int64 a4, char a5);
__int64 __fastcall _ProcessValue__QITaskXmlHandler__TriggersXmlHandler__MEAAJAEBUSchema__W4TaskXmlNodeId__AEBUData_1__N_Z(TriggersXmlHandler *this, int *a2, int a3, __int64 a4);
__int64 __fastcall _ProcessValue__QITaskXmlHandler__ValidationXmlHandler__MEAAJAEBUSchema__W4TaskXmlNodeId__AEBUData_1__N_Z(ValidationXmlHandler *this, int *a2, int a3, __int64 a4);
void __fastcall TriggersXmlHandler::CurrentAction::Reset(TriggersXmlHandler::CurrentAction *this); // idb
void __fastcall ValidationXmlHandler::CurrentTrigger::Reset(__int64 a1, int a2);
void __fastcall ValidationXmlHandler::CurrentTrigger::_unnamed_type_strings_::Reset(ValidationXmlHandler::CurrentTrigger::_unnamed_type_strings_ *this); // idb
__int64 *__fastcall _bstr_t::operator=(__int64 *a1, __int64 *a2);
_bstr_t *__fastcall XmlParserTempString::GetCopy(const OLECHAR **a1, _bstr_t *a2);
__int64 __fastcall JobStore::RegTreeEntryOpen(HKEY *this, const unsigned __int16 *a2, HKEY *a3);
_bstr_t *__fastcall _bstr_t::_bstr_t(_bstr_t *this, const unsigned __int16 *a2);
OLECHAR ***__fastcall _bstr_t::operator+=(OLECHAR ***a1, BSTR **a2);
_bstr_t::Data_t *__fastcall _bstr_t::Data_t::Data_t(_bstr_t::Data_t *this, OLECHAR ***a2, BSTR **a3);
_bstr_t *__fastcall _bstr_t::_bstr_t(_bstr_t *this, unsigned __int16 *a2);
LPVOID __fastcall operator new(SIZE_T dwBytes);
BSTR __fastcall XmlParserTempString::DetachBstr(const OLECHAR **this);
BSTR __fastcall XmlParserTempString::GetNullTerminated(XmlParserTempString *this);
void __fastcall Triggers::WnfStateChangeTrigger::~WnfStateChangeTrigger(Triggers::WnfStateChangeTrigger *this); // idb
__int64 __fastcall JobSecurity::StreamIn(void **this, HKEY a2);
HLOCAL __fastcall tsched::AutoLocalPtr<_SECURITY_DESCRIPTOR>::Attach(void **a1, void *a2);
char __fastcall ValidationXmlHandler::CheckId(__int64 ***this, __int64 **a2);
__int64 ***__fastcall std::_Tree<std::_Tmap_traits<_bstr_t,void *,ValidationXmlHandler::stringless,std::allocator<std::pair<_bstr_t const,void *>>,0>>::find(__int64 a1, __int64 ***a2, __int64 **a3);
__int64 __fastcall std::_Tree<std::_Tmap_traits<_bstr_t,void *,ValidationXmlHandler::stringless,std::allocator<std::pair<_bstr_t const,void *>>,0>>::_Insert_nohint<std::pair<_bstr_t const,void *>,std::_Nil>(__int64 ***a1, __int64 a2, __int64 a3, unsigned __int16 ***a4);
__int64 __fastcall ValidationXmlHandler::stringless::operator()(__int64 a1, unsigned __int16 ***a2, __int64 **a3);
_QWORD *__fastcall std::_Tree<std::_Tmap_traits<_bstr_t,void *,ValidationXmlHandler::stringless,std::allocator<std::pair<_bstr_t const,void *>>,0>>::_Insert_at<std::pair<_bstr_t const,void *>,std::_Nil>(_QWORD *a1, _QWORD *a2, char a3, _QWORD *a4, __int64 *a5);
_QWORD *__fastcall std::_Tree_buy<std::pair<_bstr_t const,void *>>::_Buynode<std::pair<_bstr_t const,void *>>(_QWORD *a1, __int64 *a2);
_QWORD *__fastcall std::_Tree_buy<std::pair<_bstr_t const,void *>>::_Buynode0(_QWORD *a1);
CBstrWriter::BufferBlock *__fastcall CBstrWriter::BufferBlock::BufferBlock(CBstrWriter::BufferBlock *this);
unsigned __int16 *__fastcall CBstrWriter::GetCopy(CBstrWriter *this); // idb
__int64 __fastcall _Write__QIStream__CBstrWriter__EEAAJPEBXKPEAK_Z(__int64 a1, char *a2, unsigned int a3, _DWORD *a4);
__int64 __fastcall StringCchCopyNW(char *a1, __int64 a2, char *a3, unsigned __int64 a4);
__int64 __fastcall std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::clear(_QWORD *a1);
void __fastcall std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::_Erase(__int64 a1, __int64 *a2);
struct _FILETIME *__fastcall Scheduling::JobSchedule::JobSchedule(struct _FILETIME *this);
__int64 __fastcall TaskAccessCheck(HANDLE ClientToken, const unsigned __int16 *a2, DWORD DesiredAccess); // idb
JobSecurity *__fastcall JobSecurity::JobSecurity(JobSecurity *this); // idb
void __fastcall JobBucket::InitOptionalSettings(JobBucket *this); // idb
__int64 __fastcall JobAccessCheck(HANDLE ClientToken, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD DesiredAccess); // idb
void __fastcall std::vector<_bstr_t>::clear(_bstr_t **a1);
void __fastcall Triggers::TimeTrigger::~TimeTrigger(Triggers::TimeTrigger *this); // idb
Triggers::GenericTrigger *__fastcall Triggers::GenericTrigger::GenericTrigger(Triggers::GenericTrigger *this);
struct _FILETIME *__fastcall Triggers::GenericTrigger::GenericData::GenericData(struct _FILETIME *this);
__int64 __fastcall User::StreamIn(User::UserEntry **this, WCHAR **a2, unsigned __int8 **a3, unsigned __int8 **a4);
__int64 __fastcall DataAligner::ReadFixedSize<bool>(__int64 a1, _BYTE *a2);
__int64 __fastcall JobBucket::StreamIn(JobBucket *this, unsigned __int64 a2, unsigned __int8 **a3, unsigned __int8 **a4);
__int64 __fastcall DataAligner::ReadVarSize(unsigned __int8 ***this, unsigned __int8 **a2, unsigned int *a3);
__int64 __fastcall DataAligner::ReadFixedSize(DataAligner *this, _DWORD *a2);
User::UserEntry **__fastcall User::LookupUser(User::UserEntry **a1, void *a2);
__int64 __fastcall Actions::ActionCollection::ReadData(Actions::ActionCollection *this, unsigned __int8 *a2, int a3, unsigned __int16 *a4);
__int64 __fastcall JobStore::StreamInUSHORT(unsigned __int16 *a1, unsigned __int16 **a2, unsigned __int8 *a3);
_QWORD *__fastcall std::_List_buy<Task *>::_Buynode<Task * const &>(__int64 a1, _QWORD *a2, _QWORD *a3, _QWORD *a4);
__int64 __fastcall Actions::ActionCollection::StreamIn(Actions::ActionCollection *this, HKEY hKey, unsigned __int16 *a3); // idb
__int64 __fastcall Triggers::GenericTrigger::GenericTrigger(__int64 a1, const OLECHAR *a2, _OWORD *a3, _OWORD *a4, int a5, int a6, char a7, _OWORD *a8);
// ExeTask *__fastcall ExeTask::ExeTask(ExeTask *__hidden this, const struct _bstr_t *, const struct _bstr_t *); idb
void __fastcall ATL::CComBSTR::Attach(BSTR *this, unsigned __int16 *a2);
__int64 __fastcall TaskXmlReader::LoadValue(TaskXmlReader *this, struct _bstr_t *a2); // idb
__int64 __fastcall JobBucket::WriteRegistrationXml(JobBucket *this, struct TaskXmlWriter *a2, struct Schema *a3); // idb
__int64 __fastcall JobBucket::WriteOptionalXmlElement(__int64 a1, __int64 a2, int a3, __int64 a4);
__int64 __fastcall TaskXmlReader::LoadInstancePolicy(TaskXmlReader *this, enum JobFlags::JobFlag *a2); // idb
__int64 __fastcall TaskXmlReader::LoadTimespan(const unsigned __int16 **this, unsigned int *a2);
__int64 __fastcall TSParser::ParseTimePeriod(const unsigned __int16 *a1, unsigned __int64 a2, struct TSTimePeriod *a3); // idb
__int64 __fastcall ULongLongToUShort(unsigned __int64 a1, unsigned __int16 *a2); // idb
__int64 __fastcall UShortAdd(unsigned __int16 a1, __int16 a2, unsigned __int16 *a3);
__int64 __fastcall TaskXmlWriter::ElementHexString(__int64 a1, int a2, tsched *a3, unsigned int a4);
__int64 __fastcall tsched::HexBinaryToString(tsched *this, unsigned __int8 *a2, _WORD *a3, unsigned __int16 *a4);
__int64 __fastcall tsched::ByteToHexDigit(tsched *this, _WORD *a2, unsigned __int16 *a3);
__int64 __fastcall TaskXmlReader::LoadHexString(tsched **this, void **a2, unsigned __int8 *a3);
__int64 __fastcall tsched::HexStringToBinary(tsched *this, const unsigned __int16 *a2, __int64 a3, unsigned __int8 *a4);
__int64 __fastcall TaskXmlWriter::WriteAttribute(__int64 a1, int a2, __int64 a3);
__int64 __fastcall TaskXmlWriter::EndDocument(TaskXmlWriter *this); // idb
__int64 __fastcall TaskXmlReader::ProcessXml(TaskXmlReader *this, struct ITaskXmlHandler *a2); // idb
__int64 __fastcall TaskXmlReader::ValidateNamespace(__int64 a1, int a2);
__int64 __fastcall TaskXmlReader::ProcessComplexContent(__int64 a1, __int64 a2, int a3, char a4, _BYTE *a5);
__int64 __fastcall TaskXmlReader::ProcessElement(__int64 a1, __int64 a2, unsigned int a3, char a4, _BYTE *a5);
__int64 __fastcall TaskXmlReader::ProcessAttributes(__int64 a1, __int64 a2, int a3, _BYTE *a4);
__int64 __fastcall TaskXmlReader::ProcessSimpleContent(__int64 a1, __int64 a2, int a3, char a4, _BYTE *a5);
__int64 __fastcall _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::operator->(__int64 *a1);
__int64 __fastcall TaskXmlReader::LoadValue(TaskXmlReader *this, bool *a2); // idb
bool __fastcall XmlParserTempString::IsEqualTo(const wchar_t **this, const unsigned __int16 *a2, size_t a3);
__int64 __fastcall TaskXmlReader::LoadRawValue(TaskXmlReader *this, struct XmlParserTempString *a2); // idb
__int64 __fastcall XmlParserTempString::Append(XmlParserTempString *this, char **a2);
__int64 __fastcall XmlParserTempString::TrimLeft(XmlParserTempString *this); // idb
void __fastcall XmlParserTempString::Clear(XmlParserTempString *this); // idb
__int64 __fastcall Schema::ChildId(int *a1, int a2);
const struct SchemaEntry * near *__fastcall Schema::GetEntry(int *a1, int a2);
__int64 __fastcall Schema::GetMaxNode(int *a1);
int __fastcall JobBucket::WriteSettingsXml(JobBucket *this, struct TaskXmlWriter *a2, struct Schema *a3);
__int64 __fastcall ServerXMLUpdateHandler::WriterHandler::EndElement(__int64 a1, __int64 a2, int a3);
__int64 __fastcall TaskXmlWriter::StartElementWithAttribute(__int64 a1, int a2, int a3, __int64 a4);
__int64 __fastcall TaskXmlWriter::Element(__int64 a1, int a2, __int64 a3);
__int64 __fastcall ServerXMLUpdateHandler::WriterHandler::Process(__int64 a1, const struct Schema *a2, int a3, __int64 a4, char a5);
__int64 __fastcall TaskXmlWriter::StartElement(int *a1, int a2);
__int64 __fastcall TaskXmlWriter::EndElement(__int64 a1);
int __fastcall TaskXmlWriter::StartDocument(__int64 a1, int a2);
__int64 __fastcall TSParser::ParseDateTime(const unsigned __int16 *a1, unsigned __int64 a2, SYSTEMTIME *a3);
__int64 __fastcall TSParser::ParseWord(const unsigned __int16 *a1, unsigned __int64 a2, unsigned int *a3, unsigned __int16 *a4); // idb
__int64 __fastcall TSParser::ParseULongLong(const unsigned __int16 *a1, unsigned __int64 a2, unsigned int *a3, unsigned __int64 *a4); // idb
__int64 __fastcall ULongToUShort(unsigned int a1, unsigned __int16 *a2); // idb
__int64 StringCchPrintfW(unsigned __int16 *a1, size_t a2, size_t *a3, ...);
static HRESULT __stdcall StringVPrintfWorkerW(STRSAFE_LPWSTR pszDest, size_t cchDest, size_t *pcchNewDestLength, STRSAFE_LPCWSTR pszFormat, va_list argList);
__int64 __fastcall tsched::TaskPathCanonicalize(tsched *this, char *a2, const unsigned __int16 *a3);
__int64 __fastcall TaskXmlWriter::ElementDuration(__int64 a1, int a2, unsigned int a3);
__int64 __fastcall StringCchCatW(unsigned __int16 *a1, __int64 a2, char *a3);
__int64 __fastcall Triggers::WnfStateChangeTrigger::WriteInnerXml(Triggers::WnfStateChangeTrigger *this, struct TaskXmlWriter *a2); // idb
char *__fastcall UbpmParams::NewHostedString(unsigned __int64 a1, __int64 *a2, unsigned __int16 *a3, unsigned __int64 a4);
__int64 __fastcall StringCchCopyW(char *a1, __int64 a2, char *a3);
__int64 __fastcall StringCchLengthW(const unsigned __int16 *a1, unsigned __int64 a2, unsigned __int64 *a3); // idb
__int64 __fastcall std::vector<unsigned short *>::_Reserve(_QWORD *a1);
char *__fastcall std::vector<unsigned short *>::_Reallocate(__int64 a1, unsigned __int64 a2);
__int64 __fastcall TaskXmlReader::LoadRunLevel(TaskXmlReader *this, enum JobFlags::JobFlag *a2); // idb
__int64 __fastcall ServerXMLUpdateHandler::WriteContext(__int64 a1, int *a2, int a3, __int64 a4, __int64 a5);
__int64 __fastcall ServerXMLUpdateHandler::ContextHandler::Process(__int64 a1, int *a2, int a3, __int64 a4);
__int64 __fastcall tsched::SafePathAppend(tsched *this, unsigned __int16 *a2, tsched *a3, tsched *a4);
__int64 __fastcall JobBucket::WritePrincipalXml(JobBucket *this, struct TaskXmlWriter *a2, struct Schema *a3); // idb
__int64 __fastcall TaskXmlReader::LoadDateTime(const unsigned __int16 **this, SYSTEMTIME *a2);
__int64 __fastcall UbpmParams::AddExeAction(UbpmParams *this, unsigned __int16 *a2, unsigned __int16 *a3, unsigned int a4, unsigned __int16 *a5, unsigned __int16 *a6);
__int64 __fastcall Triggers::TimeTrigger::WriteInnerXml(Triggers::TimeTrigger *this, struct TaskXmlWriter *a2);
__int64 __fastcall Triggers::GenericTrigger::WriteInnerXml(Triggers::GenericTrigger *this, struct TaskXmlWriter *a2); // idb
__int64 __fastcall Triggers::WnfStateChangeTrigger::WriteXml(Triggers::WnfStateChangeTrigger *this, struct TaskXmlWriter *a2); // idb
__int64 __fastcall JobBucket::GetExecutionTimeLimit(JobBucket *this);
__int64 __fastcall TSTime::operator+=(__int64 a1, __int64 *a2);
char *__fastcall UbpmParams::GetNewTriggerId(UbpmParams *this);
XmlParserTempString *__fastcall XmlParserTempString::operator=(XmlParserTempString *a1, __int64 a2);
__int64 __fastcall UbpmParams::SetActionConstraints(UbpmParams *this, const struct JobMoniker *a2); // idb
__int64 __fastcall JobBucket::GetPriority(JobBucket *this);
char *__fastcall UbpmParams::GetNewActionId(UbpmParams *this);
__int64 __fastcall TaskXmlReader::CreateXmlReader(TaskXmlReader *this); // idb
__int64 __fastcall TaskXmlWriter::ElementMultipleInstancesPolicy(__int64 a1, __int16 a2);
int __fastcall TaskXmlReader::LoadValue(TaskXmlReader *this, enum Schema::Version *a2);
__int64 __fastcall RpcServer::RetrieveTask(RpcServer *this, char *a2, const unsigned __int16 *a3, unsigned int *a4, unsigned __int16 **a5);
__int64 __fastcall GetCallerToken(const unsigned __int16 *a1, PHANDLE TokenHandle); // idb
RpcAutoImpersonate *__fastcall RpcAutoImpersonate::RpcAutoImpersonate(RpcAutoImpersonate *this, const unsigned __int16 *a2, int a3);
bool __fastcall tsched::IsRoot(tsched *this, const unsigned __int16 *a2); // idb
__int64 __fastcall SchRpcRetrieveTask(__int64 a1, char *a2, const unsigned __int16 *a3, unsigned int *a4, unsigned __int16 **a5);
__int64 __fastcall UbpmParams::AddComAction(UbpmParams *this, unsigned __int16 *a2, struct _GUID *a3, unsigned __int16 *a4, unsigned __int16 *a5);
void __fastcall TSTime::ToString(TSTime *this, unsigned __int16 *a2, int a3);
__int64 __fastcall Triggers::WnfStateChangeTrigger::ToUbpmFormat(Triggers::WnfStateChangeTrigger *this, const struct Triggers::TriggerExportOptions *a2, struct IUbpmRegistrationParams *a3); // idb
__int64 __fastcall Triggers::TimeTrigger::GetEndBoundary(__int64 a1, __int64 a2);
__int64 __fastcall Scheduling::JobSchedule::GetStop(__int64 a1, __int64 a2);
struct _SYSTEMTIME *__fastcall TSTime::ToSYSTEMTIME(TSTime *this, struct _SYSTEMTIME *__return_ptr retstr); // idb
__int64 __fastcall TSTime::operator+(__int64 a1, __int64 a2, unsigned int a3);
_OWORD *__fastcall TSTime::ToGMT(__int128 *a1, _OWORD *a2);
__int64 __fastcall TaskXmlWriter::ElementTSDateTime(__int64 a1, int a2, TSTime *a3);
__int64 __fastcall Triggers::TimeTrigger::WriteXml(Triggers::TimeTrigger *this, struct TaskXmlWriter *a2); // idb
__int64 __fastcall TaskXmlWriter::ElementRunLevel(__int64 a1, int a2, int a3);
__int64 __fastcall ServerXMLUpdateHandler::CreateWriter(ServerXMLUpdateHandler *this, const struct Schema *a2); // idb
__int64 __fastcall TaskXmlWriter::TaskXmlWriter(__int64 a1, __int64 *a2, _DWORD *a3);
void __fastcall ServerXMLUpdateHandler::WriteURI(ServerXMLUpdateHandler *this, const struct Schema *a2, const struct ITaskXmlHandler::Data *a3); // idb
__int64 __fastcall ServerXMLUpdateHandler::RegistrationInfoHandler::Process(__int64 a1, const struct Schema *a2, int a3, const struct ITaskXmlHandler::Data *a4);
__int64 __fastcall Actions::ActionCollection::WriteXml(Actions::ActionCollection *this, struct TaskXmlWriter *a2); // idb
bool __fastcall User::IsGroupAccount(User *this); // idb
char __fastcall User::IsService(User *this);
bool __fastcall User::IsLocalSystem(User *this); // idb
__int64 __fastcall User::GetSidString(User *this, struct _bstr_t *a2); // idb
void __fastcall Actions::ActionCollection::~ActionCollection(Actions::ActionCollection *this); // idb
void __fastcall ServerXMLUpdateHandler::~ServerXMLUpdateHandler(ServerXMLUpdateHandler *this); // idb
TaskXmlWriter *__fastcall TaskXmlWriter::`scalar deleting destructor'(TaskXmlWriter *this);
void __fastcall TriggersXmlHandler::~TriggersXmlHandler(TriggersXmlHandler *this); // idb
void __fastcall ValidationXmlHandler::~ValidationXmlHandler(ValidationXmlHandler *this); // idb
void __fastcall std::_Tree<std::_Tmap_traits<_bstr_t,std::list<_FILETIME> *,Aggregator::less,std::allocator<std::pair<_bstr_t const,std::list<_FILETIME> *>>,0>>::_Erase(__int64 a1, __int64 *a2);
void __fastcall ValidationXmlHandler::CurrentTrigger::~CurrentTrigger(ValidationXmlHandler::CurrentTrigger *this); // idb
void __fastcall TriggersXmlHandler::CurrentAction::~CurrentAction(TriggersXmlHandler::CurrentAction *this); // idb
Actions::ActionCollection *__fastcall Actions::ActionCollection::ActionCollection(Actions::ActionCollection *this);
__int64 __fastcall TaskXmlReader::TaskXmlReader(__int64 a1, __int64 *a2, __int64 a3, char a4);
TaskXmlReader *__fastcall TaskXmlReader::`vector deleting destructor'(TaskXmlReader *this, char a2);
signed int __fastcall ExeTask::ExportToUbpmFormat(BSTR **this, struct IUbpmRegistrationParams *a2);
signed int __fastcall ExeTask::NormalizePathAndArguments(BSTR **this);
void __fastcall ExeTask::StripQuotes(ExeTask *this); // idb
__int64 __fastcall ExeTask::SetRealTarget(ExeTask *this); // idb
__int64 __fastcall UbpmParams::AddTimeTrigger(UbpmParams *this, const struct Scheduling::JobSchedule *a2, __int64 a3, __int64 a4);
void __fastcall ServerXMLUpdateHandler::WriteSecurityDescriptor(ServerXMLUpdateHandler *this, const struct Schema *a2, const struct ITaskXmlHandler::Data *a3); // idb
__int64 __fastcall ATL::CComPtr<IStream>::operator=(__int64 *a1, __int64 a2);
_OWORD *__fastcall TSTime::ToLocal(__int128 *a1, _OWORD *a2);
__int64 __fastcall UbpmParams::NewHostedObject<std::vector<_DAB_TRIGGER_PARAMS *>,_DAB_TRIGGER_PARAMS>(__int64 *a1, __int64 a2);
__int64 __fastcall UbpmParams::ConvertToUbpmRepetitionInterval(UbpmParams *this, unsigned int a2);
__int64 __fastcall JobStore::LoadBucketFromRegistry(HKEY *a1, const unsigned __int16 *a2, int a3, __int64 a4, __int64 a5, __int64 *a6);
JobMoniker *__fastcall JobMoniker::JobMoniker(JobMoniker *this, const unsigned __int16 *a2, const struct _GUID *a3); // idb
void __fastcall JobStore::RegGetOverrideInfo(HKEY *this, const unsigned __int16 *a2, enum JobFlags::StatePersistanceFlags *a3);
__int64 __fastcall Triggers::SessionChangeTrigger::ToUbpmFormat(Triggers::SessionChangeTrigger *this, const struct Triggers::TriggerExportOptions *a2, struct IUbpmRegistrationParams *a3); // idb
void __fastcall std::list<Task *>::clear(__int64 a1);
__int64 __fastcall RpcServer::RegisterTask(void **this, unsigned __int16 *a2, struct _EVENT_DESCRIPTOR *a3, unsigned int a4, unsigned __int16 *a5, unsigned int a6, unsigned int a7, const struct _TASK_USER_CRED *a8, BYTE *a9, unsigned __int16 **a10, struct _TASK_XML_ERROR_INFO **a11);
__int64 __fastcall std::pair<User const,LogonJob *>::~pair<User const,LogonJob *>(_QWORD); // weak
User::UserEntry **__fastcall User::CreateUser(User::UserEntry **a1, __int64 **a2, const wchar_t ***a3, enum _SID_NAME_USE a4, struct _RTL_CRITICAL_SECTION *a5);
bool __fastcall _bstr_t::operator!(_QWORD *a1);
__int64 __fastcall User::UserEntry::AddRef(User::UserEntry *this);
User *__fastcall User::User(User *this); // idb
__int64 __fastcall _bstr_t::operator unsigned short const *(__int64 a1);
__int64 __fastcall User::FromImpersonationToken(struct User *a1, void *a2);
__int64 __fastcall User::FromUsername(User::UserEntry **this, LPCWSTR lpAccountName);
__int64 __fastcall User::FromSid(User::UserEntry **this, void *a2, enum _SID_NAME_USE a3);
void __fastcall User::UpdateEntry(void ***this, __int64 **a2, const wchar_t ***a3, const struct _bstr_t *a4, enum _SID_NAME_USE a5, void *a6, bool a7);
__int64 __fastcall Triggers::SessionBasedTrigger::ResolveUPN(Triggers::SessionBasedTrigger *this); // idb
void __fastcall JobSecurity::~JobSecurity(JobSecurity *__hidden this); // idb
User::UserEntry *__fastcall User::UserEntry::UserEntry(User::UserEntry *this, char a2, const struct _bstr_t *a3, const struct _bstr_t *a4, const struct _bstr_t *a5, enum _SID_NAME_USE a6, void *a7);
void __fastcall User::UserEntry::CopySid(void **this, void *a2);
ATL::CComBSTR *__fastcall ATL::CComBSTR::CComBSTR(ATL::CComBSTR *this, UINT a2);
__int64 __fastcall EventManager::EvtReport(EventManager *this, const struct _EVENT_DESCRIPTOR *a2, const unsigned __int16 *a3, const unsigned __int16 *a4);
void __fastcall tsched::SecretGuard::Erase(void **this);
__int64 __fastcall RpcServer::FlushTriggers(BSTR **a1);
__int64 __fastcall PseudoEventTrap::UnregisterSessionChangeJob(PseudoEventTrap *this, BSTR **a2);
__int64 __fastcall PseudoEventTrap::UnregisterLogonJob(PseudoEventTrap *this, BSTR **a2);
__int64 __fastcall PseudoEventTrap::UnregisterIdleJob(PseudoEventTrap *this, BSTR **a2);
__int64 __fastcall Scheduler::DeleteJobSchedule(Scheduler *this, BSTR **a2);
DWORD __fastcall ItSpUserDetectionCallback(struct _ITSRV_GLOBAL_CONTEXT *a1, int a2, _DWORD *a3);
__int64 __fastcall EventManager::EvtReport(EventManager *this, const struct _EVENT_DESCRIPTOR *a2, const unsigned __int16 *a3, int a4);
DWORD __fastcall ItSpSubmitThreadpoolWork(struct _TP_WORK **a1, struct _ITSRV_GLOBAL_CONTEXT *a2, void (__stdcall *a3)(struct _TP_CALLBACK_INSTANCE *, void *, struct _TP_WORK *));
__int64 __fastcall TaskXmlReader::LoadSessionStateChange(TaskXmlReader *this, unsigned int *a2); // idb
wmi::Exception *__fastcall wmi::Exception::Exception(wmi::Exception *this, const struct wmi::Exception *a2);
wmi::IException *__fastcall wmi::IException::IException(wmi::IException *this, const struct wmi::IException *a2);
__int64 __fastcall wmi::GenericException::GetErrorCode(wmi::GenericException *this);
__int64 __fastcall wmi::GenericException::GetErrorParam(wmi::GenericException *this);
const char *__fastcall wmi::GenericException::GetFileName(wmi::GenericException *this); // idb
__int64 __fastcall wmi::GenericException::GetLineNumber(wmi::GenericException *this); // idb
__int64 __fastcall Triggers::GenericTrigger::GetTimeoutSeconds(Triggers::GenericTrigger *this);
const unsigned __int16 *__fastcall wmi::GenericException::GetMessageParam(wmi::GenericException *this); // idb
__int64 __fastcall wmi::GenericException::GetSubErrorCode(wmi::GenericException *this);
__int64 __fastcall ComHandlerTask::Grip::PrepStop(ComHandlerTask::Grip *this); // idb
__int64 _LockRegion__QIStream__StringStream__EEAAJT_ULARGE_INTEGER__0K_Z();
__int64 __fastcall ExeTask::GetEnginePID(ExeTask *this);
__int64 __fastcall Triggers::RegistrationTrigger::GetTypeTag(Triggers::RegistrationTrigger *this);
__int64 __fastcall Triggers::WnfStateChangeTrigger::GetTypeTag(Triggers::WnfStateChangeTrigger *this);
void __fastcall wmi::RefBase::~RefBase(wmi::RefBase *this); // idb
void __fastcall std::auto_ptr<User>::`default constructor closure'(_QWORD *a1);
void __fastcall CDLink::~CDLink(CDLink *this); // idb
__int64 __fastcall tsched::EvtNopCallback(tsched *this, enum _EVT_SUBSCRIBE_NOTIFY_ACTION a2, void *a3, void *a4);
struct _GUID *__fastcall ATL::CAcl::CAce::ObjectType(ATL::CAcl::CAce *this, struct _GUID *__return_ptr retstr); // idb
char __fastcall ATL::CDacl::CAccessObjectAce::IsObjectAce(ATL::CDacl::CAccessObjectAce *this);
bool __fastcall ATL::CAcl::CAce::IsObjectAce(ATL::CAcl::CAce *this); // idb
__int64 __fastcall wil::details::RecordFailFast(wil::details *this);
bool __fastcall Triggers::GenericTrigger::Enabled(Triggers::GenericTrigger *this); // idb
bool __fastcall Triggers::TimeTrigger::Enabled(Triggers::TimeTrigger *this); // idb
_OWORD *__fastcall Triggers::GenericTrigger::GetEndBoundary(__int64 a1, _OWORD *a2);
_OWORD *__fastcall Triggers::TimeTrigger::GetStartBoundary(__int64 a1, _OWORD *a2);
__int64 __fastcall Triggers::TimeTrigger::GetTimeoutSeconds(Triggers::TimeTrigger *this);
__int64 __fastcall Triggers::BootTrigger::GetTypeTag(Triggers::BootTrigger *this);
__int64 __fastcall Triggers::EventTrigger::GetTypeTag(Triggers::EventTrigger *this);
__int64 __fastcall Triggers::IdleTrigger::GetTypeTag(Triggers::IdleTrigger *this);
__int64 __fastcall Triggers::ImmediateTrigger::GetTypeTag(Triggers::ImmediateTrigger *this);
__int64 __fastcall Triggers::LogonTrigger::GetTypeTag(Triggers::LogonTrigger *this);
__int64 __fastcall Triggers::MaintenanceTrigger::GetTypeTag(Triggers::MaintenanceTrigger *this);
__int64 __fastcall Triggers::SessionChangeTrigger::GetTypeTag(Triggers::SessionChangeTrigger *this);
__int64 __fastcall Triggers::TimeTrigger::GetTypeTag(Triggers::TimeTrigger *this);
__int64 __fastcall Triggers::MaintenanceTrigger::RegisterThyself(Triggers::MaintenanceTrigger *this, struct JobMoniker *a2, struct Triggers::TriggerOptions *a3); // idb
__int64 __fastcall MessageBoxTask::GetTypeTag(MessageBoxTask *this);
__int64 __fastcall ValidationXmlHandler::InvalidNode(__int64 a1);
__int64 __fastcall SchRpcGetNumberOfMissedRuns(__int64 a1, __int64 a2, _DWORD *a3);
void __fastcall UbpmParams::SetDynamicTaskInfo(UbpmParams *this, const struct DynamicTaskInfo *a2); // idb
struct ATL::CStringData *__fastcall ATL::CAtlStringMgr::GetNilString(ATL::CAtlStringMgr *this); // idb
__int64 __fastcall StringStream::AddRef(StringStream *this);
void __fastcall HashCompute::~HashCompute(struct _RTL_CRITICAL_SECTION *this);
__int64 __fastcall EventTrapMap::ConsumerCallback(EventTrapMap *Action, struct EventTrap *UserContext, EVT_HANDLE Event);
__int64 __fastcall Aggregator::AddEvent(Aggregator *this, const unsigned __int16 *a2, int *a3); // idb
__int64 __fastcall TSTime::operator+(__int64 a1, __int64 a2, int a3);
__int64 __fastcall EventTrapMap::EventReceived(EventTrapMap *this, struct EventTrap *a2, void *a3);
__int64 __fastcall EventTrapMap::SendUbpmTriggerEmulatorEvent(__int64 a1, __int64 a2, _QWORD **a3);
__int64 __fastcall Scheduler::EvaluateMissedRuns(Scheduler *this); // idb
__int64 __fastcall Scheduler::EnqueueMissedRuns(Scheduler *this); // idb
struct _ITSRV_GLOBAL_CONTEXT near **wil::details_abi::ThreadLocalStorage<wil::details::ThreadFailureCallbackHolder *>::~ThreadLocalStorage<wil::details::ThreadFailureCallbackHolder *>();
void __fastcall wil::manually_managed_shutdown_aware_object<wil::details::FeatureStateManager>::destroy(wil *a1);
void __fastcall wil::manually_managed_shutdown_aware_object<wil::details::EnabledStateManager>::destroy(wil *a1);
char __fastcall wil::ProcessShutdownInProgress(wil *this);
char __fastcall Scheduler::GetWakeupCall(Scheduler *this, struct TSTime *a2, struct JobMoniker *a3);
char __fastcall ScheduleList::GetWakeupCall(ScheduleList *this, struct TSTime *a2, struct JobMoniker *a3);
void __fastcall Scheduler::NotifySleep(Scheduler *this, unsigned __int8 a2);
char __fastcall wil::details::RtlDllShutdownInProgress(wil::details *this);
HINSTANCE wil_details_GetNtDllModuleHandle(void); // idb
char __fastcall Triggers::TriggerBase::Active(Triggers::TriggerBase *this);
void __fastcall ItSrvNotifyResume(char a1);
__int64 __fastcall TSTime::operator-(__int64 a1, __int128 *a2);
__int64 WppCleanupUm();
void __fastcall Scheduler::NotifyTimeChange(Scheduler *this); // idb
void __fastcall Idolater::~Idolater(Idolater *this); // idb
void __fastcall _variant_t::~_variant_t(_variant_t *this); // idb
void __fastcall wil::details::EnabledStateManager::RecordCachedUsageUnderLock(wil::details::EnabledStateManager *this); // idb
void __fastcall SortedRunList::FreeList(SortedRunList *this); // idb
void __fastcall std::vector<unsigned short>::_Tidy(__int64 a1);
void __fastcall PrivateHeap::~PrivateHeap(PrivateHeap *this); // idb
void __fastcall RpcServer::~RpcServer(RpcServer *this); // idb
__int64 wil::details_abi::ProcessLocalStorage<wil::details_abi::ProcessLocalData>::~ProcessLocalStorage<wil::details_abi::ProcessLocalData>();
HashCompute *__fastcall HashCompute::HashCompute(HashCompute *this); // idb
Idolater *__fastcall Idolater::Idolater(Idolater *this); // idb
__int64 wil::manually_managed_shutdown_aware_object<wil::details::EnabledStateManager>::construct();
wil::details::FeatureStateManager *__fastcall wil::details::FeatureStateManager::FeatureStateManager(wil::details::FeatureStateManager *this);
struct _RTL_CRITICAL_SECTION *__fastcall wil::details_abi::SubscriptionList::SubscriptionList(struct _RTL_CRITICAL_SECTION *this);
__int64 __fastcall JobsService::HandlerEx(JobsService *this, unsigned int a2, unsigned int a3, DWORD *a4);
void __fastcall PseudoEventTrap::QueueOrProcessSessionChange(struct _RTL_CRITICAL_SECTION *this, unsigned int a2, DWORD a3);
void __fastcall PseudoEventTrap::ProcessSessionChange(PseudoEventTrap *this, unsigned int a2, DWORD a3);
void __fastcall PseudoEventTrap::NotifyLogon(PseudoEventTrap *this, DWORD a2);
void __fastcall ControlEventToStrings(unsigned int a1, unsigned int a2, const char **a3, const char **a4); // idb
void __fastcall User::NotifyLogon(DWORD SessionId, const unsigned __int16 *a2); // idb
char __fastcall ATL::CSid::LoadAccount(ATL::CSid *this, LPCWSTR lpAccountName, const unsigned __int16 *a3);
void __fastcall ATL::CTempBuffer<unsigned short,128,ATL::CCRTAllocator>::FreeHeap(void **a1);
_QWORD *__fastcall ATL::CTempBuffer<unsigned short,128,ATL::CCRTAllocator>::AllocateBytes(_QWORD *a1, size_t a2);
void *__fastcall ATL::CTempBuffer<unsigned short,128,ATL::CCRTAllocator>::AllocateHeap(_QWORD *a1, size_t a2);
struct ATL::CStringData *__fastcall ATL::CAtlStringMgr::Allocate(ATL::CAtlStringMgr *this, int a2, int a3); // idb
__int64 __fastcall ATL::AtlMultiply<unsigned __int64>(_QWORD *a1, unsigned __int64 a2, unsigned __int64 a3);
_bstr_t *__fastcall _bstr_t::_bstr_t(_bstr_t *this, const char *a2); // idb
__int64 __fastcall SchRpcDelete(__int64 a1, unsigned __int16 *a2, int a3);
__int64 __fastcall RpcServer::Delete(RTL_SRWLOCK *this, unsigned __int16 *a2, int a3);
void __fastcall ATL::CSimpleStringT<unsigned short,0>::PrepareWrite2(__int64 *a1, signed int a2);
void __fastcall ATL::CSimpleStringT<unsigned short,0>::Fork(const void **a1, unsigned int a2);
void __fastcall ATL::CSimpleStringT<unsigned short,0>::SetString(__int64 *a1, const void *a2, signed int a3);
__int64 __fastcall Scheduler::CalcWait(Scheduler *this, struct _FILETIME *const a2, struct _FILETIME *const a3);
__int64 __fastcall CNtService::_HandlerEx(DWORD dwControl, DWORD dwEventType, LPVOID lpEventData, LPVOID lpContext);
__int64 __fastcall Scheduler::EvaluateScheduledJobs(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall Scheduler::StartFirstMissedRun(Scheduler *this, int a2);
__int64 __fastcall TraceLoggingRegisterEx_EventRegister_EventSetInformation(ULONGLONG *CallbackContext);
BSTR __fastcall _com_util::_ConvertStringToBSTR(const char *a1);
__int64 __fastcall ATL::CSimpleStringT<unsigned short,0>::SetLength(__int64 *a1, int a2);
__int64 WppInitUm();
void __fastcall tlgEnableCallback(LPCGUID SourceId, __int64 IsEnabled, __int64 Level, ULONGLONG MatchAnyKeyword, ULONGLONG MatchAllKeyword, PEVENT_FILTER_DESCRIPTOR FilterData, _QWORD *CallbackContext);
PrivateHeap *__fastcall PrivateHeap::PrivateHeap(PrivateHeap *this); // idb
void *__fastcall InterlockedAutoHandle::operator=(__int64 a1, __int64 a2);
_variant_t *__fastcall _variant_t::_variant_t(_variant_t *this);
__int64 __fastcall EventManager::EvtReport(EventManager *this, const struct _EVENT_DESCRIPTOR *a2, void *a3, const struct _GUID *a4); // idb
void __fastcall ATL::CWin32Heap::Free(HANDLE *this, void *a2);
LPVOID __fastcall ATL::CWin32Heap::Allocate(HANDLE *this, SIZE_T a2);
void __fastcall ATL::CAtlStringMgr::Free(ATL::CAtlStringMgr *this, struct ATL::CStringData *a2); // idb
__int64 WPP_INIT_CONTROL_ARRAY();
int *__fastcall ShutdownMgr::Sync::Sync(ShutdownMgr::Sync *this);
__int64 __fastcall ItSpConsoleDisplayStateChangeCallback(volatile __int32 *a1, int a2, _DWORD *a3);
__int64 __fastcall ItSpRpcSecurityCallback(RPC_IF_HANDLE InterfaceUuid, void *Context);
void __fastcall JobsService::SCMEventLogNotificationWorker(PTP_CALLBACK_INSTANCE Instance, PVOID Context, PTP_WORK Work);
void __fastcall EventTrapMap::ProcessSCMNotification(EventTrapMap *this, __int32 a2);
__int64 __fastcall RpcServer::StartServer(RPC_BINDING_VECTOR **BindingVector); // idb
__int64 ItSrvInitialize();
__int64 __fastcall ItSpUpdateStatus(unsigned int *a1, unsigned int a2);
__int64 __fastcall UbpmProxySingleton::RunTask(__int64 a1, __int64 a2, __int64 a3, __int64 **a4, char a5, User *a6, int a7, __int64 a8, _OWORD *a9);
__int64 __fastcall ItSpStartIdleDetection(struct _ITSRV_GLOBAL_CONTEXT *a1);
__int64 __fastcall UbpmProxySingleton::CreateShallowStringArray(BSTR ***a1, void **a2);
__int64 __fastcall UbpmProxySingleton::ExpandVariablesInStrings(BSTR **a1, BSTR ***a2);
__int64 __fastcall Task::ExpandVariablesInString(BSTR *a1, BSTR ***a2);
__int64 __fastcall ItSpRetrieveDetectionOverrides(struct _IT_IDLE_DETECTION_PARAMETERS *a1);
LSTATUS __fastcall ItSpRetrieveOverrideValue(HKEY a1, const unsigned __int16 *a2, unsigned int *a3);
__int64 __fastcall ItSpRetrieveRuntimeOverrides(struct _IT_IDLE_RUNTIME_PARAMETERS *a1);
__int64 __fastcall ItSpRetrieveOverrideValue(HKEY hKey, const unsigned __int16 *a2, unsigned __int16 **a3, unsigned int *a4);
LSTATUS __fastcall ItSpRetrieveOverrideValue(HKEY a1, const unsigned __int16 *a2, bool *a3);
__int64 RpcServer::IsNonAdminTasksDisabled(void); // idb
__int64 RpcServer::IsRpcOverTcpDisabled(void); // idb
__int64 JobsService::ControlOperationalLog(void); // idb
signed int __fastcall JobsService::IsMachineDomainJoinPrevDetected(int *a1);
__int64 __fastcall JobsService::IsMachineDomainJoined(int *a1); // idb
__int64 IsSystemUpgradeInProgress();
__int64 __fastcall QueryUpgradeValue(_DWORD *a1);
__int64 JobStore::IsWinPESetupInProgress(void); // idb
__int64 JobStore::IsSystemSetupInProgress(void); // idb
signed int __fastcall Actions::ActionCollection::ExtractActionArgs(__int64 **a1, __int64 *a2, __int64 *a3);
__int64 *__fastcall std::vector<_bstr_t>::push_back(__int64 *a1, __int64 *a2);
__int64 __fastcall std::vector<_bstr_t>::_Reserve(_QWORD *a1);
__int64 *__fastcall std::vector<_bstr_t>::_Reallocate(__int64 a1, unsigned __int64 a2);
__int64 *__fastcall std::_Uninit_move<_bstr_t *,_bstr_t *,std::allocator<_bstr_t>,_bstr_t>(__int64 *a1, __int64 *a2, __int64 *a3);
__int64 __fastcall JobsService::Initialize(JobsService *this, struct SERVICE_STATUS_HANDLE__ *a2, __int64 a3, const unsigned __int16 *const *a4);
__int64 __fastcall JobsService::InitializeWPTS(JobsService *this); // idb
__int64 __fastcall JobsService::InitializeSCMEventLogNotifications(JobsService *this); // idb
__int64 __fastcall PlugIn::Load(struct _RTL_CRITICAL_SECTION *this);
signed int __fastcall PlugIn::LoadFunctionPointers(PlugIn *this);
bool JobsService::IsCompatibilityAdapterDisabled(void); // idb
__int64 __fastcall Idolater::Init(Idolater *this); // idb
__int64 __fastcall Idolater::RegisterWithIdleService(Idolater *this); // idb
__int64 __fastcall ItSrvSetTSchedHandle(HANDLE hSourceHandle, HANDLE a2); // idb
__int64 __fastcall ItSrvRegisterIdleTask(__int64 a1, _QWORD *a2, __int64 a3);
unsigned __int8 __fastcall ItSpCheckRegistrationExempts(struct _ITSRV_GLOBAL_CONTEXT *a1, void *a2);
__int64 __fastcall EventManager::EvtReport(EventManager *this, const struct _EVENT_DESCRIPTOR *a2, __int64 a3, __int64 a4);
// PseudoEventTrap *__fastcall PseudoEventTrap::PseudoEventTrap(PseudoEventTrap *__hidden this); idb
_QWORD *std::_Tree_alloc<0,std::_Tree_base_types<std::pair<User const,LogonJob *>>>::_Buyheadnode();
EventTrapMap *__fastcall EventTrapMap::EventTrapMap(EventTrapMap *this); // idb
Scheduler *__fastcall Scheduler::Scheduler(Scheduler *this, void *a2, void *a3); // idb
_QWORD *std::_Tree_alloc<0,std::_Tree_base_types<std::pair<JobMoniker const,_FILETIME>>>::_Buyheadnode();
__int64 CredStore::Init(void); // idb
__int64 __fastcall CredStore::Upgrade(CredStore *this); // idb
__int64 __fastcall CredStore::StartUpgrade(__int64 a1, HKEY *a2);
__int64 __fastcall JobStore::CreateCommonJobStore(HKEY a1, HKEY a2); // idb
__int64 __fastcall JobStore::InitJobStore(JobStore *this); // idb
__int64 __fastcall JobStore::InitKnownTreeFolder(HKEY *this, unsigned __int16 *a2, LPCWSTR StringSecurityDescriptor);
__int64 __fastcall JobStore::InitStorePath(void **this);
__int64 __fastcall JobStore::ExpandEnvironmentString(LPCWSTR lpSrc, void **a2);
void __fastcall JobStore::ConfigurationChangeCallback(void *a1);
void __fastcall JobStore::ReadConfiguration(JobStore *this); // idb
void __fastcall JobStore::InitConfig(JobStore *this); // idb
__int64 __fastcall HashCompute::init(HashCompute *this);
JobStore *__fastcall JobStore::JobStore(JobStore *this, HKEY a2, HKEY a3); // idb
_QWORD *std::_Tree_alloc<0,std::_Tree_base_types<JobMoniker>>::_Buyheadnode();
User::UserEntry *__fastcall User::GetLocalSystem(User::UserEntry *a1);
User::UserEntry *__fastcall User::CreateUser(User::UserEntry *a1, WCHAR ***a2, enum _SID_NAME_USE a3, void *a4, bool a5);
User::UserEntry **__fastcall User::GetNetworkService(User::UserEntry **a1);
User::UserEntry **__fastcall User::GetLocalService(User::UserEntry **a1);
__int64 __fastcall User::UpdateEntry(User *this); // idb
__int64 __fastcall User::InitializeUserTable();
User::UserEntry **__fastcall User::CreateWellKnownUser(User::UserEntry **a1, WELL_KNOWN_SID_TYPE a2);
__int64 __fastcall User::FromSidToDomainAccount(struct _bstr_t *a1, void *a2); // idb
__int64 __fastcall User::AssembleFullUserName(struct _bstr_t *a1, char ***a2, char ***a3);
__int64 __fastcall User::LookupUserSid(struct _bstr_t *a1, struct _bstr_t *a2, enum _SID_NAME_USE *a3, void *a4);
OLECHAR **__fastcall ATL::CComBSTR::operator=(OLECHAR **a1, LPCSTR *a2);
void __fastcall ServiceMain(unsigned int a1, const unsigned __int16 *const *a2); // idb
__int64 __fastcall CNtService::Run(CNtService *this, char *a2, unsigned int a3, const unsigned __int16 *const *a4, void *lpContext);
__int64 __fastcall CNtService::ReportStatusToSCMgr(CNtService *this, int a2, __int64 a3, int a4, unsigned int a5);
JobsService *__fastcall JobsService::JobsService(JobsService *this);
void __fastcall PseudoEventTrap::DiscoverAutologons(PseudoEventTrap *this); // idb
__int64 __fastcall _WorkerThread__QCNtService__JobsService__UEAAKXZ(__int64 a1, __int64 a2, void *a3, const struct _GUID *a4);
__int64 __fastcall Scheduler::TimerThreadFunction(Scheduler *this); // idb
__int64 JobsService::SetServiceRestartOptions(void); // idb
void __fastcall PseudoEventTrap::ProcessSessionChanges(PseudoEventTrap *this); // idb
__int64 __fastcall JobStore::ReloadMigratedTasks(JobStore *this); // idb
__int64 __fastcall JobStore::IsMTRCompleted(JobStore *this); // idb
char __fastcall tlgKeywordOn(__int64 a1, __int64 a2);
__int64 __fastcall JobStore::IsPermissionsRestoreCompleted(JobStore *this); // idb
__int64 __fastcall JobStore::LoadJobs(JobStore *this, int a2); // idb
__int64 __fastcall JobStore::LoadIndex(HKEY *a1, int a2, bool a3, bool *a4);
__int64 __fastcall IndexEnumerator::FindNext(IndexEnumerator *this); // idb
__int64 __fastcall JobStore::InstantiateTaskEntry(HKEY *this, const wchar_t **a2, unsigned __int8 a3, bool *a4);
__int64 __fastcall std::_Tree<std::_Tset_traits<JobMoniker,std::less<JobMoniker>,std::allocator<JobMoniker>,0>>::erase(_QWORD *a1, __int64 a2);
_QWORD *__fastcall std::_Tree<std::_Tset_traits<JobMoniker,std::less<JobMoniker>,std::allocator<JobMoniker>,0>>::erase(_QWORD *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4);
void __fastcall std::_Tree<std::_Tset_traits<JobMoniker,std::less<JobMoniker>,std::allocator<JobMoniker>,0>>::_Erase(__int64 a1, wmi::RefBase **a2);
__int64 __fastcall Actions::ActionCollection::HasAction(__int64 **a1, __int16 a2);
__int64 __fastcall JobStore::IsMigrationCleanupCompleted(JobStore *this); // idb
__int64 __fastcall JobStore::IsHashingCompleted(JobStore *this); // idb
__int64 __fastcall IndexEnumerator::GetMoniker(IndexEnumerator *this, struct JobMoniker *a2); // idb
__int64 __fastcall JobStore::EnumStoredTasks(__int64 a1, int a2, _QWORD *a3);
IndexEnumerator *__fastcall IndexEnumerator::`vector deleting destructor'(IndexEnumerator *this, char a2);
char *__fastcall JobMoniker::`vector deleting destructor'(JobMoniker *this);
__int64 __fastcall IndexEnumerator::Initialize(IndexEnumerator *this, HKEY a2, HKEY a3);
__int64 __fastcall IndexEnumerator::LoadMoniker(HKEY hKey, HKEY a2, DWORD dwIndex, struct JobMoniker *a4); // idb
JobMoniker **__fastcall wmi::AutoVectorPtr<JobMoniker>::operator=(JobMoniker **a1, JobMoniker *a2);
__int64 __fastcall _Register__QEventTriggerRegistrar__EventTrapMap__UEAAJAEBVJobMoniker__PEAUEventTrigger_Triggers___Z(__int64 a1, JobMoniker *a2, struct Triggers::EventTrigger *a3);
EventTrap *__fastcall EventTrap::EventTrap(EventTrap *this, const struct JobMoniker *a2, struct Triggers::EventTrigger *a3); // idb
void __fastcall JobMoniker::~JobMoniker(wmi::RefBase **this);
__int64 __fastcall Triggers::Trigulator::RegisterAllUbpmEmulatedTriggers(Triggers::Trigulator *this, const wchar_t **a2);
__int64 __fastcall Triggers::EventTrigger::EventTrigger(__int64 a1, const OLECHAR *a2, _bstr_t *a3, __int128 *a4, __int128 *a5, int a6, int a7, char a8, __int128 *a9, int a10, int a11, _bstr_t *a12, void **a13);
Triggers::EventTrigger *__fastcall Triggers::EventTrigger::EventTrigger(Triggers::EventTrigger *this);
_QWORD *__fastcall std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>(_QWORD *a1, _QWORD *a2);
_QWORD *__fastcall std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::_Copy_nodes<std::integral_constant<bool,0>>(_QWORD *a1, __int64 a2, __int64 a3, char a4);
__int64 __fastcall Triggers::EventTrigger::StreamIn(Triggers::EventTrigger *this, unsigned __int64 a2, unsigned __int8 **a3, unsigned __int8 *a4);
__int64 __fastcall UbpmParams::AddMaintenanceTrigger(UbpmParams *this); // idb
__int64 __fastcall SchRpcRun(__int64 a1, unsigned __int16 *a2, unsigned int a3, const unsigned __int16 **a4, unsigned int a5, unsigned int a6, unsigned __int16 *a7, struct _GUID *a8);
__int64 __fastcall RpcServer::RunTask(RTL_SRWLOCK *this, unsigned __int16 *a2, unsigned int a3, const unsigned __int16 **a4, unsigned int a5, DWORD SessionId, const unsigned __int16 *StringSid, struct _GUID *a8);
__int64 __fastcall std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::_Insert_nohint<std::pair<_bstr_t const,_bstr_t>,std::_Nil>(__int64 *a1, __int64 a2, __int64 a3, BSTR **a4);
_QWORD *__fastcall std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::_Insert_at<std::pair<_bstr_t const,_bstr_t>,std::_Nil>(_QWORD *a1, _QWORD *a2, char a3, _QWORD *a4, __int64 *a5);
_QWORD *__fastcall std::_Tree_buy<std::pair<_bstr_t const,_bstr_t>>::_Buynode<std::pair<_bstr_t const,_bstr_t>>(_QWORD *a1, __int64 *a2);
__int64 __fastcall EventManager::EvtReport(EventManager *this, const struct _EVENT_DESCRIPTOR *a2, const unsigned __int16 *a3, const struct _GUID *a4, unsigned __int16 *a5);
__int64 *__fastcall User::GetAccount(__int64 a1, __int64 *a2);
__int64 *__fastcall std::pair<_bstr_t,_bstr_t>::pair<_bstr_t,_bstr_t>(__int64 *a1, __int64 *a2, __int64 *a3);
HRESULT __fastcall ExeTask::ResolveDocRunAssociation(ExeTask *this, LPCWSTR pszAssoc);
__int64 __fastcall ExeTask::SetAssocLaunchCommand(ExeTask *this, __int64 a2, unsigned int a3);
ATL::CComBSTR *__fastcall ATL::CComBSTR::CComBSTR(ATL::CComBSTR *this, UINT a2, const unsigned __int16 *a3);
__int64 __fastcall Triggers::LogonTrigger::ToUbpmFormat(Triggers::LogonTrigger *this, const struct Triggers::TriggerExportOptions *a2, struct IUbpmRegistrationParams *a3); // idb
__int64 InitializeCmdlineProcessing(void); // idb
void InitExtensions(void); // idb
DWORD __fastcall ItSpBatteryThesholdCallback(struct _ITSRV_GLOBAL_CONTEXT *a1, int a2, _DWORD *a3);
DWORD __fastcall ItSpPowerSourceDetectionCallback(struct _ITSRV_GLOBAL_CONTEXT *a1, int a2, _DWORD *a3);
DWORD __fastcall ItSpLPEDetectionCallback(struct _ITSRV_GLOBAL_CONTEXT *a1, int a2, _DWORD *a3);
void __fastcall JobMoniker::`default constructor closure'(JobMoniker *this); // idb
__int64 __fastcall Triggers::SessionChangeTrigger::WriteXml(Triggers::SessionChangeTrigger *this, struct TaskXmlWriter *a2); // idb
__int64 __fastcall Triggers::SessionChangeTrigger::WriteInnerXml(Triggers::SessionChangeTrigger *this, struct TaskXmlWriter *a2);
__int64 __fastcall TaskXmlWriter::ElementSessionStateChange(TaskXmlWriter *this, int a2);
__int64 __fastcall Auditor::StartupAuditing(Auditor *this, const unsigned __int16 *a2, __int64 a3);
__int64 __fastcall Auditor::EnableNamedPrivilege(Auditor *this, const unsigned __int16 *a2, __int64 a3, DWORD *a4);
void __fastcall tsched::HandleFree::~HandleFree(void ***this);
__int64 __fastcall User::LookupPrivilege(LPCWSTR lpName, PLUID lpLuid); // idb
__int64 __fastcall Triggers::EventTrigger::ToUbpmFormat(Triggers::EventTrigger *this, const struct Triggers::TriggerExportOptions *a2, struct IUbpmRegistrationParams *a3); // idb
__int64 __fastcall Triggers::BootTrigger::ToUbpmFormat(Triggers::BootTrigger *this, const struct Triggers::TriggerExportOptions *a2, struct IUbpmRegistrationParams *a3); // idb
__int64 __fastcall Triggers::RegistrationTrigger::ToUbpmFormat(Triggers::RegistrationTrigger *this, const struct Triggers::TriggerExportOptions *a2, struct IUbpmRegistrationParams *a3); // idb
Triggers::EventTrigger *__fastcall Triggers::EventTrigger::`scalar deleting destructor'(Triggers::EventTrigger *this, char a2);
void __fastcall AutoEvtHandle::Close(void **this);
__int64 __fastcall Triggers::IdleTrigger::ToUbpmFormat(Triggers::IdleTrigger *this, const struct Triggers::TriggerExportOptions *a2, struct IUbpmRegistrationParams *a3); // idb
__int64 __fastcall Triggers::MaintenanceTrigger::ToUbpmFormat(Triggers::MaintenanceTrigger *this, const struct Triggers::TriggerExportOptions *a2, struct IUbpmRegistrationParams *a3); // idb
_QWORD *__fastcall User::CreateLocalAdmin(_QWORD *a1);
__int64 __fastcall Triggers::IdleTrigger::IdleTrigger(__int64 a1, const OLECHAR *a2, __int128 *a3, __int128 *a4, int a5, int a6, char a7, __int128 *a8, char a9);
__int64 __fastcall Triggers::EventTrigger::WriteXml(Triggers::EventTrigger *this, struct TaskXmlWriter *a2); // idb
__int64 __fastcall Triggers::EventTrigger::WriteInnerXml(Triggers::EventTrigger *this, struct TaskXmlWriter *a2); // idb
__int64 __fastcall Triggers::EventTrigger::RegisterThyself(Triggers::EventTrigger *this, struct JobMoniker *a2, struct Triggers::TriggerOptions *a3); // idb
void __fastcall JobsService::SCMEventLogNotificationCallback(char a1, char *a2);
__int64 __fastcall Triggers::RegistrationTrigger::WriteXml(Triggers::RegistrationTrigger *this, struct TaskXmlWriter *a2); // idb
_QWORD *__fastcall Triggers::RegistrationTrigger::RegistrationTrigger(_QWORD *a1, const OLECHAR *a2, __int128 *a3, __int128 *a4, int a5, int a6, char a7, __int128 *a8);
signed int ShutdownMgr::Initialize(void);
__int64 __fastcall JobsService::DetectBootStart(JobsService *this); // idb
__int64 *__fastcall ATL::CAtlStringMgr::CAtlStringMgr(ATL::CAtlStringMgr *this, struct ATL::IAtlMemMgr *a2);
void __fastcall ATL::CWin32Heap::~CWin32Heap(ATL::CWin32Heap *this); // idb
std::bad_alloc *__fastcall std::bad_alloc::bad_alloc(std::bad_alloc *this, const struct std::bad_alloc *a2);
std::bad_alloc *__fastcall std::bad_alloc::bad_alloc(std::bad_alloc *this);
std::logic_error *__fastcall std::logic_error::logic_error(std::logic_error *this, const struct std::logic_error *a2);
std::length_error *__fastcall std::length_error::length_error(std::length_error *this, char *a2);
std::bad_alloc *__fastcall std::bad_alloc::`vector deleting destructor'(std::bad_alloc *this, char a2);
std::length_error *__fastcall std::length_error::`scalar deleting destructor'(std::length_error *this, char a2);
// void __noreturn std::_Xbad_alloc(void); idb
void __fastcall __noreturn std::_Xlength_error(char *a1);
void __fastcall __noreturn std::_Xout_of_range(char *a1);
const char *__fastcall std::_Syserror_map(int a1); // idb
const char *__fastcall std::_Winerror_map(int a1); // idb
__int64 pre_c_init();
__int64 __fastcall CRT_INIT(__int64 a1, int a2, __int64 a3);
__int64 __fastcall _DllMainCRTStartup(HINSTANCE hinstDLL, __int64 fdwReason, void *a3);
// __int64 __fastcall _CxxFrameHandler3_0(_QWORD, _QWORD, _QWORD, _QWORD); weak
type_info *__fastcall type_info::`scalar deleting destructor'(type_info *this, char a2);
// void __cdecl free_0(void *Block);
_onexit_t __cdecl onexit_0(_onexit_t Func);
// int __cdecl atexit(void (__cdecl *)());
// exception *exception::exception(exception *__hidden this); idb
// exception *exception::exception(exception *__hidden this, const char *const *); idb
// exception *exception::exception(exception *__hidden this, const char *const *, int); idb
// exception *exception::exception(exception *__hidden this, const struct exception *); idb
// void exception::~exception(exception *__hidden this); idb
// void __stdcall __noreturn CxxThrowException_0(void *pExceptionObject, _ThrowInfo *pThrowInfo);
// void *__cdecl memcpy_0(void *, const void *Src, size_t Size);
// void *__cdecl memmove_0(void *, const void *Src, size_t Size);
// __int64 __fastcall amsg_exit_0(_QWORD); weak
__int64 __fastcall FindPESection(__int64 a1, unsigned __int64 a2);
// __int64 __fastcall IsNonwritableInCurrentImage(_QWORD); weak
_BOOL8 __fastcall ValidateImageBase(__int64 a1);
// void *__cdecl malloc_0(size_t Size);
void __cdecl _security_init_cookie();
// void __cdecl initterm_0(_PVFV *First, _PVFV *Last);
// __int64 __fastcall lock_0(_QWORD); weak
// __int64 __fastcall unlock_0(_QWORD); weak
// __int64 __fastcall _dllonexit_0(_QWORD, _QWORD, _QWORD); weak
// ULONG __stdcall EventRegister_0(LPCGUID ProviderId, PENABLECALLBACK EnableCallback, PVOID CallbackContext, PREGHANDLE RegHandle);
// ULONG __stdcall EventUnregister_0(REGHANDLE RegHandle);
__int64 __fastcall load_CoInitializeEx(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall _tailMerge_api_ms_win_core_com_l1_1_0_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_GetServiceRegistryStateKey(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall _tailMerge_api_ms_win_service_core_l1_1_3_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_CoUninitialize(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_OpenSCManagerW(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall _tailMerge_api_ms_win_service_management_l1_1_0_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_OpenServiceW(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_SubscribeServiceChangeNotifications(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall _tailMerge_api_ms_win_service_private_l1_1_0_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_UnsubscribeServiceChangeNotifications(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_CloseServiceHandle(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_NetGetJoinInformation(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall _tailMerge_wkscli_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_NetApiBufferFree(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall _tailMerge_netutils_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_RegisterServiceCtrlHandlerExW(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall _tailMerge_api_ms_win_service_core_l1_1_0_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_SetServiceStatus(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_CoCreateInstance(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_ConvertSidToStringSidW(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall _tailMerge_api_ms_win_security_sddl_l1_1_0_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_IIDFromString(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_LsaOpenPolicy(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall _tailMerge_api_ms_win_security_lsapolicy_l1_1_0_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_LsaClose(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_LsaQueryInformationPolicy(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_LsaFreeMemory(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_LookupAccountNameW(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall _tailMerge_api_ms_win_security_lsalookup_l2_1_0_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_GetUserNameExW(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall _tailMerge_sspicli_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_ConvertStringSidToSidW(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_LookupAccountNameLocalW(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall _tailMerge_api_ms_win_security_lsalookup_l1_1_0_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_LookupAccountSidLocalW(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_LookupPrivilegeValueW(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_AuthzFreeAuditEvent(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall _tailMerge_authz_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_AuthziLogAuditEvent(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_GetSecurityInfo(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall _tailMerge_api_ms_win_security_provider_l1_1_0_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_ConvertStringSecurityDescriptorToSecurityDescriptorW(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_StringFromGUID2(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_SetSecurityInfo(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_GetNamedSecurityInfoW(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_LsaConnectUntrusted(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_CredDeleteW(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall _tailMerge_api_ms_win_security_credentials_l1_1_0_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_CoCreateGuid(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_LsaDeregisterLogonProcess(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_CredFree(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_LogonUserExExW(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_LsaCallAuthenticationPackage(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_CredEnumerateW(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_LsaLookupAuthenticationPackage(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_LsaFreeReturnBuffer(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_CredWriteW(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_BCryptGetProperty(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall _tailMerge_bcrypt_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_BCryptOpenAlgorithmProvider(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_BCryptFinishHash(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_BCryptCloseAlgorithmProvider(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_BCryptDestroyHash(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_BCryptHashData(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_BCryptCreateHash(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_PowerSettingRegisterNotification(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall _tailMerge_api_ms_win_power_setting_l1_1_0_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_PowerDeterminePlatformRole(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall _tailMerge_powrprof_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_PowerSettingUnregisterNotification(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_CoFreeUnusedLibraries(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_NetIsServiceAccount(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall _tailMerge_logoncli_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_DeriveAppContainerSidFromAppContainerName(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall _tailMerge_userenv_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_AuthziFreeAuditEventType(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_AuthziInitializeAuditParams(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_AuthziInitializeAuditEvent(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_AuthziInitializeAuditEventType(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_WmiCloseBlock(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall _tailMerge_wmiclnt_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_WmiQueryAllDataW(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_WmiOpenBlock(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char IsUMgrQueryUserContextPresent();
__int64 __fastcall load_UMgrQueryUserContext(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall _tailMerge_ext_ms_win_session_usermgr_l1_1_0_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_EvtClose(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall _tailMerge_ext_ms_win_wevtapi_eventlog_l1_1_0_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_EvtOpenChannelConfig(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_EvtGetChannelConfigProperty(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_EvtSetChannelConfigProperty(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall _tailMerge_ext_ms_win_wevtapi_eventlog_l1_1_2_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_EvtSaveChannelConfig(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_EvtSubscribe(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_EvtCreateRenderContext(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_EvtRender(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_WTSQuerySessionInformationW(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall _tailMerge_ext_ms_win_session_wtsapi32_l1_1_0_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_WTSFreeMemory(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_WTSEnumerateSessionsW(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_WTSQueryUserToken(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_AssocQueryStringW(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall _tailMerge_ext_ms_win_shell_shlwapi_l1_1_0_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
void __fastcall `eh vector constructor iterator'(void *, unsigned __int64, unsigned __int64, void (__stdcall *)(void *), void (__stdcall *)(void *)); // idb
void __fastcall `eh vector constructor iterator'(char *a1, __int64 a2, int a3, void (__fastcall *a4)(char *));
void __fastcall `eh vector destructor iterator'(void *, unsigned __int64, unsigned __int64, void (__stdcall *)(void *)); // idb
void __fastcall `eh vector destructor iterator'(char *a1, __int64 a2, int a3, void (__stdcall *a4)(void *));
void __fastcall __ArrayUnwind(char *a1, __int64 a2, int a3, void (__fastcall *a4)(char *));
void __fastcall Init_thread_footer(_DWORD *a1);
void __fastcall Init_thread_header(_DWORD *a1);
// __int64 __fastcall _GSHandlerCheckCommon(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall ApiSetQueryApiSetPresence_0(_QWORD, _QWORD); weak
__int64 __fastcall load_CreateXmlWriter(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall _tailMerge_xmllite_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_CreateXmlWriterOutputWithEncodingName(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_StringFromCLSID(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_CoTaskMemFree(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_CLSIDFromString(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_CreateXmlReader(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_CredMarshalCredentialW(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_QueryServiceStatus(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall _tailMerge_api_ms_win_service_winsvc_l1_1_0_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall load_ConvertSecurityDescriptorToStringSecurityDescriptorW(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved);
__int64 __fastcall ExeTask::SetBatchLaunchCommand(BSTR **this);
bool __fastcall User::IsLocalSystem(PSID pSid2); // idb
__int64 __fastcall Auditor::GetCallerProcessInfo(Auditor *this, unsigned int *a2, unsigned __int64 *a3, unsigned int *a4, unsigned int *a5); // idb
unsigned __int16 *__fastcall Auditor::GetComputerNameDnsFullyQualified(Auditor *this); // idb
void __fastcall lambda_0374aa0a5d1201b2358c6bce99369c58_::_lambda_invoker_cdecl_(PTP_CALLBACK_INSTANCE Instance, RTL_SRWLOCK *Context, PTP_TIMER Timer);
__int64 __fastcall _lambda_0ae89f7ca77040da3af7dd229dfecfb4_::_lambda_invoker_cdecl_(__int64 a1, __int64 a2, __int64 a3, wil::details::FeatureStateManager *a4);
void __fastcall _lambda_1ad7ecfab602a777ecf020873216a663_::_lambda_invoker_cdecl_(void *); // idb
void __fastcall lambda_5035b992506f4af81a770c5842624510_::_lambda_invoker_cdecl_(PTP_CALLBACK_INSTANCE Instance, PVOID Context, PTP_TIMER Timer);
void __fastcall _lambda_aa194dc0bf891154933407eb98fb868a_::_lambda_invoker_cdecl_(void *a1); // idb
void __fastcall lambda_d51448ba32f8ef42e59400edd4566183_::_lambda_invoker_cdecl_(PTP_CALLBACK_INSTANCE Instance, RTL_SRWLOCK *Context, PTP_TIMER Timer);
void __fastcall _lambda_fee8cea507d2413a58be13acfb66740a_::_lambda_invoker_cdecl_(void *); // idb
void __fastcall wil::assign_null_to_opt_param<unsigned short const *>(_QWORD *a1);
void __fastcall wil::assign_to_opt_param<unsigned int>(_DWORD *a1);
__int64 __fastcall wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>(__int64 (__fastcall **a1)(_QWORD), _QWORD *a2);
__int64 __fastcall wil::unique_any_t<wil::details::unique_storage<wil::details::resource_policy<void *,void (*)(void *),&void wil::details::UnregisterWilFeatureConfigurationChange(void *),wistd::integral_constant<unsigned __int64,0>,void *,void *,0,std::nullptr_t>>>::~unique_any_t<wil::details::unique_storage<wil::details::resource_policy<void *,void (*)(void *),&void wil::details::UnregisterWilFeatureConfigurationChange(void *),wistd::integral_constant<unsigned __int64,0>,void *,void *,0,std::nullptr_t>>>(__int64 *a1);
bool __fastcall wil::details_abi::operator!=(_QWORD *a1, _QWORD *a2);
__int64 __fastcall wil::details::EnsureSubscribedToFeatureConfigurationChanges(wil::details *this);
__int64 __fastcall wil::details::EnabledStateManager::EnsureSubscribedToFeatureConfigurationChangesImpl(RTL_SRWLOCK *this);
char __fastcall wil::details::FeatureStateManager::EnsureSubscribedToStateChangesUnderLock(wil::details::FeatureStateManager *this, __int64 a2, __int64 a3);
__int64 __fastcall wil::details::FeatureStateManager::EnsureSubscribedToStateChangesUnderLock(wil::details **a1, __int64 a2, __int64 a3);
__int64 __fastcall JobStore::GenerateTaskXmlFromCollections(__int64 a1, __int64 a2, Triggers::Trigulator *a3, Actions::ActionCollection *a4, char **a5);
__int64 __fastcall JobStore::GenerateTaskXmlFromRegistry(HKEY *a1, struct JobMoniker *a2, __int64 a3, unsigned int *a4, char **a5);
signed __int32 *__fastcall wil::details::FeatureImpl<__WilFeatureTraits_Feature_2510298426>::GetCachedFeatureEnabledState(wil::details *a1, signed __int32 *a2);
_QWORD *__fastcall wil::details::FeatureImpl<__WilFeatureTraits_Feature_2510298426>::GetCurrentFeatureEnabledState(__int64 a1, _QWORD *a2);
__int64 __fastcall wil::details::EnabledStateManager::InvalidateFeatureStateCache(__int64 a1, volatile signed __int32 *a2, int a3);
bool __fastcall wil::details::IsFeatureConfigured(wil::details *a1, unsigned int a2, unsigned __int8 a3, int a4, _DWORD *a5);
LPVOID __fastcall wil::details::ProcessHeapAlloc(DWORD dwFlags, SIZE_T dwBytes);
void __fastcall wil::details::EnabledStateManager::QueueBackgroundUsageReporting(PVOID pv, __int64 a2, struct wil_details_FeatureReportingCache *a3);
__int64 (__fastcall *wil::details::FeatureImpl<__WilFeatureTraits_Feature_2510298426>::ReportUsage(volatile signed __int32 *a1, unsigned __int8 a2, char a3, ...))(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD);
__int64 __fastcall wil::details::ReportUsageToServiceDirect(volatile signed __int32 *a1, __int64 a2, int a3, __int64 a4, unsigned int a5);
__int64 __fastcall wil::details::RtlDisownModuleHeapAllocation(wil::details *this, void *a2, void *a3); // idb
static HRESULT __stdcall StringCopyWorkerA(STRSAFE_LPSTR pszDest, size_t cchDest, size_t *pcchNewDestLength, STRSAFE_PCNZCH pszSrc, size_t cchToCopy);
static HRESULT __stdcall StringVPrintfWorkerW_0(STRSAFE_LPWSTR pszDest, size_t cchDest, size_t *pcchNewDestLength, STRSAFE_LPCWSTR pszFormat, va_list argList);
static HRESULT __stdcall StringValidateDestA(STRSAFE_PCNZCH pszDest, size_t cchDest, const size_t cchMax);
void __fastcall wil::details::SubscribeFeatureStateCacheToConfigurationChanges(volatile signed __int32 *a1, int a2, int a3);
void __fastcall wil::details::UnregisterWilFeatureConfigurationChange(wil::details *this, void *a2); // idb
__int64 __fastcall wil::details::WilApiImpl_GetFeatureEnabledState(wil::details *this, unsigned int a2, _DWORD *a3, int *a4);
__int64 __fastcall wil::details::WilStringVPrintfWorkerA(char *a1, size_t a2, __int64 a3, const char *a4, va_list ArgList);
__int64 __fastcall JobStore::XmlLoadRawTaskFile(char **a1, JobMoniker *a2, void **a3);
__int64 __fastcall JobStore::XmlSaveTaskFile(JobStore *this, const struct JobMoniker *a2, const unsigned __int16 *a3, LPCWSTR StringSecurityDescriptor); // idb
void __fastcall __noreturn wil::details::in1diag3::_FailFastImmediate_Unexpected(wil::details::in1diag3 *this); // idb
char __fastcall wil::details::FeatureImpl<__WilFeatureTraits_Feature_2510298426>::__private_IsEnabled(__int64 a1);
struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ **__fastcall wil::unique_any_t<wil::details::unique_storage<wil::details::resource_policy<FEATURE_STATE_CHANGE_SUBSCRIPTION__ *,void (*)(FEATURE_STATE_CHANGE_SUBSCRIPTION__ *),&void wil::details::UnsubscribeProcessWideUsageFlush(FEATURE_STATE_CHANGE_SUBSCRIPTION__ *),wistd::integral_constant<unsigned __int64,0>,FEATURE_STATE_CHANGE_SUBSCRIPTION__ *,FEATURE_STATE_CHANGE_SUBSCRIPTION__ *,0,std::nullptr_t>>>::put(struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ **a1);
wil::details **__fastcall wil::unique_any_t<wil::details::unique_storage<wil::details::resource_policy<FEATURE_STATE_CHANGE_SUBSCRIPTION__ *,void (*)(FEATURE_STATE_CHANGE_SUBSCRIPTION__ *),&void wil::details::WilApi_UnsubscribeFeatureStateChangeNotification(FEATURE_STATE_CHANGE_SUBSCRIPTION__ *),wistd::integral_constant<unsigned __int64,0>,FEATURE_STATE_CHANGE_SUBSCRIPTION__ *,FEATURE_STATE_CHANGE_SUBSCRIPTION__ *,0,std::nullptr_t>>>::put(wil::details **a1);
__int64 __fastcall wil_QueryFeatureState(__int64 a1, unsigned int a2, int a3, int a4, _DWORD *a5, _DWORD *a6);
__int64 __fastcall wil_RtlStagingConfig_QueryFeatureState(__int64 a1, unsigned int a2, int a3, _DWORD *a4);
__int64 __fastcall wil_RtlStagingConfig_RecordFeatureUsage(int a1, __int16 a2, int a3);
__int64 __fastcall wil_StagingConfig_QueryFeatureState(int a1, __int64 a2, __int64 a3, int a4, _DWORD *a5);
__int64 __fastcall wil_StagingConfig_RecordFeatureUsage(unsigned int a1, unsigned __int16 a2, __int64 a3);
__int64 __fastcall wil_details_FeatureReporting_IncrementOpportunityInCache(volatile signed __int32 *a1, int a2, __int64 a3, _DWORD *a4);
__int64 __fastcall wil_details_FeatureReporting_IncrementUsageInCache(volatile signed __int32 *a1, int a2, __int64 a3, _DWORD *a4);
int *__fastcall wil_details_FeatureReporting_RecordUsageInCache(__int64 a1, volatile signed __int32 *a2, __int64 a3);
__int64 __fastcall wil_details_MapReportingKind(int a1, int a2);
__int64 __fastcall wil_details_NtQueryWnfStateData(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall wil_details_NtUpdateWnfStateData(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, int a5, int a6, int a7);
__int64 __fastcall wil_details_RecordCachedUsage(unsigned int a1, __int64 a2);
__int64 __fastcall wil_details_RtlRegisterFeatureConfigurationChangeNotification(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall wil_details_RtlSubscribeWnfStateChangeNotification(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5);
_BOOL8 __fastcall wil_details_StagingConfigFeature_HasUniqueState(_DWORD *a1);
__int64 __fastcall wil_details_StagingConfig_AreAnyFeaturesConfigured(__int64 a1);
__int64 __fastcall wil_details_StagingConfig_FireNotification(__int64 a1, __int64 a2, __int64 a3, int a4);
void __fastcall wil_details_StagingConfig_Free(__int64 a1);
__int64 __fastcall wil_details_StagingConfig_Load(__int64 a1, int a2, __int64 a3, __int64 a4);
__int64 __fastcall wil_details_StagingConfig_QueryFeatureState(__int64 a1, __int64 a2, int a3, int a4);
void __stdcall CredStore::Lock(LPCRITICAL_SECTION lpCriticalSection);
signed int __fastcall CredStore::OpenCredManagerKey(CredStore *this, HKEY *a2);
__int64 __fastcall CredStore::ReleaseRefUserRecord(LPCRITICAL_SECTION lpCriticalSection, User *this, void **a3);
void __stdcall CredStore::Unlock(LPCRITICAL_SECTION lpCriticalSection);
signed int __fastcall JobStore::LoadFileToBuffer(HANDLE hFile, void **a2);
__int64 __fastcall UbpmParams::AddBasicTrigger(__int64 *a1, int a2, int a3, int a4, int a5, __int64 a6, __int128 *a7, __int128 *a8, unsigned int a9, __int64 a10, int a11, int a12, _QWORD *a13, __int64 a14);
__int64 __fastcall UbpmParams::AddBootTrigger(UbpmParams *this, int a2, int a3, int a4, const struct Repetition *a5, struct _SYSTEMTIME *a6, struct _SYSTEMTIME *a7);
__int64 __fastcall UbpmParams::AddEventTrigger(UbpmParams *this, int a2, int a3, int a4, const struct Repetition *a5, struct _SYSTEMTIME *a6, struct _SYSTEMTIME *a7);
__int64 __fastcall UbpmParams::AddIdleTrigger(UbpmParams *this, int a2, int a3, int a4, const struct Repetition *a5, struct _SYSTEMTIME *a6, struct _SYSTEMTIME *a7, int a8);
__int64 __fastcall UbpmParams::AddLogonTrigger(UbpmParams *this, __int64 a2, const struct User *a3, int a4, unsigned int a5, const struct Repetition *a6, const struct _SYSTEMTIME *a7, const struct _SYSTEMTIME *a8);
__int64 __fastcall UbpmParams::AddRegistrationTrigger(UbpmParams *this, int a2, int a3, int a4, const struct Repetition *a5, struct _SYSTEMTIME *a6, struct _SYSTEMTIME *a7, unsigned int a8, __int64 a9);
__int64 __fastcall UbpmParams::AddSessionBasedTrigger(UbpmParams *this, int a2, int a3, const struct User *a4, unsigned int a5, unsigned int a6, const struct Repetition *a7, const struct _SYSTEMTIME *a8, const struct _SYSTEMTIME *a9);
__int64 __fastcall UbpmParams::AddWnfStateChangeTrigger(UbpmParams *this, int a2, int a3, int a4, const struct Repetition *a5, struct _SYSTEMTIME *a6, struct _SYSTEMTIME *a7, struct _WNF_STATE_NAME a8, void *a9);
__int64 __fastcall _GSHandlerCheck_EH(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
// double __cdecl floor_0(double X);
// double __cdecl log_0(double X);
// int __cdecl memcmp_0(const void *Buf1, const void *Buf2, size_t Size);
// void *__cdecl memset_0(void *, int Val, size_t Size);
// int __cdecl wcscmp_0(const wchar_t *String1, const wchar_t *String2);
__int64 __fastcall guard_dispatch_icall_nop(); // weak
__int64 __fastcall dynamic_atexit_destructor_for__g_PrivateHeap__(); // weak
void *__fastcall dynamic_atexit_destructor_for__ShutdownMgr::s_hEvent__(__int64 a1);
__int64 __fastcall dynamic_atexit_destructor_for__ShutdownMgr::s_sync__(); // weak
__int64 __fastcall dynamic_atexit_destructor_for__g_Idolater__(); // weak
void **dynamic_atexit_destructor_for__std::_Error_objects_int_::_Generic_object__();
void **dynamic_atexit_destructor_for__std::_Error_objects_int_::_Iostream_object__();
void **dynamic_atexit_destructor_for__std::_Error_objects_int_::_System_object__();
void __fastcall wil::details::_dynamic_atexit_destructor_for__g_enabledStateManager__(wil *a1);
void __fastcall wil::details::_dynamic_atexit_destructor_for__g_featureStateManager__(wil *a1);
__int64 __fastcall wil::details::_dynamic_atexit_destructor_for__g_processLocalData__(); // weak
__int64 __fastcall wil::details::_dynamic_atexit_destructor_for__g_threadFailureCallbacks__(); // weak
void dynamic_atexit_destructor_for__JobStore::m_hashObject__();
__int64 __fastcall dynamic_atexit_destructor_for__RpcServer::s_singleton__(); // weak
void ATL::_dynamic_atexit_destructor_for__g_strheap__();
void **ATL::_dynamic_atexit_destructor_for__g_strmgr__();
__int64 __fastcall dynamic_atexit_destructor_for__vtMissing__(); // weak
void __fastcall tsched::SrwLockExclusiveScope::~SrwLockExclusiveScope(PSRWLOCK *this);
void __fastcall _bstr_t::~_bstr_t(_bstr_t *__hidden this); // idb
wmi::GenericException *__fastcall wmi::GenericException::GenericException(wmi::GenericException *this, int a2);
void __fastcall tsched::WTSFreeMe<_WTS_SESSION_INFOW>::~WTSFreeMe<_WTS_SESSION_INFOW>(void ***a1);
void __fastcall std::map<JobMoniker,_FILETIME,Scheduler::JobMonikerLess,std::allocator<std::pair<JobMoniker const,_FILETIME>>>::~map<JobMoniker,_FILETIME,Scheduler::JobMonikerLess,std::allocator<std::pair<JobMoniker const,_FILETIME>>>(_QWORD *a1);
void __fastcall AuthzAutoHandle::~AuthzAutoHandle(AuthzAutoHandle *this); // idb
void __fastcall wmi::AutoHandle::~AutoHandle(wmi::AutoHandle *__hidden this); // idb
void __fastcall wmi::AutoRegKey::~AutoRegKey(wmi::AutoRegKey *__hidden this); // idb
void __fastcall wmi::GenericException::~GenericException(void **this);
void __fastcall JobsService::~JobsService(JobsService *this); // idb
void __fastcall Scheduler::~Scheduler(Scheduler *this); // idb
void __fastcall ShutdownGuard::~ShutdownGuard(ShutdownGuard *this); // idb
void __fastcall SortedRunList::~SortedRunList(wmi::RefBase **this);
bool __fastcall TSTime::operator>=(__int64 a1, __int128 *a2);
void **__fastcall wmi::GenericException::`vector deleting destructor'(void **this, char a2);
void ModuleTracker::Dump(void); // idb
__int64 __fastcall JobsService::EnableOperationalLog(BOOL a1);
void __fastcall JobsService::FinalCleanup(JobsService *this, __int64 a2, void *a3, const struct _GUID *a4);
void __fastcall JobsService::FinalizeSCMEventLogNotifications(JobsService *this); // idb
signed int __fastcall tsched::GetLastHrError(tsched *this);
void __fastcall JobsService::Log(JobsService *this, const unsigned __int16 *a2); // idb
__int64 __fastcall JobsService::SetMachineDomainJoinPrevDetected(int a1); // idb
int __fastcall JobsService::SetWakeupTimer(__int64 a1, __int64 a2, JobMoniker *a3);
signed __int64 ShutdownMgr::Shutdown(void);
void __fastcall _Stop__QCNtService__JobsService__UEAAXH_Z(__int64 a1, int a2);
__int64 __fastcall JobsService::UninitializeWPTS(JobsService *this); // idb
void __fastcall JobsService::WakeUpProc(EventManager *lpArgToCompletionRoutine, DWORD dwTimerLowValue, void *dwTimerHighValue, const struct _GUID *a4);
void __fastcall std::_Tree<std::_Tmap_traits<JobMoniker,_FILETIME,Scheduler::JobMonikerLess,std::allocator<std::pair<JobMoniker const,_FILETIME>>,0>>::_Erase(__int64 a1, wmi::RefBase **a2);
_QWORD *__fastcall std::_Tree<std::_Tmap_traits<User,LogonJob *,User::less,std::allocator<std::pair<User const,LogonJob *>>,1>>::_Lrotate(__int64 a1, __int64 a2);
_QWORD *__fastcall std::_Tree_val<std::_Tree_simple_types<std::pair<_bstr_t const,std::list<_FILETIME> *>>>::_Min(_QWORD *a1);
_QWORD *__fastcall std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::_Rrotate(__int64 a1, _QWORD *a2);
_QWORD *__fastcall std::_Tree<std::_Tmap_traits<JobMoniker,_FILETIME,Scheduler::JobMonikerLess,std::allocator<std::pair<JobMoniker const,_FILETIME>>,0>>::erase(_QWORD *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4);
_QWORD *__fastcall std::_Tree<std::_Tset_traits<JobMoniker,std::less<JobMoniker>,std::allocator<JobMoniker>,0>>::erase(_QWORD *a1, _QWORD *a2, _QWORD *a3);
__int64 __fastcall WPP_SF_(__int64 a1, unsigned __int16 a2, __int64 a3);
__int64 __fastcall WPP_SF_D(__int64 a1, unsigned __int16 a2, __int64 a3, int a4);
__int64 __fastcall WPP_SF_DsDsqq(__int64 a1, __int64 a2, __int64 a3, int a4, __int64 a5, char a6, __int64 a7);
__int64 __fastcall WPP_SF_SD(__int64 a1, unsigned __int16 a2, __int64 a3, const wchar_t *a4);
__int64 WPP_SF_q(__int64 a1, unsigned __int16 a2, __int64 a3, ...);
__int64 __fastcall WppControlCallback(int a1, __int64 a2, _DWORD *a3, __int64 a4);
void __fastcall CNtService::~CNtService(CNtService *this); // idb
void __fastcall tsched::CSLock::~CSLock(LPCRITICAL_SECTION *this);
__int64 __fastcall CNtService::HandlerEx(CNtService *this, int a2, __int64 a3, void *a4);
void __fastcall CNtService::Log(CNtService *this, const unsigned __int16 *a2); // idb
wmi::OutOfMemoryException *__fastcall wmi::OutOfMemoryException::OutOfMemoryException(wmi::OutOfMemoryException *this);
void *__fastcall operator new[](unsigned __int64); // idb
void *__stdcall MIDL_user_allocate(size_t size);
__int64 *__fastcall std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_bstr_t>>>,_bstr_t *,std::allocator<_bstr_t>>(__int64 *a1, __int64 *a2, __int64 *a3);
__int64 **__fastcall std::vector<_bstr_t>::vector<_bstr_t>(__int64 **a1, __int64 **a2);
EmailTask *__fastcall EmailTask::EmailTask(EmailTask *this, const struct _bstr_t *a2, const struct _bstr_t *a3); // idb
// __int64 __fastcall EmailTask::EmailTask(_DWORD, _DWORD, _DWORD, _DWORD, __int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64); weak
__int64 __fastcall wmi::AutoRef<INetworkListManagerPrivate>::~AutoRef<INetworkListManagerPrivate>(__int64 *a1);
void __fastcall std::_Tree_comp<0,std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::~_Tree_comp<0,std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>(void **a1);
void __fastcall ATL::CComBSTR::~CComBSTR(BSTR *this);
void __fastcall EmailTask::~EmailTask(EmailTask *this); // idb
EmailTask *__fastcall EmailTask::`vector deleting destructor'(EmailTask *this, char a2);
Task *__fastcall Task::`scalar deleting destructor'(Task *this, char a2);
const unsigned __int16 *__fastcall EmailTask::GetName(EmailTask *this); // idb
const unsigned __int16 *__fastcall MessageBoxTask::GetName(MessageBoxTask *this); // idb
__int64 __fastcall EmailTask::GetStorageSize(EmailTask *this);
__int64 __fastcall MessageBoxTask::GetStorageSize(MessageBoxTask *this);
void __fastcall __noreturn ATL::PrivateAtlThrow(int a1); // idb
__int64 __fastcall ExeTask::ResolveLink(ExeTask *this, unsigned __int16 **a2); // idb
__int64 __fastcall EmailTask::StreamIn(EmailTask *this, __int64 a2, unsigned __int8 **a3, unsigned __int8 *a4);
__int64 __fastcall MessageBoxTask::StreamIn(_bstr_t::Data_t **this, __int64 a2, unsigned __int8 **a3, unsigned __int8 *a4);
__int64 __fastcall EmailTask::StreamOut(EmailTask *this, __int64 a2, unsigned __int8 **a3, unsigned __int8 *a4);
__int64 __fastcall MessageBoxTask::StreamOut(MessageBoxTask *this, __int64 a2, unsigned __int8 **a3, const unsigned __int8 *a4);
__int64 __fastcall EmailTask::WriteXml(EmailTask *this, struct TaskXmlWriter *a2); // idb
__int64 __fastcall MessageBoxTask::WriteXml(MessageBoxTask *this, struct TaskXmlWriter *a2); // idb
__int64 *__fastcall std::vector<_bstr_t>::push_back(__int64 *a1, __int64 *a2);
__int64 __fastcall Task::GetStorageSize(Task *this);
__int64 __fastcall Task::StreamIn(_bstr_t::Data_t **this, __int64 a2, unsigned __int8 **a3, unsigned __int8 *a4);
BSTR ***__fastcall std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::find(BSTR ***a1, BSTR ***a2, BSTR **a3);
void __fastcall tsched::ClearList<IdleJobList>(_QWORD *a1);
_QWORD *__fastcall std::_List_buy<wmi::AutoVectorPtr<_SID_AND_ATTRIBUTES> *,std::allocator<wmi::AutoVectorPtr<_SID_AND_ATTRIBUTES> *>>::_Buynode<wmi::AutoVectorPtr<_SID_AND_ATTRIBUTES> * const &>(__int64 a1, _QWORD *a2, _QWORD *a3, _QWORD *a4);
_QWORD *__fastcall std::_Tree_buy<std::pair<User const,SessionChangeJob *>>::_Buynode<std::pair<User const,SessionChangeJob *>>(_QWORD *a1, __int64 a2);
__int64 __fastcall std::list<IdleJob *>::_Insert<IdleJob * const &>(__int64 a1, __int64 a2, _QWORD *a3);
_QWORD *__fastcall std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::_Insert_at<std::pair<User const,SessionChangeJob *>,std::_Nil>(_QWORD *a1, _QWORD *a2, char a3, _QWORD *a4, __int64 a5);
__int64 __fastcall std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::_Insert_nohint<std::pair<User const,SessionChangeJob *>,std::_Nil>(_QWORD *a1, __int64 a2, __int64 a3, _QWORD *a4);
void __fastcall std::list<IdleJob *>::merge<IdleLess>(__int64 ***a1, __int64 a2);
__int64 (__fastcall ****__fastcall tsched::DeleteMe<Triggers::LogonTrigger>::~DeleteMe<Triggers::LogonTrigger>(__int64 a1))(_QWORD, __int64);
LogonJob **__fastcall tsched::DeleteMe<SessionChangeJob>::~DeleteMe<SessionChangeJob>(__int64 a1);
void __fastcall std::multimap<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>>::~multimap<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>>(__int64 ***a1);
void __fastcall IdleJobList::~IdleJobList(void **this);
void __fastcall PseudoEventTrap::~PseudoEventTrap(PseudoEventTrap *this); // idb
char __fastcall User::less::operator()(__int64 a1, _QWORD *a2, _QWORD *a3);
LogonJob *__fastcall LogonJob::`scalar deleting destructor'(LogonJob *this);
void __fastcall PseudoEventTrap::IdleEnded(PseudoEventTrap *this); // idb
void __fastcall PseudoEventTrap::IdleStarted(PseudoEventTrap *this); // idb
void __fastcall PseudoEventTrap::JobEnded(__int64 a1, __int64 a2);
void __fastcall PseudoEventTrap::NotifyOtherSessionChanges(struct _RTL_CRITICAL_SECTION *this, int a2, DWORD a3);
__int64 __fastcall PseudoEventTrap::RegisterIdleJob(PseudoEventTrap *this, const struct JobMoniker *a2, struct Triggers::IdleTrigger *a3);
__int64 __fastcall PseudoEventTrap::RegisterLogonJob(PseudoEventTrap *this, const struct JobMoniker *a2, struct Triggers::LogonTrigger *a3);
__int64 __fastcall PseudoEventTrap::RegisterSessionChangeJob(PseudoEventTrap *this, const struct JobMoniker *a2, struct Triggers::SessionChangeTrigger *a3);
void __fastcall PseudoEventTrap::StartIdleTasks(PseudoEventTrap *this); // idb
__int64 __fastcall StringCbLengthW(const unsigned __int16 *a1, unsigned __int64 a2, unsigned __int64 *a3); // idb
_QWORD *__fastcall std::_Tree_buy<std::pair<User const,LogonJob *>>::_Buynode0(_QWORD *a1);
void __fastcall std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::_Erase(__int64 a1, char *a2);
__int64 __fastcall std::list<IdleJob *>::_Incsize(__int64 a1, unsigned __int64 a2);
__int64 __fastcall std::list<IdleJob *>::_Splice_same(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, unsigned __int64 a6);
__int64 __fastcall std::_Tree<std::_Tmap_traits<User,LogonJob *,User::less,std::allocator<std::pair<User const,LogonJob *>>,1>>::clear(_QWORD *a1);
void __fastcall std::list<IdleJob *>::clear(__int64 a1);
__int64 **__fastcall std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::erase(__int64 ***a1, __int64 **a2, __int64 *a3, __int64 *a4);
__int64 **__fastcall std::_Tree<std::_Tmap_traits<User,LogonJob *,User::less,std::allocator<std::pair<User const,LogonJob *>>,1>>::erase(_QWORD *a1, __int64 **a2, __int64 *a3);
_QWORD *__fastcall std::list<IdleJob *>::erase(__int64 **a1, _QWORD *a2, __int64 *a3);
_QWORD *__fastcall std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::find(__int64 a1, _QWORD *a2, _QWORD *a3);
void __fastcall IdleJobList::insert_sorted(IdleJobList *this, struct IdleJob *a2); // idb
__int64 __fastcall WPP_SF_S(__int64 a1, unsigned __int16 a2, __int64 a3, const wchar_t *a4);
__int64 __fastcall WPP_SF_dS(__int64 a1, unsigned __int16 a2, __int64 a3, int a4, __int64 a5);
__int64 __fastcall WPP_SF_dd(__int64 a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall WPP_SF_dsd(__int64 a1, __int64 a2, __int64 a3, int a4, __int64 a5);
void __fastcall std::vector<unsigned short>::_Insert<unsigned short const *>(__int64 a1, _WORD *a2, const void *a3, __int64 a4);
__int64 __fastcall std::_Rotate<unsigned short *,__int64,unsigned short>(_WORD *a1, __int64 a2, _WORD *a3);
void __fastcall std::vector<unsigned short>::assign<unsigned short *>(_WORD **a1, const void *a2, __int64 a3);
_WORD *__fastcall std::rotate<unsigned short *>(_WORD *a1, __int64 a2, _WORD *a3);
void __fastcall std::map<_bstr_t,_bstr_t>::~map<_bstr_t,_bstr_t>(void **a1);
void __fastcall std::pair<_bstr_t const,_bstr_t>::~pair<_bstr_t const,_bstr_t>(_bstr_t *this);
void __fastcall Aggregator::~Aggregator(__int64 ***this);
void __fastcall EventTrapMap::~EventTrapMap(EventTrapMap *this); // idb
EventTrap *__fastcall EventTrap::`scalar deleting destructor'(EventTrap *this);
signed int __fastcall EventTrapMap::FormatEvtVariant(char *a1, LPCCH *a2);
__int64 __fastcall StringCchVPrintfExW(STRSAFE_LPWSTR pszDest, size_t a2, unsigned __int16 **a3, unsigned __int64 *a4, unsigned int a5, const unsigned __int16 *pszFormat, va_list argList);
__int64 EventTrapMap::StringPrintf(char *a1, const unsigned __int16 *a2, ...);
__int64 __fastcall EventTrapMap::StringVPrintf(char *a1, const unsigned __int16 *a2, va_list a3);
static HRESULT __stdcall StringVPrintfWorkerW_1(STRSAFE_LPWSTR pszDest, size_t cchDest, size_t *pcchNewDestLength, STRSAFE_LPCWSTR pszFormat, va_list argList);
__int64 __fastcall std::_Tree_val<std::_Tree_simple_types<std::pair<_bstr_t const,_bstr_t>>>::_Max(__int64 a1);
char *__fastcall std::vector<unsigned short>::_Reallocate(__int64 a1, unsigned __int64 a2);
char *__fastcall std::vector<void *>::_Reallocate(__int64 a1, unsigned __int64 a2);
unsigned __int64 __fastcall std::vector<unsigned short>::_Reserve(_QWORD *a1, unsigned __int64 a2);
__int64 __fastcall std::vector<_DAB_REGISTRATION_TRIGGER_PARAMS *>::_Reserve(_QWORD *a1);
__int64 __fastcall std::_Tree<std::_Tmap_traits<_bstr_t,std::list<_FILETIME> *,Aggregator::less,std::allocator<std::pair<_bstr_t const,std::list<_FILETIME> *>>,0>>::clear(_QWORD *a1);
__int64 **__fastcall std::_Tree<std::_Tmap_traits<_bstr_t,std::list<_FILETIME> *,Aggregator::less,std::allocator<std::pair<_bstr_t const,std::list<_FILETIME> *>>,0>>::erase(__int64 ***a1, __int64 **a2, __int64 *a3, __int64 *a4);
__int64 **__fastcall std::_Tree<std::_Tmap_traits<_bstr_t,std::list<_FILETIME> *,Aggregator::less,std::allocator<std::pair<_bstr_t const,std::list<_FILETIME> *>>,0>>::erase(_QWORD *a1, __int64 **a2, __int64 *a3);
char **__fastcall std::vector<unsigned short>::erase(_QWORD *a1, char **a2, char *a3, char *a4);
__int64 __fastcall std::vector<unsigned short>::push_back(__int64 *a1, unsigned __int16 *a2);
unsigned __int64 __fastcall std::vector<unsigned short>::resize(char *a1, unsigned __int64 a2);
__int64 __fastcall WPP_SF_SSD(__int64 a1, unsigned __int16 a2, __int64 a3, const wchar_t *a4, __int64 a5);
__int64 WPP_SF_qS(__int64 a1, unsigned __int16 a2, __int64 a3, ...);
void __fastcall Idolater::IdleStart(Idolater *this, struct _FILETIME *a2); // idb
void __fastcall Idolater::IdleStartCallback(void *a1, struct _FILETIME *a2);
__int64 __fastcall Idolater::SendUbpmIdleEvent(Idolater *this, char a2);
__int64 __fastcall Idolater::UnRegisterWithIdleService(Idolater *this);
void __fastcall Idolater::Uninit(Idolater *this); // idb
_QWORD *__fastcall std::_List_buy<_FILETIME>::_Buynode<_FILETIME const &>(__int64 a1, _QWORD *a2, _QWORD *a3, _QWORD *a4);
_QWORD *__fastcall std::_Tree_buy<std::pair<_bstr_t const,std::list<_FILETIME> *>>::_Buynode<std::pair<unsigned short const *,std::list<_FILETIME> *>>(_QWORD *a1, __int64 a2);
__int64 *__fastcall std::_Tree<std::_Tmap_traits<_bstr_t,std::list<_FILETIME> *,Aggregator::less,std::allocator<std::pair<_bstr_t const,std::list<_FILETIME> *>>,0>>::_Insert_at<std::pair<_bstr_t const,std::list<_FILETIME> *> &,std::_Tree_node<std::pair<_bstr_t const,std::list<_FILETIME> *>,void *> *>(__int64 *a1, __int64 *a2, char a3, _QWORD *a4, int a5, __int64 a6);
__int64 __fastcall std::_Tree<std::_Tmap_traits<_bstr_t,std::list<_FILETIME> *,Aggregator::less,std::allocator<std::pair<_bstr_t const,std::list<_FILETIME> *>>,0>>::_Insert_nohint<std::pair<_bstr_t const,std::list<_FILETIME> *> &,std::_Tree_node<std::pair<_bstr_t const,std::list<_FILETIME> *>,void *> *>(__int64 *a1, __int64 a2, __int64 a3, const wchar_t ***a4, char *lpMem);
bool __fastcall Aggregator::less::operator()(__int64 a1, const wchar_t **a2, const wchar_t **a3);
_QWORD *__fastcall std::_List_alloc<0,std::_List_base_types<_FILETIME>>::_Buynode0(__int64 a1, _QWORD *a2, _QWORD *a3);
void __fastcall std::_Tree<std::_Tmap_traits<_bstr_t,std::list<_FILETIME> *,Aggregator::less,std::allocator<std::pair<_bstr_t const,std::list<_FILETIME> *>>,0>>::_Destroy_if_not_nil(__int64 a1, __int64 a2);
_QWORD *__fastcall std::_Tree<std::_Tmap_traits<_bstr_t,std::list<_FILETIME> *,Aggregator::less,std::allocator<std::pair<_bstr_t const,std::list<_FILETIME> *>>,0>>::find(__int64 *a1, _QWORD *a2, const wchar_t ***a3);
JobMoniker *__fastcall JobMoniker::JobMoniker(JobMoniker *this, const struct JobMoniker *a2, const struct _GUID *a3);
wmi::RefBase *__fastcall wmi::RefBase::`vector deleting destructor'(wmi::RefBase *this, char a2);
void __fastcall JobMoniker::_GenId(UUID *this);
__int64 WPP_SF_qSS(__int64 a1, __int64 a2, __int64 a3, ...);
__int64 WPP_SF_qS_guid_(__int64 a1, unsigned __int16 a2, __int64 a3, ...);
__int64 WPP_SF_qq(__int64 a1, __int64 a2, __int64 a3, ...);
__int64 WPP_SF_qqq(__int64 a1, __int64 a2, __int64 a3, ...);
void __fastcall ATL::CStringT<unsigned short,ATL::StrTraitATL<unsigned short,ATL::ChTraitsCRT<unsigned short>>>::~CStringT<unsigned short,ATL::StrTraitATL<unsigned short,ATL::ChTraitsCRT<unsigned short>>>(_QWORD *a1);
void __fastcall ATL::CTempBuffer<unsigned short,128,ATL::CCRTAllocator>::~CTempBuffer<unsigned short,128,ATL::CCRTAllocator>(void **a1);
HLOCAL __fastcall tsched::LocalFreeMe<unsigned short>::~LocalFreeMe<unsigned short>(HLOCAL **a1);
__int64 __fastcall wmi::ScopeGuardImpl1<long (*)(void *),void *>::~ScopeGuardImpl1<long (*)(void *),void *>(__int64 a1);
void __fastcall std::auto_ptr<User>::~auto_ptr<User>(User **a1);
User::UserEntry **__fastcall User::operator=(User::UserEntry **a1, User::UserEntry **a2);
ATL::CSid *__fastcall ATL::CSid::`scalar deleting destructor'(ATL::CSid *this, char a2);
User *__fastcall User::`scalar deleting destructor'(User *this);
User::UserEntry **__fastcall User::CreateAlias(User::UserEntry **a1, const struct _bstr_t *a2);
__int64 __fastcall User::FromUserSession(User::UserEntry **this, DWORD SessionId, void *a3);
WCHAR *User::GetComputerNameW(void);
__int64 *__fastcall User::GetDomain(__int64 a1, __int64 *a2);
__int64 __fastcall User::GetSessionIdForUser(unsigned int *a1, unsigned __int64 *a2); // idb
__int64 __fastcall User::LookupType(User *this, enum _SID_NAME_USE *a2); // idb
void *__fastcall ATL::CTempBuffer<unsigned short,128,ATL::CCRTAllocator>::ReAllocateHeap(void **a1, size_t a2);
__int64 __fastcall ATL::CSimpleStringT<unsigned short,0>::Reallocate(__int64 *a1, unsigned int a2);
_QWORD *__fastcall ATL::CTempBuffer<unsigned short,128,ATL::CCRTAllocator>::Reallocate(void **a1, unsigned __int64 a2);
char __fastcall User::SupportsTaskHardening(LPCWSTR lpAccountName);
void __noreturn ATL::CSimpleStringT<unsigned short,0>::ThrowMemoryException();
void User::UninitializeUserTable(void); // idb
__int64 __fastcall std::vector<ServerXMLUpdateHandler::ISubHandler *>::_Reserve(_QWORD *a1);
ULONG __fastcall tlgWriteTransfer_EventWriteTransfer(__int64 a1, unsigned __int8 *a2, const GUID *a3, const GUID *a4, ULONG UserDataCount, PEVENT_DATA_DESCRIPTOR UserData);
void std::_Rotate<_bstr_t *,__int64,_bstr_t>(__int64 *a1, __int64 a2, __int64 *a3, ...);
void __fastcall JobBucket::AddCapability(JobBucket *this, const unsigned __int16 *a2); // idb
void __fastcall JobBucket::SetDisplayName(JobBucket *this, const unsigned __int16 *a2); // idb
__int64 __fastcall User::GetPrivilegeName(struct _LUID a1, const unsigned __int16 **a2); // idb
void __fastcall CreateDataDescriptor(struct _EVENT_DATA_DESCRIPTOR *a1, const unsigned __int16 *a2); // idb
__int64 __fastcall EventManager::EvtReport(EventManager *this, const struct _EVENT_DESCRIPTOR *a2, __int64 a3, __int64 a4, char a5);
__int64 __fastcall EventManager::EvtReport(EventManager *this, const struct _EVENT_DESCRIPTOR *a2, __int64 a3, void *a4);
__int64 __fastcall EventManager::EvtReport(EventManager *this, const struct _EVENT_DESCRIPTOR *a2, const unsigned __int16 *a3, const unsigned __int16 *a4, unsigned int a5);
__int64 __fastcall EventManager::EvtReport(EventManager *this, const struct _EVENT_DESCRIPTOR *a2, const unsigned __int16 *a3, void *a4);
__int64 __fastcall EventManager::EvtReport(EventManager *this, const struct _EVENT_DESCRIPTOR *a2, const unsigned __int16 *a3, const struct _GUID *a4);
errno_t __fastcall EventManager::LogIt(EventManager *this, const unsigned __int16 *a2, int a3);
void __fastcall RpcAutoImpersonate::~RpcAutoImpersonate(RpcAutoImpersonate *this); // idb
_QWORD *__fastcall std::_Tree_buy<std::pair<JobMoniker const,_FILETIME>>::_Buynode<std::pair<JobMoniker,_FILETIME>>(_QWORD *a1, const struct JobMoniker *a2);
__int64 *__fastcall std::_Tree<std::_Tmap_traits<JobMoniker,_FILETIME,Scheduler::JobMonikerLess,std::allocator<std::pair<JobMoniker const,_FILETIME>>,0>>::_Insert_at<std::pair<JobMoniker const,_FILETIME> &,std::_Tree_node<std::pair<JobMoniker const,_FILETIME>,void *> *>(__int64 *a1, __int64 *a2, char a3, _QWORD *a4, int a5, __int64 a6);
__int64 *__fastcall std::_Tree<std::_Tmap_traits<JobMoniker,_FILETIME,Scheduler::JobMonikerLess,std::allocator<std::pair<JobMoniker const,_FILETIME>>,0>>::_Insert_hint<std::pair<JobMoniker const,_FILETIME> &,std::_Tree_node<std::pair<JobMoniker const,_FILETIME>,void *> *>(__int64 *a1, __int64 *a2, BSTR **a3, __int64 a4, wmi::RefBase **a5);
__int64 __fastcall std::_Tree<std::_Tmap_traits<JobMoniker,_FILETIME,Scheduler::JobMonikerLess,std::allocator<std::pair<JobMoniker const,_FILETIME>>,0>>::_Insert_nohint<std::pair<JobMoniker const,_FILETIME> &,std::_Tree_node<std::pair<JobMoniker const,_FILETIME>,void *> *>(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, wmi::RefBase **lpMem);
ScheduleListItem *__fastcall ScheduleListItem::ScheduleListItem(ScheduleListItem *this, const struct Scheduling::JobSchedule *a2, const struct JobMoniker *a3);
void __fastcall RunList::~RunList(RunList *this); // idb
void __fastcall ScheduleListItem::~ScheduleListItem(wmi::RefBase **this);
BSTR **__fastcall std::map<JobMoniker,_FILETIME,Scheduler::JobMonikerLess,std::allocator<std::pair<JobMoniker const,_FILETIME>>>::operator[](BSTR ***a1, BSTR **a2, __int64 a3);
wmi::RefBase **__fastcall ScheduleListItem::`scalar deleting destructor'(wmi::RefBase **this, char a2);
__int64 __fastcall ScheduleList::Add(ScheduleList *this, const struct JobMoniker *a2, const struct Scheduling::JobSchedule *a3);
__int64 __fastcall Scheduler::AddJobSchedule(Scheduler *this, struct Scheduling::JobSchedule *a2, struct JobMoniker *a3, unsigned int *a4);
void __fastcall ScheduleListItem::Delete(ScheduleListItem *this); // idb
__int64 __fastcall Scheduler::EnqueueExpiredTaskDeletion(Scheduler *this, const wchar_t **a2, const struct TSTime *a3);
__int64 __fastcall Scheduler::EnqueueMissedRun(Scheduler *this, struct Scheduling::JobSchedule *a2, struct JobMoniker *a3, unsigned int *a4);
__int64 __fastcall Scheduler::EvaluateScheduledJob(__int64 a1, __int64 a2, JobMoniker *a3, __int128 *a4, __int128 *a5);
void __fastcall Scheduler::JobEnded(Scheduler *a1, wmi::RefBase **a2);
__int64 __fastcall Scheduler::StartJobs(Scheduler *this); // idb
_QWORD *__fastcall std::_Tree_buy<std::pair<JobMoniker const,_FILETIME>>::_Buynode0(_QWORD *a1);
void __fastcall std::_Tree<std::_Tmap_traits<JobMoniker,_FILETIME,Scheduler::JobMonikerLess,std::allocator<std::pair<JobMoniker const,_FILETIME>>,0>>::_Destroy_if_not_nil(__int64 a1, wmi::RefBase **a2);
BSTR ***__fastcall std::_Tree<std::_Tmap_traits<JobMoniker,_FILETIME,Scheduler::JobMonikerLess,std::allocator<std::pair<JobMoniker const,_FILETIME>>,0>>::find(BSTR ***a1, BSTR ***a2, __int64 a3);
__int64 __fastcall WPP_SF_SDd(__int64 a1, __int64 a2, __int64 a3, const wchar_t *a4);
__int64 __fastcall WPP_SF_SS(__int64 a1, unsigned __int16 a2, __int64 a3, const wchar_t *a4, __int64 a5);
__int64 __fastcall WPP_SF_SSS(__int64 a1, __int64 a2, __int64 a3, const wchar_t *a4, __int64 a5, __int64 a6);
__int64 __fastcall WPP_SF_SSSDd(__int64 a1, unsigned __int16 a2, __int64 a3, const wchar_t *a4, __int64 a5, __int64 a6);
__int64 __fastcall WPP_SF_Sq(__int64 a1, unsigned __int16 a2, __int64 a3, const wchar_t *a4);
__int64 __fastcall WPP_SF_ddS(__int64 a1, unsigned __int16 a2, __int64 a3, int a4, char a5, __int64 a6);
__int64 __fastcall WPP_SF_ddddddddddddd(__int64 a1, __int64 a2, __int64 a3, int a4);
SortedRunListItem *__fastcall SortedRunListItem::SortedRunListItem(SortedRunListItem *this, const struct RunListItem *a2, const struct JobMoniker *a3, const struct TSTime *a4);
wmi::RefBase **__fastcall SortedRunListItem::`vector deleting destructor'(wmi::RefBase **this, char a2);
__int64 __fastcall SortedRunList::AddSorted(SortedRunList *this, const struct RunListItem *a2, const struct JobMoniker *a3, const struct TSTime *a4);
void __fastcall SortedRunListItem::Delete(SortedRunListItem *this); // idb
void __fastcall TraceTime(const char *a1, struct _FILETIME *a2, const struct JobMoniker *a3);
__int64 __fastcall WPP_SF_sddddddS(__int64 a1, __int64 a2, __int64 a3, const char *a4, char a5, char a6, char a7, char a8, char a9, char a10, __int64 a11);
LPVOID __fastcall std::_Allocate<char>(SIZE_T a1);
_QWORD *__fastcall std::string::string(_QWORD *a1, void *a2);
_DWORD *__fastcall std::bitset<5>::bitset<5>(_DWORD *a1, unsigned __int64 a2);
_DWORD *__fastcall std::bitset<7>::bitset<7>(_DWORD *a1, unsigned __int64 a2);
_DWORD *__fastcall std::bitset<31>::bitset<31>(_DWORD *a1, unsigned __int64 a2);
_DWORD *__fastcall std::bitset<12>::bitset<12>(_DWORD *a1, unsigned __int64 a2);
std::_Iostream_error_category *__fastcall std::_Iostream_error_category::`scalar deleting destructor'(std::_Iostream_error_category *this, char a2);
__int64 __fastcall Scheduling::JobSchedule::GetNextRun(__int64 a1, __int128 *a2, _OWORD *a3);
_BOOL8 __fastcall TSTime::IsLeapYear(unsigned __int16 a1);
__int64 __fastcall TSTime::MonthDays(unsigned __int16 a1, unsigned __int16 a2, unsigned __int16 *a3); // idb
__int64 __fastcall std::string::_Copy(const void **Src, unsigned __int64 a2, size_t a3);
bool __fastcall std::string::_Grow(void *a1, unsigned __int64 a2, char a3);
bool __fastcall std::string::_Inside(_QWORD *a1, unsigned __int64 a2);
// __int64 __fastcall std::string::_Tidy(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall std::string::assign(void *); idb
// __int64 __fastcall std::string::assign(void *, void *Src); idb
void **__fastcall std::string::assign(void **a1, void *Src, size_t Size);
__int64 __fastcall std::_System_error_category::default_error_condition(__int64 a1, __int64 a2, int a3);
__int64 __fastcall std::error_category::default_error_condition(__int64 a1, __int64 a2, int a3);
bool __fastcall std::error_category::equivalent(std::error_category *this, std::error_category **a2, int a3);
bool __fastcall std::error_category::equivalent(std::error_category *this, unsigned int a2, const struct std::error_condition *a3);
_QWORD *__fastcall std::string::erase(_QWORD *a1, unsigned __int64 a2, unsigned __int64 a3);
_QWORD *__fastcall std::string::erase(_QWORD *a1, unsigned __int64 a2);
_QWORD *__fastcall std::_Generic_error_category::message(__int64 a1, _QWORD *a2, int a3);
_QWORD *__fastcall std::_Iostream_error_category::message(__int64 a1, _QWORD *a2, int a3);
_QWORD *__fastcall std::_System_error_category::message(__int64 a1, _QWORD *a2, int a3);
const char *__fastcall std::_Generic_error_category::name(std::_Generic_error_category *this); // idb
const char *__fastcall std::_Iostream_error_category::name(std::_Iostream_error_category *this); // idb
const char *__fastcall std::_System_error_category::name(std::_System_error_category *this); // idb
void __fastcall PlugIn::Internal_Unload(PlugIn *this); // idb
__int64 __fastcall PlugIn::StartCleanUp(LPCRITICAL_SECTION lpCriticalSection);
void __fastcall _lambda_152aa9d2a3a0648fa2fa7fcef514b376_::_lambda_invoker_cdecl_(char *a1);
ULONG __fastcall _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapSz<unsigned short>,_tlgWrapSz<unsigned short>>(__int64 a1, unsigned __int8 *a2, __int64 a3, __int64 a4, const WCHAR **a5, const WCHAR **a6);
ULONG __fastcall _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapperByVal<4>,_tlgWrapSz<unsigned short>,_tlgWrapSz<unsigned short>>(__int64 a1, unsigned __int8 *a2, __int64 a3, __int64 a4, __int64 a5, const WCHAR **a6, const WCHAR **a7);
ULONG __fastcall _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapperByVal<4>,_tlgWrapperByVal<1>,_tlgWrapperByVal<1>,_tlgWrapperByVal<1>>(__int64 a1, unsigned __int8 *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8);
char *__fastcall wil::details::WriteResultString<char const *>(char *Destination, const char *a2, wil::details *a3, char **a4);
char *__fastcall wil::details::WriteResultString<unsigned short const *>(unsigned __int16 *Destination, const unsigned __int16 *a2, wil::details *a3, unsigned __int16 **a4);
_QWORD *__fastcall std::_Tree_buy<JobMoniker>::_Buynode<JobMoniker const &>(_QWORD *a1, const struct JobMoniker *a2);
_QWORD *__fastcall std::_Tree<std::_Tset_traits<JobMoniker,std::less<JobMoniker>,std::allocator<JobMoniker>,0>>::_Insert_at<JobMoniker const &,std::_Nil>(_QWORD *a1, _QWORD *a2, char a3, _QWORD *a4, const struct JobMoniker *a5);
__int64 __fastcall std::_Tree<std::_Tset_traits<JobMoniker,std::less<JobMoniker>,std::allocator<JobMoniker>,0>>::_Insert_nohint<JobMoniker const &,std::_Nil>(__int64 **a1, __int64 a2, __int64 a3, BSTR **a4);
__int64 __fastcall wil::details_abi::ProcessLocalStorageData<wil::details_abi::FeatureStateData>::ProcessLocalStorageData<wil::details_abi::FeatureStateData>(__int64 a1, _QWORD *a2, _QWORD *a3);
ATL::CDacl::CAccessObjectAce *__fastcall ATL::CDacl::CAccessObjectAce::CAccessObjectAce(ATL::CDacl::CAccessObjectAce *this, const struct ATL::CSid *a2, int a3, char a4, bool a5, const struct _GUID *a6, const struct _GUID *a7);
__int64 __fastcall wil::details_abi::RawUsageIndex::RawUsageIndex(__int64 a1, __int16 a2, __int16 a3, char a4, __int16 a5, char a6);
wil::ResultException *__fastcall wil::ResultException::ResultException(wil::ResultException *this, const struct wil::ResultException *a2);
__int64 __fastcall wil::details_abi::UsageIndexes::UsageIndexes(wil::details_abi::UsageIndexes *this); // idb
wil::last_error_context *__fastcall wil::last_error_context::last_error_context(wil::last_error_context *this);
__int64 __fastcall wmi::AutoRef<TaskXmlReader>::~AutoRef<TaskXmlReader>(_QWORD); // weak
__int64 __fastcall wil::details_abi::ProcessLocalStorageData<wil::details_abi::ProcessLocalData>::~ProcessLocalStorageData<wil::details_abi::ProcessLocalData>(_QWORD *a1);
__int64 __fastcall wil::details_abi::ProcessLocalStorageData<wil::details_abi::FeatureStateData>::~ProcessLocalStorageData<wil::details_abi::FeatureStateData>(__int64 a1);
__int64 __fastcall _com_ptr_t<_com_IIID<IStream,&__s_GUID const _GUID_0000000c_0000_0000_c000_000000000046>>::~_com_ptr_t<_com_IIID<IStream,&__s_GUID const _GUID_0000000c_0000_0000_c000_000000000046>>(_QWORD); // weak
TaskXmlWriter *__fastcall std::auto_ptr<TaskXmlWriter>::~auto_ptr<TaskXmlWriter>(TaskXmlWriter **a1);
__int64 __fastcall wistd::function<bool (void *,unsigned __int64,void *,unsigned __int64,unsigned int)>::~function<bool (void *,unsigned __int64,void *,unsigned __int64,unsigned int)>(__int64 a1);
__int64 __fastcall wil::unique_any_t<wil::mutex_t<wil::details::unique_storage<wil::details::resource_policy<void *,void (*)(void *),&void wil::details::CloseHandle(void *),wistd::integral_constant<unsigned __int64,0>,void *,void *,0,std::nullptr_t>>,wil::err_returncode_policy>>::~unique_any_t<wil::mutex_t<wil::details::unique_storage<wil::details::resource_policy<void *,void (*)(void *),&void wil::details::CloseHandle(void *),wistd::integral_constant<unsigned __int64,0>,void *,void *,0,std::nullptr_t>>,wil::err_returncode_policy>>(__int64 *a1);
__int64 __fastcall wil::unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_SRWLOCK *,void (*)(_RTL_SRWLOCK *),&void ReleaseSRWLockExclusive(_RTL_SRWLOCK *),wistd::integral_constant<unsigned __int64,1>,_RTL_SRWLOCK *,_RTL_SRWLOCK *,0,std::nullptr_t>>>::~unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_SRWLOCK *,void (*)(_RTL_SRWLOCK *),&void ReleaseSRWLockExclusive(_RTL_SRWLOCK *),wistd::integral_constant<unsigned __int64,1>,_RTL_SRWLOCK *,_RTL_SRWLOCK *,0,std::nullptr_t>>>(__int64 *a1);
__int64 __fastcall wil::unique_any_t<wil::details::unique_storage<wil::details::resource_policy<void *,void (*)(void *),&void wil::details::ReleaseMutex(void *),wistd::integral_constant<unsigned __int64,2>,void *,void *,0,std::nullptr_t>>>::~unique_any_t<wil::details::unique_storage<wil::details::resource_policy<void *,void (*)(void *),&void wil::details::ReleaseMutex(void *),wistd::integral_constant<unsigned __int64,2>,void *,void *,0,std::nullptr_t>>>(__int64 *a1);
void __fastcall wistd::unique_ptr<wil::details_abi::ProcessLocalStorageData<wil::details_abi::ProcessLocalData>,wil::process_heap_deleter>::~unique_ptr<wil::details_abi::ProcessLocalStorageData<wil::details_abi::ProcessLocalData>,wil::process_heap_deleter>(wil::details **a1, void *a2);
// __int64 __fastcall std::vector<_DAB_SCHEDULE_BY_DAY *>::~vector<_DAB_SCHEDULE_BY_DAY *>(_QWORD); weak
void __fastcall ATL::CDacl::CAccessAce::~CAccessAce(void **this);
void __fastcall ATL::CSecurityDesc::~CSecurityDesc(ATL::CSecurityDesc *this); // idb
void __fastcall wil::details::EnabledStateManager::~EnabledStateManager(struct _TP_TIMER **this);
void __fastcall wil::details::FeatureStateManager::~FeatureStateManager(wil::details::FeatureStateManager *this); // idb
void __fastcall JobStore::~JobStore(JobStore *this); // idb
void __fastcall ServerXMLUpdateHandler::NetworkInputHandler::~NetworkInputHandler(ServerXMLUpdateHandler::NetworkInputHandler *this); // idb
void __fastcall wil::details_abi::RawUsageIndex::~RawUsageIndex(wil::details_abi::RawUsageIndex *this, void *a2);
void __fastcall wil::ResultException::~ResultException(LPVOID *this);
void __fastcall wil::details_abi::SemaphoreValue::~SemaphoreValue(wil::details_abi::SemaphoreValue *this); // idb
void __fastcall wil::details_abi::UsageIndexes::~UsageIndexes(wil::details_abi::UsageIndexes *this, void *a2);
void __fastcall wil::details_abi::heap_buffer::~heap_buffer(wil::details_abi::heap_buffer *this, void *a2);
void __fastcall wil::last_error_context::~last_error_context(wil::last_error_context *this); // idb
__int64 (__fastcall ****__fastcall ATL::CAutoPtr<ATL::CDacl::CAccessAce>::operator=(__int64 (__fastcall ****a1)(_QWORD, __int64), _QWORD *a2))(_QWORD, __int64);
__int64 *__fastcall _com_ptr_t<_com_IIID<IStream,&__s_GUID const _GUID_0000000c_0000_0000_c000_000000000046>>::operator=(__int64 *a1);
char __fastcall wistd::__function::__func<_lambda_8db0ce862824541f40dfb767113f1e28_,bool (void *,unsigned __int64,void *,unsigned __int64,unsigned int)>::operator()(__int64 a1, void **a2, size_t *a3, void **a4, unsigned __int64 *a5, unsigned int *a6);
_QWORD *__fastcall wistd::__function::__func<_lambda_8db0ce862824541f40dfb767113f1e28_,bool (void *,unsigned __int64,void *,unsigned __int64,unsigned int)>::`vector deleting destructor'(_QWORD *a1, char a2);
void **__fastcall ATL::CDacl::CAccessObjectAce::`vector deleting destructor'(void **this, char a2);
void **__fastcall ATL::CAcl::CAce::`scalar deleting destructor'(void **this, char a2);
void **__fastcall ATL::CAcl::`vector deleting destructor'(void **this, char a2);
ATL::CDacl *__fastcall ATL::CDacl::`vector deleting destructor'(ATL::CDacl *this, char a2);
ATL::CSecurityDesc *__fastcall ATL::CSecurityDesc::`scalar deleting destructor'(ATL::CSecurityDesc *this, char a2);
LPVOID *__fastcall wil::ResultException::`scalar deleting destructor'(LPVOID *this, char a2);
unsigned __int8 __fastcall ATL::CDacl::CAccessObjectAce::AceType(ATL::CDacl::CAccessObjectAce *this); // idb
__int64 __fastcall wil::details_abi::ProcessLocalStorageData<wil::details_abi::ProcessLocalData>::Acquire(__int64 a1, wil::details **a2);
__int64 __fastcall wil::details_abi::ProcessLocalStorageData<wil::details_abi::FeatureStateData>::Acquire(__int64 a1, __int64 *a2);
bool __fastcall ATL::CDacl::AddAllowedAce(ATL::CDacl *this, const struct ATL::CSid *a2);
signed int ATL::AtlHresultFromLastError(void);
bool __fastcall ATL::AtlSetDacl(HANDLE handle, enum _SE_OBJECT_TYPE a2, const struct ATL::CDacl *a3);
void __noreturn ATL::AtlThrowLastWin32(void); // idb
void __fastcall JobSecurity::Attach(void **this, struct _SECURITY_DESCRIPTOR *a2);
void __fastcall ATL::CSecurityDesc::Clear(ATL::CSecurityDesc *this); // idb
void __fastcall wil::details_abi::ThreadLocalData::Clear(wil::details_abi::ThreadLocalData *this); // idb
void __fastcall wil::details::CloseHandle(wil::details *this, void *a2); // idb
__int64 __fastcall wil::details_abi::UsageIndexProperty::Compare(const void **this, void *a2, size_t a3);
__int64 __fastcall JobStore::CopyDirectoryWithPermissions(char **this, unsigned __int16 *a2, unsigned __int16 *a3);
__int64 __fastcall JobStore::CopyDirectoryWithPermissionsRecursive(char **this, unsigned __int16 *a2, unsigned __int16 *a3);
__int64 __fastcall JobStore::CopyFileWithPermissions(char **this, unsigned __int16 *a2, unsigned __int16 *a3);
__int64 __fastcall wil::details_abi::SemaphoreValue::CreateFromValueInternal(wil::details_abi::SemaphoreValue *this, char *a2, __int64 a3, unsigned __int64 a4);
__int64 __fastcall JobStore::CreateXmlFolder(JobStore *this, char *a2, LPCWSTR StringSecurityDescriptor);
void JobStore::DeleteCommonJobStore(void); // idb
__int64 __fastcall JobStore::DeleteExpiredTask(JobStore *this, const struct JobMoniker *a2);
void __fastcall wil::details::DestroyThreadPoolTimer<wil::details::SystemThreadPoolMethods,0>::Destroy(PTP_TIMER pti);
void __fastcall wil::details_abi::SemaphoreValue::Destroy(wil::details_abi::SemaphoreValue *this); // idb
__int64 __fastcall JobStore::DestroyMigratedUbpmStatsFiles(JobStore *this); // idb
__int64 __fastcall JobStore::DropBackupRestorePermissions(JobStore *this, BOOLEAN a2, char a3);
__int64 __fastcall JobStore::DuplicateFilePermissions(char **this, unsigned __int16 *a2, unsigned __int16 *a3);
void __fastcall wil::details::EnsureCoalescedTimer_SetTimer(struct _TP_TIMER **a1, _BYTE *a2, __int64 a3);
bool __fastcall wil::details::FeatureStateManager::EnsureStateData(RTL_SRWLOCK *this);
void __fastcall wil::details::FeatureStateManager::EnsureSubscribedToProcessWideUsageFlushUnderLock(wil::details::FeatureStateManager *this); // idb
void __fastcall wil::details::EnabledStateManager::EnsureSubscribedToUsageFlush(wil::details::EnabledStateManager *this, struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ **a2);
void __fastcall wil::details::in1diag3::FailFast_Unexpected(wil::details::in1diag3 *this, void *a2, __int64 a3, const char *a4);
__int64 __fastcall JobStore::FileRemoveTaskXml(JobStore *this, const struct JobMoniker *a2); // idb
__int64 __fastcall JobStore::FileSddlSet(JobStore *this, char *a2, const unsigned __int16 *a3);
__int64 __fastcall JobStore::FileSddlSetWithRestorePrivs(JobStore *this, WCHAR *a2, const unsigned __int16 *a3, __int64 a4);
__int64 __fastcall JobStore::FileTaskFolderRemove(JobStore *this, char *a2);
unsigned __int8 *__fastcall wil::details_abi::RawUsageIndex::FindInsertionPointOrIncrement(wil::details_abi::RawUsageIndex *this, struct wil::details_abi::UsageIndexProperty *a2, unsigned __int8 *a3, void *a4, unsigned __int64 a5, unsigned int a6); // idb
void __fastcall wil::details::FeatureStateManager::FlushUsage(wil::details::FeatureStateManager *this); // idb
void __fastcall wil::details::FreeProcessHeap(wil::details *this, void *a2); // idb
char __fastcall ATL::CSecurityDesc::FromString(ATL::CSecurityDesc *this, LPCWSTR StringSecurityDescriptor);
_WORD *__fastcall ATL::CDacl::CAccessAce::GetACE(ATL::CDacl::CAccessAce *this);
char *__fastcall ATL::CDacl::CAccessObjectAce::GetACE(ATL::CDacl::CAccessObjectAce *this);
__int64 __fastcall RpcAutoImpersonate::GetClientUser(RpcAutoImpersonate *this, struct User *a2);
void __fastcall wil::details::ThreadFailureCallbackHolder::GetContextAndNotifyFailure(struct wil::FailureInfo *a1, char *a2, unsigned __int64 a3); // idb
void __fastcall wil::details::GetContextAndNotifyFailure(wil::details *this, struct wil::FailureInfo *a2, char *a3);
const char *__fastcall wil::details::GetCurrentModuleName(wil::details *this); // idb
__int64 __fastcall wil::GetFailureLogString(STRSAFE_LPWSTR pszDest, unsigned __int16 *a2, __int64 a3, const struct wil::FailureInfo *a4);
DWORD __fastcall wil::details::GetLastErrorFail(wil::details *this, void *a2, __int64 a3, const char *a4, const char *a5, const char *a6);
signed int __fastcall wil::details::GetLastErrorFailHr(wil::details *this, __int64 a2, __int64 a3, const char *a4);
__int64 __fastcall ATL::CDacl::CAccessAce::GetLength(ATL::CDacl::CAccessAce *this);
__int64 __fastcall ATL::CDacl::CAccessObjectAce::GetLength(ATL::CDacl::CAccessObjectAce *this);
__int64 wil::details_abi::ThreadLocalStorage<wil::details::ThreadFailureCallbackHolder *>::GetLocal();
__int64 __fastcall wil::details_abi::ThreadLocalStorage<wil::details_abi::ThreadLocalData>::GetLocal(__int64 a1);
__int64 __fastcall JobStore::GetMigratedUbpmDynamicTaskInfo(JobStore *this, UUID *a2, struct DynamicTaskInfo *a3);
char __fastcall wil::details::GetModuleInformation(LPCWSTR lpModuleName, _DWORD *a2, char *a3, char *a4);
const struct _ACL *__fastcall ATL::CAcl::GetPACL(ATL::CAcl *this); // idb
__int64 __fastcall wil::details_abi::ProcessLocalStorage<wil::details_abi::ProcessLocalData>::GetShared(wil::details *a1);
__int64 __fastcall wil::details_abi::UsageIndexProperty::GetSize(wil::details_abi::UsageIndexProperty *this);
bool __fastcall wil::details::ThreadFailureCallbackHolder::GetThreadContext(struct wil::FailureInfo *a1, struct wil::details::ThreadFailureCallbackHolder **a2, char *a3, unsigned __int64 a4);
struct wil::details_abi::ThreadLocalData *__fastcall wil::details_abi::GetThreadLocalDataCache(wil::details_abi *this);
__int64 __fastcall JobStore::GetUbpmStatsFileName(JobStore *this, UUID *a2, unsigned __int16 *a3);
__int64 __fastcall wil::details_abi::SemaphoreValue::GetValueFromSemaphore(HANDLE hHandle, int *a2); // idb
__int64 __fastcall JobStore::GetXmlFileSecurity(JobStore *this, const unsigned __int16 *a2, void **a3);
struct _GUID *__fastcall ATL::CDacl::CAccessObjectAce::InheritedObjectType(ATL::CDacl::CAccessObjectAce *this, struct _GUID *__return_ptr retstr); // idb
void __fastcall ATL::CSecurityDesc::Init(ATL::CSecurityDesc *this, struct _SECURITY_DESCRIPTOR *a2);
__int64 JobStore::IsOOBEInProgress(void); // idb
bool __fastcall PlugIn::IsRegistering(PlugIn *this, const unsigned __int16 *a2, const unsigned __int16 *a3); // idb
char __fastcall wil::details_abi::RawUsageIndex::Iterate(__int64 a1, __int64 a2);
__int64 __fastcall JobStore::LoadTaskIfNeeded(JobStore *this, struct JobMoniker *a2); // idb
void __fastcall wil::details::LogFailure(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, int a7, unsigned int a8, _WORD *a9, __int64 a10, WCHAR *lpOutputString, __int64 a12, char *a13, __int64 a14, __int64 a15);
STRSAFE_LPWSTR wil::details::LogStringPrintf(STRSAFE_LPWSTR pszDest, STRSAFE_LPWSTR a2, size_t *a3, const unsigned __int16 *a4, ...);
unsigned __int8 *__fastcall wil::details_abi::RawUsageIndex::LowerBound(wil::details_abi::RawUsageIndex *this, unsigned __int8 *a2, unsigned __int64 a3, void *a4, unsigned __int64 a5);
__int64 __fastcall wil::details_abi::ProcessLocalStorageData<wil::details_abi::ProcessLocalData>::MakeAndInitialize(char *a1, _QWORD *a2, wil::details **a3);
__int64 __fastcall wil::details_abi::ProcessLocalStorageData<wil::details_abi::FeatureStateData>::MakeAndInitialize(char *a1, _QWORD *a2, __int64 *a3);
__int64 __fastcall JobStore::MigrateDynamicTaskInfo(__int64 **this, const struct JobMoniker *a2, const struct _GUID *a3);
__int64 __fastcall JobStore::MigrateSecurityInfoP(JobStore *this, unsigned __int16 *a2);
signed int __fastcall wil::details::NtStatusToHr(wil::details *this);
struct _GUID *__fastcall ATL::CDacl::CAccessObjectAce::ObjectType(ATL::CDacl::CAccessObjectAce *this, struct _GUID *__return_ptr retstr); // idb
void __fastcall wil::details_abi::SubscriptionList::OnSignaled(LPCRITICAL_SECTION lpCriticalSection, PSRWLOCK SRWLock); // idb
void __fastcall wil::details::EnabledStateManager::OnStateChange(RTL_SRWLOCK *this);
void __fastcall wil::details::FeatureStateManager::OnStateChange(wil::details::FeatureStateManager *this); // idb
void __fastcall wil::details::EnabledStateManager::OnTimer(RTL_SRWLOCK *this);
__int64 __fastcall ATL::CDacl::CAccessAce::Order(const struct ATL::CDacl::CAccessAce *a1, const struct ATL::CDacl::CAccessAce *a2); // idb
void __fastcall ATL::CDacl::PrepareAcesForACL(ATL::CDacl *this); // idb
void __fastcall wil::details_abi::FeatureStateData::ProcessShutdown(wil::details_abi::FeatureStateData *this); // idb
void __fastcall wil::details::FeatureStateManager::QueueBackgroundSRUMUsageReporting(PVOID pv, int a2, __int16 a3, int a4);
bool __fastcall wil::details_abi::UsageIndexProperty::Read(wil::details_abi::UsageIndexProperty *this, unsigned __int8 **a2, unsigned __int8 *a3); // idb
void __fastcall wil::details_abi::UsageIndexes::Record(wil::details_abi::UsageIndexes *this, __int64 a2, __int64 a3, const struct wil::details_abi::RawUsageIndex *a4);
__int64 __fastcall wil::details::RecordException(wil::details *this);
char __fastcall wil::details_abi::FeatureStateData::RecordFeatureUsage(__int64 a1, int a2, unsigned int a3, unsigned int a4);
void __fastcall wil::details::FeatureStateManager::RecordFeatureUsage(_BYTE *a1, int a2, unsigned int a3, unsigned int a4);
__int64 __fastcall wil::details::RecordLog(wil::details *this);
__int64 __fastcall wil::details::RecordReturn(wil::details *this);
void __fastcall wil::details::RecordSRUMFeatureUsage(wil::details *this);
char __fastcall wil::details_abi::UsageIndex<enum wil_details_ServiceReportingKind,unsigned int,2>::RecordUsage(wil::details **a1, int a2, int a3, unsigned int a4);
char __fastcall wil::details_abi::UsageIndex<enum wil_details_ServiceReportingKind,unsigned int,0>::RecordUsage(wil::details **a1, int a2, int a3);
void __fastcall wil::details_abi::FeatureStateData::RecordUsage(RTL_SRWLOCK *this);
char __fastcall wil::details_abi::RawUsageIndex::RecordUsage(wil::details **this, void *a2, size_t a3, void *a4, unsigned __int64 a5, unsigned int a6);
char __fastcall wil::details_abi::RawUsageIndex::RecordUsageInternal(wil::details_abi::RawUsageIndex *this, void *a2, size_t a3, void *a4, unsigned __int64 a5, unsigned int a6);
void __fastcall wil::details_abi::RecordWnfUsageIndex(wil::details_abi *this, const struct __WIL__WNF_STATE_NAME *a2, __int64 a3, const struct wil::details_abi::RawUsageIndex *a4);
__int64 __fastcall JobStore::RegFolderEntryCreate(JobStore *this, const unsigned __int16 *a2, const struct JobSecurity *a3);
__int64 __fastcall JobStore::RegJobSecuritySet(HKEY *this, const unsigned __int16 *a2, struct JobSecurity *a3);
__int64 __fastcall JobStore::RegOpenTaskOverrideKey(JobStore *this, const unsigned __int16 *a2, REGSAM a3, int a4, HKEY *a5);
__int64 __fastcall JobStore::RegTaskEntryCreate(HKEY *this, const struct JobMoniker *a2, const struct JobSecurity *a3, const struct Triggers::Trigulator *a4, const struct Actions::ActionCollection *a5, BYTE *lpData);
__int64 __fastcall JobStore::RegTaskEntryKeyCreate(HKEY *this, GUID *a2, const struct JobSecurity *a3, const enum JobStore::TaskIndex *a4, int a5, HKEY *a6);
__int64 __fastcall PlugIn::RegisterTask(PlugIn *this, const unsigned __int16 *a2, const unsigned __int16 *a3, const unsigned __int16 *a4, unsigned int a5, unsigned __int16 *a6); // idb
__int64 __fastcall wil::details_abi::ProcessLocalStorageData<wil::details_abi::ProcessLocalData>::Release(HANDLE *lpMem);
void __fastcall wil::details_abi::ProcessLocalStorageData<wil::details_abi::FeatureStateData>::Release(HANDLE *lpMem);
void __fastcall wil::details::ReleaseMutex(wil::details *this, void *a2); // idb
void __fastcall ATL::CDacl::RemoveAce(ATL::CDacl *this, unsigned int a2); // idb
int __fastcall ATL::CAtlArray<ATL::CAutoPtr<ATL::CDacl::CAccessAce>,ATL::CAutoPtrElementTraits<ATL::CDacl::CAccessAce>>::RemoveAt(_QWORD *a1, unsigned __int64 a2);
__int64 __fastcall JobStore::RemoveMigratedUbpmStatsFile(JobStore *this, UUID *a2);
LSTATUS __fastcall JobStore::RemoveTaskEntry(HKEY *this, const struct JobMoniker *a2);
__int64 __fastcall JobStore::RemoveTaskEntryP(__int64 a1, JobMoniker *a2, int a3);
__int64 __fastcall JobStore::RemoveTaskFolderEntry(HKEY *this, const unsigned __int16 *a2);
__int64 __fastcall JobStore::RemoveTaskOrFolder(JobStore *this, unsigned __int16 *a2, int *a3, struct JobMoniker *a4);
__int64 __fastcall JobStore::RemoveTaskOrFolderP(JobStore *this, unsigned __int16 *a2, int a3, int a4, int a5, int *a6, struct JobMoniker *a7);
void __fastcall wil::details::ReportFailure(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, int a7, unsigned int a8);
__int64 __fastcall wil::details::ReportFailure_GetLastError(wil::details *a1, void *a2, __int64 a3, const char *a4, __int64 a5, const char *a6);
__int64 __fastcall wil::details::ReportFailure_GetLastErrorHr(wil::details *a1, void *a2, __int64 a3, const char *a4, __int64 a5, const char *a6);
void __fastcall wil::details::ReportFailure_Hr(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, int a7, unsigned int a8);
__int64 __fastcall wil::details::ResultStringSize(wil::details *this, const char *a2);
__int64 __fastcall wil::details::ResultStringSize(wil::details *this, const unsigned __int16 *a2);
void __fastcall __noreturn wil::details::Rethrow(wil::details *this); // idb
void __fastcall wil::details_abi::FeatureStateData::RetrieveUsageUnderLock(wil::details_abi::FeatureStateData *this, struct wil::details_abi::UsageIndexes *a2);
__int64 __fastcall wil::details::in1diag3::Return_GetLastError(wil::details::in1diag3 *this, void *a2, __int64 a3, const char *a4);
void __fastcall wil::details::in1diag3::Return_Hr(wil::details::in1diag3 *this, void *a2, __int64 a3, const char *a4);
void __fastcall JobStore::ReverseSlashesInString(JobStore *this, unsigned __int16 *a2); // idb
__int64 __fastcall wil::details::RtlNtStatusToDosErrorNoTeb(wil::details *this);
void __fastcall wil::details_abi::ThreadLocalFailureInfo::Set(wil::details_abi::ThreadLocalFailureInfo *this, const struct wil::FailureInfo *a2, int a3);
void __fastcall wil::details_abi::RawUsageIndex::SetBuffer(wil::details_abi::RawUsageIndex *this, char *a2, unsigned __int64 a3, const char *a4);
void __fastcall wil::StoredFailureInfo::SetFailureInfo(wil::StoredFailureInfo *this, const struct wil::FailureInfo *a2); // idb
void __fastcall wil::details_abi::ThreadLocalData::SetLastError(wil::details_abi::ThreadLocalData *this, const struct wil::FailureInfo *a2);
unsigned __int8 *__fastcall wil::details_abi::RawUsageIndex::SkipValues(wil::details_abi::RawUsageIndex *this, struct wil::details_abi::UsageIndexProperty *a2, unsigned __int8 *a3);
__int64 wil::details::StringCchPrintfA(wil::details *this, char *a2, const char *a3, const char *a4, ...);
void __fastcall wil::details::FeatureStateManager::SubscribeToEnabledStateChanges(RTL_SRWLOCK *this, struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ **a2, void (__stdcall *a3)(void *), __int64 a4);
void __fastcall wil::details::FeatureStateManager::SubscribeToUsageFlush(RTL_SRWLOCK *this, struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ **a2, void (__stdcall *a3)(void *));
void __fastcall wil::details_abi::SubscriptionList::SubscribeUnderLock(wil::details_abi::SubscriptionList *this, struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ **a2, void (__stdcall *a3)(void *), __int64 a4);
void __fastcall wil::details_abi::RawUsageIndex::Swap(wil::details_abi::RawUsageIndex *this, struct wil::details_abi::RawUsageIndex *a2); // idb
__int64 __fastcall JobStore::TakeBackupRestorePermissions(JobStore *this, unsigned __int8 *a2, unsigned __int8 *a3); // idb
void __fastcall __noreturn wil::details::ThrowResultExceptionInternal(wil::details *this, const struct wil::FailureInfo *a2); // idb
__int64 __fastcall wil::details_abi::SemaphoreValue::TryGetPointer(char *a1, void **a2, __int64 a3, bool *a4);
__int64 __fastcall wil::details_abi::SemaphoreValue::TryGetValueInternal(char *a1, __int64 a2, unsigned __int64 *a3, bool *a4);
void __fastcall wil::details_abi::SubscriptionList::Unsubscribe(struct _RTL_CRITICAL_SECTION *this, RTL_SRWLOCK *a2, struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ *a3);
void __fastcall wil::details::UnsubscribeProcessWideUsageFlush(struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ *this, struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ *a2); // idb
void __fastcall wil::details::UnsubscribeWilWnf(wil::details *this, struct __WIL__WNF_USER_SUBSCRIPTION *a2); // idb
void __fastcall wil::details_abi::UsageIndexProperty::UpdateCount(wil::details_abi::UsageIndexProperty *this, int a2);
void __fastcall wil::details::WilApiImpl_RecordFeatureUsage(wil::details *this, unsigned int a2, unsigned int a3);
void __fastcall wil::details::WilApiImpl_SubscribeFeatureStateChangeNotification(struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ **this, struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ **a2, void (__stdcall *a3)(void *), void *a4); // idb
void __fastcall wil::details::WilApiImpl_UnsubscribeFeatureStateChangeNotification(struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ *this, struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ *a2); // idb
void __fastcall wil::details::WilApi_RecordFeatureUsage(wil::details *this);
void __fastcall wil::details::WilApi_SubscribeFeatureStateChangeNotification(wil::details *this, struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ **a2, void (__stdcall *a3)(void *), void *a4); // idb
void __fastcall wil::details::WilApi_UnsubscribeFeatureStateChangeNotification(wil::details *this, struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ *a2); // idb
void __fastcall wil::details::WilDynamicLoadRaiseFailFastException(wil::details *this, struct _EXCEPTION_RECORD *a2, struct _CONTEXT *a3);
void __fastcall __noreturn wil::details::WilFailFast(wil::details *this, const struct wil::FailureInfo *a2); // idb
void __fastcall __noreturn wil::details::WilRaiseFailFastException(struct _EXCEPTION_RECORD *this, struct _EXCEPTION_RECORD *a2, struct _CONTEXT *a3);
bool __fastcall wil::details_abi::UsageIndexProperty::Write(wil::details_abi::UsageIndexProperty *this, char **a2, char *a3);
_QWORD *__fastcall std::_Tree_buy<JobMoniker>::_Buynode0(_QWORD *a1);
void __fastcall wil::details::in1diag3::_FailFast_GetLastError(wil::details::in1diag3 *this, void *a2, __int64 a3, const char *a4);
void __fastcall wil::details::in1diag3::_FailFast_Unexpected(wil::details::in1diag3 *this, void *a2, __int64 a3, const char *a4);
void **__fastcall wistd::__function::__func<_lambda_8db0ce862824541f40dfb767113f1e28_,bool (void *,unsigned __int64,void *,unsigned __int64,unsigned int)>::__move(__int64 a1, __int64 a2);
_QWORD *__fastcall wil::mutex_t<wil::details::unique_storage<wil::details::resource_policy<void *,void (*)(void *),&void wil::details::CloseHandle(void *),wistd::integral_constant<unsigned __int64,0>,void *,void *,0,std::nullptr_t>>,wil::err_returncode_policy>::acquire(HANDLE *a1, _QWORD *a2);
void __fastcall wil::details::shared_buffer::assign(LPVOID *this, int *a2, void *a3);
bool __fastcall wil::details::shared_buffer::create(LPVOID *this, const void *Source, void *a3);
char __fastcall wil::details_abi::heap_buffer::ensure(wil::details_abi::heap_buffer *this, unsigned __int64 a2);
RTL_SRWLOCK **__fastcall wil::srwlock::lock_exclusive(RTL_SRWLOCK *a1, RTL_SRWLOCK **a2);
char __fastcall wil::details_abi::heap_buffer::push_back(void **this, const void *a2, unsigned __int64 a3);
char __fastcall wil::details_abi::heap_buffer::reserve(wil::details_abi::heap_buffer *this, unsigned __int64 a2);
void __fastcall wil::details::unique_storage<wil::details::resource_policy<_TP_TIMER *,void (*)(_TP_TIMER *),&public: static void wil::details::DestroyThreadPoolTimer<wil::details::SystemThreadPoolMethods,0>::Destroy(_TP_TIMER *),wistd::integral_constant<unsigned __int64,0>,_TP_TIMER *,_TP_TIMER *,0,std::nullptr_t>>::reset(struct _TP_TIMER **a1, struct _TP_TIMER *a2);
void __fastcall wil::details::unique_storage<wil::details::resource_policy<void *,void (*)(void *),&void wil::details::CloseHandle(void *),wistd::integral_constant<unsigned __int64,0>,void *,void *,0,std::nullptr_t>>::reset(__int64 *a1, __int64 a2);
void __fastcall wil::details::unique_storage<wil::details::resource_policy<void *,void (*)(void *),&void wil::details::ReleaseMutex(void *),wistd::integral_constant<unsigned __int64,2>,void *,void *,0,std::nullptr_t>>::reset(__int64 *a1, __int64 a2);
void __fastcall wil::details::shared_buffer::reset(LPVOID *this);
const char *__fastcall wil::ResultException::what(wil::ResultException *this, __int64 a2, __int64 a3, const struct wil::FailureInfo *a4);
__int64 __fastcall wil_details_WriteSRUMWnfUsageBuffer(__int64 *a1, __int64 a2, __int64 a3);
__int64 __fastcall WPP_SF_S_guid_(__int64 a1, __int64 a2, __int64 a3, const wchar_t *a4);
__int64 __fastcall WPP_SF_dD(__int64 a1, unsigned __int16 a2, __int64 a3, int a4);
void __fastcall tsched::SecretGuard::~SecretGuard(tsched::SecretGuard *__hidden this); // idb
__int64 __fastcall CredStore::AddrefUserRecord(LPCRITICAL_SECTION lpCriticalSection, User *this, void **a3);
__int64 __fastcall CredStore::DeleteNtCredential(struct _RTL_CRITICAL_SECTION *this, const struct User *a2);
__int64 __fastcall CredStore::GetAliasCredId(char *a1, void **a2);
__int64 __fastcall CredStore::GetCredId(User *this, void **a2);
__int64 __fastcall CredStore::InitAliasesKey(CredStore *this); // idb
__int64 __fastcall NotifyLsaOfPasswordChange(char *a1, char *a2, char *a3);
int __fastcall CredStore::ResolveAlias(HKEY *this, const unsigned __int16 *a2, User::UserEntry **a3);
__int64 __fastcall CredStore::StoreNtCredential(LPCRITICAL_SECTION lpCriticalSection, const struct User *this, unsigned __int16 *a3);
__int64 __fastcall StringCbCopyW(char *a1, unsigned __int64 a2, char *a3);
__int64 CredStore::Uninit(void); // idb
__int64 __fastcall CredStore::UpgradeCred(LPCRITICAL_SECTION lpCriticalSection, HKEY hKey, char *a3, const unsigned __int16 *a4, const unsigned __int16 *lpAccountName);
void __fastcall CredStore::WipeoutStore(CredStore *this, HKEY *a2);
__int64 __fastcall JobStore::MarkHashingCompletion(JobStore *this); // idb
__int64 __fastcall JobStore::MarkMTRCompletion(JobStore *this); // idb
__int64 __fastcall JobStore::MarkMigrationCleanupCompletion(JobStore *this); // idb
__int64 __fastcall JobStore::MarkPermissionsRestoreCompletion(JobStore *this); // idb
__int64 __fastcall JobStore::StreamInDWORD(unsigned int *a1, unsigned int **a2, unsigned __int8 *a3);
__int64 __fastcall JobStore::StreamOutDWORD(int a1, unsigned __int8 **a2, unsigned __int8 *a3);
_QWORD *__fastcall std::_Tree_buy<std::pair<_bstr_t const,_bstr_t>>::_Buynode<std::pair<_bstr_t const,_bstr_t> &>(_QWORD *a1, __int64 *a2);
__int64 *__fastcall std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::_Insert_at<std::pair<_bstr_t const,_bstr_t> &,std::_Tree_node<std::pair<_bstr_t const,_bstr_t>,void *> *>(__int64 *a1, __int64 *a2, char a3, _QWORD *a4, int a5, __int64 a6);
__int64 __fastcall std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::_Insert_nohint<std::pair<_bstr_t const,_bstr_t> &,std::_Tree_node<std::pair<_bstr_t const,_bstr_t>,void *> *>(__int64 *a1, __int64 a2, __int64 a3, BSTR **a4, void *lpMem);
__int64 __fastcall std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::insert<std::pair<_bstr_t,_bstr_t>>(__int64 *a1, __int64 a2, __int64 *a3);
void __fastcall Triggers::GenericTrigger::~GenericTrigger(Triggers::GenericTrigger *this); // idb
void __fastcall Triggers::TriggerBase::~TriggerBase(Triggers::TriggerBase *this); // idb
Triggers::Trigger *__fastcall Triggers::Trigger::`vector deleting destructor'(Triggers::Trigger *this, char a2);
__int64 __fastcall Triggers::EventTrigger::GetStorageSize(BSTR **this);
__int64 __fastcall Triggers::LogXTrigger::GetStorageSize(Triggers::LogXTrigger *this);
const unsigned __int16 *__fastcall Triggers::GenericTrigger::GetTriggerId(Triggers::GenericTrigger *this); // idb
const unsigned __int16 *__fastcall Triggers::TimeTrigger::GetTriggerId(Triggers::TimeTrigger *this); // idb
__int64 __fastcall Triggers::Trigulator::RegisterAll(Triggers::Trigulator *a1, struct JobMoniker *a2, __int128 *a3, __int128 *a4, int a5);
__int64 __fastcall Triggers::RegistrationTrigger::RegisterThyself(Triggers::RegistrationTrigger *this, struct JobMoniker *a2, struct Triggers::TriggerOptions *a3); // idb
__int64 __fastcall Triggers::IdleTrigger::RegisterThyself(Triggers::IdleTrigger *this, struct JobMoniker *a2, struct Triggers::TriggerOptions *a3); // idb
__int64 __fastcall Triggers::LogonTrigger::RegisterThyself(Triggers::LogonTrigger *this, struct JobMoniker *a2, struct Triggers::TriggerOptions *a3); // idb
__int64 __fastcall Triggers::SessionChangeTrigger::RegisterThyself(Triggers::SessionChangeTrigger *this, struct JobMoniker *a2, struct Triggers::TriggerOptions *a3); // idb
__int64 __fastcall Triggers::TimeTrigger::RegisterThyself(Triggers::TimeTrigger *this, struct JobMoniker *a2, struct Triggers::TriggerOptions *a3);
__int64 __fastcall Triggers::Trigulator::ScheduleExpiredTaskDeletion(Triggers::Trigulator *this, const struct JobMoniker *a2);
__int64 __fastcall Triggers::EventTrigger::StreamOutImpl(Triggers::EventTrigger *this, __int64 a2, unsigned __int8 **a3, unsigned __int8 *a4);
__int64 __fastcall Triggers::LogXTrigger::StreamOutImpl(Triggers::LogXTrigger *this, __int64 a2, unsigned __int8 **a3, unsigned __int8 *a4);
__int64 __fastcall Triggers::IdleTrigger::WriteXml(Triggers::IdleTrigger *this, struct TaskXmlWriter *a2); // idb
void __fastcall std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::_Destroy_if_not_nil(__int64 a1, __int64 a2);
__int64 __fastcall WPP_SF_Sdd(__int64 a1);
struct _RTL_CRITICAL_SECTION *__fastcall HashCompute::`vector deleting destructor'(struct _RTL_CRITICAL_SECTION *this, char a2);
signed int __fastcall DynamicTaskInfo::StreamOut(BYTE *lpData, HKEY hKey);
void __fastcall MessageBoxTask::~MessageBoxTask(void **this);
void **__fastcall MessageBoxTask::`scalar deleting destructor'(void **this, char a2);
char *__fastcall wmi::AutoVectorPtr<JobMoniker>::~AutoVectorPtr<JobMoniker>(JobMoniker **a1);
DWORD __fastcall ItSpBatteryRemainingCallback(struct _ITSRV_GLOBAL_CONTEXT *a1, int a2, _DWORD *a3);
void __fastcall ItSpCleanupGlobalContext(struct _ITSRV_GLOBAL_CONTEXT *a1); // idb
void __fastcall ItSpCleanupIdleTask(struct _ITSRV_IDLE_TASK_CONTEXT *a1); // idb
DWORD __fastcall ItSpConstrainedModeDetectionCallback(struct _WNF_STATE_NAME a1, __int64 a2, struct _WNF_TYPE_ID *a3, volatile __int32 *a4, _QWORD *a5, unsigned int a6);
struct _ITSRV_IDLE_TASK_CONTEXT *__fastcall ItSpFindIdleTask(struct _LIST_ENTRY *a1, int *a2); // idb
void __fastcall ItSpIdleCancellationCallback(PTP_CALLBACK_INSTANCE Instance, char *Context, PTP_TIMER Timer);
void ItSpNotifyProcessIdleTasks(void); // idb
bool __fastcall ItSpResumeTimeoutIsOver(struct _ITSRV_GLOBAL_CONTEXT *a1, struct _FILETIME *a2);
void __fastcall ItSpSendIdleExitPerftrackNotification(struct _ITSRV_GLOBAL_CONTEXT *a1); // idb
void __fastcall ItSpStopIdleDetection(struct _ITSRV_GLOBAL_CONTEXT *a1); // idb
__int64 __fastcall ItSpStoreDetectionOverrides(struct _IT_IDLE_DETECTION_PARAMETERS *a1);
__int64 __fastcall ItSpStoreOverrideValue(HKEY a1, const unsigned __int16 *a2, const BYTE *lpData, DWORD cbData);
LSTATUS __fastcall ItSpStoreOverrideValue(HKEY a1, const unsigned __int16 *a2, char a3);
__int64 __fastcall ItSpStoreRuntimeOverrides(struct _IT_IDLE_RUNTIME_PARAMETERS *a1);
DWORD __fastcall ItSpSubmitThreadpoolTimer(struct _TP_TIMER **a1, struct _ITSRV_GLOBAL_CONTEXT *a2, void (__stdcall *a3)(struct _TP_CALLBACK_INSTANCE *, void *, struct _TP_TIMER *), unsigned int a4);
void __fastcall ItSpUnregisterIdleTask(unsigned __int16 *a1, int **a2, char a3);
void __fastcall IT_HANDLE_rundown(int *a1);
__int64 __fastcall ItSrvProcessIdleTasks(EventManager *a1, __int64 a2, void *a3, const struct _GUID *a4);
__int64 __fastcall ItSrvSetDetectionParameters(__int64 a1, __int64 a2);
__int64 __fastcall ItSrvSetRuntimeOverrides(__int64 a1, __int64 a2);
void ItSrvUninitialize();
void __fastcall ItSrvUnregisterIdleTask(unsigned __int16 *a1, int **a2);
__int64 __fastcall ItSpScheduledTaskIsIdleStarted(struct ITaskService *a1, unsigned __int16 *const a2, int *a3); // idb
__int64 ItSpStartScheduledIdleTasks(void); // idb
__int64 __fastcall ItSpStartScheduledIdleTasksInFolder(struct ITaskService *a1, struct ITaskFolder *a2); // idb
__int64 ItSpWaitForScheduledIdleTasks(void); // idb
_QWORD *__fastcall ATL::CComPtrBase<IRunningTask>::Release(_QWORD *a1);
_QWORD *__fastcall std::_List_buy<_GUID>::_Buynode<_GUID const &>(__int64 a1, _QWORD *a2, _QWORD *a3, _OWORD *a4);
TaskAccessChecker *__fastcall TaskAccessChecker::TaskAccessChecker(TaskAccessChecker *this); // idb
void __fastcall std::list<UbpmInstance>::~list<UbpmInstance>(void **a1);
void __fastcall std::list<_GUID>::~list<_GUID>(__int64 a1);
void __fastcall tsched::SrwLockSharedScope::~SrwLockSharedScope(PSRWLOCK *this);
void __fastcall TaskAccessChecker::~TaskAccessChecker(void **this);
_QWORD *__fastcall tsched::SecretGuard::operator=(void **a1);
__int64 __fastcall RpcServer::AcquireStateChangeNotification(RTL_SRWLOCK *this, char *a2, union _LARGE_INTEGER **a3);
__int64 __fastcall TaskAccessChecker::AllowEnumInstance(TaskAccessChecker *this, const struct JobMoniker *a2);
__int64 __fastcall TaskAccessChecker::AllowStopInstance(TaskAccessChecker *this, const struct JobMoniker *a2);
__int64 __fastcall RpcServer::CreateFolder(RTL_SRWLOCK *this, unsigned __int16 *a2, const unsigned __int16 *a3, int a4);
__int64 __fastcall RpcServer::CreateRegistrationPath(RpcServer *this, const unsigned __int16 *a2, struct JobSecurity *a3, void *a4);
__int64 __fastcall RpcServer::EnumIndex(RpcServer *this, int a2, unsigned int *a3, unsigned int a4, unsigned int *a5, unsigned __int16 ***a6);
__int64 __fastcall RpcServer::EnumInstances(RpcServer *this, char *a2, int a3, unsigned int *a4, struct _GUID **a5);
__int64 __fastcall RpcServer::GetBasicInstanceInfo(RpcServer *this, struct _GUID *a2, struct JobMoniker *a3, enum tsched::InternalTaskState *a4, struct _bstr_t *a5, unsigned int *a6);
__int64 __fastcall RpcServer::GetInstanceInfo(RpcServer *this, struct _GUID *a2, unsigned __int16 **a3, unsigned int *a4, unsigned __int16 **a5, unsigned __int16 **a6, unsigned int *a7, struct _GUID **a8, unsigned int *a9); // idb
__int64 __fastcall RpcServer::GetLastRunInfo(RTL_SRWLOCK *this, char *a2, struct _SYSTEMTIME *a3, unsigned int *a4);
__int64 __fastcall RpcServer::GetSecurity(RTL_SRWLOCK *this, char *a2, SECURITY_INFORMATION a3, unsigned __int16 **a4);
__int64 __fastcall RpcServer::GetTaskDynamicData(RTL_SRWLOCK *this, char *a2, struct _SCHRPC_TASK_INFO_OUT_2 **a3);
__int64 __fastcall RpcServer::MigrateTask(void **this, unsigned __int16 *a2, struct _EVENT_DESCRIPTOR *a3, unsigned int a4, const unsigned __int16 *a5, const unsigned __int16 *a6, struct _SCHRPC_DYNAMIC_TASK_INFO *a7);
__int64 __fastcall RpcServer::SavePasswords(const struct JobMoniker *a1, unsigned int a2, const struct _TASK_USER_CRED *a3); // idb
__int64 __fastcall RpcServer::SetSecurity(RTL_SRWLOCK *this, char *a2, unsigned __int16 *a3, int a4);
__int64 __fastcall RpcServer::StopInstance(RpcServer *this, struct _GUID *a2, int a3);
void __fastcall RpcServer::StopServer(RPC_BINDING_VECTOR **BindingVector); // idb
__int64 __fastcall RpcServer::StopTask(RTL_SRWLOCK *this, unsigned __int16 *a2, int a3);
bool __fastcall RpcServer::UserGroupCheck(DWORD SessionId, const struct User *a2, const struct User *this); // idb
__int64 __fastcall RpcServer::ValidatePasswords(unsigned int a1, const struct User *a2, const unsigned __int16 *a3);
_QWORD *__fastcall std::_List_alloc<0,std::_List_base_types<UbpmInstance>>::_Buynode0(__int64 a1, _QWORD *a2, _QWORD *a3);
_QWORD *__fastcall std::_List_alloc<0,std::_List_base_types<_GUID>>::_Buynode0(__int64 a1, _QWORD *a2, _QWORD *a3);
void __fastcall std::list<UbpmInstance>::clear(__int64 a1);
__int64 __fastcall WPP_SF_SDddSS(__int64 a1, __int64 a2, __int64 a3, const wchar_t *a4, char a5, char a6, char a7, __int64 a8, __int64 a9);
bool IsImpersonatedAsLocalSystem(void); // idb
signed int __fastcall IsPasswordManagedServiceAccount(unsigned __int16 *a1, unsigned __int16 *a2, bool *a3);
__int64 __fastcall I_pAcquireBackgroundExecutionMode(__int64 a1, unsigned int a2, unsigned int a3, _QWORD *a4);
__int64 __fastcall I_pReleaseBackgroundExecutionMode(_QWORD **a1);
__int64 __fastcall I_pSchRpcAquireTaskStateNotificationsName(__int64 a1, char *a2, union _LARGE_INTEGER **a3);
__int64 __fastcall I_pSchRpcEnumTasks(__int64 a1, int a2, int *a3, unsigned int *a4, unsigned int a5, unsigned int *a6, unsigned __int16 ***a7);
int __fastcall I_pSchRpcGetTaskInfo(__int64 a1, int a2, const unsigned __int16 *a3, struct _SCHRPC_TASK_INFO_OUT_2 **a4);
__int64 __fastcall I_pSchRpcRegisterTask(__int64 a1, int a2, const unsigned __int16 *a3, const unsigned __int16 *a4, unsigned int a5, unsigned __int16 *a6, unsigned __int16 *a7, struct _SCHRPC_DYNAMIC_TASK_INFO **a8);
__int64 __fastcall SchRpcCreateFolder(__int64 a1, unsigned __int16 *a2, const unsigned __int16 *a3, int a4);
__int64 __fastcall SchRpcEnumFolders(__int64 a1, char *a2, int a3, unsigned int *a4, unsigned int a5, unsigned int *a6, unsigned __int16 ***a7);
__int64 __fastcall SchRpcEnumInstances(__int64 a1, char *a2, int a3, unsigned int *a4, struct _GUID **a5);
__int64 __fastcall SchRpcGetInstanceInfo(__int64 a1, struct _GUID *a2, unsigned __int16 **a3, unsigned int *a4, unsigned __int16 **a5, unsigned __int16 **a6, unsigned int *a7, struct _GUID **a8, unsigned int *a9);
__int64 __fastcall SchRpcGetLastRunInfo(__int64 a1, char *a2, struct _SYSTEMTIME *a3, unsigned int *a4);
__int64 __fastcall SchRpcGetSecurity(__int64 a1, char *a2, SECURITY_INFORMATION a3, unsigned __int16 **a4);
__int64 __fastcall SchRpcSetSecurity(__int64 a1, char *a2, unsigned __int16 *a3, int a4);
__int64 __fastcall SchRpcStop(__int64 a1, unsigned __int16 *a2, int a3);
__int64 __fastcall SchRpcStopInstance(__int64 a1, struct _GUID *a2, int a3);
_QWORD *__fastcall std::_List_buy<UbpmInstance>::_Buynode<UbpmInstance const &>(__int64 a1, _QWORD *a2, _QWORD *a3, __int64 a4);
_QWORD *__fastcall std::list<UbpmInstance>::_Insert<UbpmInstance const &>(__int64 a1, __int64 a2, __int64 a3);
char **__fastcall std::list<UbpmInstance>::assign<std::_List_const_iterator<std::_List_val<std::_List_simple_types<UbpmInstance>>>>(char *a1, __int64 *a2, __int64 *a3);
void __fastcall AutoUbpmConsumerHandle::~AutoUbpmConsumerHandle(AutoUbpmConsumerHandle *this); // idb
void __fastcall UbpmFreeMe::~UbpmFreeMe(UbpmFreeMe *this); // idb
__int64 __fastcall UbpmProxySingleton::AquireStateNotificationName(UbpmProxySingleton *this, const wchar_t **a2, struct _WNF_STATE_NAME *a3);
__int64 __fastcall UbpmProxySingleton::EnableTask(UbpmProxySingleton *this, const wchar_t **a2, int a3);
__int64 __fastcall UbpmProxySingleton::EnumAllInstances(__int64 a1, char *a2);
__int64 __fastcall UbpmProxySingleton::EnumInstances(UbpmProxySingleton *a1, const wchar_t **a2, __int64 *a3);
__int64 __fastcall UbpmProxySingleton::GetInstanceInfo(UbpmProxySingleton *this, const struct _GUID *a2, enum tsched::InternalTaskState *a3, struct JobMoniker *a4, _bstr_t::Data_t **a5, unsigned int *a6);
__int64 __fastcall UbpmProxySingleton::GetLastRunInfo(UbpmProxySingleton *this, const wchar_t **a2, struct _FILETIME *a3, struct _FILETIME *a4, struct _FILETIME *a5, unsigned int *a6);
__int64 __fastcall UbpmProxySingleton::GetTaskState(UbpmProxySingleton *this, const wchar_t **a2, enum tsched::InternalTaskState *a3);
__int64 __fastcall UbpmProxySingleton::IsV2Compatible(UbpmProxySingleton *this, const struct JobMoniker *a2, struct Triggers::Trigulator *a3, struct Actions::ActionCollection *a4, int *a5); // idb
__int64 __fastcall UbpmProxySingleton::LookupTask(UbpmProxySingleton *this, const struct _GUID *a2, struct JobMoniker *a3); // idb
__int64 __fastcall UbpmProxySingleton::LookupTaskByIndex(__int64 a1, const struct _GUID *a2, int a3, __int64 a4, int a5, enum tsched::InternalTaskState *a6, _bstr_t::Data_t **a7, unsigned int *a8);
__int64 __fastcall UbpmProxySingleton::MatchConsumerWithInstance(UbpmProxySingleton *this, const struct _GUID *a2, struct JobMoniker *a3, int a4, enum tsched::InternalTaskState *a5, _bstr_t::Data_t **a6, unsigned int *a7);
__int64 __fastcall UbpmProxySingleton::StopInstance(UbpmProxySingleton *this, const struct JobMoniker *a2, const struct _GUID *a3);
__int64 __fastcall UbpmProxySingleton::StopInstances(UbpmProxySingleton *this, const struct JobMoniker *a2, const struct User *a3, const struct _GUID *a4);
__int64 __fastcall UbpmProxySingleton::StopTask(UbpmProxySingleton *this, const struct JobMoniker *a2, const struct User *a3); // idb
__int64 __fastcall UbpmProxySingleton::UnregisterConsumer(UbpmProxySingleton *this, const wchar_t **a2, int a3);
__int64 __fastcall UbpmProxySingleton::UpdateTaskNotificationSecurity(UbpmProxySingleton *this, struct JobMoniker *a2, __int64 a3, int a4);
char **__fastcall std::list<UbpmInstance>::erase(char **a1, char **a2, char *a3, char *a4);
__int64 __fastcall WPP_SF_SdD(__int64 a1, unsigned __int16 a2, __int64 a3, const wchar_t *a4);
__int64 __fastcall WPP_SF__guid_D(__int64 a1, unsigned __int16 a2, __int64 a3, __int64 a4);
__int64 __fastcall WPP_SF__guid_SD(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall WPP_SF__guid_dD(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall UbpmParams::NewHostedObject<std::list<std::vector<unsigned char> *,std::allocator<std::vector<unsigned char> *>>,std::vector<unsigned char>>(_QWORD *a1, __int64 a2);
__int64 __fastcall UbpmParams::NewHostedObject<std::vector<_DAB_REGISTRATION_TRIGGER_PARAMS *>,_DAB_REGISTRATION_TRIGGER_PARAMS>(__int64 *a1, _OWORD *a2);
__int64 __fastcall UbpmParams::NewHostedObject<std::vector<_DAB_SCHEDULE_BY_MONTH *>,_DAB_SCHEDULE_BY_MONTH>(__int64 *a1, _QWORD *a2);
__int64 __fastcall UbpmParams::NewHostedObject<std::vector<_DAB_SCHEDULE_BY_MONTHLY_DAY_OF_WEEK *>,_DAB_SCHEDULE_BY_MONTHLY_DAY_OF_WEEK>(__int64 *a1, _DWORD *a2);
void __fastcall std::vector<unsigned char>::_Insert<unsigned char *>(__int64 a1, _BYTE *a2, _BYTE *a3, _BYTE *a4);
__int64 __fastcall std::_Rotate<unsigned char *,__int64,unsigned char>(_BYTE *a1, _BYTE *a2, _BYTE *a3);
_BYTE *__fastcall std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char>>>,unsigned char *,std::allocator<unsigned char>>(_BYTE *a1, _BYTE *a2, _BYTE *a3);
_QWORD *__fastcall std::vector<unsigned char>::vector<unsigned char>(_QWORD *a1, __int64 a2);
void __fastcall UbpmParams::_unnamed_type_m_actionAccountInfo_::~_unnamed_type_m_actionAccountInfo_(UbpmParams::_unnamed_type_m_actionAccountInfo_ *this); // idb
void __fastcall tsched::DeleteMe<_DAB_SCHEDULE_BY_MONTHLY_DAY_OF_WEEK>::~DeleteMe<_DAB_SCHEDULE_BY_MONTHLY_DAY_OF_WEEK>(__int64 a1);
void ***__fastcall tsched::DeleteMe<wmi::AutoVectorPtr<_DAB_SID_INFO *>>::~DeleteMe<wmi::AutoVectorPtr<_DAB_SID_INFO *>>(__int64 a1);
void **__fastcall tsched::DeleteMe<std::vector<unsigned char>>::~DeleteMe<std::vector<unsigned char>>(void ***a1);
void __fastcall std::list<wmi::AutoVectorPtr<_SID_AND_ATTRIBUTES> *,std::allocator<wmi::AutoVectorPtr<_SID_AND_ATTRIBUTES> *>>::~list<wmi::AutoVectorPtr<_SID_AND_ATTRIBUTES> *,std::allocator<wmi::AutoVectorPtr<_SID_AND_ATTRIBUTES> *>>(void **a1);
void __fastcall tsched::FreeSidGuard::~FreeSidGuard(void ***this);
void **__fastcall wmi::AutoVectorPtr<_SID_AND_ATTRIBUTES>::`scalar deleting destructor'(void **lpMem);
void *__fastcall std::vector<unsigned char>::`scalar deleting destructor'(void *lpMem);
struct _SID_AND_ATTRIBUTES *__fastcall UbpmParams::CreateHostedCapabilitiesSidArray(UbpmParams *this, const struct JobMoniker *a2); // idb
__int64 __fastcall UbpmParams::CreateHostedPackageSid(UbpmParams *this, const struct JobMoniker *a2);
__int64 __fastcall UbpmParams::CreateHostedSid(UbpmParams *this, _BYTE *a2);
__int64 __fastcall UbpmParams::CreateHostedSidFromCapabilityName(UbpmParams *this, const unsigned __int16 *a2);
char *__fastcall UbpmParams::CreateHostedSidInfoArray(UbpmParams *this, void *const **a2);
const unsigned __int16 *__fastcall UbpmParams::GetPath(JobMoniker **this);
char **__fastcall std::vector<unsigned char>::erase(_QWORD *a1, char **a2, char *a3, char *a4);
__int64 __fastcall std::vector<void *>::push_back(__int64 *a1, __int64 *a2);
char **__fastcall std::vector<unsigned char>::resize(char **a1);
__int64 __fastcall WPP_SF_SSSD(__int64 a1, unsigned __int16 a2, __int64 a3, const wchar_t *a4, __int64 a5, __int64 a6);
__int64 __fastcall WPP_SF__guid_SSD(__int64 a1, unsigned __int16 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
ULONG __fastcall _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapSz<char>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>>(__int64 a1, unsigned __int8 *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, const unsigned __int16 **a9, __int64 a10, __int64 a11, __int64 a12, __int64 a13);
DWORD __fastcall GetImageTuple(__int64 a1, CHAR *a2, __int64 a3, _DWORD *a4, _DWORD *a5);
void MicrosoftTelemetryAssertTriggeredNoArgs();
void __fastcall MicrosoftTelemetryAssertTriggeredWorker(unsigned __int64 a1);
void tlgDefineProvider_annotation__Tlgmtaum_hTelemetryAssertDiagTrackProv();
char *__fastcall _bstr_t::Data_t::GetString(_bstr_t::Data_t *this);
void __fastcall __noreturn tsched::KnownExceptionToHResult(tsched *this, char *a2, __int64 a3, char *a4);
__int64 __fastcall tsched::SetJobFileSecurityByName(wchar_t *String2, const unsigned __int16 *a2, const WCHAR *a3, const unsigned __int16 *a4);
__int64 WPP_SF_qDqqqqD(__int64 a1, __int64 a2, __int64 a3, ...);
ATL::CAtlStringMgr *__fastcall ATL::CAtlStringMgr::`scalar deleting destructor'(ATL::CAtlStringMgr *this, char a2);
ATL::CWin32Heap *__fastcall ATL::CWin32Heap::`vector deleting destructor'(ATL::CWin32Heap *this, char a2);
SIZE_T __fastcall ATL::CWin32Heap::GetSize(HANDLE *this, void *a2);
struct ATL::CStringData *__fastcall ATL::CAtlStringMgr::Reallocate(ATL::CAtlStringMgr *this, struct ATL::CStringData *a2, int a3, unsigned int a4);
LPVOID __fastcall ATL::CWin32Heap::Reallocate(HANDLE *this, void *a2, SIZE_T a3);
void __fastcall __noreturn _com_issue_error(int a1); // idb
char *__fastcall _com_util::ConvertBSTRToString(LPCWCH lpWideCharStr); // idb
_com_error *__fastcall _com_error::_com_error(_com_error *this, const struct _com_error *a2); // idb
void __fastcall _com_error::~_com_error(_com_error *this); // idb
_com_error *__fastcall _com_error::`scalar deleting destructor'(_com_error *this, char a2);
__int64 __fastcall TaskXmlWriter::ElementLogonType(__int64 a1, int a2, int a3);
__int64 __fastcall TaskXmlWriter::ElementLogonType(__int64 a1, __int64 a2, int a3);
__int64 __fastcall TaskXmlWriter::ElementProcessTokenSidType(__int64 a1, int a2, int a3);
__int64 __fastcall TaskXmlWriter::ElementWithAttribute(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall TaskXmlWriter::SectionDaysOfMonth(TaskXmlWriter *this, int a2);
__int64 __fastcall TaskXmlWriter::SectionDaysOfWeek(TaskXmlWriter *this, unsigned __int16 a2);
__int64 __fastcall TaskXmlWriter::SectionMonths(TaskXmlWriter *this, unsigned __int16 a2);
__int64 __fastcall TaskXmlWriter::SectionWeeks(TaskXmlWriter *this, int a2);
__int64 __fastcall TaskXmlWriter::WriteStringValue(TaskXmlWriter *this, const unsigned __int16 *a2); // idb
__int64 __fastcall _Seek__QIStream__StringReader__EEAAJT_LARGE_INTEGER__KPEAT_ULARGE_INTEGER___Z(__int64 a1, __int64 a2, int a3, _QWORD *a4);
void __fastcall ITaskXmlHandler::Data::~Data(void **this);
void __fastcall tsched::LibLock::~LibLock(HMODULE *this);
__int64 __fastcall TaskXmlReader::LoadDayOfMonth(TaskXmlReader *this, unsigned __int16 *a2); // idb
__int64 __fastcall TaskXmlReader::LoadPrivilege(const WCHAR **this, unsigned __int64 *a2);
__int64 __fastcall TaskXmlReader::LoadProcessTokenSidType(TaskXmlReader *this, enum JobFlags::JobFlag *a2); // idb
__int64 __fastcall TaskXmlReader::LoadWeek(TaskXmlReader *this, unsigned __int16 *a2); // idb
__int64 __fastcall TaskXmlReader::SetErrorInfo(TaskXmlReader *this, int a2, char *a3, unsigned int a4, unsigned __int16 *a5, unsigned int a6);
__int64 __fastcall TaskXmlReader::SetErrorInfo(int *a1, int a2, int a3);
__int64 __fastcall TaskXmlReader::SetErrorInfo(int *a1, int a2, int a3, __int64 a4);
__int64 __fastcall TaskXmlReader::SetErrorInfoXmlLite(TaskXmlReader *this, int a2); // idb
__int64 __fastcall TaskXmlReader::SkipElement(TaskXmlReader *this); // idb
__int64 __fastcall XmlParserTempString::Trim(XmlParserTempString *this); // idb
__int64 __fastcall XmlParserTempString::TrimRight(XmlParserTempString *this); // idb
__int64 __fastcall IsNetworkAvailable(struct _GUID *a1); // idb
__int64 IsNetworkAvailable();
bool IsNetworkServiceRunning();
signed int __fastcall MarshalCredential(__int64 a1, LPWSTR *a2);
void __fastcall ComHandlerTask::Grip::~Grip(ComHandlerTask::Grip *this); // idb
ComHandlerTask::Grip *__fastcall ComHandlerTask::Grip::`vector deleting destructor'(ComHandlerTask::Grip *this, char a2);
struct ComHandlerGrip *__fastcall ComHandlerTask::CreateNewGrip(ComHandlerTask *this); // idb
__int64 __fastcall ComHandlerTask::Grip::Init(ComHandlerTask::Grip *this, void **a2); // idb
__int64 __fastcall ComHandlerTask::Grip::Stop(HANDLE *this);
__int64 __fastcall ComHandlerTask::Grip::TaskCompleted(ComHandlerTask::Grip *this);
ComHandlerBase *__fastcall ComHandlerBase::`vector deleting destructor'(ComHandlerBase *this, char a2);
__int64 __fastcall ServerXMLUpdateHandler::EnableHandler::EndElement(__int64 a1, const struct Schema *a2, int a3);
__int64 __fastcall ServerXMLUpdateHandler::NetworkId2Name(ServerXMLUpdateHandler *this, const struct _GUID *a2, _bstr_t::Data_t **a3);
__int64 __fastcall ServerXMLUpdateHandler::NetworkName2Id(ServerXMLUpdateHandler *this, const wchar_t ***a2, struct _GUID *a3);
__int64 __fastcall ServerXMLUpdateHandler::EnableHandler::Process(__int64 a1, const struct Schema *a2, int a3);
void __fastcall ServerXMLUpdateHandler::WriteContext(__int64 a1, int *a2, int a3, __int64 a4);
void __fastcall ServerXMLUpdateHandler::WriteEnabled(ServerXMLUpdateHandler *this, const struct Schema *a2); // idb
void __fastcall ServerXMLUpdateHandler::WriteEnabledAndSettings(ServerXMLUpdateHandler *this, const struct Schema *a2); // idb
void __fastcall ServerXMLUpdateHandler::WriteNetworkSettings(ServerXMLUpdateHandler *this, const struct Schema *a2, const struct _GUID *a3, __int64 **a4);
void __fastcall ServerXMLUpdateHandler::WritePrincipals(ServerXMLUpdateHandler *this, const struct Schema *a2, const unsigned __int16 *a3, const unsigned __int16 *a4, int a5);
void __fastcall ServerXMLUpdateHandler::WritedRegistraionInfoAndOverrides(ServerXMLUpdateHandler *this, const struct Schema *a2); // idb
__int64 __fastcall JobSecurity::Assign(void **this, void *a2);
int __fastcall JobSecurity::StreamOut(JobSecurity *this, HKEY a2);
int __fastcall JobSecurity::Update(PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor, PSECURITY_DESCRIPTOR ModificationDescriptor, HANDLE Token);
__int64 __fastcall TriggersXmlHandler::CheckEventSubscription(TriggersXmlHandler *this, const unsigned __int16 *a2);
// __int64 __fastcall UbpmAcquireJobBackgroundMode(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall UbpmTriggerConsumerSetDisabledForUser(_QWORD, _QWORD, _QWORD); weak
// __int64 UbpmTerminate(void); weak
// __int64 __fastcall UbpmTriggerConsumerConfigure(_QWORD, _QWORD); weak
// __int64 __fastcall UbpmInitialize(_QWORD); weak
// __int64 __fastcall UbpmSessionStateChanged(_QWORD, _QWORD, _QWORD); weak
// __int64 UbpmReleaseJobBackgroundMode(void); weak
// __int64 __fastcall UbpmTriggerConsumerQueryStatus(_QWORD, _QWORD); weak
// __int64 __fastcall UbpmCloseTriggerConsumer(_QWORD, _QWORD); weak
// __int64 UbpmApiBufferFree(void); weak
// __int64 __fastcall UbpmTriggerConsumerControl(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall UbpmOpenTriggerConsumer(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall UbpmTriggerConsumerSetStatePublishingSecurity(_QWORD, _QWORD); weak
// __int64 __fastcall UbpmTriggerConsumerRegister(_QWORD, _QWORD); weak
// __int64 __fastcall UbpmTriggerConsumerUnregister(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD); weak
// __int64 __fastcall UbpmTriggerConsumerControlNotifications(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall ResolveDelayLoadedAPI(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD); weak
// __int64 __fastcall PcwCreateQuery(_QWORD, _QWORD); weak
// __int64 __fastcall PcwAddQueryItem(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _QWORD); weak
// __int64 __fastcall PcwCollectData(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall RegisterWaitForSingleObjectEx(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD); weak
// __int64 __fastcall EventSetInformation(_QWORD, _QWORD, _QWORD, _QWORD); weak
// void type_info::~type_info(type_info *__hidden this); weak
// __int64 __fastcall rand_s(_QWORD); weak
// __int64 __fastcall RtlPublishWnfStateData(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall RtlDeriveCapabilitySidsFromName(_QWORD, _QWORD, _QWORD); weak
// __int64 RtlGetCurrentServiceSessionId(void); weak
// __int64 __fastcall RtlSidDominates(_QWORD, _QWORD, _QWORD); weak
// __int64 RtlUnsubscribeWnfNotificationWaitForCompletion(void); weak
// __int64 __fastcall RtlReleaseSRWLockShared(_QWORD); weak
// __int64 __fastcall RtlAcquireSRWLockShared(_QWORD); weak
// __int64 __fastcall RtlAcquireSRWLockExclusive(_QWORD); weak
// __int64 __fastcall RtlReleaseSRWLockExclusive(_QWORD); weak
// __int64 __fastcall RtlSubscribeWnfStateChangeNotification(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD); weak
// __int64 __fastcall RtlInitializeSRWLock(_QWORD); weak
// __int64 __fastcall EtwEventEnabled(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall EtwEventActivityIdControl(_QWORD, _QWORD); weak
// __int64 __fastcall NtQueryWnfStateNameInformation(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD); weak
// __int64 __fastcall EtwEventRegister(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall EtwEventWrite(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 EtwEventUnregister(void); weak
// __int64 RtlIsStateSeparationEnabled(void); weak
// __int64 EtwUnregisterTraceGuids(void); weak
// __int64 __fastcall EtwRegisterTraceGuidsW(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall EtwGetTraceEnableFlags(_QWORD); weak
// __int64 __fastcall EtwGetTraceEnableLevel(_QWORD); weak
// __int64 __fastcall EtwGetTraceLoggerHandle(_QWORD); weak
// __int64 __fastcall EtwTraceMessage(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 AuthziFreeAuditEventType(void); weak
// __int64 __fastcall AuthziInitializeAuditEvent(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall AuthziInitializeAuditParams(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD, _QWORD, _DWORD, _QWORD, _DWORD, _QWORD, _DWORD, _QWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _QWORD); weak
// __int64 __fastcall AuthziLogAuditEvent(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall AuthziInitializeAuditEventType(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall LogonUserExExW(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall DeriveAppContainerSidFromAppContainerName(_QWORD, _QWORD); weak
// __int64 WmiCloseBlock(void); weak
// __int64 __fastcall WmiOpenBlock(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall WmiQueryAllDataW(_QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall GetServiceRegistryStateKey(_QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 UnsubscribeServiceChangeNotifications(void); weak
// __int64 __fastcall SubscribeServiceChangeNotifications(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// __int64 __fastcall UMgrQueryUserContext(_QWORD, _QWORD); weak

//-------------------------------------------------------------------------
// Data declarations

WCHAR _ImageBase = 23117u; // idb
__int16 word_180000008 = 4; // weak
__int16 word_180000018 = 64; // weak
int *__ptr32 off_18000003C = (int *__ptr32)0x100; // weak
char byte_180000040[192] =
{
  '\x0E',
  '\x1F',
  '\xBA',
  '\x0E',
  '\0',
  '\xB4',
  '\t',
  '\xCD',
  '!',
  '\xB8',
  '\x01',
  'L',
  '\xCD',
  '!',
  'T',
  'h',
  'i',
  's',
  ' ',
  'p',
  'r',
  'o',
  'g',
  'r',
  'a',
  'm',
  ' ',
  'c',
  'a',
  'n',
  'n',
  'o',
  't',
  ' ',
  'b',
  'e',
  ' ',
  'r',
  'u',
  'n',
  ' ',
  'i',
  'n',
  ' ',
  'D',
  'O',
  'S',
  ' ',
  'm',
  'o',
  'd',
  'e',
  '.',
  '\r',
  '\r',
  '\n',
  '$',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\xF1',
  'I',
  'x',
  '\xFF',
  '\xB5',
  '(',
  '\x16',
  '\xAC',
  '\xB5',
  '(',
  '\x16',
  '\xAC',
  '\xB5',
  '(',
  '\x16',
  '\xAC',
  '\xBC',
  'P',
  '\x85',
  '\xAC',
  '\xE7',
  '(',
  '\x16',
  '\xAC',
  '\xA1',
  'C',
  '\x15',
  '\xAD',
  '\xB6',
  '(',
  '\x16',
  '\xAC',
  '\xA1',
  'C',
  '\x12',
  '\xAD',
  '\xA0',
  '(',
  '\x16',
  '\xAC',
  '\xB5',
  '(',
  '\x17',
  '\xAC',
  'v',
  ')',
  '\x16',
  '\xAC',
  '\xA1',
  'C',
  '\x17',
  '\xAD',
  '\xB0',
  '(',
  '\x16',
  '\xAC',
  '\xA1',
  'C',
  '\x13',
  '\xAD',
  '\xBD',
  '(',
  '\x16',
  '\xAC',
  '\xA1',
  'C',
  '\x16',
  '\xAD',
  '\xB4',
  '(',
  '\x16',
  '\xAC',
  '\xA1',
  'C',
  '\x1B',
  '\xAD',
  '\xF8',
  '(',
  '\x16',
  '\xAC',
  '\xA1',
  'C',
  '\xE9',
  '\xAC',
  '\xB4',
  '(',
  '\x16',
  '\xAC',
  '\xA1',
  'C',
  '\x14',
  '\xAD',
  '\xB4',
  '(',
  '\x16',
  '\xAC',
  'R',
  'i',
  'c',
  'h',
  '\xB5',
  '(',
  '\x16',
  '\xAC',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
void *Triggers::BootTrigger::`vftable' = &Triggers::IdleTrigger::`vector deleting destructor'; // weak
void *ExeTask::`vftable' = &ExeTask::`scalar deleting destructor'; // weak
void *Triggers::SessionChangeTrigger::`vftable' = &Triggers::SessionChangeTrigger::`vector deleting destructor'; // weak
void *Triggers::LogonTrigger::`vftable' = &Triggers::SessionChangeTrigger::`vector deleting destructor'; // weak
void *Triggers::SessionBasedTrigger::`vftable' = &Triggers::SessionChangeTrigger::`vector deleting destructor'; // weak
void *RunListItem::`vftable' = &CDLink::`vector deleting destructor'; // weak
_UNKNOWN unk_180070230; // weak
_UNKNOWN unk_180070290; // weak
const UUID Uuid2 = { 2261997897u, 33737u, 16452u, { 180u, 36u, 219u, 54u, 50u, 49u, 253u, 12u } }; // idb
_UNKNOWN unk_1800702F0; // weak
void *ATL::CDacl::CAccessAce::`vftable' = &ATL::CDacl::CAccessAce::`vector deleting destructor'; // weak
void *ATL::CAcl::CAce::`vftable' = &ATL::CAcl::CAce::`scalar deleting destructor'; // weak
void *ATL::CSid::`vftable' = &ATL::CSid::`scalar deleting destructor'; // weak
void *ATL::CAcl::`vftable' = &ATL::CAcl::`vector deleting destructor'; // weak
void *ATL::CDacl::`vftable' = &ATL::CDacl::`vector deleting destructor'; // weak
void *HashCompute::`vftable' = &HashCompute::`vector deleting destructor'; // weak
void *PseudoEventTrap::`vftable' = &PseudoEventTrap::JobEnded; // weak
void *EventTrapMap::`vftable' = &_Register__QEventTriggerRegistrar__EventTrapMap__UEAAJAEBVJobMoniker__PEAUEventTrigger_Triggers___Z; // weak
void *SortedRunListItem::`vftable' = &SortedRunListItem::`vector deleting destructor'; // weak
void *ScheduleListItem::`vftable' = &ScheduleListItem::`scalar deleting destructor'; // weak
void *Scheduler::`vftable' = &Scheduler::JobEnded; // weak
void *std::error_category::`vftable' = &std::_Iostream_error_category::`scalar deleting destructor'; // weak
void *JobsService::`vftable' = &CNtService::Run; // weak
void *CNtService::`vftable' = &CNtService::Run; // weak
void *IndexEnumerator::`vftable' = &IndexEnumerator::`vector deleting destructor'; // weak
void *Triggers::MaintenanceTrigger::`vftable' = &Triggers::IdleTrigger::`vector deleting destructor'; // weak
void *ServerXMLUpdateHandler::NetworkInputHandler::`vftable' = &ServerXMLUpdateHandler::NetworkInputHandler::Process; // weak
void *ServerXMLUpdateHandler::PrincipalHandler::`vftable' = &ServerXMLUpdateHandler::PrincipalHandler::Process; // weak
void *ServerXMLUpdateHandler::`vftable' = &_ProcessElement__QITaskXmlHandler__ServerXMLUpdateHandler__UEAAJAEBUSchema__W4TaskXmlNodeId___Z; // weak
void *StringReader::`vftable' = &StringStream::QueryInterface; // weak
void *TriggersXmlHandler::`vftable' = &_ProcessElement__QITaskXmlHandler__TriggersXmlHandler__MEAAJAEBUSchema__W4TaskXmlNodeId___Z; // weak
void *ValidationXmlHandler::`vftable' = &_ProcessElement__QITaskXmlHandler__ValidationXmlHandler__MEAAJAEBUSchema__W4TaskXmlNodeId___Z; // weak
void *FolderEnumerator::`vftable' = &FolderEnumerator::`vector deleting destructor'; // weak
void *Triggers::ImmediateTrigger::`vftable' = &Triggers::IdleTrigger::`vector deleting destructor'; // weak
void *UbpmParams::`vftable' = &UbpmParams::GetPath; // weak
void *ComHandlerTask::`vftable' = &ComHandlerTask::`vector deleting destructor'; // weak
void *ComHandlerBase::`vftable' = &ComHandlerBase::`vector deleting destructor'; // weak
void *Task::`vftable' = &Task::`scalar deleting destructor'; // weak
void *CBstrWriter::`vftable' = &StringStream::QueryInterface; // weak
void *JobBucket::`vftable' = &JobBucket::`vector deleting destructor'; // weak
void *wmi::RefBase::`vftable' = &wmi::RefBase::`vector deleting destructor'; // weak
void *Triggers::Trigger::`vftable' = &Triggers::Trigger::`vector deleting destructor'; // weak
void *Triggers::WnfStateChangeTrigger::`vftable' = &Triggers::WnfStateChangeTrigger::`vector deleting destructor'; // weak
void *Triggers::TimeTrigger::`vftable' = &Triggers::TimeTrigger::`vector deleting destructor'; // weak
void *Triggers::GenericTrigger::`vftable' = &Triggers::IdleTrigger::`vector deleting destructor'; // weak
void *TaskXmlReader::`vftable' = &TaskXmlReader::`vector deleting destructor'; // weak
void *Triggers::EventTrigger::`vftable' = &Triggers::EventTrigger::`scalar deleting destructor'; // weak
void *Triggers::IdleTrigger::`vftable' = &Triggers::IdleTrigger::`vector deleting destructor'; // weak
void *Triggers::RegistrationTrigger::`vftable' = &Triggers::IdleTrigger::`vector deleting destructor'; // weak
void *std::bad_alloc::`vftable' = &std::bad_alloc::`vector deleting destructor'; // weak
void *std::length_error::`vftable' = &std::length_error::`scalar deleting destructor'; // weak
_UNKNOWN unk_180070D00; // weak
_UNKNOWN unk_1800711B0; // weak
void *wmi::GenericException::`vftable' = &wmi::GenericException::GetErrorCode; // weak
void *wistd::__function::__func<_lambda_8db0ce862824541f40dfb767113f1e28_,bool (void *,unsigned __int64,void *,unsigned __int64,unsigned int)>::`vftable' = &wistd::__function::__func<_lambda_8db0ce862824541f40dfb767113f1e28_,bool (void *,unsigned __int64,void *,unsigned __int64,unsigned int)>::`vector deleting destructor'; // weak
void *ATL::CSecurityDesc::`vftable' = &ATL::CSecurityDesc::`scalar deleting destructor'; // weak
void *wistd::__function::__base<bool (void *,unsigned __int64,void *,unsigned __int64,unsigned int)>::`vftable' = &wistd::__function::__func<_lambda_8db0ce862824541f40dfb767113f1e28_,bool (void *,unsigned __int64,void *,unsigned __int64,unsigned int)>::`vector deleting destructor'; // weak
void *ATL::CAtlStringMgr::`vftable' = &ATL::CAtlStringMgr::Allocate; // weak
void *ATL::CWin32Heap::`vftable' = &ATL::CWin32Heap::Allocate; // weak
void *_com_error::`vftable' = &_com_error::`scalar deleting destructor'; // weak
void *ComHandlerTask::Grip::`vftable' = &ComHandlerTask::Grip::`vector deleting destructor'; // weak
const struct SchemaEntry * near *Schema::schemaEntries = &_guard_xfg_check_icall_fptr; // weak
wchar_t *off_1800728D0 = L"SeCreateTokenPrivilege"; // weak
_UNKNOWN unk_1800728D8; // weak
void *ServerXMLUpdateHandler::ISubHandler::`vftable' = &purecall_0; // weak
void *ServerXMLUpdateHandler::NetworkOutputHandler::`vftable' = &ServerXMLUpdateHandler::NetworkOutputHandler::Process; // weak
void *ServerXMLUpdateHandler::WriterHandler::`vftable' = &ServerXMLUpdateHandler::WriterHandler::Process; // weak
void *ServerXMLUpdateHandler::RegistrationInfoHandler::`vftable' = &ServerXMLUpdateHandler::RegistrationInfoHandler::Process; // weak
void *ServerXMLUpdateHandler::EnableHandler::`vftable' = &ServerXMLUpdateHandler::EnableHandler::Process; // weak
void *ServerXMLUpdateHandler::ContextHandler::`vftable' = &ServerXMLUpdateHandler::ContextHandler::Process; // weak
void *wmi::OutOfMemoryException::`vftable' = &wmi::GenericException::GetErrorCode; // weak
void *EmailTask::`vftable' = &EmailTask::`vector deleting destructor'; // weak
void *ATL::CDacl::CAccessObjectAce::`vftable' = &ATL::CDacl::CAccessObjectAce::`vector deleting destructor'; // weak
void *wil::ResultException::`vftable' = &wil::ResultException::`scalar deleting destructor'; // weak
void *MessageBoxTask::`vftable' = &MessageBoxTask::`scalar deleting destructor'; // weak
wchar_t *const Schema::namespaceUri = L"http://schemas.microsoft.com/windows/2004/02/mit/task"; // idb
_UNKNOWN unk_180073870; // weak
// extern UINT (__stdcall *SysStringLen)(BSTR pbstr);
// extern BSTR (__stdcall *SysAllocString)(const OLECHAR *psz);
// extern BSTR (__stdcall *SysAllocStringLen)(const OLECHAR *strIn, UINT ui);
// extern UINT (__stdcall *SysStringByteLen)(BSTR bstr);
// extern void (__stdcall *SysFreeString)(BSTR bstrString);
// extern HRESULT (__stdcall *VariantClear)(VARIANTARG *pvarg);
// extern BSTR (__stdcall *SysAllocStringByteLen)(LPCSTR psz, UINT len);
// extern RPC_STATUS (__stdcall *UuidToStringW)(const UUID *Uuid, RPC_WSTR *StringUuid);
// extern RPC_STATUS (__stdcall *RpcStringFreeW)(RPC_WSTR *String);
// extern RPC_STATUS (__stdcall *RpcBindingToStringBindingW)(RPC_BINDING_HANDLE Binding, RPC_WSTR *StringBinding);
// extern RPC_STATUS (__stdcall *UuidCreate)(UUID *Uuid);
// extern RPC_STATUS (__stdcall *RpcStringBindingParseW)(RPC_WSTR StringBinding, RPC_WSTR *ObjUuid, RPC_WSTR *Protseq, RPC_WSTR *NetworkAddr, RPC_WSTR *Endpoint, RPC_WSTR *NetworkOptions);
// extern RPC_STATUS (__stdcall *RpcServerRegisterIfEx)(RPC_IF_HANDLE IfSpec, UUID *MgrTypeUuid, void *MgrEpv, unsigned int Flags, unsigned int MaxCalls, RPC_IF_CALLBACK_FN *IfCallback);
// extern RPC_STATUS (__stdcall *RpcImpersonateClient)(RPC_BINDING_HANDLE BindingHandle);
// extern RPC_STATUS (__stdcall *RpcBindingVectorFree)(RPC_BINDING_VECTOR **BindingVector);
// extern RPC_STATUS (__stdcall *RpcServerUnregisterIf)(RPC_IF_HANDLE IfSpec, UUID *MgrTypeUuid, unsigned int WaitForCallsToComplete);
// extern RPC_STATUS (__stdcall *RpcServerInqDefaultPrincNameW)(unsigned int AuthnSvc, RPC_WSTR *PrincName);
// extern int (__stdcall *UuidEqual)(UUID *Uuid1, UUID *Uuid2, RPC_STATUS *Status);
// extern RPC_STATUS (__stdcall *RpcServerRegisterAuthInfoW)(RPC_WSTR ServerPrincName, unsigned int AuthnSvc, RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFn, void *Arg);
// extern RPC_STATUS (__stdcall *RpcRevertToSelf)();
// extern RPC_STATUS (__stdcall *RpcEpUnregister)(RPC_IF_HANDLE IfSpec, RPC_BINDING_VECTOR *BindingVector, UUID_VECTOR *UuidVector);
// extern RPC_STATUS (__stdcall *RpcEpRegisterW)(RPC_IF_HANDLE IfSpec, RPC_BINDING_VECTOR *BindingVector, UUID_VECTOR *UuidVector, RPC_WSTR Annotation);
// extern RPC_STATUS (__stdcall *RpcServerInqBindings)(RPC_BINDING_VECTOR **BindingVector);
// extern RPC_STATUS (__stdcall *RpcServerUnregisterIfEx)(RPC_IF_HANDLE IfSpec, UUID *MgrTypeUuid, int RundownContextHandles);
// extern RPC_STATUS (__stdcall *RpcServerUseProtseqW)(RPC_WSTR Protseq, unsigned int MaxCalls, void *SecurityDescriptor);
// extern RPC_STATUS (__stdcall *RpcServerInqCallAttributesW)(RPC_BINDING_HANDLE ClientBinding, void *RpcCallAttributes);
// extern void (__stdcall *OutputDebugStringW)(LPCWSTR lpOutputString);
// extern BOOL (__stdcall *IsDebuggerPresent)();
// extern _UNKNOWN DelayLoadFailureHook; weak
// extern void (__stdcall *SetLastError)(DWORD dwErrCode);
// extern DWORD (__stdcall *GetLastError)();
// extern LONG (__stdcall *CompareFileTime)(const FILETIME *lpFileTime1, const FILETIME *lpFileTime2);
// extern BOOL (__stdcall *ReadFile)(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// extern HANDLE (__stdcall *FindFirstFileW)(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);
// extern BOOL (__stdcall *FindNextFileW)(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData);
// extern BOOL (__stdcall *WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// extern BOOL (__stdcall *RemoveDirectoryW)(LPCWSTR lpPathName);
// extern BOOL (__stdcall *SetEndOfFile)(HANDLE hFile);
// extern DWORD (__stdcall *GetFinalPathNameByHandleW)(HANDLE hFile, LPWSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags);
// extern HANDLE (__stdcall *CreateFileW)(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern BOOL (__stdcall *GetFileAttributesExW)(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation);
// extern BOOL (__stdcall *SetFileInformationByHandle)(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize);
// extern BOOL (__stdcall *DeleteFileW)(LPCWSTR lpFileName);
// extern BOOL (__stdcall *FlushFileBuffers)(HANDLE hFile);
// extern BOOL (__stdcall *GetFileSizeEx)(HANDLE hFile, PLARGE_INTEGER lpFileSize);
// extern BOOL (__stdcall *FileTimeToLocalFileTime)(const FILETIME *lpFileTime, LPFILETIME lpLocalFileTime);
// extern DWORD (__stdcall *GetFileAttributesW)(LPCWSTR lpFileName);
// extern BOOL (__stdcall *LocalFileTimeToFileTime)(const FILETIME *lpLocalFileTime, LPFILETIME lpFileTime);
// extern BOOL (__stdcall *CreateDirectoryW)(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
// extern BOOL (__stdcall *GetFileInformationByHandle)(HANDLE hFile, LPBY_HANDLE_FILE_INFORMATION lpFileInformation);
// extern BOOL (__stdcall *FindClose)(HANDLE hFindFile);
// extern BOOL (__stdcall *CopyFileW)(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern BOOL (__stdcall *DuplicateHandle)(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions);
// extern BOOL (__stdcall *HeapSetInformation)(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength);
// extern HANDLE (__stdcall *GetProcessHeap)();
// extern SIZE_T (__stdcall *HeapSize)(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem);
// extern LPVOID (__stdcall *HeapReAlloc)(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes);
// extern BOOL (__stdcall *HeapFree)(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// extern BOOL (__stdcall *HeapDestroy)(HANDLE hHeap);
// extern LPVOID (__stdcall *HeapAlloc)(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// extern HANDLE (__stdcall *HeapCreate)(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize);
// extern HLOCAL (__stdcall *LocalFree)(HLOCAL hMem);
// extern HLOCAL (__stdcall *LocalAlloc)(UINT uFlags, SIZE_T uBytes);
// extern BOOL (__stdcall *GetComputerNameW)(LPWSTR lpBuffer, LPDWORD nSize);
// extern BOOL (__stdcall *DisableThreadLibraryCalls)(HMODULE hLibModule);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern BOOL (__stdcall *GetModuleHandleExW)(DWORD dwFlags, LPCWSTR lpModuleName, HMODULE *phModule);
// extern HMODULE (__stdcall *GetModuleHandleW)(LPCWSTR lpModuleName);
// extern BOOL (__stdcall *FreeLibrary)(HMODULE hLibModule);
// extern HMODULE (__stdcall *LoadLibraryExW)(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
// extern DWORD (__stdcall *GetModuleFileNameA)(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// extern int (__stdcall *LoadStringW)(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int cchBufferMax);
// extern DWORD (__stdcall *FormatMessageW)(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, va_list *Arguments);
// extern BOOL (__stdcall *SetThreadPreferredUILanguages)(DWORD dwFlags, PCZZWSTR pwszLanguagesBuffer, PULONG pulNumLanguages);
// extern BOOL (__stdcall *GetThreadPreferredUILanguages)(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer);
// extern DWORD (__stdcall *ExpandEnvironmentStringsW)(LPCWSTR lpSrc, LPWSTR lpDst, DWORD nSize);
// extern DWORD (__stdcall *SearchPathW)(LPCWSTR lpPath, LPCWSTR lpFileName, LPCWSTR lpExtension, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart);
// extern BOOL (__stdcall *OpenThreadToken)(HANDLE ThreadHandle, DWORD DesiredAccess, BOOL OpenAsSelf, PHANDLE TokenHandle);
// extern HANDLE (__stdcall *GetCurrentThread)();
// extern DWORD (__stdcall *GetCurrentProcessId)();
// extern DWORD (__stdcall *GetCurrentThreadId)();
// extern HANDLE (__stdcall *GetCurrentProcess)();
// extern BOOL (__stdcall *OpenProcessToken)(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle);
// extern HANDLE (__stdcall *OpenProcess)(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);
// extern BOOL (__stdcall *QueryPerformanceCounter)(LARGE_INTEGER *lpPerformanceCount);
// extern BOOL (__stdcall *QueryFullProcessImageNameW)(HANDLE hProcess, DWORD dwFlags, LPWSTR lpExeName, PDWORD lpdwSize);
// extern LSTATUS (__stdcall *RegNotifyChangeKeyValue)(HKEY hKey, BOOL bWatchSubtree, DWORD dwNotifyFilter, HANDLE hEvent, BOOL fAsynchronous);
// extern LSTATUS (__stdcall *RegDeleteKeyExW)(HKEY hKey, LPCWSTR lpSubKey, REGSAM samDesired, DWORD Reserved);
// extern LSTATUS (__stdcall *RegSetValueExW)(HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData);
// extern LSTATUS (__stdcall *RegGetValueW)(HKEY hkey, LPCWSTR lpSubKey, LPCWSTR lpValue, DWORD dwFlags, LPDWORD pdwType, PVOID pvData, LPDWORD pcbData);
// extern LSTATUS (__stdcall *RegDeleteValueW)(HKEY hKey, LPCWSTR lpValueName);
// extern LSTATUS (__stdcall *RegQueryInfoKeyW)(HKEY hKey, LPWSTR lpClass, LPDWORD lpcchClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime);
// extern LSTATUS (__stdcall *RegOpenKeyExW)(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
// extern LSTATUS (__stdcall *RegFlushKey)(HKEY hKey);
// extern LSTATUS (__stdcall *RegEnumKeyExW)(HKEY hKey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcchName, LPDWORD lpReserved, LPWSTR lpClass, LPDWORD lpcchClass, PFILETIME lpftLastWriteTime);
// extern LSTATUS (__stdcall *RegQueryValueExW)(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// extern LSTATUS (__stdcall *RegCreateKeyExW)(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
// extern LSTATUS (__stdcall *RegCloseKey)(HKEY hKey);
// extern LSTATUS (__stdcall *RegDeleteTreeW)(HKEY hKey, LPCWSTR lpSubKey);
// extern SIZE_T (__stdcall *RtlCompareMemory)(const void *Source1, const void *Source2, SIZE_T Length);
// extern LPWSTR (__stdcall *PathAddBackslashW)(LPWSTR pszPath);
// extern BOOL (__stdcall *PathIsPrefixW)(LPCWSTR pszPrefix, LPCWSTR pszPath);
// extern LPWSTR (__stdcall *PathSkipRootW)(LPCWSTR pszPath);
// extern BOOL (__stdcall *PathFileExistsW)(LPCWSTR pszPath);
// extern int (__stdcall *WideCharToMultiByte)(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar);
// extern int (__stdcall *MultiByteToWideChar)(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// extern int (__stdcall *lstrlenA)(LPCSTR lpString);
// extern BOOL (__stdcall *ReleaseSemaphore)(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount);
// extern HANDLE (__stdcall *OpenSemaphoreW)(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName);
// extern BOOL (__stdcall *InitializeCriticalSectionEx)(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount, DWORD Flags);
// extern void (__stdcall *ReleaseSRWLockShared)(PSRWLOCK SRWLock);
// extern void (__stdcall *ReleaseSRWLockExclusive)(PSRWLOCK SRWLock);
// extern void (__stdcall *EnterCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern HANDLE (__stdcall *CreateSemaphoreExW)(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess);
// extern BOOL (__stdcall *SetWaitableTimerEx)(HANDLE hTimer, const LARGE_INTEGER *lpDueTime, LONG lPeriod, PTIMERAPCROUTINE pfnCompletionRoutine, LPVOID lpArgToCompletionRoutine, PREASON_CONTEXT WakeContext, ULONG TolerableDelay);
// extern HANDLE (__stdcall *CreateMutexExW)(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess);
// extern void (__stdcall *AcquireSRWLockShared)(PSRWLOCK SRWLock);
// extern BOOL (__stdcall *SetEvent)(HANDLE hEvent);
// extern void (__stdcall *AcquireSRWLockExclusive)(PSRWLOCK SRWLock);
// extern DWORD (__stdcall *WaitForSingleObject)(HANDLE hHandle, DWORD dwMilliseconds);
// extern HANDLE (__stdcall *OpenEventW)(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName);
// extern DWORD (__stdcall *WaitForMultipleObjectsEx)(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds, BOOL bAlertable);
// extern DWORD (__stdcall *WaitForSingleObjectEx)(HANDLE hHandle, DWORD dwMilliseconds, BOOL bAlertable);
// extern void (__stdcall *InitializeCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *LeaveCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern BOOL (__stdcall *ReleaseMutex)(HANDLE hMutex);
// extern HANDLE (__stdcall *CreateEventW)(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName);
// extern BOOL (__stdcall *ResetEvent)(HANDLE hEvent);
// extern void (__stdcall *InitializeSRWLock)(PSRWLOCK SRWLock);
// extern HANDLE (__stdcall *CreateWaitableTimerExW)(LPSECURITY_ATTRIBUTES lpTimerAttributes, LPCWSTR lpTimerName, DWORD dwFlags, DWORD dwDesiredAccess);
// extern void (__stdcall *DeleteCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern BOOL (__stdcall *SleepConditionVariableSRW)(PCONDITION_VARIABLE ConditionVariable, PSRWLOCK SRWLock, DWORD dwMilliseconds, ULONG Flags);
// extern void (__stdcall *WakeAllConditionVariable)(PCONDITION_VARIABLE ConditionVariable);
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern void (__stdcall *GetSystemTimeAsFileTime)(LPFILETIME lpSystemTimeAsFileTime);
// extern DWORD (__stdcall *GetTickCount)();
// extern BOOL (__stdcall *GetVersionExW)(LPOSVERSIONINFOW lpVersionInformation);
// extern BOOL (__stdcall *GetComputerNameExW)(COMPUTER_NAME_FORMAT NameType, LPWSTR lpBuffer, LPDWORD nSize);
// extern void (__stdcall *SetThreadpoolTimer)(PTP_TIMER pti, PFILETIME pftDueTime, DWORD msPeriod, DWORD msWindowLength);
// extern PTP_TIMER (__stdcall *CreateThreadpoolTimer)(PTP_TIMER_CALLBACK pfnti, PVOID pv, PTP_CALLBACK_ENVIRON pcbe);
// extern void (__stdcall *SubmitThreadpoolWork)(PTP_WORK pwk);
// extern void (__stdcall *CloseThreadpoolWork)(PTP_WORK pwk);
// extern PTP_CLEANUP_GROUP (__stdcall *CreateThreadpoolCleanupGroup)();
// extern PTP_WORK (__stdcall *CreateThreadpoolWork)(PTP_WORK_CALLBACK pfnwk, PVOID pv, PTP_CALLBACK_ENVIRON pcbe);
// extern void (__stdcall *WaitForThreadpoolTimerCallbacks)(PTP_TIMER pti, BOOL fCancelPendingCallbacks);
// extern void (__stdcall *CloseThreadpoolCleanupGroupMembers)(PTP_CLEANUP_GROUP ptpcg, BOOL fCancelPendingCallbacks, PVOID pvCleanupContext);
// extern void (__stdcall *CloseThreadpoolCleanupGroup)(PTP_CLEANUP_GROUP ptpcg);
// extern void (__stdcall *CloseThreadpoolTimer)(PTP_TIMER pti);
// extern BOOL (__stdcall *CreateTimerQueueTimer)(PHANDLE phNewTimer, HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, PVOID Parameter, DWORD DueTime, DWORD Period, ULONG Flags);
// extern BOOL (__stdcall *UnregisterWaitEx)(HANDLE WaitHandle, HANDLE CompletionEvent);
// extern BOOL (__stdcall *DeleteTimerQueueTimer)(HANDLE TimerQueue, HANDLE Timer, HANDLE CompletionEvent);
// extern BOOL (__stdcall *ChangeTimerQueueTimer)(HANDLE TimerQueue, HANDLE Timer, ULONG DueTime, ULONG Period);
// extern DWORD (__stdcall *GetTimeZoneInformation)(LPTIME_ZONE_INFORMATION lpTimeZoneInformation);
// extern BOOL (__stdcall *FileTimeToSystemTime)(const FILETIME *lpFileTime, LPSYSTEMTIME lpSystemTime);
// extern BOOL (__stdcall *TzSpecificLocalTimeToSystemTime)(const TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpLocalTime, LPSYSTEMTIME lpUniversalTime);
// extern BOOL (__stdcall *SystemTimeToFileTime)(const SYSTEMTIME *lpSystemTime, LPFILETIME lpFileTime);
// extern BOOL (__stdcall *SystemTimeToTzSpecificLocalTime)(const TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpUniversalTime, LPSYSTEMTIME lpLocalTime);
// extern DWORD (__stdcall *GetDynamicTimeZoneInformation)(PDYNAMIC_TIME_ZONE_INFORMATION pTimeZoneInformation);
// extern ULONG (__stdcall *EventUnregister)(REGHANDLE RegHandle);
// extern BOOLEAN (__stdcall *EventProviderEnabled)(REGHANDLE RegHandle, UCHAR Level, ULONGLONG Keyword);
// extern ULONG (__stdcall *EventWriteTransfer)(REGHANDLE RegHandle, PCEVENT_DESCRIPTOR EventDescriptor, LPCGUID ActivityId, LPCGUID RelatedActivityId, ULONG UserDataCount, PEVENT_DATA_DESCRIPTOR UserData);
// extern ULONG (__stdcall *EventRegister)(LPCGUID ProviderId, PENABLECALLBACK EnableCallback, PVOID CallbackContext, PREGHANDLE RegHandle);
// extern DWORD (__stdcall *GetLengthSid)(PSID pSid);
// extern BOOL (__stdcall *MakeSelfRelativeSD)(PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor, PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor, LPDWORD lpdwBufferLength);
// extern BOOL (__stdcall *CreateWellKnownSid)(WELL_KNOWN_SID_TYPE WellKnownSidType, PSID DomainSid, PSID pSid, DWORD *cbSid);
// extern BOOL (__stdcall *PrivilegeCheck)(HANDLE ClientToken, PPRIVILEGE_SET RequiredPrivileges, LPBOOL pfResult);
// extern BOOL (__stdcall *AccessCheck)(PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength, LPDWORD GrantedAccess, LPBOOL AccessStatus);
// extern PDWORD (__stdcall *GetSidSubAuthority)(PSID pSid, DWORD nSubAuthority);
// extern BOOL (__stdcall *GetTokenInformation)(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, DWORD TokenInformationLength, PDWORD ReturnLength);
// extern BOOL (__stdcall *GetSecurityDescriptorSacl)(PSECURITY_DESCRIPTOR pSecurityDescriptor, LPBOOL lpbSaclPresent, PACL *pSacl, LPBOOL lpbSaclDefaulted);
// extern BOOL (__stdcall *IsValidSid)(PSID pSid);
// extern BOOL (__stdcall *AllocateAndInitializeSid)(PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, BYTE nSubAuthorityCount, DWORD nSubAuthority0, DWORD nSubAuthority1, DWORD nSubAuthority2, DWORD nSubAuthority3, DWORD nSubAuthority4, DWORD nSubAuthority5, DWORD nSubAuthority6, DWORD nSubAuthority7, PSID *pSid);
// extern BOOL (__stdcall *EqualSid)(PSID pSid1, PSID pSid2);
// extern BOOL (__stdcall *AdjustTokenPrivileges)(HANDLE TokenHandle, BOOL DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, DWORD BufferLength, PTOKEN_PRIVILEGES PreviousState, PDWORD ReturnLength);
// extern BOOL (__stdcall *CopySid)(DWORD nDestinationSidLength, PSID pDestinationSid, PSID pSourceSid);
// extern BOOL (__stdcall *GetAclInformation)(PACL pAcl, LPVOID pAclInformation, DWORD nAclInformationLength, ACL_INFORMATION_CLASS dwAclInformationClass);
// extern PUCHAR (__stdcall *GetSidSubAuthorityCount)(PSID pSid);
// extern BOOL (__stdcall *GetAce)(PACL pAcl, DWORD dwAceIndex, LPVOID *pAce);
// extern BOOL (__stdcall *DuplicateToken)(HANDLE ExistingTokenHandle, SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, PHANDLE DuplicateTokenHandle);
// extern BOOL (__stdcall *GetSecurityDescriptorGroup)(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID *pGroup, LPBOOL lpbGroupDefaulted);
// extern PSID_IDENTIFIER_AUTHORITY (__stdcall *GetSidIdentifierAuthority)(PSID pSid);
// extern BOOL (__stdcall *AddAce)(PACL pAcl, DWORD dwAceRevision, DWORD dwStartingAceIndex, LPVOID pAceList, DWORD nAceListLength);
// extern PVOID (__stdcall *FreeSid)(PSID pSid);
// extern BOOL (__stdcall *CheckTokenMembership)(HANDLE TokenHandle, PSID SidToCheck, PBOOL IsMember);
// extern BOOL (__stdcall *InitializeAcl)(PACL pAcl, DWORD nAclLength, DWORD dwAclRevision);
// extern DWORD (__stdcall *GetSecurityDescriptorLength)(PSECURITY_DESCRIPTOR pSecurityDescriptor);
// extern BOOL (__stdcall *IsWellKnownSid)(PSID pSid, WELL_KNOWN_SID_TYPE WellKnownSidType);
// extern BOOL (__stdcall *GetSecurityDescriptorControl)(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSECURITY_DESCRIPTOR_CONTROL pControl, LPDWORD lpdwRevision);
// extern BOOL (__stdcall *GetSecurityDescriptorOwner)(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID *pOwner, LPBOOL lpbOwnerDefaulted);
// extern BOOL (__stdcall *GetSecurityDescriptorDacl)(PSECURITY_DESCRIPTOR pSecurityDescriptor, LPBOOL lpbDaclPresent, PACL *pDacl, LPBOOL lpbDaclDefaulted);
// extern BOOL (__stdcall *ChangeServiceConfig2W)(SC_HANDLE hService, DWORD dwInfoLevel, LPVOID lpInfo);
// extern _onexit_t (__cdecl *_onexit)(_onexit_t Func);
// extern errno_t (__cdecl *memcpy_s)(void *const Destination, const rsize_t DestinationSize, const void *const Source, const rsize_t SourceSize);
// extern int (__cdecl *_wcsicmp)(const wchar_t *String1, const wchar_t *String2);
// extern errno_t (__cdecl *_wsplitpath_s)(const wchar_t *FullPath, wchar_t *Drive, size_t DriveCount, wchar_t *Dir, size_t DirCount, wchar_t *Filename, size_t FilenameCount, wchar_t *Ext, size_t ExtCount);
// extern wchar_t *(__cdecl *wcschr)(const wchar_t *Str, wchar_t Ch);
// extern int (__cdecl *_wcsnicmp)(const wchar_t *String1, const wchar_t *String2, size_t MaxCount);
// extern wchar_t *(__cdecl *wcsrchr)(const wchar_t *Str, wchar_t Ch);
// extern errno_t (__cdecl *memmove_s)(void *const Destination, const rsize_t DestinationSize, const void *const Source, const rsize_t SourceSize);
// extern void *(__cdecl *realloc)(void *Block, size_t Size);
// extern int (__cdecl *fflush)(FILE *Stream);
// extern int (__cdecl *fclose)(FILE *Stream);
// extern int (__cdecl *fputws)(const wchar_t *Buffer, FILE *Stream);
// extern errno_t (__cdecl *fopen_s)(FILE **Stream, const char *FileName, const char *Mode);
// extern void *(__cdecl *calloc)(size_t Count, size_t Size);
// extern int (__cdecl *rand)();
// extern int (__cdecl *_vsnprintf_s)(char *const Buffer, const size_t BufferCount, const size_t MaxCount, const char *const Format, va_list ArgList);
// extern int (__cdecl *_wtoi)(const wchar_t *String);
// extern wchar_t *(__cdecl *wcsstr)(const wchar_t *Str, const wchar_t *SubStr);
// extern int (__cdecl *wcsncmp)(const wchar_t *String1, const wchar_t *String2, size_t MaxCount);
// extern errno_t (__cdecl *_ltow_s)(int Value, wchar_t *Buffer, size_t BufferCount, int Radix);
// extern int (__cdecl *toupper)(int C);
// extern void *(__cdecl *malloc)(size_t Size);
// extern unsigned __int64 (__cdecl *_wcstoui64)(const wchar_t *String, wchar_t **EndPtr, int Radix);
// extern int (__cdecl *iswdigit)(wint_t C);
// extern int (__cdecl *_wtol)(const wchar_t *String);
// extern void (__cdecl *srand)(unsigned int Seed);
// extern int (__cdecl *_vsnwprintf)(wchar_t *Buffer, size_t BufferCount, const wchar_t *Format, va_list Args);
// extern void (__cdecl *free)(void *Block);
// extern NTSTATUS (__stdcall *NtQueryInformationToken)(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, PVOID TokenInformation, ULONG TokenInformationLength, PULONG ReturnLength);
// extern PVOID (__stdcall *RtlFreeSid)(PSID Sid);
// extern NTSTATUS (__stdcall *RtlAllocateAndInitializeSid)(PSID_IDENTIFIER_AUTHORITY IdentifierAuthority, UCHAR SubAuthorityCount, ULONG SubAuthority0, ULONG SubAuthority1, ULONG SubAuthority2, ULONG SubAuthority3, ULONG SubAuthority4, ULONG SubAuthority5, ULONG SubAuthority6, ULONG SubAuthority7, PSID *Sid);
// extern NTSTATUS (__stdcall *NtPowerInformation)(POWER_INFORMATION_LEVEL PowerInformationLevel, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength);
// extern BOOLEAN (*NtIsSystemResumeAutomatic)(void);
// extern void (__stdcall *RtlInitString)(PSTRING DestinationString, PCSZ SourceString);
// extern void (__stdcall *RtlInitUnicodeString)(PUNICODE_STRING DestinationString, PCWSTR SourceString);
// extern NTSTATUS (__stdcall *RtlAdjustPrivilege)(ULONG Privilege, BOOLEAN NewValue, BOOLEAN ForThread, PBOOLEAN OldValue);
// extern ULONG (__stdcall *RtlLengthSecurityDescriptor)(PSECURITY_DESCRIPTOR SecurityDescriptor);
// extern NTSTATUS (__stdcall *NtQueryInformationProcess)(HANDLE ProcessHandle, PROCESSINFOCLASS ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength);
// extern NTSTATUS (__stdcall *RtlNewSecurityObjectEx)(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CreatorDescriptor, PSECURITY_DESCRIPTOR *NewDescriptor, LPGUID ObjectType, BOOLEAN IsDirectoryObject, ULONG AutoInheritFlags, HANDLE Token, PGENERIC_MAPPING GenericMapping);
// extern NTSTATUS (__stdcall *RtlGetControlSecurityDescriptor)(PSECURITY_DESCRIPTOR SecurityDescriptor, PSECURITY_DESCRIPTOR_CONTROL Control, PULONG Revision);
// extern NTSTATUS (__stdcall *RtlGetOwnerSecurityDescriptor)(PSECURITY_DESCRIPTOR SecurityDescriptor, PSID *Owner, PBOOLEAN OwnerDefaulted);
// extern NTSTATUS (__stdcall *RtlGetGroupSecurityDescriptor)(PSECURITY_DESCRIPTOR SecurityDescriptor, PSID *Group, PBOOLEAN GroupDefaulted);
// extern NTSTATUS (__stdcall *RtlGetDaclSecurityDescriptor)(PSECURITY_DESCRIPTOR SecurityDescriptor, PBOOLEAN DaclPresent, PACL *Dacl, PBOOLEAN DaclDefaulted);
// extern NTSTATUS (__stdcall *RtlSetSecurityObjectEx)(SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR ModificationDescriptor, PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor, ULONG AutoInheritFlags, PGENERIC_MAPPING GenericMapping, HANDLE Token);
// extern NTSTATUS (__stdcall *RtlGetAce)(PACL Acl, ULONG AceIndex, PVOID *Ace);
// extern ULONG (__stdcall *RtlLengthSid)(PSID Sid);
// extern NTSTATUS (__stdcall *RtlCreateAcl)(PACL Acl, ULONG AclSize, ULONG AclRevision);
// extern NTSTATUS (__stdcall *RtlCreateSecurityDescriptor)(PSECURITY_DESCRIPTOR SecurityDescriptor, ULONG Revision);
// extern NTSTATUS (__stdcall *RtlAddAccessAllowedAce)(PACL Acl, ULONG Revision, ACCESS_MASK AccessMask, PSID Sid);
// extern NTSTATUS (__stdcall *RtlAddAce)(PACL Acl, ULONG AceRevision, ULONG StartingAceIndex, PVOID AceList, ULONG AceListLength);
// extern NTSTATUS (__stdcall *RtlSetDaclSecurityDescriptor)(PSECURITY_DESCRIPTOR SecurityDescriptor, BOOLEAN DaclPresent, PACL Dacl, BOOLEAN DaclDefaulted);
// extern NTSTATUS (__stdcall *RtlSetOwnerSecurityDescriptor)(PSECURITY_DESCRIPTOR SecurityDescriptor, PSID Owner, BOOLEAN OwnerDefaulted);
// extern NTSTATUS (__stdcall *RtlSetGroupSecurityDescriptor)(PSECURITY_DESCRIPTOR SecurityDescriptor, PSID Group, BOOLEAN GroupDefaulted);
// extern NTSTATUS (__stdcall *RtlAbsoluteToSelfRelativeSD)(PSECURITY_DESCRIPTOR AbsoluteSecurityDescriptor, PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor, PULONG BufferLength);
// extern CCHAR (__stdcall *RtlFindLeastSignificantBit)(ULONGLONG Value);
// extern ULONG (__stdcall *RtlNtStatusToDosError)(NTSTATUS Status);
// extern NTSTATUS (__stdcall *NtSetThreadExecutionState)(EXECUTION_STATE esFlags, EXECUTION_STATE *PreviousFlags);
__int64 (__fastcall *_guard_dispatch_icall_fptr)() = &guard_dispatch_icall_nop; // weak
const _PVFV _xc_a = NULL; // idb
const _PVFV _xc_z = NULL; // idb
_UNKNOWN _xi_a; // weak
__int64 (*_xi_z)(void) = NULL; // weak
GUID GUID_CONSOLE_DISPLAY_STATE =
{
  1877382486u,
  28746u,
  18336u,
  { 143u, 36u, 194u, 141u, 147u, 111u, 218u, 71u }
};
GUID GUID_BATTERY_PERCENTAGE_REMAINING =
{
  2813165633u,
  46170u,
  19630u,
  { 135u, 163u, 238u, 203u, 180u, 104u, 169u, 225u }
};
GUID GUID_BATTERY_DISCHARGE_LEVEL_1 = { 2172893850u, 59664u, 18650u, { 135u, 105u, 20u, 174u, 109u, 193u, 23u, 10u } };
GUID GUID_ACDC_POWER_SOURCE = { 1564383833u, 59861u, 19200u, { 166u, 189u, 255u, 52u, 255u, 81u, 101u, 72u } };
GUID GUID_LOW_POWER_EPOCH =
{
  3777182099u,
  60068u,
  18191u,
  { 157u, 231u, 163u, 81u, 193u, 182u, 251u, 113u }
};
GUID GUID_GLOBAL_USER_PRESENCE = { 2020510237u, 46119u, 17220u, { 146u, 7u, 9u, 231u, 11u, 220u, 190u, 169u } };
_UNKNOWN DiskPerfGuid; // weak
_UNKNOWN UBPM_TRIGGER_EMULATOR_EVENT; // weak
_UNKNOWN TRIGGER_EMULATOR_PROVIDER_GUID; // weak
_UNKNOWN TASKSCHED; // weak
_UNKNOWN IDLE_TRIGGER_PROVIDER_GUID; // weak
const struct _EVENT_DESCRIPTOR ItSpEvt_RegisterIdleTask = { 500u, 0u, 18u, 4u, 0u, 500u, 1152921504606846977uLL }; // idb
const unsigned __int16 word_18007630E = 0u; // idb
const struct _EVENT_DESCRIPTOR SCHEDULE_SERVICE_START = { 400u, 0u, 16u, 4u, 1u, 400u, 9223372036854775808uLL }; // idb
const FILETIME FileTime2 = { 4294967295u, 4294967295u }; // idb
const struct _EVENT_DESCRIPTOR SCHEDULE_SERVICE_TIME_CHANGE_SIGNALED = { 411u, 0u, 16u, 4u, 0u, 411u, 9223372036854775808uLL }; // idb
const WCHAR ChannelPath = 0u; // idb
GUID GUID_7279fc88_709d_4095_b63d_69fe4b0d9030 = { 1920597128u, 28829u, 16533u, { 182u, 61u, 105u, 254u, 75u, 13u, 144u, 48u } };
wchar_t aP[2] = L"P"; // weak
GUID GUID_7279fc81_709d_4095_b63d_69fe4b0d9030 = { 1920597121u, 28829u, 16533u, { 182u, 61u, 105u, 254u, 75u, 13u, 144u, 48u } };
const struct _EVENT_DESCRIPTOR ItSpEvt_PowerNotificationReceived = { 509u, 0u, 18u, 4u, 0u, 509u, 1152921504606846977uLL }; // idb
GUID IID_ISequentialStream = { 208878128u, 10780u, 4558u, { 173u, 229u, 0u, 170u, 0u, 68u, 119u, 61u } };
GUID IID_IStream = { 12u, 0u, 0u, { 192u, 0u, 0u, 0u, 0u, 0u, 0u, 70u } };
GUID IID_IPersistFile = { 267u, 0u, 0u, { 192u, 0u, 0u, 0u, 0u, 0u, 0u, 70u } };
GUID IID_IShellLinkW = { 136441u, 0u, 0u, { 192u, 0u, 0u, 0u, 0u, 0u, 0u, 70u } };
GUID CLSID_ShellLink = { 136193u, 0u, 0u, { 192u, 0u, 0u, 0u, 0u, 0u, 0u, 70u } };
GUID GUID_NULL = { 0u, 0u, 0u, { 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u } };
GUID IID_IUnknown = { 0u, 0u, 0u, { 192u, 0u, 0u, 0u, 0u, 0u, 0u, 70u } };
_UNKNOWN TASK_UPDATED; // weak
const struct _EVENT_DESCRIPTOR TASK_REGISTERED_WITHOUT_CREDENTIALS = { 116u, 0u, 16u, 3u, 0u, 116u, 9223372036854775808uLL }; // idb
const struct _EVENT_DESCRIPTOR JOB_REGISTERED = { 106u, 0u, 16u, 4u, 0u, 106u, 9223372036854775808uLL }; // idb
const struct _EVENT_DESCRIPTOR TASK_INSTANTIATE_FAILED = { 151u, 0u, 16u, 2u, 0u, 151u, 9223372036854775808uLL }; // idb
const struct _EVENT_DESCRIPTOR TASK_REGISTERED_WITHOUT_SOME_TRIGGERS = { 113u, 0u, 16u, 3u, 0u, 113u, 9223372036854775808uLL }; // idb
const struct _EVENT_DESCRIPTOR TASK_DISABLED = { 142u, 0u, 16u, 4u, 0u, 142u, 9223372036854775808uLL }; // idb
_UNKNOWN WPP_e3966bf9b81b3ab085a9dfdc4dace9ef_Traceguids; // weak
_UNKNOWN MACHINE_IDLE_GUID; // weak
_UNKNOWN WPP_0a02ad6f637a3dce55ae09b3fc909c99_Traceguids; // weak
_UNKNOWN WPP_0026520f6666348a6128473d4ed545c7_Traceguids; // weak
_UNKNOWN WPP_0fa9442aab3237762f9b607a66102705_Traceguids; // weak
GUID GUID_2faba4c7_4da9_4013_9697_20cc3fd40f85 = { 799777991u, 19881u, 16403u, { 150u, 151u, 32u, 204u, 63u, 212u, 15u, 133u } };
GUID GUID_0ad9d0d7_0c7f_4ebb_9a5f_d1c648dca528 = { 182046935u, 3199u, 20155u, { 154u, 95u, 209u, 198u, 72u, 220u, 165u, 40u } };
_UNKNOWN WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids; // weak
_UNKNOWN WPP_ffeb42fce81a3445f9740a981b62c86a_Traceguids; // weak
_UNKNOWN WPP_f0f7296807f33a7e423f6d049324e537_Traceguids; // weak
GUID CLSID_TaskScheduler = { 260519583u, 42213u, 19708u, { 189u, 62u, 115u, 230u, 21u, 69u, 114u, 221u } };
struct _GUID *const DOUBLE_100_0 = (struct _GUID *const)0x4059000000000000LL; // idb
const double DOUBLE_127_0 = 127.0; // weak
_DWORD dword_18007D000[256] =
{
  0,
  1996959894,
  -301047508,
  -1727442502,
  124634137,
  1886057615,
  -379345611,
  -1637575261,
  249268274,
  2044508324,
  -522852066,
  -1747789432,
  162941995,
  2125561021,
  -407360249,
  -1866523247,
  498536548,
  1789927666,
  -205950648,
  -2067906082,
  450548861,
  1843258603,
  -187386543,
  -2083289657,
  325883990,
  1684777152,
  -43845254,
  -1973040660,
  335633487,
  1661365465,
  -99664541,
  -1928851979,
  997073096,
  1281953886,
  -715111964,
  -1570279054,
  1006888145,
  1258607687,
  -770865667,
  -1526024853,
  901097722,
  1119000684,
  -608450090,
  -1396901568,
  853044451,
  1172266101,
  -589951537,
  -1412350631,
  651767980,
  1373503546,
  -925412992,
  -1076862698,
  565507253,
  1454621731,
  -809855591,
  -1195530993,
  671266974,
  1594198024,
  -972236366,
  -1324619484,
  795835527,
  1483230225,
  -1050600021,
  -1234817731,
  1994146192,
  31158534,
  -1731059524,
  -271249366,
  1907459465,
  112637215,
  -1614814043,
  -390540237,
  2013776290,
  251722036,
  -1777751922,
  -519137256,
  2137656763,
  141376813,
  -1855689577,
  -429695999,
  1802195444,
  476864866,
  -2056965928,
  -228458418,
  1812370925,
  453092731,
  -2113342271,
  -183516073,
  1706088902,
  314042704,
  -1950435094,
  -54949764,
  1658658271,
  366619977,
  -1932296973,
  -69972891,
  1303535960,
  984961486,
  -1547960204,
  -725929758,
  1256170817,
  1037604311,
  -1529756563,
  -740887301,
  1131014506,
  879679996,
  -1385723834,
  -631195440,
  1141124467,
  855842277,
  -1442165665,
  -586318647,
  1342533948,
  654459306,
  -1106571248,
  -921952122,
  1466479909,
  544179635,
  -1184443383,
  -832445281,
  1591671054,
  702138776,
  -1328506846,
  -942167884,
  1504918807,
  783551873,
  -1212326853,
  -1061524307,
  -306674912,
  -1698712650,
  62317068,
  1957810842,
  -355121351,
  -1647151185,
  81470997,
  1943803523,
  -480048366,
  -1805370492,
  225274430,
  2053790376,
  -468791541,
  -1828061283,
  167816743,
  2097651377,
  -267414716,
  -2029476910,
  503444072,
  1762050814,
  -144550051,
  -2140837941,
  426522225,
  1852507879,
  -19653770,
  -1982649376,
  282753626,
  1742555852,
  -105259153,
  -1900089351,
  397917763,
  1622183637,
  -690576408,
  -1580100738,
  953729732,
  1340076626,
  -776247311,
  -1497606297,
  1068828381,
  1219638859,
  -670225446,
  -1358292148,
  906185462,
  1090812512,
  -547295293,
  -1469587627,
  829329135,
  1181335161,
  -882789492,
  -1134132454,
  628085408,
  1382605366,
  -871598187,
  -1156888829,
  570562233,
  1426400815,
  -977650754,
  -1296233688,
  733239954,
  1555261956,
  -1026031705,
  -1244606671,
  752459403,
  1541320221,
  -1687895376,
  -328994266,
  1969922972,
  40735498,
  -1677130071,
  -351390145,
  1913087877,
  83908371,
  -1782625662,
  -491226604,
  2075208622,
  213261112,
  -1831694693,
  -438977011,
  2094854071,
  198958881,
  -2032938284,
  -237706686,
  1759359992,
  534414190,
  -2118248755,
  -155638181,
  1873836001,
  414664567,
  -2012718362,
  -15766928,
  1711684554,
  285281116,
  -1889165569,
  -127750551,
  1634467795,
  376229701,
  -1609899400,
  -686959890,
  1308918612,
  956543938,
  -1486412191,
  -799009033,
  1231636301,
  1047427035,
  -1362007478,
  -640263460,
  1088359270,
  936918000,
  -1447252397,
  -558129467,
  1202900863,
  817233897,
  -1111625188,
  -893730166,
  1404277552,
  615818150,
  -1160759803,
  -841546093,
  1423857449,
  601450431,
  -1285129682,
  -1000256840,
  1567103746,
  711928724,
  -1274298825,
  -1022587231,
  1510334235,
  755167117
}; // weak
__int64 WNF_SEB_SYSTEM_IDLE = 4720910673054025845LL; // weak
unsigned int near *PriorityToPriorityClass = (unsigned int near *)0x8000000100LL; // weak
const unsigned __int64 near *const Schema::schemaEntriesCount = (const unsigned __int64 near *const)0x1FLL; // weak
__int128 xmmword_18007DCF0 = 0x927C0000927C000000001LL; // weak
__int128 xmmword_18007DD00 = 0x5A0000005A0000000000007530LL; // weak
__int128 xmmword_18007DD14 = 0x927C0000927C000000001LL; // weak
__int128 xmmword_18007DD24 = 0x50000000500000000000007530LL; // weak
__int128 xmmword_18007DD38 = 0x5265C0000927C0000927C000000000LL; // weak
__int128 xmmword_18007DD48 = 0x50000000500000000000007530LL; // weak
__int128 xmmword_18007DD5C = 0x927C0000927C000000001LL; // weak
__int128 xmmword_18007DD6C = 0x50000000500000000000007530LL; // weak
__int128 xmmword_18007DD80 = 0x927C0000927C000000001LL; // weak
__int128 xmmword_18007DD90 = 0x50000000500000000000007530LL; // weak
__int128 _xmm = 0x44663031446630314466303144663031LL; // weak
__int64 WNF_XBOX_SYSTEM_CONSTRAINED_MODE_STATUS_CHANGED = 1840015347277406325LL; // weak
unsigned __int8 byte_18007EA71[87] =
{
  11u,
  4u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  75u,
  0u,
  0u,
  85u,
  115u,
  101u,
  114u,
  58u,
  58u,
  85u,
  112u,
  100u,
  97u,
  116u,
  101u,
  69u,
  110u,
  116u,
  114u,
  121u,
  95u,
  78u,
  117u,
  108u,
  108u,
  85u,
  115u,
  101u,
  114u,
  68u,
  101u,
  116u,
  97u,
  105u,
  108u,
  115u,
  0u,
  109u,
  95u,
  100u,
  111u,
  109u,
  97u,
  105u,
  110u,
  0u,
  1u,
  109u,
  95u,
  97u,
  99u,
  99u,
  111u,
  117u,
  110u,
  116u,
  0u,
  1u,
  109u,
  95u,
  117u,
  115u,
  101u,
  114u,
  78u,
  97u,
  109u,
  101u,
  0u,
  1u,
  117u,
  115u,
  101u,
  0u,
  8u,
  6u
}; // weak
unsigned __int8 byte_18007EAC8[94] =
{
  11u,
  2u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  82u,
  0u,
  0u,
  85u,
  115u,
  101u,
  114u,
  58u,
  58u,
  67u,
  114u,
  101u,
  97u,
  116u,
  101u,
  85u,
  115u,
  101u,
  114u,
  95u,
  65u,
  108u,
  108u,
  111u,
  99u,
  97u,
  116u,
  105u,
  111u,
  110u,
  70u,
  97u,
  105u,
  108u,
  117u,
  114u,
  101u,
  0u,
  112u,
  83u,
  73u,
  68u,
  0u,
  19u,
  68u,
  111u,
  109u,
  97u,
  105u,
  110u,
  0u,
  1u,
  65u,
  99u,
  99u,
  111u,
  117u,
  110u,
  116u,
  0u,
  1u,
  68u,
  111u,
  109u,
  97u,
  105u,
  110u,
  95u,
  65u,
  99u,
  99u,
  111u,
  117u,
  110u,
  116u,
  0u,
  1u,
  117u,
  115u,
  101u,
  0u,
  8u,
  6u
}; // weak
unsigned __int8 byte_18007EB26[78] =
{
  11u,
  2u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  66u,
  0u,
  0u,
  85u,
  115u,
  101u,
  114u,
  58u,
  58u,
  67u,
  114u,
  101u,
  97u,
  116u,
  101u,
  85u,
  115u,
  101u,
  114u,
  95u,
  65u,
  108u,
  108u,
  111u,
  99u,
  97u,
  116u,
  105u,
  111u,
  110u,
  70u,
  97u,
  105u,
  108u,
  117u,
  114u,
  101u,
  0u,
  112u,
  83u,
  73u,
  68u,
  0u,
  19u,
  68u,
  111u,
  109u,
  97u,
  105u,
  110u,
  0u,
  1u,
  65u,
  99u,
  99u,
  111u,
  117u,
  110u,
  116u,
  0u,
  1u,
  117u,
  115u,
  101u,
  0u,
  8u,
  6u
}; // weak
unsigned __int8 byte_18007EB74[106] =
{
  11u,
  2u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  94u,
  0u,
  0u,
  85u,
  115u,
  101u,
  114u,
  58u,
  58u,
  67u,
  114u,
  101u,
  97u,
  116u,
  101u,
  85u,
  115u,
  101u,
  114u,
  95u,
  65u,
  108u,
  108u,
  111u,
  99u,
  97u,
  116u,
  105u,
  111u,
  110u,
  70u,
  97u,
  105u,
  108u,
  117u,
  114u,
  101u,
  0u,
  112u,
  83u,
  73u,
  68u,
  0u,
  19u,
  95u,
  98u,
  115u,
  116u,
  114u,
  95u,
  97u,
  99u,
  99u,
  111u,
  117u,
  110u,
  116u,
  0u,
  1u,
  95u,
  98u,
  115u,
  116u,
  114u,
  95u,
  100u,
  111u,
  109u,
  97u,
  105u,
  110u,
  0u,
  1u,
  100u,
  111u,
  109u,
  97u,
  105u,
  110u,
  95u,
  65u,
  99u,
  99u,
  111u,
  117u,
  110u,
  116u,
  0u,
  1u,
  117u,
  115u,
  101u,
  0u,
  8u,
  6u
}; // weak
unsigned __int8 byte_18007EBDE[49] =
{
  11u,
  4u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  85u,
  115u,
  101u,
  114u,
  58u,
  58u,
  67u,
  114u,
  101u,
  97u,
  116u,
  101u,
  85u,
  115u,
  101u,
  114u,
  95u,
  77u,
  97u,
  108u,
  102u,
  111u,
  114u,
  109u,
  101u,
  100u,
  65u,
  99u,
  99u,
  111u,
  117u,
  110u,
  116u,
  0u,
  6u
}; // weak
unsigned __int8 byte_18007EC0F[90] =
{
  11u,
  4u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  78u,
  0u,
  0u,
  85u,
  115u,
  101u,
  114u,
  58u,
  58u,
  67u,
  114u,
  101u,
  97u,
  116u,
  101u,
  85u,
  115u,
  101u,
  114u,
  95u,
  68u,
  111u,
  109u,
  97u,
  105u,
  110u,
  65u,
  99u,
  99u,
  111u,
  117u,
  110u,
  116u,
  0u,
  112u,
  83u,
  73u,
  68u,
  0u,
  19u,
  68u,
  111u,
  109u,
  97u,
  105u,
  110u,
  0u,
  1u,
  65u,
  99u,
  99u,
  111u,
  117u,
  110u,
  116u,
  0u,
  1u,
  68u,
  111u,
  109u,
  97u,
  105u,
  110u,
  95u,
  65u,
  99u,
  99u,
  111u,
  117u,
  110u,
  116u,
  0u,
  1u,
  117u,
  115u,
  101u,
  0u,
  8u,
  6u
}; // weak
unsigned __int8 byte_18007EC69[73] =
{
  11u,
  4u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  61u,
  0u,
  0u,
  85u,
  115u,
  101u,
  114u,
  58u,
  58u,
  83u,
  116u,
  114u,
  101u,
  97u,
  109u,
  73u,
  110u,
  95u,
  70u,
  114u,
  111u,
  109u,
  83u,
  105u,
  100u,
  84u,
  111u,
  68u,
  111u,
  109u,
  97u,
  105u,
  110u,
  65u,
  99u,
  99u,
  111u,
  117u,
  110u,
  116u,
  70u,
  97u,
  105u,
  108u,
  0u,
  72u,
  82u,
  101u,
  115u,
  117u,
  108u,
  116u,
  0u,
  135u,
  15u,
  112u,
  83u,
  73u,
  68u,
  0u,
  19u,
  6u
}; // weak
int dword_18007ECB2[22] =
{
  16778251,
  0,
  1275068480,
  1766653952,
  1952543335,
  1601073001,
  1701536084,
  1953719634,
  1181053551,
  7104865,
  1952543859,
  134247285,
  1801675106,
  1633120373,
  1634616691,
  1684368482,
  1912833024,
  1869902693,
  1633117554,
  1634616691,
  1684368482,
  100893696
}; // weak
unsigned __int8 byte_18007ED0A[59] =
{
  11u,
  4u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  64u,
  0u,
  0u,
  47u,
  0u,
  0u,
  77u,
  105u,
  103u,
  114u,
  97u,
  116u,
  105u,
  111u,
  110u,
  95u,
  68u,
  70u,
  78u,
  83u,
  101u,
  116u,
  83u,
  101u,
  99u,
  73u,
  110u,
  102u,
  111u,
  70u,
  97u,
  105u,
  108u,
  0u,
  104u,
  114u,
  0u,
  135u,
  15u,
  115u,
  114u,
  99u,
  0u,
  1u,
  100u,
  101u,
  115u,
  116u,
  0u,
  1u,
  6u
}; // weak
unsigned __int8 byte_18007ED45[54] =
{
  11u,
  4u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  64u,
  0u,
  0u,
  42u,
  0u,
  0u,
  77u,
  105u,
  103u,
  114u,
  97u,
  116u,
  105u,
  111u,
  110u,
  95u,
  67u,
  111u,
  112u,
  121u,
  70u,
  105u,
  108u,
  101u,
  70u,
  97u,
  105u,
  108u,
  0u,
  104u,
  114u,
  0u,
  135u,
  15u,
  115u,
  114u,
  99u,
  0u,
  1u,
  100u,
  101u,
  115u,
  116u,
  0u,
  1u,
  6u
}; // weak
unsigned __int8 byte_18007ED7B[59] =
{
  11u,
  4u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  64u,
  0u,
  0u,
  47u,
  0u,
  0u,
  77u,
  105u,
  103u,
  114u,
  97u,
  116u,
  105u,
  111u,
  110u,
  95u,
  68u,
  70u,
  78u,
  71u,
  101u,
  116u,
  83u,
  101u,
  99u,
  73u,
  110u,
  102u,
  111u,
  70u,
  97u,
  105u,
  108u,
  0u,
  104u,
  114u,
  0u,
  135u,
  15u,
  115u,
  114u,
  99u,
  0u,
  1u,
  100u,
  101u,
  115u,
  116u,
  0u,
  1u,
  6u
}; // weak
unsigned __int8 byte_18007EDB6[107] =
{
  11u,
  4u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  64u,
  0u,
  0u,
  95u,
  0u,
  0u,
  77u,
  105u,
  103u,
  114u,
  97u,
  116u,
  105u,
  111u,
  110u,
  95u,
  68u,
  114u,
  111u,
  112u,
  66u,
  97u,
  99u,
  107u,
  117u,
  112u,
  80u,
  114u,
  105u,
  118u,
  70u,
  97u,
  105u,
  108u,
  0u,
  115u,
  116u,
  97u,
  116u,
  117u,
  115u,
  0u,
  8u,
  98u,
  97u,
  99u,
  107u,
  117u,
  112u,
  87u,
  97u,
  115u,
  69u,
  110u,
  97u,
  98u,
  108u,
  101u,
  100u,
  0u,
  132u,
  3u,
  114u,
  101u,
  115u,
  116u,
  111u,
  114u,
  101u,
  87u,
  97u,
  115u,
  69u,
  110u,
  97u,
  98u,
  108u,
  101u,
  100u,
  0u,
  132u,
  3u,
  112u,
  114u,
  101u,
  118u,
  105u,
  111u,
  117u,
  115u,
  83u,
  116u,
  97u,
  116u,
  101u,
  0u,
  132u,
  3u,
  6u
}; // weak
int dword_18007EE21[12] =
{
  16778251,
  0,
  620757056,
  1766653952,
  1952543335,
  778989417,
  1282436948,
  1818588773,
  2037411651,
  1818845510,
  1744856165,
  260505714
}; // weak
int dword_18007EE52[8] =
{
  33686539,
  0,
  352321536,
  1867251712,
  1867146337,
  1912632162,
  1819636581,
  260505716
}; // weak
unsigned __int8 byte_18007EE73[74] =
{
  11u,
  4u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  64u,
  0u,
  0u,
  62u,
  0u,
  0u,
  77u,
  105u,
  103u,
  114u,
  97u,
  116u,
  105u,
  111u,
  110u,
  95u,
  83u,
  101u,
  116u,
  83u,
  100u,
  100u,
  108u,
  87u,
  105u,
  116u,
  104u,
  82u,
  101u,
  115u,
  116u,
  111u,
  114u,
  101u,
  80u,
  114u,
  105u,
  118u,
  115u,
  70u,
  97u,
  105u,
  108u,
  0u,
  104u,
  114u,
  0u,
  135u,
  15u,
  105u,
  116u,
  101u,
  109u,
  112u,
  97u,
  116u,
  104u,
  0u,
  1u,
  115u,
  100u,
  100u,
  108u,
  0u,
  1u,
  6u
}; // weak
unsigned __int8 byte_18007EEBD[65] =
{
  11u,
  4u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  64u,
  0u,
  0u,
  53u,
  0u,
  0u,
  77u,
  105u,
  103u,
  114u,
  97u,
  116u,
  105u,
  111u,
  110u,
  95u,
  83u,
  101u,
  116u,
  83u,
  100u,
  100u,
  108u,
  78u,
  111u,
  116u,
  73u,
  109u,
  112u,
  101u,
  114u,
  115u,
  111u,
  110u,
  97u,
  116u,
  105u,
  110u,
  103u,
  70u,
  97u,
  105u,
  108u,
  0u,
  112u,
  97u,
  116u,
  104u,
  0u,
  1u,
  115u,
  100u,
  100u,
  108u,
  0u,
  1u,
  6u
}; // weak
int dword_18007EEFE[9] =
{
  33555467,
  0,
  452984832,
  1766653952,
  1952543335,
  1601073001,
  1886220099,
  1702126956,
  7497728
}; // weak
unsigned __int8 byte_18007EF25[108] =
{
  11u,
  4u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  64u,
  0u,
  0u,
  96u,
  0u,
  0u,
  77u,
  105u,
  103u,
  114u,
  97u,
  116u,
  105u,
  111u,
  110u,
  95u,
  68u,
  114u,
  111u,
  112u,
  82u,
  101u,
  115u,
  116u,
  111u,
  114u,
  101u,
  80u,
  114u,
  105u,
  118u,
  70u,
  97u,
  105u,
  108u,
  0u,
  115u,
  116u,
  97u,
  116u,
  117u,
  115u,
  0u,
  8u,
  98u,
  97u,
  99u,
  107u,
  117u,
  112u,
  87u,
  97u,
  115u,
  69u,
  110u,
  97u,
  98u,
  108u,
  101u,
  100u,
  0u,
  132u,
  3u,
  114u,
  101u,
  115u,
  116u,
  111u,
  114u,
  101u,
  87u,
  97u,
  115u,
  69u,
  110u,
  97u,
  98u,
  108u,
  101u,
  100u,
  0u,
  132u,
  3u,
  112u,
  114u,
  101u,
  118u,
  105u,
  111u,
  117u,
  115u,
  83u,
  116u,
  97u,
  116u,
  101u,
  0u,
  132u,
  3u,
  6u
}; // weak
unsigned __int8 byte_18007EF91[59] =
{
  11u,
  4u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  64u,
  0u,
  0u,
  47u,
  0u,
  0u,
  77u,
  105u,
  103u,
  114u,
  97u,
  116u,
  105u,
  111u,
  110u,
  95u,
  68u,
  70u,
  78u,
  67u,
  114u,
  101u,
  97u,
  116u,
  101u,
  70u,
  105u,
  108u,
  101u,
  70u,
  97u,
  105u,
  108u,
  0u,
  104u,
  114u,
  0u,
  135u,
  15u,
  115u,
  114u,
  99u,
  0u,
  1u,
  100u,
  101u,
  115u,
  116u,
  0u,
  1u,
  6u
}; // weak
int dword_18007EFCC[10] =
{
  16778251,
  0,
  520093760,
  1766653952,
  1952543335,
  778989417,
  1282436948,
  1818588773,
  2037411651,
  7497728
}; // weak
int dword_18007EFF7[16] =
{
  16778251,
  0,
  922746944,
  1766653952,
  1952543335,
  1601073001,
  1701536084,
  1801675074,
  1632006261,
  1929407593,
  1970561396,
  1644691571,
  1969972065,
  1935759216,
  1650552389,
  6579564
}; // weak
unsigned __int8 byte_18007F03A[64] =
{
  11u,
  4u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  64u,
  0u,
  0u,
  52u,
  0u,
  0u,
  77u,
  105u,
  103u,
  114u,
  97u,
  116u,
  105u,
  111u,
  110u,
  95u,
  68u,
  70u,
  78u,
  82u,
  101u,
  97u,
  108u,
  80u,
  97u,
  116u,
  104u,
  73u,
  110u,
  118u,
  97u,
  108u,
  105u,
  100u,
  70u,
  97u,
  105u,
  108u,
  0u,
  104u,
  114u,
  0u,
  135u,
  15u,
  115u,
  114u,
  99u,
  0u,
  1u,
  100u,
  101u,
  115u,
  116u,
  0u,
  1u,
  6u
}; // weak
int dword_18007F07A[9] =
{
  33621003,
  0,
  436207616,
  1867251712,
  1867146337,
  1107325794,
  1416916847,
  1281715561,
  6578543
}; // weak
unsigned __int8 byte_18007F0A0[50] =
{
  11u,
  4u,
  2u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  38u,
  0u,
  0u,
  82u,
  112u,
  99u,
  95u,
  69u,
  110u,
  97u,
  98u,
  108u,
  101u,
  84u,
  97u,
  115u,
  107u,
  0u,
  80u,
  97u,
  116u,
  104u,
  0u,
  1u,
  104u,
  114u,
  0u,
  135u,
  15u,
  69u,
  110u,
  97u,
  98u,
  108u,
  101u,
  100u,
  0u,
  13u,
  6u
}; // weak
unsigned __int8 byte_18007F0D2[32] =
{
  11u,
  5u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  20u,
  0u,
  0u,
  82u,
  112u,
  99u,
  95u,
  82u,
  101u,
  103u,
  105u,
  115u,
  116u,
  101u,
  114u,
  84u,
  97u,
  115u,
  107u,
  0u,
  6u
}; // weak
unsigned __int8 byte_18007F0F2[52] =
{
  11u,
  4u,
  2u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  40u,
  0u,
  0u,
  82u,
  112u,
  99u,
  95u,
  82u,
  101u,
  103u,
  105u,
  115u,
  116u,
  101u,
  114u,
  84u,
  97u,
  115u,
  107u,
  0u,
  80u,
  97u,
  116u,
  104u,
  0u,
  1u,
  104u,
  114u,
  0u,
  135u,
  15u,
  84u,
  97u,
  115u,
  107u,
  88u,
  109u,
  108u,
  0u,
  1u,
  6u
}; // weak
_UNKNOWN unk_18007F126; // weak
unsigned __int8 byte_18007F153[27] =
{
  11u,
  5u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  15u,
  0u,
  0u,
  82u,
  112u,
  99u,
  95u,
  82u,
  117u,
  110u,
  84u,
  97u,
  115u,
  107u,
  0u,
  6u
}; // weak
_UNKNOWN unk_18007F16E; // weak
unsigned __int8 byte_18007F18C[28] =
{
  11u,
  5u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  16u,
  0u,
  0u,
  82u,
  112u,
  99u,
  95u,
  83u,
  116u,
  111u,
  112u,
  84u,
  97u,
  115u,
  107u,
  0u,
  6u
}; // weak
unsigned __int8 byte_18007F1A8[30] =
{
  11u,
  5u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  18u,
  0u,
  0u,
  82u,
  112u,
  99u,
  95u,
  69u,
  110u,
  97u,
  98u,
  108u,
  101u,
  84u,
  97u,
  115u,
  107u,
  0u,
  6u
}; // weak
unsigned __int8 byte_18007F1C6[43] =
{
  11u,
  4u,
  2u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  31u,
  0u,
  0u,
  82u,
  112u,
  99u,
  95u,
  83u,
  116u,
  111u,
  112u,
  84u,
  97u,
  115u,
  107u,
  0u,
  84u,
  97u,
  115u,
  107u,
  78u,
  97u,
  109u,
  101u,
  0u,
  1u,
  104u,
  114u,
  0u,
  135u,
  15u,
  6u
}; // weak
unsigned __int8 byte_18007F1F1[53] =
{
  11u,
  4u,
  2u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  41u,
  0u,
  0u,
  82u,
  112u,
  99u,
  95u,
  82u,
  117u,
  110u,
  84u,
  97u,
  115u,
  107u,
  0u,
  84u,
  97u,
  115u,
  107u,
  78u,
  97u,
  109u,
  101u,
  0u,
  1u,
  104u,
  114u,
  0u,
  135u,
  15u,
  83u,
  101u,
  115u,
  115u,
  105u,
  111u,
  110u,
  73u,
  100u,
  0u,
  7u,
  6u
}; // weak
unsigned __int8 byte_18007F226[145] =
{
  11u,
  5u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  64u,
  0u,
  0u,
  117u,
  0u,
  0u,
  65u,
  115u,
  115u,
  101u,
  114u,
  116u,
  0u,
  97u,
  115u,
  115u,
  101u,
  114u,
  116u,
  86u,
  101u,
  114u,
  115u,
  105u,
  111u,
  110u,
  0u,
  8u,
  114u,
  118u,
  97u,
  0u,
  8u,
  116u,
  105u,
  109u,
  101u,
  115u,
  116u,
  97u,
  109u,
  112u,
  0u,
  8u,
  105u,
  109u,
  97u,
  103u,
  101u,
  83u,
  105u,
  122u,
  101u,
  0u,
  8u,
  105u,
  109u,
  97u,
  103u,
  101u,
  78u,
  97u,
  109u,
  101u,
  0u,
  2u,
  99u,
  111u,
  117u,
  110u,
  116u,
  0u,
  8u,
  116u,
  111u,
  116u,
  97u,
  108u,
  72u,
  105u,
  116u,
  115u,
  0u,
  8u,
  77u,
  111u,
  100u,
  117u,
  108u,
  101u,
  67u,
  111u,
  108u,
  108u,
  101u,
  99u,
  116u,
  105u,
  111u,
  110u,
  0u,
  8u,
  71u,
  108u,
  111u,
  98u,
  97u,
  108u,
  67u,
  111u,
  108u,
  108u,
  101u,
  99u,
  116u,
  105u,
  111u,
  110u,
  0u,
  8u,
  4u,
  157u,
  36u,
  27u,
  109u,
  27u,
  19u,
  138u,
  70u,
  137u,
  155u,
  251u,
  10u,
  217u,
  85u,
  23u,
  114u
}; // weak
GUID GUID_0000000c_0000_0000_c000_000000000046 = { 12u, 0u, 0u, { 192u, 0u, 0u, 0u, 0u, 0u, 0u, 70u } };
_UNKNOWN SCHEDULE_SERVICE_RUN_BOOT_JOBS_FAILED; // weak
const struct _EVENT_DESCRIPTOR TASK_STARTED_ON_COMPUTER_WAKEUP = { 145u, 0u, 16u, 4u, 0u, 145u, 9223372036854775808uLL }; // idb
const struct _EVENT_DESCRIPTOR SCHEDULE_SERVICE_STOP = { 402u, 0u, 16u, 4u, 2u, 402u, 9223372036854775808uLL }; // idb
const struct _EVENT_DESCRIPTOR ItSpEvt_ExecuteIdleTask_Start = { 502u, 0u, 18u, 4u, 1u, 502u, 1152921504606846977uLL }; // idb
const struct _EVENT_DESCRIPTOR ItSpEvt_ExplicitProcessing_Start = { 506u, 0u, 18u, 4u, 1u, 506u, 1152921504606846977uLL }; // idb
const struct _EVENT_DESCRIPTOR TASK_DELETED = { 141u, 0u, 16u, 4u, 0u, 141u, 9223372036854775808uLL }; // idb
const struct _EVENT_DESCRIPTOR ItSpEvt_NotifyIdleTask_Stop = { 505u, 0u, 18u, 4u, 2u, 504u, 1152921504606846977uLL }; // idb
const struct _EVENT_DESCRIPTOR ItSpEvt_PerfTrack_IdleExitStats = { 511u, 0u, 18u, 4u, 0u, 511u, 1153202979583557633uLL }; // idb
const struct _EVENT_DESCRIPTOR SCHEDULE_SERVICE_START_FAILED = { 401u, 0u, 8u, 1u, 101u, 401u, 4611686018427387904uLL }; // idb
const struct _EVENT_DESCRIPTOR SCHEDULE_SERVICE_ERROR = { 403u, 0u, 16u, 2u, 104u, 403u, 9223372036854775808uLL }; // idb
const struct _EVENT_DESCRIPTOR TASK_LOAD_FAILED = { 146u, 0u, 16u, 2u, 0u, 146u, 9223372036854775808uLL }; // idb
const struct _EVENT_DESCRIPTOR MISSED_TASK_LAUNCHED = { 114u, 0u, 16u, 3u, 0u, 114u, 9223372036854775808uLL }; // idb
const struct _EVENT_DESCRIPTOR EVENT_AGGREGATE_FAILED = { 205u, 0u, 16u, 2u, 0u, 205u, 9223372036854775808uLL }; // idb
const struct _EVENT_DESCRIPTOR SCHEDULE_SERVICE_CRED_STORE_INIT_ERROR = { 406u, 0u, 8u, 1u, 0u, 406u, 4611686018427387904uLL }; // idb
const struct _EVENT_DESCRIPTOR JOB_COMPLETION_PENDING = { 155u, 0u, 16u, 4u, 0u, 136u, 9223372036854775809uLL }; // idb
const struct _EVENT_DESCRIPTOR JOB_START_FAILED = { 101u, 0u, 16u, 2u, 101u, 101u, 9223372036854775809uLL }; // idb
const struct _EVENT_DESCRIPTOR SCHEDULE_SERVICE_SET_WAKEUP_TIMER_ERROR = { 410u, 0u, 16u, 2u, 0u, 410u, 9223372036854775808uLL }; // idb
const struct _EVENT_DESCRIPTOR COMPAT_START_FAILED = { 701u, 0u, 8u, 2u, 0u, 701u, 4611686018427387904uLL }; // idb
const struct _EVENT_DESCRIPTOR SCHEDULE_SERVICE_RPC_INIT_ERROR = { 404u, 0u, 8u, 3u, 0u, 404u, 4611686018427387904uLL }; // idb
const struct _EVENT_DESCRIPTOR SCHEDULE_OPERATIONAL_LOG_DISABLED = { 719u, 0u, 8u, 4u, 0u, 719u, 4611686018427387904uLL }; // idb
const struct _EVENT_DESCRIPTOR ItSpEvt_NotifyIdleTask_Start = { 504u, 0u, 18u, 4u, 1u, 504u, 1152921504606846977uLL }; // idb
const struct _EVENT_DESCRIPTOR ItSpEvt_ExecuteIdleTask_Stop = { 503u, 0u, 18u, 4u, 2u, 502u, 1152921504606846977uLL }; // idb
const struct _EVENT_DESCRIPTOR VISTA_BETA2_CREDSTORE_UPGRADE_FAILED = { 718u, 0u, 8u, 2u, 0u, 712u, 4611686018427387904uLL }; // idb
const struct _EVENT_DESCRIPTOR EVENT_RENDER_FAILED = { 204u, 0u, 16u, 2u, 0u, 204u, 9223372036854775808uLL }; // idb
const struct _EVENT_DESCRIPTOR IMPERSONATION_FAILURE = { 105u, 0u, 16u, 2u, 0u, 105u, 9223372036854775808uLL }; // idb
const struct _EVENT_DESCRIPTOR SCHEDULE_SERVICE_IDLE_SERVICE_INIT_ERROR = { 408u, 0u, 8u, 2u, 0u, 408u, 4611686018427387904uLL }; // idb
const struct _EVENT_DESCRIPTOR IGNORED_TASK_START = { 128u, 0u, 16u, 4u, 0u, 128u, 9223372036854775808uLL }; // idb
_UNKNOWN ItSpEvt_PerfTrack_IdleEntryStats; // weak
const struct _EVENT_DESCRIPTOR ItSpEvt_ExplicitProcessing_Stop = { 507u, 0u, 18u, 4u, 2u, 506u, 1152921504606846977uLL }; // idb
const struct _EVENT_DESCRIPTOR SCHEDULE_SERVICE_COM_INIT_ERROR = { 405u, 0u, 8u, 1u, 0u, 405u, 4611686018427387904uLL }; // idb
const struct _EVENT_DESCRIPTOR ItSpEvt_ExplicitProcessing_Active = { 508u, 0u, 18u, 4u, 0u, 508u, 1152921504606846977uLL }; // idb
const struct _EVENT_DESCRIPTOR TIME_TRIGGER = { 107u, 0u, 16u, 4u, 0u, 107u, 9223372036854775808uLL }; // idb
const struct _EVENT_DESCRIPTOR SCHEDULE_SERVICE_LOAD_JOBS_FAILED = { 413u, 0u, 8u, 2u, 0u, 403u, 4611686018427387904uLL }; // idb
const struct _EVENT_DESCRIPTOR ItSpEvt_UnregisterIdleTask = { 501u, 0u, 18u, 4u, 0u, 501u, 1152921504606846977uLL }; // idb
const struct _EVENT_DESCRIPTOR ItSpEvt_IdleCheckPoint = { 512u, 0u, 18u, 4u, 0u, 512u, 1152921504606846977uLL }; // idb
_UNKNOWN UBPM_IDLE_TRIGGER_EVENT; // weak
const struct _EVENT_DESCRIPTOR TASK_EVENT_SUBSCRIPTION_FAILED = { 150u, 0u, 16u, 2u, 0u, 150u, 9223372036854775808uLL }; // idb
wchar_t aInitialization[25] = L"Initialization sequence:"; // weak
wchar_t aUninitializati[27] = L"Uninitialization sequence:"; // weak
_UNKNOWN WPP_ThisDir_CTLGUID_JobCtlGuid; // weak
_UNKNOWN MACHINE_NOT_IDLE_GUID; // weak
wchar_t asc_18007F994[3] = L"%_"; // weak
_UNKNOWN WPP_c0b0770bd08e382a040e2237764c2feb_Traceguids; // weak
_UNKNOWN WPP_16de8f11014e3cd60e9c758468ee516f_Traceguids; // weak
_UNKNOWN WPP_4aaaf28b39ec324c0c8953682ef38beb_Traceguids; // weak
_UNKNOWN WPP_16e3f8fe698a3782de2a32e152cb4c16_Traceguids; // weak
_UNKNOWN WPP_5435fee58aaf3c352ed5cdc6abf88a31_Traceguids; // weak
_UNKNOWN WPP_36853d0798d4305d7569c8a69e5e95fb_Traceguids; // weak
char byte_1800801E0[264] =
{
  '\0',
  '\x01',
  '\x01',
  '\x02',
  '\x01',
  '\x02',
  '\x02',
  '\x03',
  '\x01',
  '\x02',
  '\x02',
  '\x03',
  '\x02',
  '\x03',
  '\x03',
  '\x04',
  '\x01',
  '\x02',
  '\x02',
  '\x03',
  '\x02',
  '\x03',
  '\x03',
  '\x04',
  '\x02',
  '\x03',
  '\x03',
  '\x04',
  '\x03',
  '\x04',
  '\x04',
  '\x05',
  '\x01',
  '\x02',
  '\x02',
  '\x03',
  '\x02',
  '\x03',
  '\x03',
  '\x04',
  '\x02',
  '\x03',
  '\x03',
  '\x04',
  '\x03',
  '\x04',
  '\x04',
  '\x05',
  '\x02',
  '\x03',
  '\x03',
  '\x04',
  '\x03',
  '\x04',
  '\x04',
  '\x05',
  '\x03',
  '\x04',
  '\x04',
  '\x05',
  '\x04',
  '\x05',
  '\x05',
  '\x06',
  '\x01',
  '\x02',
  '\x02',
  '\x03',
  '\x02',
  '\x03',
  '\x03',
  '\x04',
  '\x02',
  '\x03',
  '\x03',
  '\x04',
  '\x03',
  '\x04',
  '\x04',
  '\x05',
  '\x02',
  '\x03',
  '\x03',
  '\x04',
  '\x03',
  '\x04',
  '\x04',
  '\x05',
  '\x03',
  '\x04',
  '\x04',
  '\x05',
  '\x04',
  '\x05',
  '\x05',
  '\x06',
  '\x02',
  '\x03',
  '\x03',
  '\x04',
  '\x03',
  '\x04',
  '\x04',
  '\x05',
  '\x03',
  '\x04',
  '\x04',
  '\x05',
  '\x04',
  '\x05',
  '\x05',
  '\x06',
  '\x03',
  '\x04',
  '\x04',
  '\x05',
  '\x04',
  '\x05',
  '\x05',
  '\x06',
  '\x04',
  '\x05',
  '\x05',
  '\x06',
  '\x05',
  '\x06',
  '\x06',
  '\a',
  '\x01',
  '\x02',
  '\x02',
  '\x03',
  '\x02',
  '\x03',
  '\x03',
  '\x04',
  '\x02',
  '\x03',
  '\x03',
  '\x04',
  '\x03',
  '\x04',
  '\x04',
  '\x05',
  '\x02',
  '\x03',
  '\x03',
  '\x04',
  '\x03',
  '\x04',
  '\x04',
  '\x05',
  '\x03',
  '\x04',
  '\x04',
  '\x05',
  '\x04',
  '\x05',
  '\x05',
  '\x06',
  '\x02',
  '\x03',
  '\x03',
  '\x04',
  '\x03',
  '\x04',
  '\x04',
  '\x05',
  '\x03',
  '\x04',
  '\x04',
  '\x05',
  '\x04',
  '\x05',
  '\x05',
  '\x06',
  '\x03',
  '\x04',
  '\x04',
  '\x05',
  '\x04',
  '\x05',
  '\x05',
  '\x06',
  '\x04',
  '\x05',
  '\x05',
  '\x06',
  '\x05',
  '\x06',
  '\x06',
  '\a',
  '\x02',
  '\x03',
  '\x03',
  '\x04',
  '\x03',
  '\x04',
  '\x04',
  '\x05',
  '\x03',
  '\x04',
  '\x04',
  '\x05',
  '\x04',
  '\x05',
  '\x05',
  '\x06',
  '\x03',
  '\x04',
  '\x04',
  '\x05',
  '\x04',
  '\x05',
  '\x05',
  '\x06',
  '\x04',
  '\x05',
  '\x05',
  '\x06',
  '\x05',
  '\x06',
  '\x06',
  '\a',
  '\x03',
  '\x04',
  '\x04',
  '\x05',
  '\x04',
  '\x05',
  '\x05',
  '\x06',
  '\x04',
  '\x05',
  '\x05',
  '\x06',
  '\x05',
  '\x06',
  '\x06',
  '\a',
  '\x04',
  '\x05',
  '\x05',
  '\x06',
  '\x05',
  '\x06',
  '\x06',
  '\a',
  '\x05',
  '\x06',
  '\x06',
  '\a',
  '\x06',
  '\a',
  '\a',
  '\b',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
_UNKNOWN WPP_f32e8b4c95493fd2d2cc17cc251c34cf_Traceguids; // weak
_UNKNOWN WPP_3bd1f756d1cf3533ff3385535c09a7f6_Traceguids; // weak
_UNKNOWN unk_1800805B0; // weak
_UNKNOWN WPP_9c6330531b9f37c0b720c7be8cd79119_Traceguids; // weak
_UNKNOWN WPP_2b8d55565e60367fc767d22ca087624d_Traceguids; // weak
_UNKNOWN WPP_fa1b8c42477831648a2e44d3a9ea2fb6_Traceguids; // weak
_UNKNOWN WPP_3a28f766f52e3b91612b0fe468777cfd_Traceguids; // weak
wchar_t aLasttime[11] = L"::LastTime"; // weak
_UNKNOWN WPP_cb202d2a42b13414d5ff4ecf77487b4e_Traceguids; // weak
int _ResolveDelayLoadedAPIFlags = 0; // weak
__int64 _pfnDefaultDliFailureHook2 = 0LL; // weak
_UNKNOWN unk_180080F3C; // weak
_UNKNOWN unk_180080F74; // weak
_DWORD dword_1800822B0[120] =
{
  -1072894463,
  4001,
  -1072894462,
  4002,
  -1072894461,
  4003,
  -1072894460,
  4004,
  -1072894431,
  4005,
  -1072894430,
  4006,
  -1072894429,
  4007,
  -1072894428,
  4008,
  -1072894427,
  4009,
  -1072894426,
  4010,
  -1072894425,
  4011,
  -1072894424,
  4012,
  -1072894423,
  4013,
  -1072894422,
  4014,
  -1072894421,
  4015,
  -1072894420,
  4016,
  -1072894419,
  4017,
  -1072894418,
  4018,
  -1072894417,
  4019,
  -1072894416,
  4020,
  -1072894415,
  4021,
  -1072894414,
  4022,
  -1072894413,
  4023,
  -1072894412,
  4024,
  -1072894411,
  4025,
  -1072894410,
  4026,
  -1072894409,
  4027,
  -1072894408,
  4028,
  -1072894407,
  4029,
  -1072894406,
  4030,
  -1072894405,
  4031,
  -1072894404,
  4032,
  -1072894403,
  4033,
  -1072894402,
  4034,
  -1072894401,
  4035,
  -1072894400,
  4036,
  -1072894399,
  4037,
  -1072894398,
  4038,
  -1072894397,
  4039,
  -1072894396,
  4040,
  -1072894395,
  4041,
  -1072894394,
  4042,
  -1072894393,
  4043,
  -1072894392,
  4044,
  -1072894391,
  4045,
  -1072894390,
  4046,
  -1072894389,
  4047,
  -1072894388,
  4048,
  -1072894387,
  4049,
  -1072894386,
  4050,
  -1072894367,
  4051,
  -1072894366,
  4052,
  -1072894365,
  4053,
  -1072894364,
  4054,
  -1072894363,
  4055,
  -1072894362,
  4056,
  -1072894361,
  4057,
  -1072894360,
  4058,
  -1072894359,
  4059,
  -1072894358,
  4060
}; // weak
_UNKNOWN WPP_66bc7a8e9c2933fa102678c8dfb90698_Traceguids; // weak
_UNKNOWN WPP_6a02f12a6b2c3ac58024ebcfa94f3c9a_Traceguids; // weak
_UNKNOWN WPP_7017595665aa327ef55a7f0df9945125_Traceguids; // weak
GUID CLSID_CNetworkListManager = { 2759424466u, 50201u, 4569u, { 165u, 180u, 0u, 17u, 133u, 173u, 43u, 137u } };
GUID IID_INetworkListManagerPrivate =
{
  3490140157u,
  22287u,
  19099u,
  { 141u, 105u, 25u, 159u, 219u, 165u, 114u, 59u }
};
const _ThrowInfo TI3_AVlength_error_std__ = { 0u, 193572, 0, 593784 }; // idb
const _ThrowInfo TI3_AVout_of_range_std__ = { 0u, 193572, 0, 593888 }; // idb
const _ThrowInfo TI3_AVGenericException_wmi__ = { 0u, 302768, 0, 594080 }; // idb
const _ThrowInfo TI4_AVOutOfMemoryException_wmi__ = { 0u, 302768, 0, 594144 }; // idb
const _ThrowInfo TI2_AVResultException_wil__ = { 0u, 356068, 0, 594256 }; // idb
const _ThrowInfo TI1_AV_com_error__ = { 0u, 447788, 0, 594392 }; // idb
int _DELAY_IMPORT_DESCRIPTOR_api_ms_win_core_com_l1_1_0_dll = 1; // weak
int _DELAY_IMPORT_DESCRIPTOR_api_ms_win_service_core_l1_1_3_dll = 1; // weak
int _DELAY_IMPORT_DESCRIPTOR_api_ms_win_service_management_l1_1_0_dll = 1; // weak
int _DELAY_IMPORT_DESCRIPTOR_api_ms_win_service_private_l1_1_0_dll = 1; // weak
int _DELAY_IMPORT_DESCRIPTOR_wkscli_dll = 1; // weak
int _DELAY_IMPORT_DESCRIPTOR_netutils_dll = 1; // weak
int _DELAY_IMPORT_DESCRIPTOR_api_ms_win_service_core_l1_1_0_dll = 1; // weak
int _DELAY_IMPORT_DESCRIPTOR_api_ms_win_security_sddl_l1_1_0_dll = 1; // weak
int _DELAY_IMPORT_DESCRIPTOR_api_ms_win_security_lsapolicy_l1_1_0_dll = 1; // weak
int _DELAY_IMPORT_DESCRIPTOR_api_ms_win_security_lsalookup_l2_1_0_dll = 1; // weak
int _DELAY_IMPORT_DESCRIPTOR_SspiCli_dll = 1; // weak
int _DELAY_IMPORT_DESCRIPTOR_api_ms_win_security_lsalookup_l1_1_0_dll = 1; // weak
int _DELAY_IMPORT_DESCRIPTOR_AUTHZ_dll = 1; // weak
int _DELAY_IMPORT_DESCRIPTOR_api_ms_win_security_provider_l1_1_0_dll = 1; // weak
int _DELAY_IMPORT_DESCRIPTOR_api_ms_win_security_credentials_l1_1_0_dll = 1; // weak
int _DELAY_IMPORT_DESCRIPTOR_bcrypt_dll = 1; // weak
int _DELAY_IMPORT_DESCRIPTOR_api_ms_win_power_setting_l1_1_0_dll = 1; // weak
int _DELAY_IMPORT_DESCRIPTOR_POWRPROF_dll = 1; // weak
int _DELAY_IMPORT_DESCRIPTOR_logoncli_dll = 1; // weak
int _DELAY_IMPORT_DESCRIPTOR_USERENV_dll = 1; // weak
int _DELAY_IMPORT_DESCRIPTOR_WMICLNT_dll = 1; // weak
int _DELAY_IMPORT_DESCRIPTOR_ext_ms_win_session_usermgr_l1_1_0_dll = 1; // weak
int _DELAY_IMPORT_DESCRIPTOR_ext_ms_win_wevtapi_eventlog_l1_1_0_dll = 1; // weak
int _DELAY_IMPORT_DESCRIPTOR_ext_ms_win_wevtapi_eventlog_l1_1_2_dll = 1; // weak
int _DELAY_IMPORT_DESCRIPTOR_ext_ms_win_session_wtsapi32_l1_1_0_dll = 1; // weak
int _DELAY_IMPORT_DESCRIPTOR_ext_ms_win_shell_shlwapi_l1_1_0_dll = 1; // weak
int _DELAY_IMPORT_DESCRIPTOR_XmlLite_dll = 1; // weak
int _DELAY_IMPORT_DESCRIPTOR_api_ms_win_service_winsvc_l1_1_0_dll = 1; // weak
_UNKNOWN unk_180096000; // weak
void *WPP_GLOBAL_Control = &WPP_GLOBAL_Control; // weak
unsigned __int16 * near *PathExts = &aCom; // weak
_UNKNOWN ModuleTracker::init; // weak
unsigned int dword_1800AFC38 = 4294967295u; // idb
int dword_1800AFC48 = -1; // weak
int dword_1800AFC58 = -1; // weak
int dword_1800AFC68 = -1; // weak
int dword_1800AFC78 = -1; // weak
int dword_1800AFC88 = -1; // weak
int dword_1800AFCB8 = -1; // weak
int dword_1800AFCC8 = -1; // weak
int dword_1800AFCD8 = -1; // weak
int dword_1800AFCE8 = -1; // weak
int dword_1800AFCF8 = -1; // weak
int dword_1800AFD08 = -1; // weak
int dword_1800AFD18 = -1; // weak
int dword_1800AFD28 = -1; // weak
int dword_1800AFD38 = -1; // weak
int dword_1800AFD48 = -1; // weak
int dword_1800AFD58 = -1; // weak
int dword_1800AFD68 = -1; // weak
unsigned __int16 *off_1800AFD70 = &aExe_0; // idb
unsigned __int16 *off_1800AFD80 = &aPif; // idb
int dword_1800AFD98 = 0; // weak
REGHANDLE qword_1800AFDB8 = 0uLL; // idb
int dword_1800AFDD0 = 0; // idb
__int64 qword_1800AFDE0 = 0LL; // weak
__int64 qword_1800AFDE8 = 0LL; // weak
REGHANDLE qword_1800AFDF0 = 0uLL; // idb
_UNKNOWN ModuleTracker::uninit; // weak
int dword_1800AFE18[] = { -1 }; // weak
int dword_1800AFE38 = -1; // weak
int dword_1800AFE48 = -1; // weak
int dword_1800AFE58 = -1; // weak
int dword_1800AFE68 = -1; // weak
int dword_1800AFE98 = -1; // weak
int dword_1800AFEA8 = -1; // weak
int dword_1800AFEB8 = -1; // weak
int dword_1800AFEC8 = -1; // weak
int dword_1800AFED8 = -1; // weak
int dword_1800AFEE8 = -1; // weak
int dword_1800AFF08 = -1; // weak
int dword_1800AFF18 = -1; // weak
int dword_1800AFF28 = -1; // weak
int dword_1800AFF48 = -1; // weak
void **std::_Error_objects<int>::_System_object[3] =
{
  &std::_System_error_category::`vftable',
  &std::_Iostream_error_category::`vftable',
  &std::_Generic_error_category::`vftable'
}; // weak
void **std::_Error_objects<int>::_Iostream_object[2] =
{
  &std::_Iostream_error_category::`vftable',
  &std::_Generic_error_category::`vftable'
}; // weak
void **std::_Error_objects<int>::_Generic_object = &std::_Generic_error_category::`vftable'; // weak
int dword_1800AFF68 = 0; // idb
__int64 qword_1800AFF78 = 0LL; // weak
__int64 qword_1800AFF80 = 0LL; // weak
REGHANDLE RegHandle = 0uLL; // idb
char *wil::details::g_processLocalData = "WilError_03"; // weak
LPVOID qword_1800AFFA8 = NULL; // idb
void **UbpmProxySingleton::s_singleton[2] = { &UbpmProxySingleton::`vftable', &type_info::`vftable' }; // weak
int _native_dllmain_reason = -1; // weak
uintptr_t _security_cookie = 47936899621426uLL;
__int64 _security_cookie_complement = -47936899621427LL; // weak
int Init_global_epoch = 2147483648; // weak
unsigned int ExtsFound = 10u; // weak
int dword_1800B01F4 = 1; // weak
int dword_1800B01F8 = 1; // weak
volatile int wil::details::ThreadFailureCallbackHolder::s_telemetryId = 1; // weak
BYTE NullData[16] = { 72u, 77u, 72u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }; // weak
int dword_1800B022C = 0; // weak
int dword_1800B0230 = 0; // weak
int dword_1800B0858; // weak
RTL_SRWLOCK stru_1800B0888; // idb
RTL_CONDITION_VARIABLE ConditionVariable; // idb
int tls_index; // weak
__int64 _native_startup_lock; // weak
int _native_startup_state; // weak
__int64 _onexitend; // weak
void *_onexitbegin; // idb
__int64 _dyn_tls_init_callback; // weak
__int64 (__fastcall *pRawDllMain)(_QWORD, _QWORD, _QWORD); // weak
HINSTANCE g_hInstance; // weak
__int64 g_wil_details_pfnRtlNotifyFeatureUsage; // weak
__int64 g_wil_details_pfnRtlQueryFeatureConfiguration; // weak
__int64 g_wil_details_pfnRtlRegisterFeatureConfigurationChangeNotification; // weak
__int64 g_wil_details_pfnRtlUnregisterFeatureConfigurationChangeNotification; // weak
__int64 wil::details_abi::g_pProcessLocalData; // weak
__int64 wil::details::g_pThreadFailureCallbacks; // weak
void (__stdcall *wil::details::g_pfnGetContextAndNotifyFailure)(struct wil::FailureInfo *, char *, unsigned __int64); // weak
void (*wil::details::g_pfnRethrow)(void); // weak
void (__stdcall *wil::details::g_pfnThrowResultException)(const struct wil::FailureInfo *); // weak
int `wil::details::RecordException'::`2'::s_hrErrorLast; // weak
int `wil::details::RecordFailFast'::`2'::s_hrErrorLast; // weak
__int64 g_wil_details_pfnRtlSubscribeWnfStateChangeNotification; // weak
__int64 g_wil_details_pfnNtQueryWnfStateData; // weak
__int64 `wil::details::RtlDisownModuleHeapAllocation'::`2'::s_pfnRtlDisownModuleHeapAllocation; // weak
__int64 g_wil_details_pfnRtlUnsubscribeWnfNotificationWaitForCompletion; // weak
__int64 g_wil_details_pfnNtUpdateWnfStateData; // weak
int `wil::details::RecordReturn'::`2'::s_hrErrorLast; // weak
int `wil::details::RecordLog'::`2'::s_hrErrorLast; // weak
char byte_1800B09E8; // weak
char byte_1800B09E9; // weak
struct MicrosoftTelemetryAssertTriggeredNode *g_MicrosoftTelemetryAssertsTriggeredList; // weak
__int64 qword_1800B09F8; // weak
HLOCAL tsched::StoreSecurity::g_pRestrictedKeySecurity; // idb
HLOCAL tsched::StoreSecurity::g_pConfigKeySecurity; // idb
int ShutdownMgr::s_sync; // weak
int dword_1800B0A14; // weak
_UNKNOWN ShutdownMgr::s_hEvent; // weak
_UNKNOWN JobStore::m_hashObject; // weak
ULONG dwBytes; // idb
PUCHAR pbHashObject; // idb
int dword_1800B0A40; // weak
struct _RTL_CRITICAL_SECTION CriticalSection; // idb
_UNKNOWN wil::details::g_enabledStateManager; // weak
__int64 qword_1800B0A78; // weak
__int64 qword_1800B0A80; // weak
char byte_1800B0A88; // weak
int dword_1800B0A8C; // weak
__int128 xmmword_1800B0A90; // weak
__int128 xmmword_1800B0AA0; // weak
__int128 xmmword_1800B0AB0; // weak
_UNKNOWN xmmword_1800B0AC0; // weak
__int128 xmmword_1800B0AD0; // weak
__int64 `wil::details::RtlDllShutdownInProgress'::`2'::s_pfnRtlDllShutdownInProgress; // weak
HINSTANCE g_wil_details_ntdllModuleHandle; // weak
bool byte_1800B0AF0; // idb
HMODULE g_hModuleWpts; // idb
HANDLE g_hShutdownEvent; // idb
Scheduler *g_pScheduler; // idb
PseudoEventTrap *g_pPseudoEventTrap; // idb
EventTrapMap *g_pEventTrapMap; // idb
void *User::s_userCache; // idb
void *User::s_userTable; // idb
LPCRITICAL_SECTION User::s_cs; // idb
EventManager *g_pEventManager; // idb
AuthzAutoHandle *g_pAuditor; // idb
JobStore *JobStore::m_pCommonStore; // idb
LPCRITICAL_SECTION CredStore::g_pCommonStore; // idb
int dword_1800B0B58; // weak
int dword_1800B0B5C; // weak
int dword_1800B0B60; // weak
int dword_1800B0B64; // weak
int dword_1800B0B68; // weak
int dword_1800B0B6C; // weak
_UNKNOWN `wil::details::IsFeatureConfigured'::`2'::machineStoreProbe; // weak
int `wil::details::RecordLog'::`2'::s_cErrorCount; // weak
int `wil::details::RecordException'::`2'::s_cErrorCount; // weak
int `wil::details::LogFailure'::`2'::s_failureId; // weak
int `wil::details::RecordReturn'::`2'::s_cErrorCount; // weak
_UNKNOWN `wil::details::IsFeatureConfigured'::`2'::userStoreProbe; // weak
RTL_SRWLOCK g_MicrosoftTelemetryAssertLock; // idb
_UNKNOWN `wil::Feature<__WilFeatureTraits_Feature_2510298426>::GetImpl'::`2'::impl; // weak
int dword_1800B0BC8; // weak
int dword_1800B0BCC; // weak
RTL_SRWLOCK stru_1800B0BD0; // idb
__int64 ATL::g_strheap; // weak
__int64 qword_1800B0BE0; // weak
char byte_1800B0BE8; // weak
__int64 ATL::g_strmgr; // weak
__int64 qword_1800B0BF8; // weak
__int64 qword_1800B0C00; // weak
__int64 qword_1800B0C08; // weak
int dword_1800B0C10; // weak
int dword_1800B0C18; // weak
__int64 WPP_MAIN_CB; // weak
__int64 qword_1800B0C30; // weak
__int64 qword_1800B0C38; // weak
__int64 WPP_REGISTRATION_GUIDS; // weak
HANDLE g_PrivateHeap; // idb
int dword_1800B0C58; // weak
__int128 g_Idolater; // weak
char byte_1800B0C70; // weak
_UNKNOWN hSourceHandle; // weak
_UNKNOWN xmmword_1800B0C80; // weak
HANDLE WaitHandle; // idb
struct _RTL_CRITICAL_SECTION stru_1800B0CA0; // idb
char byte_1800B0CC8; // weak
__int64 qword_1800B0CD0; // weak
_RTL_CRITICAL_SECTION PlugIn::s_singleton; // weak
__int64 (__fastcall *qword_1800B0D30)(_QWORD); // weak
__int64 (__fastcall *qword_1800B0D38)(_QWORD, _QWORD); // weak
__int64 RpcServer::s_singleton; // weak
RTL_SRWLOCK SRWLock; // idb
int dword_1800B0D60; // weak
VARIANTARG vtMissing; // idb
_UNKNOWN wil::details::g_featureStateManager; // weak
LPVOID qword_1800B0D90; // idb
struct wil::srwlock *qword_1800B0D98; // idb
_UNKNOWN unk_1800B0DA0; // weak
_UNKNOWN unk_1800B0DC8; // weak
_UNKNOWN unk_1800B0E28; // weak
_UNKNOWN wil::details::g_threadFailureCallbacks; // weak
struct _ITSRV_GLOBAL_CONTEXT near *ItSrvGlobalContext; // weak
__int128 xmmword_1800B0EF4; // weak
__int128 xmmword_1800B0F04; // weak
struct _RTL_CRITICAL_SECTION stru_1800B0F18; // idb
struct _LIST_ENTRY stru_1800B0F40; // idb
HANDLE qword_1800B0F50; // idb
int dword_1800B0F58; // weak
struct _RTL_CRITICAL_SECTION stru_1800B0F60; // idb
int dword_1800B0F88; // weak
struct _RTL_CRITICAL_SECTION stru_1800B0F90; // idb
struct _LIST_ENTRY stru_1800B0FB8; // idb
int dword_1800B0FC8; // weak
HANDLE Timer; // idb
int dword_1800B0FD8; // weak
__int128 xmmword_1800B0FE0; // weak
__int128 xmmword_1800B0FF0; // weak
__int128 xmmword_1800B1000; // weak
int dword_1800B1010; // weak
int dword_1800B1014; // weak
int dword_1800B1018; // weak
PTP_CLEANUP_GROUP ptpcg; // idb
RTL_SRWLOCK stru_1800B1028; // idb
__int64 qword_1800B1030; // weak
HANDLE hObject; // idb
HANDLE hEvent; // idb
HANDLE hHandle; // idb
HANDLE qword_1800B1050; // idb
HANDLE qword_1800B1058; // idb
_UNKNOWN unk_1800B1060; // weak
DWORD DueTime; // idb
DWORD Period; // idb
ULONG xmmword_1800B1070; // idb
int dword_1800B1080; // weak
_UNKNOWN unk_1800B1088; // weak
_UNKNOWN byte_1800B1090; // weak
__int64 qword_1800B1094; // weak
__int64 qword_1800B10A0; // weak
LPVOID lpMem; // idb
HANDLE qword_1800B10B8; // idb
int dword_1800B10C0; // weak
int dword_1800B10C4; // weak
int dword_1800B10D0; // weak
__int64 qword_1800B10D8; // weak
int dword_1800B1118; // weak
int dword_1800B111C; // weak
int dword_1800B1128; // weak
__int64 qword_1800B1130; // weak
_UNKNOWN unk_1800B1170; // weak
int dword_1800B11B4; // weak
RPC_BINDING_VECTOR *BindingVector; // idb
char byte_1800B11C0; // weak
char byte_1800B11C1; // weak
char byte_1800B11C2; // weak
HANDLE qword_1800B11C8; // idb
HANDLE qword_1800B11D0; // idb
HPOWERNOTIFY RegistrationHandle; // idb
HPOWERNOTIFY qword_1800B11E0; // idb
__int64 qword_1800B11E8; // weak
int dword_1800B11F0; // weak
int dword_1800B11F4; // weak
int dword_1800B11F8; // weak
HPOWERNOTIFY qword_1800B1208; // idb
int dword_1800B1210; // weak
HPOWERNOTIFY qword_1800B1218; // idb
int dword_1800B1220; // weak
HPOWERNOTIFY qword_1800B1228; // idb
int dword_1800B1230; // weak
HPOWERNOTIFY qword_1800B1238; // idb
int dword_1800B1240; // weak
__int64 qword_1800B1248; // weak
__int64 qword_1800B1250; // weak
unsigned int JobsService::s_dwLastNotificationMaskReceived; // weak
OLECHAR CmdExe::m_buffer[264]; // weak
HANDLE TSchedStartEvent; // idb
HANDLE TSchedStopEvent; // idb
int (__stdcall *wil::details::g_pfnRtlDisownModuleHeapAllocation)(void *, void *); // weak
void (*wil::details::g_pfnDebugBreak)(void); // weak
const char *(*wil::details::g_pfnGetModuleName)(void); // weak
void (__stdcall *wil::details::g_pfnRaiseFailFastException)(struct _EXCEPTION_RECORD *, struct _CONTEXT *, unsigned int); // weak
unsigned int (__stdcall *wil::details::g_pfnRtlNtStatusToDosErrorNoTeb)(int); // weak
__int64 g_wil_details_internalRecordFeatureUsage; // weak
__int64 (__fastcall *g_wil_details_RecordSRUMFeatureUsage)(_QWORD, _QWORD, _QWORD); // weak
__int64 g_wil_details_internalGetFeatureEnabledState; // weak
char byte_1800B14D1; // weak
unsigned __int8 (*wil::details::g_pfnDllShutdownInProgress)(void); // weak
WCHAR User::s_computername; // idb
bool (*wil::g_pfnIsDebuggerPresent)(void); // weak
bool wil::g_fIsDebuggerPresent; // weak
bool wil::g_fBreakOnFailure; // weak
__int64 (__fastcall *g_pfnResultLoggingCallback)(_QWORD, _QWORD, _QWORD); // weak
void (__stdcall *wil::details::g_pfnTelemetryCallback)(bool, const struct wil::FailureInfo *); // weak
bool wil::details::g_resultMessageCallbackSet; // weak
void (__stdcall *wil::details::g_pfnLoggingCallback)(const struct wil::FailureInfo *); // weak
__int64 g_pfnThrowPlatformException; // weak
void (__stdcall *wil::details::g_pfnOriginateCallback)(const struct wil::FailureInfo *); // weak
bool wil::details::g_processShutdownInProgress; // weak
bool (__stdcall *wil::g_pfnWilFailFast)(const struct wil::FailureInfo *); // weak
char `wil::details::GetCurrentModuleName'::`2'::s_fModuleValid; // weak
int `wil::SetLastError'::`2'::lastThread; // weak
int `wil::SetLastError'::`5'::depth; // weak
__int64 g_wil_details_internalSubscribeFeatureStateChangeNotification; // weak
__int64 g_wil_details_apiRecordFeatureUsage; // weak
unsigned int `wil::details::GetCurrentModuleName'::`2'::s_szModule[16]; // weak
__int64 g_wil_details_apiSubscribeFeatureStateChangeNotification; // weak
__int64 `wil::details::RtlNtStatusToDosErrorNoTeb'::`2'::s_pfnRtlNtStatusToDosErrorNoTeb; // weak
__int64 g_wil_details_apiGetFeatureEnabledState; // weak
__int64 g_wil_details_internalUnsubscribeFeatureStateChangeNotification; // weak
__int64 g_wil_details_apiUnsubscribeFeatureStateChangeNotification; // weak
__int64 (__fastcall *g_wil_details_pfnFeatureLoggingHook)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD); // weak
// extern BOOL (__stdcall *AuthzFreeAuditEvent)(AUTHZ_AUDIT_EVENT_HANDLE hAuditEvent);
// extern POWER_PLATFORM_ROLE (__stdcall *PowerDeterminePlatformRole)();
// extern NTSTATUS (__stdcall *LsaFreeReturnBuffer)(PVOID Buffer);
// extern NTSTATUS (__stdcall *LsaDeregisterLogonProcess)(HANDLE LsaHandle);
// extern NTSTATUS (__stdcall *LsaConnectUntrusted)(PHANDLE LsaHandle);
// extern NTSTATUS (__stdcall *LsaLookupAuthenticationPackage)(HANDLE LsaHandle, PLSA_STRING PackageName, PULONG AuthenticationPackage);
// extern BOOLEAN (__stdcall *GetUserNameExW)(EXTENDED_NAME_FORMAT NameFormat, LPWSTR lpNameBuffer, PULONG nSize);
// extern NTSTATUS (__stdcall *LsaCallAuthenticationPackage)(HANDLE LsaHandle, ULONG AuthenticationPackage, PVOID ProtocolSubmitBuffer, ULONG SubmitBufferLength, PVOID *ProtocolReturnBuffer, PULONG ReturnBufferLength, PNTSTATUS ProtocolStatus);
// extern HRESULT (__stdcall *CreateXmlWriter)(const IID *const riid, void **ppvObject, IMalloc *pMalloc);
// extern HRESULT (__stdcall *CreateXmlWriterOutputWithEncodingName)(IUnknown *pOutputStream, IMalloc *pMalloc, LPCWSTR pwszEncodingName, IXmlWriterOutput **ppOutput);
// extern HRESULT (__stdcall *CreateXmlReader)(const IID *const riid, void **ppvObject, IMalloc *pMalloc);
// extern void (__stdcall *CoTaskMemFree)(LPVOID pv);
// extern HRESULT (__stdcall *CLSIDFromString)(LPCOLESTR lpsz, LPCLSID pclsid);
// extern void (__stdcall *CoUninitialize)();
// extern void (__stdcall *CoFreeUnusedLibraries)();
// extern HRESULT (__stdcall *StringFromCLSID)(const IID *const rclsid, LPOLESTR *lplpsz);
// extern HRESULT (__stdcall *CoCreateInstance)(const IID *const rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, const IID *const riid, LPVOID *ppv);
// extern HRESULT (__stdcall *CoCreateGuid)(GUID *pguid);
// extern int (__stdcall *StringFromGUID2)(const GUID *const rguid, LPOLESTR lpsz, int cchMax);
// extern HRESULT (__stdcall *IIDFromString)(LPCOLESTR lpsz, LPIID lpiid);
// extern HRESULT (__stdcall *CoInitializeEx)(LPVOID pvReserved, DWORD dwCoInit);
// extern DWORD (__stdcall *PowerSettingRegisterNotification)(LPCGUID SettingGuid, DWORD Flags, HANDLE Recipient, PHPOWERNOTIFY RegistrationHandle);
// extern DWORD (__stdcall *PowerSettingUnregisterNotification)(HPOWERNOTIFY RegistrationHandle);
// extern BOOL (__stdcall *CredMarshalCredentialW)(CRED_MARSHAL_TYPE CredType, PVOID Credential, LPWSTR *MarshaledCredential);
// extern BOOL (__stdcall *CredWriteW)(PCREDENTIALW Credential, DWORD Flags);
// extern BOOL (__stdcall *CredDeleteW)(LPCWSTR TargetName, DWORD Type, DWORD Flags);
// extern BOOL (__stdcall *CredEnumerateW)(LPCWSTR Filter, DWORD Flags, DWORD *Count, PCREDENTIALW **Credential);
// extern void (__stdcall *CredFree)(PVOID Buffer);
// extern BOOL (__stdcall *LookupAccountNameLocalW)(LPCWSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse);
// extern BOOL (__stdcall *LookupAccountSidLocalW)(PSID Sid, LPWSTR Name, LPDWORD cchName, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse);
// extern BOOL (__stdcall *LookupAccountNameW)(LPCWSTR lpSystemName, LPCWSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse);
// extern BOOL (__stdcall *LookupPrivilegeValueW)(LPCWSTR lpSystemName, LPCWSTR lpName, PLUID lpLuid);
// extern NTSTATUS (__stdcall *LsaFreeMemory)(PVOID Buffer);
// extern NTSTATUS (__stdcall *LsaQueryInformationPolicy)(LSA_HANDLE PolicyHandle, POLICY_INFORMATION_CLASS InformationClass, PVOID *Buffer);
// extern NTSTATUS (__stdcall *LsaClose)(LSA_HANDLE ObjectHandle);
// extern NTSTATUS (__stdcall *LsaOpenPolicy)(PLSA_UNICODE_STRING SystemName, PLSA_OBJECT_ATTRIBUTES ObjectAttributes, ACCESS_MASK DesiredAccess, PLSA_HANDLE PolicyHandle);
// extern DWORD (__stdcall *GetNamedSecurityInfoW)(LPCWSTR pObjectName, SE_OBJECT_TYPE ObjectType, SECURITY_INFORMATION SecurityInfo, PSID *ppsidOwner, PSID *ppsidGroup, PACL *ppDacl, PACL *ppSacl, PSECURITY_DESCRIPTOR *ppSecurityDescriptor);
// extern DWORD (__stdcall *SetSecurityInfo)(HANDLE handle, SE_OBJECT_TYPE ObjectType, SECURITY_INFORMATION SecurityInfo, PSID psidOwner, PSID psidGroup, PACL pDacl, PACL pSacl);
// extern DWORD (__stdcall *GetSecurityInfo)(HANDLE handle, SE_OBJECT_TYPE ObjectType, SECURITY_INFORMATION SecurityInfo, PSID *ppsidOwner, PSID *ppsidGroup, PACL *ppDacl, PACL *ppSacl, PSECURITY_DESCRIPTOR *ppSecurityDescriptor);
// extern BOOL (__stdcall *ConvertSecurityDescriptorToStringSecurityDescriptorW)(PSECURITY_DESCRIPTOR SecurityDescriptor, DWORD RequestedStringSDRevision, SECURITY_INFORMATION SecurityInformation, LPWSTR *StringSecurityDescriptor, PULONG StringSecurityDescriptorLen);
// extern BOOL (__stdcall *ConvertStringSecurityDescriptorToSecurityDescriptorW)(LPCWSTR StringSecurityDescriptor, DWORD StringSDRevision, PSECURITY_DESCRIPTOR *SecurityDescriptor, PULONG SecurityDescriptorSize);
// extern BOOL (__stdcall *ConvertStringSidToSidW)(LPCWSTR StringSid, PSID *Sid);
// extern BOOL (__stdcall *ConvertSidToStringSidW)(PSID Sid, LPWSTR *StringSid);
// extern SERVICE_STATUS_HANDLE (__stdcall *RegisterServiceCtrlHandlerExW)(LPCWSTR lpServiceName, LPHANDLER_FUNCTION_EX lpHandlerProc, LPVOID lpContext);
// extern BOOL (__stdcall *SetServiceStatus)(SERVICE_STATUS_HANDLE hServiceStatus, LPSERVICE_STATUS lpServiceStatus);
// extern BOOL (__stdcall *CloseServiceHandle)(SC_HANDLE hSCObject);
// extern SC_HANDLE (__stdcall *OpenServiceW)(SC_HANDLE hSCManager, LPCWSTR lpServiceName, DWORD dwDesiredAccess);
// extern SC_HANDLE (__stdcall *OpenSCManagerW)(LPCWSTR lpMachineName, LPCWSTR lpDatabaseName, DWORD dwDesiredAccess);
// extern BOOL (__stdcall *QueryServiceStatus)(SC_HANDLE hService, LPSERVICE_STATUS lpServiceStatus);
// extern NTSTATUS (__stdcall *BCryptDestroyHash)(BCRYPT_HASH_HANDLE hHash);
// extern NTSTATUS (__stdcall *BCryptHashData)(BCRYPT_HASH_HANDLE hHash, PUCHAR pbInput, ULONG cbInput, ULONG dwFlags);
// extern NTSTATUS (__stdcall *BCryptGetProperty)(BCRYPT_HANDLE hObject, LPCWSTR pszProperty, PUCHAR pbOutput, ULONG cbOutput, ULONG *pcbResult, ULONG dwFlags);
// extern NTSTATUS (__stdcall *BCryptFinishHash)(BCRYPT_HASH_HANDLE hHash, PUCHAR pbOutput, ULONG cbOutput, ULONG dwFlags);
// extern NTSTATUS (__stdcall *BCryptOpenAlgorithmProvider)(BCRYPT_ALG_HANDLE *phAlgorithm, LPCWSTR pszAlgId, LPCWSTR pszImplementation, ULONG dwFlags);
// extern NTSTATUS (__stdcall *BCryptCreateHash)(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_HASH_HANDLE *phHash, PUCHAR pbHashObject, ULONG cbHashObject, PUCHAR pbSecret, ULONG cbSecret, ULONG dwFlags);
// extern NTSTATUS (__stdcall *BCryptCloseAlgorithmProvider)(BCRYPT_ALG_HANDLE hAlgorithm, ULONG dwFlags);
// extern BOOL (__stdcall *WTSQuerySessionInformationW)(HANDLE hServer, DWORD SessionId, WTS_INFO_CLASS WTSInfoClass, LPWSTR *ppBuffer, DWORD *pBytesReturned);
// extern BOOL (__stdcall *WTSQueryUserToken)(ULONG SessionId, PHANDLE phToken);
// extern void (__stdcall *WTSFreeMemory)(PVOID pMemory);
// extern BOOL (__stdcall *WTSEnumerateSessionsW)(HANDLE hServer, DWORD Reserved, DWORD Version, PWTS_SESSION_INFOW *ppSessionInfo, DWORD *pCount);
// extern HRESULT (__stdcall *AssocQueryStringW)(ASSOCF flags, ASSOCSTR str, LPCWSTR pszAssoc, LPCWSTR pszExtra, LPWSTR pszOut, DWORD *pcchOut);
// extern EVT_HANDLE (__stdcall *EvtCreateRenderContext)(DWORD ValuePathsCount, LPCWSTR *ValuePaths, DWORD Flags);
// extern EVT_HANDLE (__stdcall *EvtSubscribe)(EVT_HANDLE Session, HANDLE SignalEvent, LPCWSTR ChannelPath, LPCWSTR Query, EVT_HANDLE Bookmark, PVOID Context, EVT_SUBSCRIBE_CALLBACK Callback, DWORD Flags);
// extern BOOL (__stdcall *EvtGetChannelConfigProperty)(EVT_HANDLE ChannelConfig, EVT_CHANNEL_CONFIG_PROPERTY_ID PropertyId, DWORD Flags, DWORD PropertyValueBufferSize, PEVT_VARIANT PropertyValueBuffer, PDWORD PropertyValueBufferUsed);
// extern BOOL (__stdcall *EvtRender)(EVT_HANDLE Context, EVT_HANDLE Fragment, DWORD Flags, DWORD BufferSize, PVOID Buffer, PDWORD BufferUsed, PDWORD PropertyCount);
// extern EVT_HANDLE (__stdcall *EvtOpenChannelConfig)(EVT_HANDLE Session, LPCWSTR ChannelPath, DWORD Flags);
// extern BOOL (__stdcall *EvtClose)(EVT_HANDLE Object);
// extern BOOL (__stdcall *EvtSetChannelConfigProperty)(EVT_HANDLE ChannelConfig, EVT_CHANNEL_CONFIG_PROPERTY_ID PropertyId, DWORD Flags, PEVT_VARIANT PropertyValue);
// extern BOOL (__stdcall *EvtSaveChannelConfig)(EVT_HANDLE ChannelConfig, DWORD Flags);
// extern NTSTATUS (__stdcall *NetIsServiceAccount)(LPWSTR ServerName, LPWSTR AccountName, BOOL *IsService);
// extern DWORD (__stdcall *NetApiBufferFree)(LPVOID Buffer);
// extern DWORD (__stdcall *NetGetJoinInformation)(LPCWSTR lpServer, LPWSTR *lpNameBuffer, PNETSETUP_JOIN_STATUS BufferType);


//----- (0000000180001008) ----------------------------------------------------
ULONG __fastcall _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<>(
        __int64 a1,
        unsigned __int8 *a2)
{
  struct _EVENT_DATA_DESCRIPTOR v3; // [rsp+30h] [rbp-38h] BYREF

  return tlgWriteTransfer_EventWriteTransfer((__int64)&dword_1800AFF68, a2, 0LL, 0LL, 2u, &v3);
}

//----- (0000000180001058) ----------------------------------------------------
ULONG __fastcall _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapSid<_SID>,_tlgWrapSz<unsigned short>,_tlgWrapSz<unsigned short>,_tlgWrapSz<unsigned short>,_tlgWrapperByVal<4>>(
        __int64 a1,
        unsigned __int8 *a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        const WCHAR **a6,
        const WCHAR **a7,
        const WCHAR **a8,
        __int64 a9)
{
  __int64 v10; // rcx
  int v11; // r8d
  const WCHAR *v12; // rdx
  __int64 v13; // rax
  int v14; // r9d
  const WCHAR *v15; // rdx
  __int64 v16; // rax
  int v17; // r9d
  const WCHAR *v18; // rdx
  int v19; // eax
  struct _EVENT_DATA_DESCRIPTOR v21; // [rsp+30h] [rbp-51h] BYREF
  __int64 v22; // [rsp+50h] [rbp-31h]
  int v23; // [rsp+58h] [rbp-29h]
  int v24; // [rsp+5Ch] [rbp-25h]
  const WCHAR *v25; // [rsp+60h] [rbp-21h]
  int v26; // [rsp+68h] [rbp-19h]
  int v27; // [rsp+6Ch] [rbp-15h]
  const WCHAR *v28; // [rsp+70h] [rbp-11h]
  int v29; // [rsp+78h] [rbp-9h]
  int v30; // [rsp+7Ch] [rbp-5h]
  const WCHAR *v31; // [rsp+80h] [rbp-1h]
  int v32; // [rsp+88h] [rbp+7h]
  int v33; // [rsp+8Ch] [rbp+Bh]
  __int64 v34; // [rsp+90h] [rbp+Fh]
  __int64 v35; // [rsp+98h] [rbp+17h]

  v34 = a9;
  v10 = -1LL;
  v35 = 4LL;
  v11 = 2;
  v12 = *a8;
  if ( *a8 )
  {
    v13 = -1LL;
    do
      ++v13;
    while ( v12[v13] );
    v14 = 2 * v13 + 2;
  }
  else
  {
    v12 = &ChannelPath;
    v14 = 2;
  }
  v31 = v12;
  v32 = v14;
  v33 = 0;
  v15 = *a7;
  if ( *a7 )
  {
    v16 = -1LL;
    do
      ++v16;
    while ( v15[v16] );
    v17 = 2 * v16 + 2;
  }
  else
  {
    v15 = &ChannelPath;
    v17 = 2;
  }
  v28 = v15;
  v29 = v17;
  v30 = 0;
  v18 = *a6;
  if ( *a6 )
  {
    do
      ++v10;
    while ( v18[v10] );
    v11 = 2 * v10 + 2;
  }
  else
  {
    v18 = &ChannelPath;
  }
  v25 = v18;
  v26 = v11;
  v27 = 0;
  v19 = *(unsigned __int8 *)(*(_QWORD *)a5 + 1LL);
  v22 = *(_QWORD *)a5;
  v24 = 0;
  v23 = 4 * v19 + 8;
  return tlgWriteTransfer_EventWriteTransfer((__int64)&dword_1800AFF68, a2, 0LL, 0LL, 7u, &v21);
}

//----- (0000000180001198) ----------------------------------------------------
ULONG __fastcall _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapSid<_SID>,_tlgWrapSz<unsigned short>,_tlgWrapSz<unsigned short>,_tlgWrapperByVal<4>>(
        __int64 a1,
        unsigned __int8 *a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        const WCHAR **a6,
        const WCHAR **a7,
        __int64 a8)
{
  __int64 v9; // rcx
  int v10; // r9d
  const WCHAR *v11; // rdx
  __int64 v12; // rax
  int v13; // r8d
  const WCHAR *v14; // rdx
  int v15; // eax
  struct _EVENT_DATA_DESCRIPTOR v17; // [rsp+30h] [rbp-39h] BYREF
  __int64 v18; // [rsp+50h] [rbp-19h]
  int v19; // [rsp+58h] [rbp-11h]
  int v20; // [rsp+5Ch] [rbp-Dh]
  const WCHAR *v21; // [rsp+60h] [rbp-9h]
  int v22; // [rsp+68h] [rbp-1h]
  int v23; // [rsp+6Ch] [rbp+3h]
  const WCHAR *v24; // [rsp+70h] [rbp+7h]
  int v25; // [rsp+78h] [rbp+Fh]
  int v26; // [rsp+7Ch] [rbp+13h]
  __int64 v27; // [rsp+80h] [rbp+17h]
  __int64 v28; // [rsp+88h] [rbp+1Fh]

  v27 = a8;
  v9 = -1LL;
  v28 = 4LL;
  v10 = 2;
  v11 = *a7;
  if ( *a7 )
  {
    v12 = -1LL;
    do
      ++v12;
    while ( v11[v12] );
    v13 = 2 * v12 + 2;
  }
  else
  {
    v11 = &ChannelPath;
    v13 = 2;
  }
  v24 = v11;
  v25 = v13;
  v26 = 0;
  v14 = *a6;
  if ( *a6 )
  {
    do
      ++v9;
    while ( v14[v9] );
    v10 = 2 * v9 + 2;
  }
  else
  {
    v14 = &ChannelPath;
  }
  v21 = v14;
  v22 = v10;
  v23 = 0;
  v15 = *(unsigned __int8 *)(*(_QWORD *)a5 + 1LL);
  v18 = *(_QWORD *)a5;
  v20 = 0;
  v19 = 4 * v15 + 8;
  return tlgWriteTransfer_EventWriteTransfer((__int64)&dword_1800AFF68, a2, 0LL, 0LL, 6u, &v17);
}

//----- (00000001800012A0) ----------------------------------------------------
ULONG __fastcall _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapSz<unsigned short>,_tlgWrapSz<unsigned short>,_tlgWrapSz<unsigned short>,_tlgWrapperByVal<4>>(
        __int64 a1,
        unsigned __int8 *a2,
        __int64 a3,
        __int64 a4,
        const WCHAR **a5,
        const WCHAR **a6,
        const WCHAR **a7,
        __int64 a8)
{
  __int64 v9; // rcx
  int v10; // r8d
  const WCHAR *v11; // rdx
  __int64 v12; // rax
  int v13; // r9d
  const WCHAR *v14; // rdx
  __int64 v15; // rax
  int v16; // r9d
  const WCHAR *v17; // rdx
  struct _EVENT_DATA_DESCRIPTOR v19; // [rsp+30h] [rbp-39h] BYREF
  const WCHAR *v20; // [rsp+50h] [rbp-19h]
  int v21; // [rsp+58h] [rbp-11h]
  int v22; // [rsp+5Ch] [rbp-Dh]
  const WCHAR *v23; // [rsp+60h] [rbp-9h]
  int v24; // [rsp+68h] [rbp-1h]
  int v25; // [rsp+6Ch] [rbp+3h]
  const WCHAR *v26; // [rsp+70h] [rbp+7h]
  int v27; // [rsp+78h] [rbp+Fh]
  int v28; // [rsp+7Ch] [rbp+13h]
  __int64 v29; // [rsp+80h] [rbp+17h]
  __int64 v30; // [rsp+88h] [rbp+1Fh]

  v29 = a8;
  v9 = -1LL;
  v30 = 4LL;
  v10 = 2;
  v11 = *a7;
  if ( *a7 )
  {
    v12 = -1LL;
    do
      ++v12;
    while ( v11[v12] );
    v13 = 2 * v12 + 2;
  }
  else
  {
    v11 = &ChannelPath;
    v13 = 2;
  }
  v26 = v11;
  v27 = v13;
  v28 = 0;
  v14 = *a6;
  if ( *a6 )
  {
    v15 = -1LL;
    do
      ++v15;
    while ( v14[v15] );
    v16 = 2 * v15 + 2;
  }
  else
  {
    v14 = &ChannelPath;
    v16 = 2;
  }
  v23 = v14;
  v24 = v16;
  v25 = 0;
  v17 = *a5;
  if ( *a5 )
  {
    do
      ++v9;
    while ( v17[v9] );
    v10 = 2 * v9 + 2;
  }
  else
  {
    v17 = &ChannelPath;
  }
  v20 = v17;
  v21 = v10;
  v22 = 0;
  return tlgWriteTransfer_EventWriteTransfer((__int64)&dword_1800AFF68, a2, 0LL, 0LL, 6u, &v19);
}

//----- (00000001800013C4) ----------------------------------------------------
ULONG __fastcall _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapperByVal<4>,_tlgWrapSid<_SID>>(
        __int64 a1,
        unsigned __int8 *a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  int v6; // eax
  struct _EVENT_DATA_DESCRIPTOR v8; // [rsp+30h] [rbp-58h] BYREF
  __int64 v9; // [rsp+50h] [rbp-38h]
  int v10; // [rsp+58h] [rbp-30h]
  int v11; // [rsp+5Ch] [rbp-2Ch]
  __int64 v12; // [rsp+60h] [rbp-28h]
  int v13; // [rsp+68h] [rbp-20h]
  int v14; // [rsp+6Ch] [rbp-1Ch]

  v6 = *(unsigned __int8 *)(*(_QWORD *)a6 + 1LL);
  v12 = *(_QWORD *)a6;
  v14 = 0;
  v13 = 4 * v6 + 8;
  v9 = a5;
  v11 = 0;
  v10 = 4;
  return tlgWriteTransfer_EventWriteTransfer((__int64)&dword_1800AFF68, a2, 0LL, 0LL, 4u, &v8);
}

//----- (0000000180001454) ----------------------------------------------------
ULONG __fastcall _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapSz<unsigned short>,_tlgWrapperByVal<4>>(
        __int64 a1,
        unsigned __int8 *a2,
        __int64 a3,
        __int64 a4,
        const WCHAR **a5,
        __int64 a6)
{
  const WCHAR *v7; // rcx
  __int64 v8; // rax
  int v9; // edx
  struct _EVENT_DATA_DESCRIPTOR v11; // [rsp+30h] [rbp-58h] BYREF
  const WCHAR *v12; // [rsp+50h] [rbp-38h]
  int v13; // [rsp+58h] [rbp-30h]
  int v14; // [rsp+5Ch] [rbp-2Ch]
  __int64 v15; // [rsp+60h] [rbp-28h]
  __int64 v16; // [rsp+68h] [rbp-20h]

  v15 = a6;
  v16 = 4LL;
  v7 = *a5;
  if ( *a5 )
  {
    v8 = -1LL;
    do
      ++v8;
    while ( v7[v8] );
    v9 = 2 * v8 + 2;
  }
  else
  {
    v7 = &ChannelPath;
    v9 = 2;
  }
  v12 = v7;
  v13 = v9;
  v14 = 0;
  return tlgWriteTransfer_EventWriteTransfer((__int64)&dword_1800AFF68, a2, 0LL, 0LL, 4u, &v11);
}

//----- (0000000180001508) ----------------------------------------------------
ULONG __fastcall _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapSz<unsigned short>,_tlgWrapperByVal<4>,_tlgWrapSz<unsigned short>>(
        __int64 a1,
        unsigned __int8 *a2,
        __int64 a3,
        __int64 a4,
        const WCHAR **a5,
        __int64 a6,
        const WCHAR **a7)
{
  __int64 v8; // rcx
  int v9; // r9d
  const WCHAR *v10; // rdx
  __int64 v11; // rax
  int v12; // r8d
  const WCHAR *v13; // rdx
  struct _EVENT_DATA_DESCRIPTOR v15; // [rsp+30h] [rbp-68h] BYREF
  const WCHAR *v16; // [rsp+50h] [rbp-48h]
  int v17; // [rsp+58h] [rbp-40h]
  int v18; // [rsp+5Ch] [rbp-3Ch]
  __int64 v19; // [rsp+60h] [rbp-38h]
  __int64 v20; // [rsp+68h] [rbp-30h]
  const WCHAR *v21; // [rsp+70h] [rbp-28h]
  int v22; // [rsp+78h] [rbp-20h]
  int v23; // [rsp+7Ch] [rbp-1Ch]

  v8 = -1LL;
  v9 = 2;
  v10 = *a7;
  if ( *a7 )
  {
    v11 = -1LL;
    do
      ++v11;
    while ( v10[v11] );
    v12 = 2 * v11 + 2;
  }
  else
  {
    v10 = &ChannelPath;
    v12 = 2;
  }
  v19 = a6;
  v21 = v10;
  v22 = v12;
  v23 = 0;
  v13 = *a5;
  v20 = 4LL;
  if ( v13 )
  {
    do
      ++v8;
    while ( v13[v8] );
    v9 = 2 * v8 + 2;
  }
  else
  {
    v13 = &ChannelPath;
  }
  v16 = v13;
  v17 = v9;
  v18 = 0;
  return tlgWriteTransfer_EventWriteTransfer((__int64)&dword_1800AFF68, a2, 0LL, 0LL, 5u, &v15);
}

//----- (0000000180001608) ----------------------------------------------------
ULONG __fastcall _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapSz<unsigned short>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>>(
        __int64 a1,
        unsigned __int8 *a2,
        __int64 a3,
        __int64 a4,
        const WCHAR **a5,
        __int64 a6,
        __int64 a7)
{
  const WCHAR *v8; // rcx
  __int64 v9; // rax
  int v10; // edx
  struct _EVENT_DATA_DESCRIPTOR v12; // [rsp+30h] [rbp-68h] BYREF
  const WCHAR *v13; // [rsp+50h] [rbp-48h]
  int v14; // [rsp+58h] [rbp-40h]
  int v15; // [rsp+5Ch] [rbp-3Ch]
  __int64 v16; // [rsp+60h] [rbp-38h]
  __int64 v17; // [rsp+68h] [rbp-30h]
  __int64 v18; // [rsp+70h] [rbp-28h]
  __int64 v19; // [rsp+78h] [rbp-20h]

  v18 = a7;
  v16 = a6;
  v19 = 4LL;
  v17 = 4LL;
  v8 = *a5;
  if ( *a5 )
  {
    v9 = -1LL;
    do
      ++v9;
    while ( v8[v9] );
    v10 = 2 * v9 + 2;
  }
  else
  {
    v8 = &ChannelPath;
    v10 = 2;
  }
  v13 = v8;
  v14 = v10;
  v15 = 0;
  return tlgWriteTransfer_EventWriteTransfer((__int64)&dword_1800AFF68, a2, 0LL, 0LL, 5u, &v12);
}

//----- (00000001800016D0) ----------------------------------------------------
int __fastcall dynamic_initializer_for__g_PrivateHeap__(PrivateHeap *a1)
{
  PrivateHeap::PrivateHeap(a1);
  return atexit((void (__cdecl *)())dynamic_atexit_destructor_for__g_PrivateHeap__);
}
// 180038750: using guessed type __int64 __fastcall dynamic_atexit_destructor_for__g_PrivateHeap__();

//----- (00000001800016F0) ----------------------------------------------------
int dynamic_initializer_for__ShutdownMgr::s_hEvent__()
{
  _InterlockedExchange64((volatile __int64 *)&ShutdownMgr::s_hEvent, 0LL);
  return atexit((void (__cdecl *)())dynamic_atexit_destructor_for__ShutdownMgr::s_hEvent__);
}

//----- (0000000180001710) ----------------------------------------------------
int __fastcall dynamic_initializer_for__ShutdownMgr::s_sync__(ShutdownMgr::Sync *a1)
{
  ShutdownMgr::Sync::Sync(a1);
  return atexit((void (__cdecl *)())dynamic_atexit_destructor_for__ShutdownMgr::s_sync__);
}
// 180038770: using guessed type __int64 __fastcall dynamic_atexit_destructor_for__ShutdownMgr::s_sync__();

//----- (0000000180001730) ----------------------------------------------------
int __fastcall dynamic_initializer_for__g_Idolater__(Idolater *a1)
{
  Idolater::Idolater(a1);
  return atexit((void (__cdecl *)())dynamic_atexit_destructor_for__g_Idolater__);
}
// 180038780: using guessed type __int64 __fastcall dynamic_atexit_destructor_for__g_Idolater__();

//----- (0000000180001750) ----------------------------------------------------
int dynamic_initializer_for__std::_Error_objects_int_::_Generic_object__()
{
  return atexit((void (__cdecl *)())dynamic_atexit_destructor_for__std::_Error_objects_int_::_Generic_object__);
}

//----- (0000000180001760) ----------------------------------------------------
int dynamic_initializer_for__std::_Error_objects_int_::_Iostream_object__()
{
  return atexit((void (__cdecl *)())dynamic_atexit_destructor_for__std::_Error_objects_int_::_Iostream_object__);
}

//----- (0000000180001770) ----------------------------------------------------
int dynamic_initializer_for__std::_Error_objects_int_::_System_object__()
{
  return atexit((void (__cdecl *)())dynamic_atexit_destructor_for__std::_Error_objects_int_::_System_object__);
}

//----- (0000000180001780) ----------------------------------------------------
int wil::details::_dynamic_initializer_for__g_enabledStateManager__()
{
  wil::manually_managed_shutdown_aware_object<wil::details::EnabledStateManager>::construct();
  return atexit((void (__cdecl *)())wil::details::_dynamic_atexit_destructor_for__g_enabledStateManager__);
}

//----- (00000001800017A0) ----------------------------------------------------
int wil::details::_dynamic_initializer_for__g_featureStateManager__()
{
  wil::details::FeatureStateManager::FeatureStateManager((wil::details::FeatureStateManager *)&wil::details::g_featureStateManager);
  return atexit((void (__cdecl *)())wil::details::_dynamic_atexit_destructor_for__g_featureStateManager__);
}

//----- (00000001800017C0) ----------------------------------------------------
void (__fastcall __noreturn *wil::details::_dynamic_initializer_for__g_header_init_InitializeResultExceptions__())(wil::details *this, const struct wil::FailureInfo *a2)
{
  void (__fastcall __noreturn *result)(wil::details *, const struct wil::FailureInfo *); // rax

  wil::details::g_pfnRethrow = (void (*)(void))wil::details::Rethrow;
  result = wil::details::ThrowResultExceptionInternal;
  wil::details::g_pfnThrowResultException = (void (__stdcall *)(const struct wil::FailureInfo *))wil::details::ThrowResultExceptionInternal;
  return result;
}
// 1800B09A0: using guessed type void (*wil::details::g_pfnRethrow)(void);
// 1800B09A8: using guessed type void (__stdcall *wil::details::g_pfnThrowResultException)(const struct wil::FailureInfo *);

//----- (00000001800017E0) ----------------------------------------------------
void *wil::details::_dynamic_initializer_for__g_header_init_InitializeResultHeader__()
{
  void *result; // rax

  wil::details::g_pfnGetContextAndNotifyFailure = (void (__stdcall *)(struct wil::FailureInfo *, char *, unsigned __int64))wil::details::GetContextAndNotifyFailure;
  wil::details_abi::g_pProcessLocalData = (__int64)&wil::details::g_processLocalData;
  result = &wil::details::g_threadFailureCallbacks;
  wil::details::g_pThreadFailureCallbacks = (__int64)&wil::details::g_threadFailureCallbacks;
  return result;
}
// 1800AFFA0: using guessed type char *wil::details::g_processLocalData;
// 1800B0988: using guessed type __int64 wil::details_abi::g_pProcessLocalData;
// 1800B0990: using guessed type __int64 wil::details::g_pThreadFailureCallbacks;
// 1800B0998: using guessed type void (__stdcall *wil::details::g_pfnGetContextAndNotifyFailure)(struct wil::FailureInfo *, char *, unsigned __int64);

//----- (0000000180001810) ----------------------------------------------------
void (__fastcall *wil::details::_dynamic_initializer_for__g_header_init_InitializeStagingHeaderInternalApi__())(struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ *this, struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ *a2)
{
  void (__fastcall *result)(struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ *, struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ *); // rax

  g_wil_details_internalGetFeatureEnabledState = (__int64)wil::details::WilApiImpl_GetFeatureEnabledState;
  g_wil_details_internalRecordFeatureUsage = (__int64)wil::details::WilApiImpl_RecordFeatureUsage;
  g_wil_details_internalSubscribeFeatureStateChangeNotification = (__int64)wil::details::WilApiImpl_SubscribeFeatureStateChangeNotification;
  result = wil::details::WilApiImpl_UnsubscribeFeatureStateChangeNotification;
  g_wil_details_internalUnsubscribeFeatureStateChangeNotification = (__int64)wil::details::WilApiImpl_UnsubscribeFeatureStateChangeNotification;
  return result;
}
// 1800B14B8: using guessed type __int64 g_wil_details_internalRecordFeatureUsage;
// 1800B14C8: using guessed type __int64 g_wil_details_internalGetFeatureEnabledState;
// 1800B1570: using guessed type __int64 g_wil_details_internalSubscribeFeatureStateChangeNotification;
// 1800B15D8: using guessed type __int64 g_wil_details_internalUnsubscribeFeatureStateChangeNotification;

//----- (0000000180001850) ----------------------------------------------------
void (__fastcall *wil::details::_dynamic_initializer_for__g_header_init_InitializeStagingSRUMFeatureReporting__())(wil::details *this)
{
  void (__fastcall *result)(wil::details *); // rax

  result = wil::details::RecordSRUMFeatureUsage;
  g_wil_details_RecordSRUMFeatureUsage = (__int64)wil::details::RecordSRUMFeatureUsage;
  return result;
}
// 1800B14C0: using guessed type __int64 g_wil_details_RecordSRUMFeatureUsage;

//----- (00000001800018C0) ----------------------------------------------------
int wil::details::_dynamic_initializer_for__g_processLocalData__()
{
  return atexit((void (__cdecl *)())wil::details::_dynamic_atexit_destructor_for__g_processLocalData__);
}
// 180038800: using guessed type __int64 __fastcall wil::details::_dynamic_atexit_destructor_for__g_processLocalData__();

//----- (00000001800018D0) ----------------------------------------------------
int wil::details::_dynamic_initializer_for__g_threadFailureCallbacks__()
{
  return atexit((void (__cdecl *)())wil::details::_dynamic_atexit_destructor_for__g_threadFailureCallbacks__);
}
// 180038810: using guessed type __int64 __fastcall wil::details::_dynamic_atexit_destructor_for__g_threadFailureCallbacks__();

//----- (00000001800018E0) ----------------------------------------------------
int __fastcall dynamic_initializer_for__JobStore::m_hashObject__(HashCompute *a1)
{
  HashCompute::HashCompute(a1);
  return atexit(dynamic_atexit_destructor_for__JobStore::m_hashObject__);
}

//----- (0000000180001900) ----------------------------------------------------
int dynamic_initializer_for__RpcServer::s_singleton__()
{
  InitializeSRWLock(&SRWLock);
  dword_1800B0D60 = 0;
  return atexit((void (__cdecl *)())dynamic_atexit_destructor_for__RpcServer::s_singleton__);
}
// 180038830: using guessed type __int64 __fastcall dynamic_atexit_destructor_for__RpcServer::s_singleton__();
// 1800B0D60: using guessed type int dword_1800B0D60;

//----- (0000000180001930) ----------------------------------------------------
int ATL::_dynamic_initializer_for__g_strheap__()
{
  HANDLE ProcessHeap; // rax

  ProcessHeap = GetProcessHeap();
  byte_1800B0BE8 = 0;
  ATL::g_strheap = (__int64)&ATL::CWin32Heap::`vftable';
  qword_1800B0BE0 = (__int64)ProcessHeap;
  return atexit(ATL::_dynamic_atexit_destructor_for__g_strheap__);
}
// 180071830: using guessed type void *ATL::CWin32Heap::`vftable';
// 1800B0BD8: using guessed type __int64 ATL::g_strheap;
// 1800B0BE0: using guessed type __int64 qword_1800B0BE0;
// 1800B0BE8: using guessed type char byte_1800B0BE8;

//----- (0000000180001970) ----------------------------------------------------
int __fastcall ATL::_dynamic_initializer_for__g_strmgr__(ATL::CAtlStringMgr *a1, struct ATL::IAtlMemMgr *a2)
{
  ATL::CAtlStringMgr::CAtlStringMgr(a1, a2);
  return atexit((void (__cdecl *)())ATL::_dynamic_atexit_destructor_for__g_strmgr__);
}

//----- (0000000180001990) ----------------------------------------------------
int __fastcall dynamic_initializer_for__vtMissing__(_variant_t *a1)
{
  _variant_t::_variant_t(a1);
  return atexit((void (__cdecl *)())dynamic_atexit_destructor_for__vtMissing__);
}
// 180038860: using guessed type __int64 __fastcall dynamic_atexit_destructor_for__vtMissing__();

//----- (00000001800019B0) ----------------------------------------------------
__int64 __fastcall Triggers::BootTrigger::WriteXml(Triggers::BootTrigger *this, struct TaskXmlWriter *a2)
{
  BSTR *v2; // rax
  UINT v5; // eax
  __int64 *v6; // rax
  __int64 v7; // r9
  __int64 result; // rax

  v2 = (BSTR *)*((_QWORD *)this + 10);
  if ( v2 && *v2 )
    v5 = SysStringLen(*v2);
  else
    v5 = 0;
  if ( v5 )
  {
    v6 = (__int64 *)*((_QWORD *)this + 10);
    if ( v6 )
      v7 = *v6;
    else
      v7 = 0LL;
    result = TaskXmlWriter::StartElementWithAttribute((__int64)a2, 21, 109, v7);
  }
  else
  {
    result = TaskXmlWriter::StartElement((int *)a2, 21);
  }
  if ( (int)result >= 0 )
  {
    result = Triggers::GenericTrigger::WriteInnerXml(this, a2);
    if ( (int)result >= 0 )
      return TaskXmlWriter::EndElement((__int64)a2);
  }
  return result;
}

//----- (0000000180001A38) ----------------------------------------------------
__int64 __fastcall ItSpIsSystemIdle(
        struct _ITSRV_GLOBAL_CONTEXT *a1,
        struct _ITSRV_SYSTEM_SNAPSHOT *a2,
        struct _ITSRV_SYSTEM_SNAPSHOT *a3,
        enum _ITSRV_IDLE_DETECTION_RESULT *a4)
{
  unsigned int v4; // ebx
  struct _ITSRV_SYSTEM_SNAPSHOT *v7; // r10
  struct _ITSRV_GLOBAL_CONTEXT *v8; // r11
  unsigned int v9; // edi
  unsigned int v10; // ebp
  double v11; // xmm5_8
  double v12; // xmm6_8
  int v13; // r15d
  EventManager *v14; // rcx
  unsigned int v16; // r14d
  int v17; // r8d
  unsigned __int64 v18; // rcx
  double v19; // xmm2_8
  int v20; // ecx
  unsigned int v21; // r8d
  unsigned int v22; // edx
  double v23; // xmm1_8

  v4 = 0;
  v7 = a2;
  v8 = a1;
  v9 = 0;
  v10 = 2;
  v11 = *(double *)&DOUBLE_100_0;
  v12 = *(double *)&DOUBLE_100_0;
  if ( !a4 || !a1 || !a2 || !a3 )
    return 87;
  v13 = *(_DWORD *)a2 - *(_DWORD *)a3;
  if ( *((_BYTE *)a1 + 368) == 1 && !_InterlockedCompareExchange((volatile signed __int32 *)a1 + 192, 0, 0) )
  {
    v9 = 4;
    goto LABEL_8;
  }
  if ( _InterlockedCompareExchange((volatile signed __int32 *)a1 + 194, 0, 0) )
  {
    v9 = 10;
    goto LABEL_8;
  }
  v16 = _InterlockedCompareExchange((volatile signed __int32 *)a1 + 204, 0, 0);
  if ( v16
    && (*((_BYTE *)a2 + 4) & 4) != 0
    && *((_BYTE *)a2 + 33)
    && !*((_BYTE *)a2 + 32)
    && *((_DWORD *)a2 + 10)
    && ItSpBatteryLifePercent(a2) < v16 )
  {
    v9 = 7;
    goto LABEL_8;
  }
  if ( (*((_BYTE *)v7 + 4) & 0x20) != 0 && *((_DWORD *)v7 + 21) )
    goto LABEL_36;
  if ( (*((_BYTE *)v7 + 4) & 0x10) != 0
    && (*((_BYTE *)v7 + 80) & 2) != 0
    && _InterlockedCompareExchange((volatile signed __int32 *)v8 + 212, 0, 0) )
  {
    v9 = 3;
    goto LABEL_8;
  }
  v10 = 0;
  if ( _InterlockedCompareExchange((volatile signed __int32 *)v8 + 193, 0, 0) )
  {
LABEL_36:
    v10 = 1;
    goto LABEL_8;
  }
  if ( *(_DWORD *)v7 <= *(_DWORD *)a3 )
    goto LABEL_44;
  v17 = *((_DWORD *)v8 + 98);
  if ( !v17 )
    goto LABEL_29;
  if ( (*((_BYTE *)v7 + 4) & 2) == 0 || (*((_BYTE *)a3 + 4) & 2) == 0 )
  {
LABEL_44:
    v9 = 1;
    goto LABEL_8;
  }
  v18 = *((_QWORD *)v7 + 1) - *((_QWORD *)a3 + 1);
  if ( v18 >= 0x271000000000LL )
    goto LABEL_8;
  v19 = fmin(100.0, (double)(int)(v18 / 0x2710) * 100.0 / (double)v13);
  v11 = fmin(v19, 100.0);
  if ( (double)v17 > v19 )
  {
    v9 = 5;
    goto LABEL_8;
  }
LABEL_29:
  v20 = *((_DWORD *)v8 + 99);
  if ( !v20 || (*((_BYTE *)v7 + 4) & 1) == 0 || (*((_BYTE *)a3 + 4) & 1) == 0 )
    goto LABEL_36;
  v21 = *((_DWORD *)v7 + 4);
  if ( v21 == *((_DWORD *)a3 + 4) )
  {
    v22 = 0;
    if ( v21 )
    {
      while ( 1 )
      {
        v23 = fmin(
                100.0,
                (double)(*(_DWORD *)(*((_QWORD *)v7 + 3) + 4LL * v22) - *(_DWORD *)(*((_QWORD *)a3 + 3) + 4LL * v22))
              * 100.0
              / (double)v13);
        v12 = fmin(v23, v12);
        if ( (double)v20 > v23 )
          break;
        if ( ++v22 >= v21 )
          goto LABEL_36;
      }
      v9 = 6;
      goto LABEL_8;
    }
    goto LABEL_36;
  }
  v9 = 2;
LABEL_8:
  ItSpUpdateLastPerfTrackData((__int64)v8, (__int64)v7, a3, v9, v11, v12, 100.0);
  if ( v10 == 1 || v10 == 2 && v9 != 4 )
    EventManager::EvtReport(v14, &ItSpEvt_IdleCheckPoint, v10, v9);
  *(_DWORD *)a4 = v10;
  return v4;
}
// 180001ADD: variable 'v8' is possibly undefined
// 180001ADD: variable 'v7' is possibly undefined
// 180001ADD: variable 'v11' is possibly undefined
// 180038900: variable 'v14' is possibly undefined

//----- (0000000180001CBC) ----------------------------------------------------
char __fastcall ItSpUpdateLastPerfTrackData(
        __int64 a1,
        __int64 a2,
        struct _ITSRV_SYSTEM_SNAPSHOT *a3,
        int a4,
        double a5,
        double a6,
        double a7)
{
  __int64 v10; // rsi
  signed __int32 v11; // ebx
  __int64 v12; // rdi
  unsigned int v13; // r15d
  double v14; // xmm0_8
  int v15; // ebp
  bool v16; // zf
  struct _FILETIME v17; // rbx
  int v18; // eax
  double v19; // xmm0_8
  unsigned int v20; // r9d
  __int64 v21; // r10
  unsigned int v22; // ecx
  unsigned __int8 v23; // al
  unsigned int v24; // r9d
  int v25; // ecx
  unsigned int v26; // eax
  struct _FILETIME SystemTimeAsFileTime; // [rsp+70h] [rbp+8h] BYREF
  struct _FILETIME v29; // [rsp+78h] [rbp+10h]

  *(_DWORD *)(a1 + 672) = a4;
  *(_QWORD *)(a1 + 640) = 0LL;
  *(_QWORD *)(a1 + 648) = 0LL;
  *(_WORD *)(a1 + 668) = 0;
  *(_QWORD *)(a1 + 656) = 0LL;
  *(_DWORD *)(a1 + 664) = 0;
  GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
  v29 = SystemTimeAsFileTime;
  v10 = _InterlockedCompareExchange64((volatile signed __int64 *)(a1 + 784), 0LL, 0LL);
  v11 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 848), 0, 0);
  v12 = *(_QWORD *)(a1 + 680);
  v13 = *(_DWORD *)(a1 + 696);
  v14 = (100.0 - a5) * 100.0;
  *(_DWORD *)(a1 + 656) = (*(_DWORD *)a2 - *(_DWORD *)a3) / 0x3E8u;
  *(_DWORD *)(a1 + 640) = ItSpConvertToLogScale(v14);
  *(_DWORD *)(a1 + 644) = ItSpConvertToLogScale((100.0 - a6) * 100.0);
  *(_DWORD *)(a1 + 648) = ItSpConvertToLogScale((100.0 - a7) * 100.0);
  v15 = -1;
  v16 = v11 == 0;
  v17 = v29;
  *(_BYTE *)(a1 + 669) = *(_DWORD *)(a2 + 84) != 0;
  LOBYTE(v18) = !v16;
  *(_BYTE *)(a1 + 668) = !v16;
  if ( (*(_BYTE *)(a2 + 4) & 4) != 0 )
  {
    v19 = 0.0;
    v20 = ItSpBatteryLifePercent((struct _ITSRV_SYSTEM_SNAPSHOT *)a2);
    v22 = -1;
    if ( ((unsigned __int64)(*(_QWORD *)&v17 - v12 + ((unsigned __int128)((*(_QWORD *)&v17 - v12) * (__int128)v21) >> 64)) >> 63)
       + ((__int64)(*(_QWORD *)&v17 - v12 + ((unsigned __int128)((*(_QWORD *)&v17 - v12) * (__int128)v21) >> 64)) >> 23) <= 0xFFFFFFFF )
      v22 = ((unsigned __int64)(*(_QWORD *)&v17
                              - v12
                              + ((unsigned __int128)((*(_QWORD *)&v17 - v12) * (__int128)v21) >> 64)) >> 63)
          + ((__int64)(*(_QWORD *)&v17 - v12 + ((unsigned __int128)((*(_QWORD *)&v17 - v12) * (__int128)v21) >> 64)) >> 23);
    if ( v12 )
    {
      if ( v20 >= v13 || !v22 )
        goto LABEL_6;
      v26 = v13 - v20;
    }
    else
    {
      v23 = ItSpBatteryLifePercent(a3);
      if ( v24 >= v23 )
        goto LABEL_6;
      v22 = *(_DWORD *)(a1 + 656);
      if ( !v22 )
        goto LABEL_6;
      v26 = v23 - v24;
    }
    v19 = (double)(int)(v26 / v22);
LABEL_6:
    v18 = ItSpConvertToLogScale(v19 * 1000.0);
    *(_DWORD *)(a1 + 652) = v18;
  }
  if ( v10 > 0 )
  {
    v25 = -1;
    if ( (unsigned __int64)((*(_QWORD *)&v17 - v10) / 10000000) <= 0xFFFFFFFF )
      v25 = (*(_QWORD *)&v17 - v10) / 10000000;
    v18 = ItSpConvertToLogScale((double)v25);
    *(_DWORD *)(a1 + 660) = v18;
  }
  if ( v12 > 0 )
  {
    if ( (unsigned __int64)((*(_QWORD *)&v17 - v12) / 10000000) <= 0xFFFFFFFF )
      v15 = (*(_QWORD *)&v17 - v12) / 10000000;
    v18 = ItSpConvertToLogScale((double)v15);
    *(_DWORD *)(a1 + 664) = v18;
  }
  return v18;
}
// 180001E15: variable 'v21' is possibly undefined
// 180001E48: variable 'v24' is possibly undefined

//----- (0000000180001ED8) ----------------------------------------------------
__int64 __fastcall ItSpConvertToLogScale(double a1)
{
  double v2; // xmm1_8
  double v3; // xmm0_8
  double v5; // xmm0_8

  if ( dword_1800B0BC8 > *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)tls_index)
                                   + 4LL) )
  {
    Init_thread_header(&dword_1800B0BC8);
    if ( dword_1800B0BC8 == -1 )
    {
      qword_1800B09F8 = log_0(2.0);
      Init_thread_footer(&dword_1800B0BC8);
    }
  }
  v2 = floor_0(a1);
  v3 = 0.0;
  if ( v2 > 0.0 )
  {
    v5 = log_0(v2);
    v3 = floor_0(v5 / *(double *)&qword_1800B09F8 + 1.0);
    if ( v3 >= 127.0 )
      v3 = DOUBLE_127_0;
  }
  return (unsigned int)(int)floor_0(v3);
}
// 18007CFD8: using guessed type const double DOUBLE_127_0;
// 1800B0898: using guessed type int tls_index;
// 1800B09F8: using guessed type __int64 qword_1800B09F8;
// 1800B0BC8: using guessed type int dword_1800B0BC8;

//----- (0000000180001FA4) ----------------------------------------------------
unsigned __int8 __fastcall ItSpBatteryLifePercent(struct _ITSRV_SYSTEM_SNAPSHOT *a1)
{
  unsigned int v1; // r8d
  unsigned int v2; // eax

  v1 = *((_DWORD *)a1 + 10);
  if ( v1 )
  {
    v2 = ((v1 >> 1) + 100 * *((_DWORD *)a1 + 11)) / v1;
    if ( v2 > 0x64 )
      LOBYTE(v2) = 100;
  }
  else
  {
    LOBYTE(v2) = -1;
  }
  return v2;
}

//----- (0000000180001FC0) ----------------------------------------------------
__int64 __fastcall SchRpcEnableTask(__int64 a1, unsigned __int16 *a2, int a3)
{
  return RpcServer::EnableTask((RTL_SRWLOCK *)&RpcServer::s_singleton, a2, a3);
}
// 180001FC0: could not find valid save-restore pair for rbp
// 1800B0D48: using guessed type __int64 RpcServer::s_singleton;

//----- (0000000180001FF4) ----------------------------------------------------
__int64 __fastcall RpcServer::EnableTask(RTL_SRWLOCK *this, unsigned __int16 *a2, int a3)
{
  HKEY *v6; // rsi
  unsigned __int16 *v7; // rbx
  const unsigned __int16 *v8; // r8
  __int64 v9; // rcx
  int CallerToken; // edi
  const unsigned __int16 *v11; // rdx
  unsigned int v12; // edx
  __int64 v13; // rcx
  unsigned int v14; // edx
  const struct JobSecurity *v15; // r8
  const wchar_t *Path; // rax
  __int64 v17; // rcx
  int TaskXmlFromCollections; // eax
  int v19; // eax
  const struct _EVENT_DESCRIPTOR *v20; // rsi
  EventManager *v21; // rcx
  const unsigned __int16 *v22; // r9
  const unsigned __int16 *v23; // rax
  const wchar_t *v24; // rax
  __int64 v25; // rcx
  __int64 v26; // r8
  __int64 v27; // r9
  int v29; // [rsp+48h] [rbp-C0h] BYREF
  __int128 v30; // [rsp+58h] [rbp-B0h] BYREF
  unsigned __int16 *v31; // [rsp+68h] [rbp-A0h] BYREF
  HANDLE ClientToken; // [rsp+70h] [rbp-98h] BYREF
  __int64 v33[3]; // [rsp+78h] [rbp-90h] BYREF
  PSECURITY_DESCRIPTOR pSecurityDescriptor[2]; // [rsp+90h] [rbp-78h] BYREF
  struct _FILETIME v35[9]; // [rsp+A0h] [rbp-68h] BYREF
  __int128 v36; // [rsp+E8h] [rbp-20h] BYREF
  BSTR *v37[2]; // [rsp+F8h] [rbp-10h] BYREF
  char v38[16]; // [rsp+108h] [rbp+0h] BYREF
  wmi::RefBase *v39; // [rsp+118h] [rbp+10h] BYREF
  unsigned __int16 v40[264]; // [rsp+128h] [rbp+20h] BYREF
  struct _GUID v41; // [rsp+338h] [rbp+230h] BYREF

  v35[7] = (struct _FILETIME)-2LL;
  v6 = (HKEY *)JobStore::m_pCommonStore;
  ClientToken = 0LL;
  JobSecurity::JobSecurity((JobSecurity *)pSecurityDescriptor);
  JobMoniker::JobMoniker((JobMoniker *)v37, 0LL, 0LL);
  Triggers::Trigulator::Trigulator(v35);
  Actions::ActionCollection::ActionCollection((Actions::ActionCollection *)v33);
  v7 = 0LL;
  v31 = 0LL;
  memset_0(&v41, 0, 0x20AuLL);
  memset_0(v40, 0, 0x20AuLL);
  if ( (unsigned int)dword_1800AFF68 > 5 && tlgKeywordOn((__int64)&dword_1800AFF68, 0LL) )
    _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<>(
      v9,
      byte_18007F1A8);
  if ( !a2 )
    goto LABEL_5;
  CallerToken = tsched::TaskPathCanonicalize((tsched *)v40, (char *)a2, v8);
  if ( CallerToken < 0 )
    goto LABEL_60;
  a2 = v40;
  if ( tsched::IsRoot((tsched *)v40, v11) )
  {
LABEL_5:
    CallerToken = -2147024809;
  }
  else
  {
    CallerToken = GetCallerToken(L"EnableTask", &ClientToken);
    if ( CallerToken < 0 )
      goto LABEL_60;
    *(_QWORD *)&v30 = this + 2;
    AcquireSRWLockExclusive(this + 2);
    CallerToken = JobStore::RegJobSecurityQuery(v6, v40, pSecurityDescriptor);
    if ( CallerToken < 0 )
      goto LABEL_10;
    CallerToken = JobAccessCheck(ClientToken, pSecurityDescriptor[0], 2u);
    if ( CallerToken < 0 )
      goto LABEL_10;
    CallerToken = JobStore::LoadBucketFromRegistry(v6, v40, 15, (__int64)v37, (__int64)v35, v33);
    if ( CallerToken < 0 )
      goto LABEL_10;
    v12 = *((_DWORD *)v39 + 4);
    v13 = (v12 >> 22) & 1;
    if ( (_DWORD)v13 == (a3 != 0) )
      goto LABEL_10;
    if ( a3 )
      v14 = v12 | 0x400000;
    else
      v14 = v12 & 0xFFBFFFFF;
    *((_DWORD *)v39 + 4) = v14;
    CallerToken = JobStore::GenerateTaskXmlFromCollections(
                    v13,
                    (__int64)v37,
                    (Triggers::Trigulator *)v35,
                    (Actions::ActionCollection *)v33,
                    (char **)&v31);
    if ( CallerToken < 0 )
    {
      tsched::SrwLockExclusiveScope::~SrwLockExclusiveScope((PSRWLOCK *)&v30);
      v7 = v31;
      goto LABEL_60;
    }
    v7 = v31;
    CallerToken = JobStore::ComputeHash((struct JobMoniker *)v37, (unsigned __int8 *)v31);
    if ( CallerToken < 0 )
    {
LABEL_10:
      tsched::SrwLockExclusiveScope::~SrwLockExclusiveScope((PSRWLOCK *)&v30);
      goto LABEL_60;
    }
    if ( (*((_DWORD *)v39 + 4) & 0x200000) != 0 && !PlugIn::IsRegistering((PlugIn *)&PlugIn::s_singleton, v40, v7) )
    {
      CallerToken = PlugIn::RegisterTask(
                      (PlugIn *)&PlugIn::s_singleton,
                      v40,
                      v7,
                      0LL,
                      a3 != 0 ? 4 : 12,
                      (unsigned __int16 *)&v41);
      if ( CallerToken < 0 )
        goto LABEL_34;
    }
    RpcAutoImpersonate::RpcAutoImpersonate((RpcAutoImpersonate *)&v29, L"RpcServer::EnableTask", 1);
    CallerToken = JobStore::XmlSaveTaskFile((JobStore *)v6, (const struct JobMoniker *)v37, v7, 0LL);
    if ( CallerToken >= 0 )
    {
      if ( v29 )
        RpcRevertToSelf();
      CallerToken = JobStore::UpdateTaskEntry(
                      v6,
                      (const struct JobMoniker *)v37,
                      v15,
                      (const struct Triggers::Trigulator *)v35,
                      (const struct Actions::ActionCollection *)v33,
                      0LL);
    }
    else
    {
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) != 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        Path = JobMoniker::GetPath((JobMoniker *)v37);
        WPP_SF_SD(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x4Bu,
          (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids,
          Path);
      }
      if ( v29 )
        RpcRevertToSelf();
    }
    if ( CallerToken < 0 )
    {
LABEL_34:
      if ( a3 )
        *((_DWORD *)v39 + 4) &= ~0x400000u;
      else
        *((_DWORD *)v39 + 4) |= 0x400000u;
      if ( (int)JobStore::UpdateTaskEntry(
                  v6,
                  (const struct JobMoniker *)v37,
                  v15,
                  (const struct Triggers::Trigulator *)v35,
                  (const struct Actions::ActionCollection *)v33,
                  0LL) < 0 )
        MicrosoftTelemetryAssertTriggeredNoArgs();
      TaskXmlFromCollections = JobStore::GenerateTaskXmlFromCollections(
                                 v17,
                                 (__int64)v37,
                                 (Triggers::Trigulator *)v35,
                                 (Actions::ActionCollection *)v33,
                                 (char **)&v31);
      v7 = v31;
      if ( TaskXmlFromCollections >= 0
        && (int)JobStore::ComputeHash((struct JobMoniker *)v37, (unsigned __int8 *)v31) >= 0 )
      {
        RpcAutoImpersonate::RpcAutoImpersonate((RpcAutoImpersonate *)&v29, L"RpcServer::EnableTask", 1);
        JobStore::XmlSaveTaskFile((JobStore *)v6, (const struct JobMoniker *)v37, v7, 0LL);
        if ( (*((_DWORD *)v39 + 4) & 0x200000) != 0 && !PlugIn::IsRegistering((PlugIn *)&PlugIn::s_singleton, v40, v7) )
          PlugIn::RegisterTask((PlugIn *)&PlugIn::s_singleton, v40, v7, 0LL, a3 != 0 ? 12 : 4, (unsigned __int16 *)&v41);
        if ( v29 )
          RpcRevertToSelf();
      }
      goto LABEL_10;
    }
    tsched::SrwLockExclusiveScope::~SrwLockExclusiveScope((PSRWLOCK *)&v30);
    if ( (*((_DWORD *)v39 + 4) & 0x2000000) != 0 )
    {
      v19 = (*((__int64 (__fastcall **)(void ***, BSTR **, bool))UbpmProxySingleton::s_singleton[0] + 13))(
              UbpmProxySingleton::s_singleton,
              v37,
              a3 != 0);
    }
    else if ( a3 )
    {
      LOBYTE(v30) = 0;
      *((_QWORD *)&v30 + 1) = -1LL;
      v36 = v30;
      LOBYTE(v30) = 0;
      *((_QWORD *)&v30 + 1) = 0LL;
      v19 = Triggers::Trigulator::RegisterAll((Triggers::Trigulator *)v35, (struct JobMoniker *)v37, &v30, &v36, 0);
    }
    else
    {
      v19 = RpcServer::FlushTriggers(v37);
    }
    CallerToken = v19;
    v20 = (const struct _EVENT_DESCRIPTOR *)&TASK_UPDATED;
    if ( !a3 )
      v20 = &TASK_DISABLED;
    v21 = (EventManager *)*User::GetAccount((__int64)v39 + 64, (__int64 *)&v30);
    if ( v21 )
      v22 = *(const unsigned __int16 **)v21;
    else
      v22 = 0LL;
    EventManager::EvtReport(v21, v20, v40, v22);
    _bstr_t::_Free((_bstr_t *)&v30);
    v23 = JobMoniker::GetPath((JobMoniker *)v37);
    Auditor::AuditJobOperation((__int64 *)g_pAuditor, (a3 != 0) + 3, (__int64)v23, (char *)v7);
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) != 0
      && *((unsigned __int8 *)WPP_GLOBAL_Control + 25) >= (int)(((CallerToken >> 31) & 0xFFFFFFFE) + 4) )
    {
      v24 = JobMoniker::GetPath((JobMoniker *)v37);
      WPP_SF_SD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x4Cu,
        (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids,
        v24);
    }
  }
LABEL_60:
  if ( (unsigned int)dword_1800AFF68 > 4 && tlgKeywordOn((__int64)&dword_1800AFF68, 0LL) )
  {
    v29 = a3;
    LODWORD(v30) = CallerToken;
    v31 = a2;
    _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapSz<unsigned short>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>>(
      v25,
      byte_18007F0A0,
      v26,
      v27,
      (const WCHAR **)&v31,
      (__int64)&v30,
      (__int64)&v29);
  }
  operator delete(v7);
  Actions::ActionCollection::~ActionCollection((Actions::ActionCollection *)v33);
  Triggers::Trigulator::~Trigulator((Triggers::Trigulator *)v35);
  wmi::AutoRef<JobBucket>::Release(&v39);
  _bstr_t::_Free((_bstr_t *)v38);
  tsched::AutoLocalPtr<unsigned short>::~AutoLocalPtr<unsigned short>(pSecurityDescriptor);
  wmi::AutoHandle::Close(&ClientToken);
  return (unsigned int)CallerToken;
}
// 1800020BF: variable 'v9' is possibly undefined
// 1800020DA: variable 'v8' is possibly undefined
// 1800020F1: variable 'v11' is possibly undefined
// 18000233B: variable 'v15' is possibly undefined
// 18000239F: variable 'v17' is possibly undefined
// 180002611: variable 'v25' is possibly undefined
// 180002611: variable 'v26' is possibly undefined
// 180002611: variable 'v27' is possibly undefined
// 18007F0A0: using guessed type unsigned __int8 byte_18007F0A0[50];
// 18007F1A8: using guessed type unsigned __int8 byte_18007F1A8[30];
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 1800AFFB0: using guessed type void **UbpmProxySingleton::s_singleton[2];
// 1800B0CE0: using guessed type _RTL_CRITICAL_SECTION PlugIn::s_singleton;
// 180001FF4: using guessed type char var_470[16];
// 180001FF4: using guessed type __int64 var_500[3];

//----- (0000000180002690) ----------------------------------------------------
__int64 __fastcall JobSecurity::AddRemovePrincipalAce(PSECURITY_DESCRIPTOR *this, void *a2, void *a3)
{
  signed int v3; // edi
  PSECURITY_DESCRIPTOR v7; // r15
  NTSTATUS DaclSecurityDescriptor; // ebx
  struct _ACL *v9; // rcx
  char v10; // si
  unsigned __int16 *v11; // rax
  char v12; // dl
  ULONG v13; // eax
  ULONG v14; // ebx
  struct _ACL *v15; // rax
  struct _ACL *v16; // rsi
  NTSTATUS Acl; // ebx
  struct _ACL *v18; // rcx
  unsigned __int16 *v19; // r9
  HLOCAL v20; // rax
  unsigned int v21; // ebx
  char *v23; // rbx
  char *v24; // rbx
  unsigned __int8 DaclPresent[4]; // [rsp+30h] [rbp-39h] BYREF
  ULONG BufferLength; // [rsp+34h] [rbp-35h] BYREF
  int v27; // [rsp+38h] [rbp-31h]
  PVOID Ace; // [rsp+40h] [rbp-29h] BYREF
  PACL Dacl; // [rsp+48h] [rbp-21h] BYREF
  PSECURITY_DESCRIPTOR SelfRelativeSecurityDescriptor; // [rsp+50h] [rbp-19h] BYREF
  PSID Owner; // [rsp+58h] [rbp-11h] BYREF
  char SecurityDescriptor[96]; // [rsp+60h] [rbp-9h] BYREF
  unsigned __int8 DaclDefaulted; // [rsp+D8h] [rbp+6Fh] BYREF
  struct _ACL *v34; // [rsp+E8h] [rbp+7Fh] BYREF

  v3 = 0;
  SelfRelativeSecurityDescriptor = 0LL;
  BufferLength = 0;
  v7 = 0LL;
  if ( !a2 && !a3 )
  {
    v21 = -2147024809;
    goto LABEL_32;
  }
  DaclSecurityDescriptor = RtlGetDaclSecurityDescriptor(*this, DaclPresent, &Dacl, &DaclDefaulted);
  if ( DaclSecurityDescriptor < 0 )
  {
LABEL_51:
    v21 = DaclSecurityDescriptor | 0x10000000;
    goto LABEL_32;
  }
  v9 = Dacl;
  v10 = 1;
  LOBYTE(v34) = 0;
  v27 = 0;
  if ( !Dacl->AceCount )
    goto LABEL_11;
  do
  {
    DaclSecurityDescriptor = RtlGetAce(v9, v3, &Ace);
    if ( DaclSecurityDescriptor < 0 )
      goto LABEL_51;
    v11 = (unsigned __int16 *)Ace;
    if ( *(_BYTE *)Ace || *((_DWORD *)Ace + 1) != 1179785 )
      goto LABEL_7;
    v23 = (char *)Ace + 8;
    if ( a2 )
    {
      if ( EqualSid((char *)Ace + 8, a2) )
      {
        v10 = 0;
        goto LABEL_8;
      }
      v11 = (unsigned __int16 *)Ace;
    }
    if ( !a3 )
      goto LABEL_7;
    if ( !EqualSid(v23, a3) )
    {
      v11 = (unsigned __int16 *)Ace;
LABEL_7:
      v27 += v11[1];
LABEL_8:
      v12 = (char)v34;
      goto LABEL_9;
    }
    v12 = 1;
    LOBYTE(v34) = 1;
LABEL_9:
    v9 = Dacl;
    ++v3;
  }
  while ( v3 < Dacl->AceCount );
  v3 = 0;
  if ( !v10 && !v12 )
    goto LABEL_31;
LABEL_11:
  v13 = RtlLengthSid(a2);
  v14 = v13 + v27 + 20;
  v15 = (struct _ACL *)LocalAlloc(0, v14);
  v34 = v15;
  v16 = v15;
  if ( !v15 )
    goto LABEL_54;
  Acl = RtlCreateAcl(v15, v14, 2u);
  if ( Acl < 0 )
    goto LABEL_55;
  Acl = RtlCreateSecurityDescriptor(SecurityDescriptor, 1u);
  if ( Acl < 0 )
    goto LABEL_55;
  Acl = RtlAddAccessAllowedAce(v16, 2u, 0x120089u, a2);
  if ( Acl < 0 )
    goto LABEL_55;
  v18 = Dacl;
  if ( Dacl->AceCount )
  {
    do
    {
      Acl = RtlGetAce(v18, v3, &Ace);
      if ( Acl < 0 )
        goto LABEL_55;
      v19 = (unsigned __int16 *)Ace;
      if ( *(_BYTE *)Ace || *((_DWORD *)Ace + 1) != 1179785 )
        goto LABEL_19;
      v24 = (char *)Ace + 8;
      if ( a2 )
      {
        if ( EqualSid((char *)Ace + 8, a2) )
          goto LABEL_20;
        v19 = (unsigned __int16 *)Ace;
      }
      if ( !a3 )
        goto LABEL_19;
      if ( !EqualSid(v24, a3) )
      {
        v19 = (unsigned __int16 *)Ace;
LABEL_19:
        Acl = RtlAddAce(v16, 2u, v3, v19, v19[1]);
        if ( Acl < 0 )
          goto LABEL_55;
      }
LABEL_20:
      v18 = Dacl;
    }
    while ( ++v3 < Dacl->AceCount );
  }
  Acl = RtlSetDaclSecurityDescriptor(SecurityDescriptor, DaclPresent[0], v16, DaclDefaulted);
  if ( Acl < 0
    || (Acl = RtlGetOwnerSecurityDescriptor(*this, &Owner, &DaclDefaulted), Acl < 0)
    || (Acl = RtlSetOwnerSecurityDescriptor(SecurityDescriptor, Owner, DaclDefaulted), Acl < 0)
    || (Acl = RtlGetGroupSecurityDescriptor(*this, &Owner, &DaclDefaulted), Acl < 0)
    || (Acl = RtlSetGroupSecurityDescriptor(SecurityDescriptor, Owner, DaclDefaulted), Acl < 0) )
  {
LABEL_55:
    v21 = Acl | 0x10000000;
    goto LABEL_56;
  }
  Acl = RtlAbsoluteToSelfRelativeSD(SecurityDescriptor, 0LL, &BufferLength);
  if ( Acl != -1073741789 )
    goto LABEL_29;
  v20 = LocalAlloc(0, BufferLength);
  tsched::AutoLocalPtr<_SECURITY_DESCRIPTOR>::Attach(&SelfRelativeSecurityDescriptor, v20);
  v7 = SelfRelativeSecurityDescriptor;
  if ( !SelfRelativeSecurityDescriptor )
  {
LABEL_54:
    v21 = -2147024882;
LABEL_56:
    tsched::AutoLocalPtr<unsigned short>::~AutoLocalPtr<unsigned short>((void **)&v34);
    goto LABEL_32;
  }
  Acl = RtlAbsoluteToSelfRelativeSD(SecurityDescriptor, SelfRelativeSecurityDescriptor, &BufferLength);
LABEL_29:
  if ( Acl < 0 )
    goto LABEL_55;
  SelfRelativeSecurityDescriptor = 0LL;
  tsched::AutoLocalPtr<_SECURITY_DESCRIPTOR>::Attach(this, v7);
  *((_DWORD *)this + 2) = BufferLength;
  tsched::AutoLocalPtr<unsigned short>::~AutoLocalPtr<unsigned short>((void **)&v34);
LABEL_31:
  v21 = 0;
LABEL_32:
  tsched::AutoLocalPtr<unsigned short>::~AutoLocalPtr<unsigned short>(&SelfRelativeSecurityDescriptor);
  return v21;
}
// 180002690: using guessed type unsigned __int8 DaclPresent[4];

//----- (0000000180002A4C) ----------------------------------------------------
HLOCAL __fastcall tsched::AutoLocalPtr<unsigned short>::~AutoLocalPtr<unsigned short>(void **a1)
{
  void *v2; // rcx
  HLOCAL result; // rax

  v2 = *a1;
  if ( v2 )
  {
    result = LocalFree(v2);
    *a1 = 0LL;
  }
  return result;
}

//----- (0000000180002A7C) ----------------------------------------------------
_QWORD *__fastcall Triggers::BootTrigger::BootTrigger(
        _QWORD *a1,
        const OLECHAR *a2,
        __int128 *a3,
        __int128 *a4,
        int a5,
        int a6,
        char a7,
        __int128 *a8)
{
  __int128 v10; // [rsp+40h] [rbp-38h] BYREF
  __int128 v11; // [rsp+50h] [rbp-28h] BYREF
  __int128 v12; // [rsp+60h] [rbp-18h] BYREF

  v11 = *a4;
  v10 = *a8;
  v12 = *a3;
  Triggers::GenericTrigger::GenericTrigger((__int64)a1, a2, &v12, &v11, a5, a6, a7, &v10);
  *a1 = &Triggers::BootTrigger::`vftable';
  return a1;
}
// 180070000: using guessed type void *Triggers::BootTrigger::`vftable';
// 180002A7C: using guessed type __int128 var_18;

//----- (0000000180002AFC) ----------------------------------------------------
__int64 __fastcall ATL::CAtlArray<ATL::CAutoPtr<ATL::CDacl::CAccessAce>,ATL::CAutoPtrElementTraits<ATL::CDacl::CAccessAce>>::CallDestructors(
        __int64 (__fastcall ****a1)(_QWORD, __int64),
        __int64 a2)
{
  __int64 v2; // rdi
  __int64 result; // rax

  if ( a2 )
  {
    v2 = a2;
    do
    {
      result = ATL::CAutoPtr<ATL::CDacl::CAccessAce>::Free(a1++);
      --v2;
    }
    while ( v2 );
  }
  return result;
}

//----- (0000000180002B38) ----------------------------------------------------
__int64 __fastcall JobStore::GenerateJobSecurity(
        HKEY *this,
        tsched *a2,
        LPCWSTR StringSecurityDescriptor,
        BOOLEAN IsDirectoryObject,
        HANDLE a5,
        PSECURITY_DESCRIPTOR *NewDescriptor)
{
  int v10; // ebx
  const unsigned __int16 *v11; // rdx
  PSECURITY_DESCRIPTOR ParentDescriptor[2]; // [rsp+38h] [rbp-30h] BYREF
  PSECURITY_DESCRIPTOR CreatorDescriptor[3]; // [rsp+48h] [rbp-20h] BYREF

  JobSecurity::JobSecurity((JobSecurity *)CreatorDescriptor);
  if ( !StringSecurityDescriptor || (v10 = JobSecurity::SetSddl(CreatorDescriptor, StringSecurityDescriptor), v10 >= 0) )
  {
    JobSecurity::JobSecurity((JobSecurity *)ParentDescriptor);
    if ( tsched::IsRoot(a2, v11)
      || (v10 = JobStore::RegContainerJobSecurityQuery(this, (wchar_t *)a2, ParentDescriptor), v10 >= 0) )
    {
      v10 = JobSecurity::Generate(NewDescriptor, ParentDescriptor[0], CreatorDescriptor[0], IsDirectoryObject, a5);
      if ( v10 >= 0 )
        v10 = 0;
    }
    tsched::AutoLocalPtr<unsigned short>::~AutoLocalPtr<unsigned short>(ParentDescriptor);
  }
  tsched::AutoLocalPtr<unsigned short>::~AutoLocalPtr<unsigned short>(CreatorDescriptor);
  return (unsigned int)v10;
}
// 180002B90: variable 'v11' is possibly undefined

//----- (0000000180002C14) ----------------------------------------------------
int __fastcall JobSecurity::Generate(
        PSECURITY_DESCRIPTOR *NewDescriptor,
        PSECURITY_DESCRIPTOR ParentDescriptor,
        PSECURITY_DESCRIPTOR CreatorDescriptor,
        BOOLEAN IsDirectoryObject,
        HANDLE Token)
{
  NTSTATUS v6; // eax
  struct _GENERIC_MAPPING GenericMapping; // [rsp+40h] [rbp-28h] BYREF

  GenericMapping.GenericRead = 1179785;
  GenericMapping.GenericWrite = 1179926;
  GenericMapping.GenericExecute = 1179808;
  GenericMapping.GenericAll = 2032127;
  v6 = RtlNewSecurityObjectEx(
         ParentDescriptor,
         CreatorDescriptor,
         NewDescriptor,
         0LL,
         IsDirectoryObject,
         3u,
         Token,
         &GenericMapping);
  if ( v6 < 0 )
    return v6 | 0x10000000;
  *((_DWORD *)NewDescriptor + 2) = RtlLengthSecurityDescriptor(*NewDescriptor);
  return 0;
}

//----- (0000000180002CC8) ----------------------------------------------------
__int64 __fastcall JobStore::RegContainerJobSecurityQuery(HKEY *this, wchar_t *a2, void **a3)
{
  wchar_t *v6; // rbx
  __int64 result; // rax

  v6 = wcsrchr(a2, 0x5Cu);
  if ( !v6 || v6 == a2 )
    return JobStore::RegJobSecurityQuery(this, L"\\", a3);
  *v6 = 0;
  result = JobStore::RegJobSecurityQuery(this, a2, a3);
  *v6 = 92;
  return result;
}

//----- (0000000180002D50) ----------------------------------------------------
signed int __fastcall JobSecurity::SetSddl(PSECURITY_DESCRIPTOR *SecurityDescriptor, LPCWSTR StringSecurityDescriptor)
{
  tsched *v3; // rcx

  if ( !StringSecurityDescriptor || !*StringSecurityDescriptor )
  {
    tsched::AutoLocalPtr<_SECURITY_DESCRIPTOR>::Attach(SecurityDescriptor, 0LL);
    *((_DWORD *)SecurityDescriptor + 2) = 0;
    return 0;
  }
  if ( ConvertStringSecurityDescriptorToSecurityDescriptorW(
         StringSecurityDescriptor,
         1u,
         SecurityDescriptor,
         (PULONG)SecurityDescriptor + 2) )
  {
    return 0;
  }
  return tsched::GetLastHrError(v3);
}
// 180002D97: variable 'v3' is possibly undefined

//----- (0000000180002DB0) ----------------------------------------------------
__int64 __fastcall ItSpUpdateSystemSnapshots(struct _ITSRV_GLOBAL_CONTEXT *a1)
{
  unsigned int SystemSnapshot; // ebx
  int v4; // [rsp+20h] [rbp-78h] BYREF
  int v5; // [rsp+24h] [rbp-74h]
  int v6; // [rsp+30h] [rbp-68h]
  __int64 v7; // [rsp+38h] [rbp-60h]

  v6 = 0;
  v7 = 0LL;
  v5 &= 0xFFFFFFC0;
  v4 = -1;
  SystemSnapshot = ItSpGetSystemSnapshot(a1, (struct _ITSRV_SYSTEM_SNAPSHOT *)&v4);
  if ( !SystemSnapshot
    && (v4 - *((_DWORD *)a1 + 116) < (unsigned int)(*((_DWORD *)a1 + 96) - 300)
     || (SystemSnapshot = ItSpCopySystemSnapshot(
                            (struct _ITSRV_GLOBAL_CONTEXT *)((char *)a1 + 552),
                            (struct _ITSRV_GLOBAL_CONTEXT *)((char *)a1 + 464))) == 0) )
  {
    SystemSnapshot = ItSpCopySystemSnapshot(
                       (struct _ITSRV_GLOBAL_CONTEXT *)((char *)a1 + 464),
                       (struct _ITSRV_SYSTEM_SNAPSHOT *)&v4);
  }
  ItSpCleanupSystemSnapshot((struct _ITSRV_SYSTEM_SNAPSHOT *)&v4);
  return SystemSnapshot;
}

//----- (0000000180002E74) ----------------------------------------------------
void __fastcall ItSpCleanupSystemSnapshot(struct _ITSRV_SYSTEM_SNAPSHOT *a1)
{
  void *v1; // rbx
  HANDLE ProcessHeap; // rax

  v1 = (void *)*((_QWORD *)a1 + 3);
  if ( v1 )
  {
    ProcessHeap = GetProcessHeap();
    HeapFree(ProcessHeap, 0, v1);
  }
}

//----- (0000000180002EB0) ----------------------------------------------------
__int64 __fastcall ATL::CAutoPtr<ATL::CDacl::CAccessAce>::Free(__int64 (__fastcall ****a1)(_QWORD, __int64))
{
  __int64 (__fastcall ***v2)(_QWORD, __int64); // rcx
  __int64 result; // rax

  v2 = *a1;
  if ( v2 )
    result = (**v2)(v2, 1LL);
  *a1 = 0LL;
  return result;
}

//----- (0000000180002EF0) ----------------------------------------------------
__int64 __fastcall Triggers::TriggerBase::StreamOut(
        Triggers::TriggerBase *this,
        __int64 a2,
        unsigned __int8 **a3,
        unsigned __int8 *a4)
{
  int v8; // eax
  unsigned __int8 *v9; // rsi

  v8 = (*(__int64 (__fastcall **)(Triggers::TriggerBase *))(*(_QWORD *)this + 88LL))(this);
  v9 = *a3;
  if ( &(*a3)[v8] > a4 || (unsigned __int64)(a4 - v9) < 8 )
    return 2147549183LL;
  *(_DWORD *)v9 = (*(__int64 (__fastcall **)(Triggers::TriggerBase *))(*(_QWORD *)this + 72LL))(this);
  *a3 += 4;
  *(_DWORD *)*a3 = 0;
  *a3 += 4;
  return (*(__int64 (__fastcall **)(Triggers::TriggerBase *, __int64, unsigned __int8 **, unsigned __int8 *))(*(_QWORD *)this + 112LL))(
           this,
           a2,
           a3,
           a4);
}

//----- (0000000180002FA0) ----------------------------------------------------
const struct ATL::CAcl::CAce *__fastcall ATL::CDacl::GetAce(ATL::CDacl *this, unsigned int a2)
{
  if ( (unsigned __int64)a2 >= *((_QWORD *)this + 4) )
    ATL::PrivateAtlThrow(-2147024809);
  return *(const struct ATL::CAcl::CAce **)(*((_QWORD *)this + 3) + 8LL * a2);
}

//----- (0000000180002FD0) ----------------------------------------------------
__int64 __fastcall I_pSetTaskDisabledForCurrentUser(__int64 a1, char *a2, char a3)
{
  return RpcServer::SetTaskDisabledForCurrentUser((RTL_SRWLOCK *)&RpcServer::s_singleton, a2, a3);
}
// 1800B0D48: using guessed type __int64 RpcServer::s_singleton;

//----- (0000000180002FE4) ----------------------------------------------------
__int64 __fastcall RpcServer::SetTaskDisabledForCurrentUser(RTL_SRWLOCK *this, char *a2, char a3)
{
  const unsigned __int16 *v6; // r8
  __int64 result; // rax
  const unsigned __int16 *v8; // rdx
  int CallerToken; // edi
  __int64 v10; // r9
  RTL_SRWLOCK *v11; // [rsp+38h] [rbp-D0h] BYREF
  HANDLE ClientToken; // [rsp+40h] [rbp-C8h] BYREF
  __int64 v13[2]; // [rsp+48h] [rbp-C0h] BYREF
  char v14[16]; // [rsp+58h] [rbp-B0h] BYREF
  char v15[16]; // [rsp+68h] [rbp-A0h] BYREF
  wmi::RefBase *v16; // [rsp+78h] [rbp-90h] BYREF
  unsigned __int16 v17[264]; // [rsp+88h] [rbp-80h] BYREF

  v13[1] = -2LL;
  if ( !a2 )
    return 2147942487LL;
  memset_0(v17, 0, 0x20AuLL);
  result = tsched::TaskPathCanonicalize((tsched *)v17, a2, v6);
  if ( (int)result < 0 )
    return result;
  if ( tsched::IsRoot((tsched *)v17, v8) )
    return 2147942487LL;
  v13[0] = 0LL;
  RpcAutoImpersonate::RpcAutoImpersonate((RpcAutoImpersonate *)&v11, L"RpcServer::SetTaskDisabledForCurrentUser", 1);
  CallerToken = User::FromImpersonationToken((struct User *)v13, 0LL);
  if ( CallerToken < 0 )
  {
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_SD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x54u,
        (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids,
        v17);
    }
    if ( (_DWORD)v11 )
      RpcRevertToSelf();
  }
  else
  {
    if ( (_DWORD)v11 )
      RpcRevertToSelf();
    ClientToken = 0LL;
    CallerToken = GetCallerToken(L"SetTaskDisabledForCurrentUser", &ClientToken);
    if ( CallerToken >= 0 )
    {
      JobMoniker::JobMoniker((JobMoniker *)v14, v17, 0LL);
      v11 = this + 2;
      AcquireSRWLockShared(this + 2);
      CallerToken = TaskAccessCheck(ClientToken, v17, 1u);
      if ( CallerToken < 0
        || (CallerToken = JobStore::LoadBucketFromRegistry(
                            (HKEY *)JobStore::m_pCommonStore,
                            v17,
                            2,
                            (__int64)v14,
                            0LL,
                            0LL),
            CallerToken < 0) )
      {
        ReleaseSRWLockShared(this + 2);
      }
      else
      {
        ReleaseSRWLockShared(this + 2);
        LOBYTE(v10) = a3 != 0;
        CallerToken = (*((__int64 (__fastcall **)(void ***, char *, __int64 *, __int64))UbpmProxySingleton::s_singleton[0]
                       + 14))(
                        UbpmProxySingleton::s_singleton,
                        v14,
                        v13,
                        v10);
      }
      wmi::AutoRef<JobBucket>::Release(&v16);
      _bstr_t::_Free((_bstr_t *)v15);
    }
    wmi::AutoHandle::Close(&ClientToken);
  }
  wmi::AutoRef<User::UserEntry>::Release(v13);
  return (unsigned int)CallerToken;
}
// 180003045: variable 'v6' is possibly undefined
// 180003056: variable 'v8' is possibly undefined
// 180003177: variable 'v10' is possibly undefined
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 1800AFFB0: using guessed type void **UbpmProxySingleton::s_singleton[2];
// 180002FE4: using guessed type char var_250[16];

//----- (00000001800031E0) ----------------------------------------------------
__int64 __fastcall Triggers::TimeTrigger::GetStorageSize(Triggers::TimeTrigger *this)
{
  BSTR *v1; // rcx
  UINT v2; // eax
  int v3; // ecx

  v1 = (BSTR *)*((_QWORD *)this + 12);
  v2 = 0;
  if ( v1 && *v1 )
    v2 = SysStringLen(*v1);
  v3 = 2 * v2 + 4;
  if ( ((2 * (_BYTE)v2 + 4) & 7) != 0 )
    v3 += 8 - ((2 * (_BYTE)v2 + 4) & 7);
  return (unsigned int)(v3 + 96);
}

//----- (0000000180003220) ----------------------------------------------------
__int64 __fastcall ExeTask::GetStorageSize(ExeTask *this)
{
  BSTR *v1; // rax
  UINT v2; // ebx
  UINT v4; // ebp
  BSTR *v5; // rax
  UINT v6; // r14d
  BSTR *v7; // rax
  UINT v8; // esi
  BSTR *v9; // rax

  v1 = (BSTR *)*((_QWORD *)this + 2);
  v2 = 0;
  if ( v1 && *v1 )
    v4 = SysStringLen(*v1);
  else
    v4 = 0;
  v5 = (BSTR *)*((_QWORD *)this + 6);
  if ( v5 && *v5 )
    v6 = SysStringLen(*v5);
  else
    v6 = 0;
  v7 = (BSTR *)*((_QWORD *)this + 7);
  if ( v7 && *v7 )
    v8 = SysStringLen(*v7);
  else
    v8 = 0;
  v9 = (BSTR *)*((_QWORD *)this + 8);
  if ( v9 && *v9 )
    v2 = SysStringLen(*v9);
  return 2 * (v4 + v6 + v2 + v8) + 18;
}

//----- (00000001800032D4) ----------------------------------------------------
ATL::CComBSTR *__fastcall ATL::CComBSTR::CComBSTR(ATL::CComBSTR *this, LPCSTR *a2)
{
  BSTR v4; // rax

  v4 = ATL::CComBSTR::Copy(a2);
  *(_QWORD *)this = v4;
  if ( *a2 && !v4 )
    ATL::PrivateAtlThrow(-2147024882);
  return this;
}

//----- (0000000180003320) ----------------------------------------------------
bool __fastcall ATL::CDacl::CAccessAce::AceType(ATL::CDacl::CAccessAce *this)
{
  return *((_BYTE *)this + 144) == 0;
}

//----- (0000000180003334) ----------------------------------------------------
__int64 __fastcall TaskXmlReader::LoadValue(TaskXmlReader *this, unsigned int *a2)
{
  _DWORD *v2; // rbx
  __int64 result; // rax
  int v6; // r9d
  int v7; // edx
  unsigned int v8; // r8d
  unsigned int v9; // edx

  v2 = (_DWORD *)((char *)this + 64);
  result = TaskXmlReader::LoadRawValue(this, (TaskXmlReader *)((char *)this + 64));
  v6 = 0;
  if ( (int)result >= 0 )
  {
    *a2 = 0;
    if ( *v2 )
    {
      while ( 1 )
      {
        v7 = *(unsigned __int16 *)(*((_QWORD *)this + 9) + 2LL * v6);
        if ( (unsigned __int16)(v7 - 48) > 9u )
          break;
        v8 = *a2;
        v9 = v7 + 2 * (v8 + 4 * (v8 - 6));
        *a2 = v9;
        if ( v9 < v8 )
          break;
        if ( (unsigned int)++v6 >= *v2 )
          return 0LL;
      }
      return 2147750680LL;
    }
    else
    {
      return 0LL;
    }
  }
  return result;
}

//----- (00000001800033C0) ----------------------------------------------------
__int64 __fastcall ComHandlerBase::GetStorageSize(ComHandlerBase *this)
{
  BSTR *v1; // rax
  UINT v2; // ebx
  UINT v4; // edi
  BSTR *v5; // rax

  v1 = (BSTR *)*((_QWORD *)this + 2);
  v2 = 0;
  if ( v1 && *v1 )
    v4 = SysStringLen(*v1);
  else
    v4 = 0;
  v5 = (BSTR *)*((_QWORD *)this + 9);
  if ( v5 && *v5 )
    v2 = SysStringLen(*v5);
  return 2 * (v2 + v4) + 24;
}

//----- (0000000180003424) ----------------------------------------------------
__int64 __fastcall TaskXmlReader::LoadLogon(TaskXmlReader *this, enum JobFlags::JobFlag *a2)
{
  const wchar_t **v2; // rdi
  __int64 result; // rax

  v2 = (const wchar_t **)((char *)this + 64);
  result = TaskXmlReader::LoadRawValue(this, (TaskXmlReader *)((char *)this + 64));
  if ( (int)result >= 0 )
  {
    if ( *(_DWORD *)v2 )
    {
      *(_DWORD *)a2 = 0;
      if ( XmlParserTempString::IsEqualTo(v2, L"S4U", 3uLL) )
      {
        *(_DWORD *)a2 = 0x4000;
        return 0LL;
      }
      if ( XmlParserTempString::IsEqualTo(v2, L"Password", 8uLL) )
      {
        *(_DWORD *)a2 = 0x40000;
        return 0LL;
      }
      if ( XmlParserTempString::IsEqualTo(v2, L"InteractiveToken", 0x10uLL) )
      {
        *(_DWORD *)a2 = 0x10000;
        return 0LL;
      }
      if ( XmlParserTempString::IsEqualTo(v2, L"InteractiveTokenOrPassword", 0x1AuLL) )
      {
        *(_DWORD *)a2 = 0x80000;
        return 0LL;
      }
    }
    return 2147750680LL;
  }
  return result;
}

//----- (00000001800034D0) ----------------------------------------------------
__int64 __fastcall UbpmProxySingleton::SetTaskDisabledForUser(
        UbpmProxySingleton *this,
        const wchar_t **a2,
        const struct User *a3,
        char a4)
{
  __int64 v7; // rdx
  signed int v8; // ebx
  __int64 v9; // r8
  int v10; // eax
  __int64 v12[3]; // [rsp+30h] [rbp-18h] BYREF

  v12[0] = 0LL;
  v8 = UbpmProxySingleton::OpenConsumer(this, (const struct JobMoniker *)a2, (struct AutoUbpmConsumerHandle *)v12);
  if ( v8 >= 0 )
  {
    LOBYTE(v9) = a4;
    v10 = UbpmTriggerConsumerSetDisabledForUser(v12[0], *(_QWORD *)(*(_QWORD *)a3 + 32LL), v9);
    v8 = v10;
    if ( v10 > 0 )
      v8 = (unsigned __int16)v10 | 0x80070000;
  }
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
  {
    v7 = ((v8 >> 31) & 0xFFFFFFFE) + 4;
    if ( *((unsigned __int8 *)WPP_GLOBAL_Control + 25) >= (int)v7 )
      WPP_SF_SdD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x1Cu,
        (__int64)&WPP_ffeb42fce81a3445f9740a981b62c86a_Traceguids,
        a2[3]);
  }
  if ( v12[0] )
    UbpmCloseTriggerConsumer(v12[0], v7);
  return (unsigned int)v8;
}
// 180003511: variable 'v9' is possibly undefined
// 180003551: variable 'v7' is possibly undefined
// 180073D28: using guessed type __int64 __fastcall UbpmTriggerConsumerSetDisabledForUser(_QWORD, _QWORD, _QWORD);
// 180073D60: using guessed type __int64 __fastcall UbpmCloseTriggerConsumer(_QWORD, _QWORD);
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 1800034D0: using guessed type __int64 var_18[3];

//----- (0000000180003580) ----------------------------------------------------
__int64 __fastcall SchRpcScheduledRuntimes(
        __int64 a1,
        char *a2,
        struct _SYSTEMTIME *a3,
        struct _SYSTEMTIME *a4,
        unsigned int a5,
        int a6,
        unsigned int *a7,
        struct _SYSTEMTIME **a8)
{
  return RpcServer::Runtimes((RTL_SRWLOCK *)&RpcServer::s_singleton, a2, a3, a4, a5, a6, a7, a8);
}
// 180003580: could not find valid save-restore pair for rbp
// 1800B0D48: using guessed type __int64 RpcServer::s_singleton;

//----- (00000001800035E4) ----------------------------------------------------
__int64 __fastcall JobMoniker::SetExistingId(JobMoniker *this)
{
  HKEY *v1; // rbx
  const unsigned __int16 *Path; // rax
  __int64 result; // rax
  struct _GUID v5; // [rsp+20h] [rbp-28h] BYREF

  v1 = (HKEY *)JobStore::m_pCommonStore;
  v5 = GUID_NULL;
  Path = JobMoniker::GetPath(this);
  result = JobStore::RegGetTreeInfo(v1, Path, &v5, 0LL);
  if ( (int)result >= 0 )
    *(struct _GUID *)this = v5;
  return result;
}

//----- (0000000180003658) ----------------------------------------------------
void __fastcall CDLink::UnLink(CDLink *this)
{
  __int64 v1; // rdx
  __int64 v2; // rdx

  v1 = *((_QWORD *)this + 1);
  if ( v1 )
    *(_QWORD *)(v1 + 16) = *((_QWORD *)this + 2);
  v2 = *((_QWORD *)this + 2);
  if ( v2 )
    *(_QWORD *)(v2 + 8) = *((_QWORD *)this + 1);
  *((_QWORD *)this + 2) = 0LL;
  *((_QWORD *)this + 1) = 0LL;
}

//----- (000000018000368C) ----------------------------------------------------
__int64 __fastcall Triggers::Trigulator::GetRunTimes(__int64 a1, __int128 *a2, __int128 *a3, __int64 a4, int a5)
{
  unsigned int v9; // edi
  _QWORD *v10; // rbx
  __int64 v11; // rax
  __int128 v12; // xmm0
  __int64 result; // rax
  __int128 v14; // [rsp+38h] [rbp-51h] BYREF
  __int128 v15; // [rsp+48h] [rbp-41h] BYREF
  __int128 v16[5]; // [rsp+58h] [rbp-31h] BYREF
  __int64 v17; // [rsp+A8h] [rbp+1Fh]

  v9 = 267013;
  if ( Triggers::Trigulator::HasTrigger(a1, 56797) )
  {
    v10 = *(_QWORD **)(a1 + 32);
    while ( 1 )
    {
      v10 = (_QWORD *)*v10;
      if ( v10 == *(_QWORD **)(a1 + 32) )
        break;
      if ( (*(unsigned int (__fastcall **)(_QWORD))(*(_QWORD *)v10[2] + 72LL))(v10[2]) == 56797 )
      {
        v11 = v10[2];
        v16[0] = *(_OWORD *)(v11 + 8);
        v16[1] = *(_OWORD *)(v11 + 24);
        v16[2] = *(_OWORD *)(v11 + 40);
        v16[3] = *(_OWORD *)(v11 + 56);
        v16[4] = *(_OWORD *)(v11 + 72);
        v12 = *a3;
        v17 = *(_QWORD *)(v11 + 88);
        v15 = *a2;
        v14 = v12;
        result = Scheduling::JobSchedule::GetRunTimes((__int64)v16, (TSTime *)&v15, (TSTime *)&v14, a4, a5);
        if ( (int)result < 0 )
          return result;
        if ( v9 != 1 && ((unsigned int)result <= 1 || v9 == 267013) )
          v9 = result;
      }
    }
  }
  return v9;
}
// 1800036E9: conditional instruction was optimized away because edi.4>=0

//----- (00000001800037B4) ----------------------------------------------------
__int64 __fastcall Scheduling::JobSchedule::GetRunTimes(__int64 a1, TSTime *a2, TSTime *a3, __int64 a4, int a5)
{
  unsigned __int16 wYear; // r14
  _OWORD *v9; // rax
  __int128 v10; // xmm0
  struct _TIME_ZONE_INFORMATION *p_TimeZoneInformation; // rbx
  WORD v12; // r11
  unsigned __int16 wDay; // r13
  int v14; // eax
  unsigned __int16 wMonth; // bx
  int v16; // r12d
  unsigned int v17; // esi
  bool v18; // zf
  __int64 v19; // r15
  unsigned int v20; // r12d
  unsigned int v21; // esi
  unsigned int v22; // eax
  FILETIME *v23; // rax
  __int64 result; // rax
  int v25; // ecx
  bool v26; // cf
  __int128 *v27; // rcx
  _OWORD *v28; // rax
  int *v29; // rax
  int *v30; // rdx
  __int64 v31; // r15
  __int64 v32; // rax
  unsigned __int64 v33; // rdx
  int *v34; // rax
  int *v35; // rdx
  __int64 v36; // rsi
  __int64 v37; // rax
  unsigned __int64 v38; // rdx
  int *v39; // rax
  int v40; // ecx
  unsigned __int16 v41; // ax
  int v42; // r11d
  unsigned int v43; // r10d
  unsigned __int16 v44; // r8
  unsigned __int64 v45; // rdx
  unsigned __int16 v46; // r9
  int v47; // eax
  bool v48; // cc
  __int16 v49; // bx
  WORD v50; // r9
  WORD v51; // r8
  __int16 v52; // r10
  int v53; // ecx
  unsigned __int16 v54; // r12
  int v55; // eax
  __int16 v56; // r10
  int v57; // r13d
  int v58; // r15d
  int v59; // edx
  unsigned __int16 v60; // ax
  unsigned __int16 v61; // si
  int v62; // eax
  int v63; // ecx
  __int16 v64; // ax
  __int64 v65; // r10
  int v66; // ecx
  int v67; // eax
  int v68; // r14d
  int v69; // esi
  unsigned __int16 v70; // r11
  unsigned __int16 v71; // bx
  __int16 v72; // r11
  int *v73; // rax
  unsigned __int64 v74; // rdx
  int *v75; // rax
  int v76; // r15d
  __int16 v77; // r9
  unsigned __int64 v78; // rdx
  int v79; // eax
  unsigned __int16 v80; // r8
  unsigned __int16 v81; // cx
  unsigned __int16 v82; // ax
  unsigned __int64 v83; // rdx
  unsigned __int16 v84; // si
  int v85; // eax
  WORD wDayOfWeek; // si
  int *v87; // rax
  unsigned __int16 v88; // dx
  WORD v89; // ax
  char v90; // r9
  int v91; // eax
  DWORD v92; // eax
  struct _TIME_ZONE_INFORMATION *v93; // rcx
  TSTime *v94; // r15
  unsigned int v95; // r10d
  __int64 v96; // rax
  int v97; // ecx
  int v98; // ecx
  int v99; // ecx
  __int16 v100; // r8
  __int16 v101; // r10
  __int16 v102; // si
  unsigned __int16 i; // r8
  unsigned __int16 v104; // bx
  unsigned __int16 v105; // ax
  unsigned __int16 v106; // ax
  unsigned __int16 v107; // r9
  unsigned __int64 v108; // rdx
  int v109; // ecx
  int v110; // eax
  int v111; // r15d
  unsigned __int16 v112; // dx
  int v113; // eax
  WORD v114; // ax
  __int16 v115; // dx
  WORD v116; // cx
  unsigned __int16 v117; // r15
  WORD v118; // ax
  WORD v119; // si
  int v120; // eax
  WORD v121; // r10
  int v122; // r12d
  int v123; // r15d
  unsigned __int16 v124; // r8
  __int16 v125; // si
  unsigned __int16 v126; // bx
  unsigned __int16 v127; // ax
  unsigned __int16 v128; // ax
  unsigned __int64 v129; // rdx
  int v130; // eax
  __int16 v131; // r8
  unsigned __int16 v132; // cx
  unsigned __int16 v133; // ax
  unsigned __int64 v134; // rdx
  int v135; // eax
  DWORD v136; // eax
  struct _TIME_ZONE_INFORMATION *v137; // rcx
  __int16 v138; // ax
  int v139; // r11d
  unsigned __int16 v140; // dx
  __int16 v141; // cx
  unsigned __int16 v142; // ax
  unsigned __int64 v143; // r10
  int v144; // eax
  unsigned __int16 v145[2]; // [rsp+30h] [rbp-D0h] BYREF
  int v146; // [rsp+34h] [rbp-CCh] BYREF
  __int16 v147; // [rsp+38h] [rbp-C8h]
  __int16 v148; // [rsp+3Ah] [rbp-C6h]
  __int16 v149; // [rsp+3Ch] [rbp-C4h]
  int v150; // [rsp+40h] [rbp-C0h]
  int v151; // [rsp+44h] [rbp-BCh] BYREF
  int v152; // [rsp+48h] [rbp-B8h] BYREF
  int v153; // [rsp+4Ch] [rbp-B4h]
  unsigned int v154; // [rsp+50h] [rbp-B0h] BYREF
  int v155; // [rsp+54h] [rbp-ACh] BYREF
  int v156; // [rsp+58h] [rbp-A8h] BYREF
  unsigned int v157; // [rsp+5Ch] [rbp-A4h]
  unsigned __int64 v158; // [rsp+60h] [rbp-A0h]
  int v159[2]; // [rsp+68h] [rbp-98h] BYREF
  struct _FILETIME FileTime[2]; // [rsp+70h] [rbp-90h] BYREF
  TSTime *v161; // [rsp+80h] [rbp-80h]
  __int64 v162; // [rsp+88h] [rbp-78h]
  TSTime *v163; // [rsp+90h] [rbp-70h]
  __int64 v164; // [rsp+98h] [rbp-68h]
  struct _FILETIME v165[2]; // [rsp+A0h] [rbp-60h] BYREF
  __int64 v166; // [rsp+B0h] [rbp-50h]
  __int128 v167; // [rsp+B8h] [rbp-48h] BYREF
  __int128 v168; // [rsp+D0h] [rbp-30h] BYREF
  __int128 v169; // [rsp+E0h] [rbp-20h] BYREF
  __int128 v170; // [rsp+F0h] [rbp-10h] BYREF
  char v171[16]; // [rsp+100h] [rbp+0h] BYREF
  SYSTEMTIME v172; // [rsp+110h] [rbp+10h] BYREF
  SYSTEMTIME UniversalTime; // [rsp+120h] [rbp+20h] BYREF
  struct _SYSTEMTIME LocalTime; // [rsp+130h] [rbp+30h] BYREF
  struct _SYSTEMTIME v175; // [rsp+140h] [rbp+40h] BYREF
  struct _SYSTEMTIME v176; // [rsp+150h] [rbp+50h] BYREF
  SYSTEMTIME SystemTime; // [rsp+160h] [rbp+60h] BYREF
  struct _TIME_ZONE_INFORMATION TimeZoneInformation; // [rsp+170h] [rbp+70h] BYREF
  unsigned __int16 v179[8]; // [rsp+220h] [rbp+120h] BYREF
  __int128 v180; // [rsp+230h] [rbp+130h]
  __int128 v181; // [rsp+240h] [rbp+140h]
  __int64 v182; // [rsp+250h] [rbp+150h]
  unsigned __int16 v183[8]; // [rsp+258h] [rbp+158h] BYREF
  __int128 v184; // [rsp+268h] [rbp+168h]
  __int128 v185; // [rsp+278h] [rbp+178h]
  __int64 v186; // [rsp+288h] [rbp+188h]
  unsigned __int16 v187[28]; // [rsp+290h] [rbp+190h] BYREF

  v166 = a4;
  v163 = a3;
  v161 = a2;
  wYear = 0;
  if ( TSTime::operator<((__int64)a3, (__int128 *)a2) )
    return 267012LL;
  if ( *(_BYTE *)a1 != *(_BYTE *)a2 )
  {
    if ( *(_BYTE *)a1 )
    {
      *(_OWORD *)a2 = *TSTime::ToLocal((__int128 *)a2, &UniversalTime);
      v9 = TSTime::ToLocal((__int128 *)a3, &UniversalTime);
    }
    else
    {
      *(_OWORD *)a2 = *TSTime::ToGMT((__int128 *)a2, &UniversalTime);
      v9 = TSTime::ToGMT((__int128 *)a3, &UniversalTime);
    }
    *(_OWORD *)a3 = *v9;
  }
  if ( *(_BYTE *)a1 != *(_BYTE *)(a1 + 16) )
  {
    v27 = (__int128 *)(a1 + 16);
    if ( *(_BYTE *)a1 )
      v28 = TSTime::ToLocal(v27, &UniversalTime);
    else
      v28 = TSTime::ToGMT(v27, &UniversalTime);
    *(_OWORD *)(a1 + 16) = *v28;
  }
  TSTime::TSTime((TSTime *)&v168);
  TSTime::TSTime((TSTime *)&v167);
  v10 = *(_OWORD *)a1;
  v156 = 0;
  v168 = v10;
  if ( *(_BYTE *)a1 )
  {
    LocalTime = *TSTime::ToSYSTEMTIME((TSTime *)a1, &UniversalTime);
  }
  else
  {
    p_TimeZoneInformation = &TimeZoneInformation;
    if ( GetTimeZoneInformation(&TimeZoneInformation) == -1 )
      p_TimeZoneInformation = 0LL;
    TSTime::ToSYSTEMTIME((TSTime *)a1, &UniversalTime);
    SystemTimeToTzSpecificLocalTime(p_TimeZoneInformation, &UniversalTime, &LocalTime);
  }
  v167 = *(_OWORD *)Scheduling::JobSchedule::GetStop(a1, (__int64)&UniversalTime);
  if ( TSTime::operator<((__int64)&v167, (__int128 *)a2) )
    return 267012LL;
  if ( TSTime::operator<((__int64)&v167, (__int128 *)a3) )
    *(_OWORD *)a3 = v167;
  if ( TSTime::operator>((__int64)&v168, (__int128 *)a3) )
    return 267012LL;
  TSTime::TSTime((TSTime *)FileTime);
  TSTime::TSTime((TSTime *)v165);
  TSTime::TSTime((TSTime *)&v169);
  v12 = 0;
  v151 = 0;
  v150 = 0;
  wDay = 0;
  v14 = *(_DWORD *)(a1 + 60);
  wMonth = 0;
  v155 = 0;
  v16 = 0;
  v159[0] = 0;
  v152 = 0;
  LOWORD(v158) = 0;
  v145[0] = 0;
  LOWORD(v153) = 0;
  LOWORD(v162) = 0;
  v148 = 0;
  LOWORD(v164) = 0;
  v147 = 0;
  v146 = 0;
  if ( v14 < 0 )
    return 2147500037LL;
  if ( v14 <= 1 )
  {
    *(_OWORD *)&FileTime[0].dwLowDateTime = v168;
    goto LABEL_18;
  }
  if ( v14 == 2 )
  {
    wDayOfWeek = LocalTime.wDayOfWeek;
    v87 = std::bitset<7>::bitset<7>(&v146, *(unsigned __int16 *)(a1 + 66));
    v12 = 0;
    v88 = 0;
    v151 = *v87;
    while ( 1 )
    {
      v89 = wDayOfWeek - 7;
      if ( wDayOfWeek < 7u )
        v89 = wDayOfWeek;
      v90 = v89;
      v158 = v89;
      if ( v89 >= 7uLL )
        break;
      v91 = *(&v151 + ((unsigned __int64)v89 >> 5));
      if ( _bittest(&v91, v90 & 0x1F) )
      {
        *(_OWORD *)&FileTime[0].dwLowDateTime = *(_OWORD *)TSTime::operator+(
                                                             (__int64)&v168,
                                                             (__int64)&UniversalTime,
                                                             86400 * (unsigned int)v88);
        goto LABEL_18;
      }
      ++v88;
      ++wDayOfWeek;
      if ( v88 >= 7u )
        goto LABEL_18;
    }
LABEL_257:
    std::_Xout_of_range("invalid bitset<N> position");
  }
  if ( v14 == 3 )
  {
    v68 = *(unsigned __int16 *)(a1 + 68);
    v69 = *(_DWORD *)(a1 + 64);
    if ( v68 == 2 && v69 == 0x10000000 )
    {
      TSTime::ToSYSTEMTIME(a2, &v175);
      TSTime::ToSYSTEMTIME(v163, &v176);
      if ( v176.wYear - v175.wYear < 8 )
      {
        v70 = v175.wYear + (v175.wMonth > 2u);
        v71 = v176.wYear + (v176.wMonth > 2u);
        while ( v70 < v71 )
        {
          if ( TSTime::IsLeapYear(v70) )
            goto LABEL_91;
          v70 = v72 + 1;
        }
        return 267012LL;
      }
    }
LABEL_91:
    if ( (v69 & 0x9FFFFFFF) == 0
      && ((v68 & 0xFFD) == 0 || (v69 & 0x20000000) == 0)
      && ((v68 & 0xAD5) == 0 || (v69 & 0x40000000) == 0) )
    {
      return 267012LL;
    }
    v73 = std::bitset<31>::bitset<31>(v159, *(unsigned int *)(a1 + 64));
    v74 = *(unsigned __int16 *)(a1 + 68);
    v159[0] = *v73;
    v75 = std::bitset<12>::bitset<12>(&v152, v74);
    wYear = LocalTime.wYear;
    wDay = LocalTime.wDay;
    v76 = 0;
    wMonth = LocalTime.wMonth;
    v152 = *v75;
    LOWORD(v154) = LocalTime.wYear + 2;
LABEL_95:
    if ( ++v16 > 2 )
    {
      ++wMonth;
      v16 = 0;
      if ( wMonth > 0xCu )
      {
        wMonth = 1;
        ++wYear;
      }
    }
    TSTime::MonthDays(wMonth, wYear, v145);
    v12 = 0;
    v77 = 0;
    if ( v145[0] )
    {
      while ( 1 )
      {
        if ( wDay > v145[0] )
        {
          wDay = 1;
          v146 = 1;
        }
        v78 = wDay - 1LL;
        if ( v78 >= 0x1F )
          goto LABEL_257;
        v79 = v159[v78 >> 5];
        if ( _bittest(&v79, ((_BYTE)wDay - 1) & 0x1F) || wDay == v145[0] && *(int *)(a1 + 64) < 0 )
          break;
        ++wDay;
        if ( (unsigned __int16)++v77 >= v145[0] )
          goto LABEL_108;
      }
      v76 = 1;
    }
LABEL_108:
    v80 = 0;
    while ( 1 )
    {
      v81 = wMonth;
      if ( wMonth > 0xCu )
        wMonth = 1;
      v82 = wYear + 1;
      if ( v81 <= 0xCu )
        v82 = wYear;
      v83 = wMonth - 1LL;
      wYear = v82;
      v84 = v82;
      if ( v83 >= 0xC )
        goto LABEL_257;
      v85 = *(&v152 + (v83 >> 5));
      if ( _bittest(&v85, v83 & 0x1F) )
      {
        if ( !v146 )
        {
          if ( v80 )
          {
LABEL_121:
            v76 = 0;
            v146 = 0;
          }
LABEL_122:
          if ( !v76 )
          {
            wDay = 1;
            goto LABEL_128;
          }
          TSTime::MonthDays(wMonth, v84, v145);
          v12 = 0;
          if ( wDay <= v145[0] )
          {
LABEL_128:
            if ( v76 )
              goto LABEL_18;
          }
          else
          {
            if ( *(int *)(a1 + 64) < 0 )
            {
              wDay = v145[0];
              goto LABEL_18;
            }
            ++wMonth;
            v76 = 0;
            wDay = 1;
            v16 = 0;
            if ( wMonth > 0xCu )
            {
              wMonth = 1;
              wYear = v84 + 1;
              goto LABEL_128;
            }
          }
          if ( wYear >= (unsigned __int16)v154 )
            goto LABEL_18;
          goto LABEL_95;
        }
        if ( v80 )
          goto LABEL_121;
        v146 = 0;
      }
      ++wMonth;
      ++v80;
      v16 = 0;
      if ( v80 >= 0xCu )
        goto LABEL_122;
    }
  }
  if ( v14 != 4 )
    return 2147500037LL;
  v29 = std::bitset<7>::bitset<7>(&v152, *(unsigned __int16 *)(a1 + 64));
  v30 = &v151;
  v31 = 0LL;
  v151 = *v29;
  do
  {
    v32 = *(unsigned __int8 *)v30;
    v30 = (int *)((char *)v30 + 1);
    v31 += byte_1800801E0[v32];
  }
  while ( (char *)v30 - (char *)&v151 != (&v152 < &v151 ? 0 : 4) );
  v33 = *(unsigned __int16 *)(a1 + 66);
  v162 = v31;
  v34 = std::bitset<5>::bitset<5>(&v152, v33);
  v35 = &v155;
  v36 = 0LL;
  v155 = *v34;
  do
  {
    v37 = *(unsigned __int8 *)v35;
    v35 = (int *)((char *)v35 + 1);
    v36 += byte_1800801E0[v37];
  }
  while ( (char *)v35 - (char *)&v155 != (&v156 < &v155 ? 0 : 4) );
  v38 = *(unsigned __int16 *)(a1 + 68);
  v164 = v36;
  v39 = std::bitset<12>::bitset<12>(&v152, v38);
  wMonth = LocalTime.wMonth;
  wYear = LocalTime.wYear;
  v40 = *v39;
  v41 = 0;
  v152 = v40;
  while ( 2 )
  {
    LOWORD(v157) = v41;
    v42 = v41;
    v150 = v41;
    v43 = v41 + 12;
    do
    {
      v44 = wYear;
      v45 = wMonth - 1LL;
      v46 = wMonth;
      if ( v45 >= 0xC )
        goto LABEL_257;
      v47 = *(&v152 + (v45 >> 5));
      if ( _bittest(&v47, ((_BYTE)wMonth - 1) & 0x1F) )
        break;
      ++wYear;
      v48 = (unsigned __int16)(wMonth + 1) <= 0xCu;
      v49 = -11;
      if ( v48 )
      {
        wYear = v44;
        v49 = 1;
      }
      LOWORD(v42) = v42 + 1;
      wMonth = v46 + v49;
      v150 = v42;
    }
    while ( (unsigned __int16)v42 < v43 );
    v172 = LocalTime;
    v172.wMonth = wMonth;
    v172.wDay = 1;
    v172.wYear = wYear;
    v149 = v42;
    TzSpecificLocalTimeToSystemTime(0LL, &v172, &SystemTime);
    SystemTimeToTzSpecificLocalTime(0LL, &SystemTime, &v172);
    v50 = v172.wDayOfWeek;
    v12 = 0;
    v51 = LocalTime.wDay;
    v52 = v36;
    v147 = v36;
    v53 = 0;
    LOWORD(v154) = v172.wDayOfWeek;
    v54 = 0;
LABEL_60:
    v153 = v53;
    if ( v54 >= 0x23u )
      goto LABEL_82;
    if ( (unsigned __int16)v53 >= 5uLL )
      goto LABEL_257;
    v55 = *(&v155 + ((unsigned __int64)(unsigned __int16)v53 >> 5));
    if ( !_bittest(&v55, v53 & 0x1F) )
      goto LABEL_80;
    v148 = v31;
    v150 = 0;
    v147 = v52 - 1;
    v56 = v31;
    v57 = (unsigned __int16)(1 - v50);
    v58 = v50;
    while ( 1 )
    {
      v59 = v58 + v57;
      v146 = v58 + v57;
      v60 = v58 - 7;
      if ( (unsigned __int16)v58 < 7u )
        v60 = v58;
      v61 = v60;
      if ( v60 >= 7uLL )
        goto LABEL_257;
      v62 = *(&v151 + ((unsigned __int64)v60 >> 5));
      if ( !_bittest(&v62, v61 & 0x1F) )
      {
        v64 = v149;
        goto LABEL_76;
      }
      LOWORD(v59) = v54 + v59;
      v146 = v59;
      v148 = v56 - 1;
      TSTime::MonthDays(wMonth, wYear, v145);
      v63 = v146;
      if ( (unsigned __int16)v146 > v145[0] )
      {
        LOWORD(v63) = v146 - 7;
        v146 = v63;
      }
      v64 = v149;
      v12 = 0;
      v158 = v61;
      if ( v149 || (v51 = LocalTime.wDay, v158 = v61, (unsigned __int16)v63 >= LocalTime.wDay) )
      {
        wDay = v146;
        goto LABEL_82;
      }
      v56 = v148;
      if ( !v148 )
        break;
LABEL_76:
      HIWORD(v66) = HIWORD(v150);
      LOWORD(v66) = v150 + 1;
      LOWORD(v58) = v58 + 1;
      v150 = v66;
      if ( (unsigned __int16)v66 >= 7u )
        goto LABEL_77;
    }
    if ( !v147 )
    {
      wDay = v146;
      v65 = v61;
      LOWORD(v36) = v164;
      v41 = v157 + 1;
      LOWORD(v31) = v162;
      v158 = v65;
      continue;
    }
    break;
  }
LABEL_77:
  wDay = v146;
  v158 = v61;
  if ( !v64 )
  {
    v158 = v61;
    if ( (unsigned __int16)v146 < v51 )
    {
      v50 = v154;
      v52 = v147;
      LOWORD(v31) = v162;
LABEL_80:
      HIWORD(v53) = HIWORD(v153);
      LOWORD(v53) = v153 + 1;
      v54 += 7;
      goto LABEL_60;
    }
  }
LABEL_82:
  HIWORD(v67) = HIWORD(v150);
  LOWORD(v67) = v150 + 1;
  v150 = v67;
LABEL_18:
  if ( (unsigned int)(*(_DWORD *)(a1 + 60) - 3) <= 1 )
  {
    v172.wHour = LocalTime.wHour;
    v172.wMinute = LocalTime.wMinute;
    v172.wSecond = LocalTime.wSecond;
    v172.wYear = wYear;
    v172.wMonth = wMonth;
    v172.wDay = wDay;
    v172.wMilliseconds = v12;
    v92 = GetTimeZoneInformation(&TimeZoneInformation);
    v93 = &TimeZoneInformation;
    if ( v92 == -1 )
      v93 = 0LL;
    TzSpecificLocalTimeToSystemTime(v93, &v172, &SystemTime);
    SystemTime.wMilliseconds = 0;
    SystemTimeToFileTime(&SystemTime, &FileTime[1]);
  }
  v17 = -1;
  v169 = *(_OWORD *)&FileTime[0].dwLowDateTime;
  v18 = *(_DWORD *)(a1 + 52) == 0;
  *(_OWORD *)&v165[0].dwLowDateTime = *(_OWORD *)&FileTime[0].dwLowDateTime;
  if ( !v18 )
    v17 = *(_DWORD *)(a1 + 52);
  v157 = v17;
  *(_QWORD *)&v176.wYear = 10000000LL * v17;
  TSTime::operator+=((__int64)&v169, (__int64 *)&v176);
  v19 = *(unsigned int *)(a1 + 48);
  *(_QWORD *)&v176.wYear = v19;
  if ( (_DWORD)v19 )
  {
    v94 = v161;
    if ( TSTime::operator<((__int64)FileTime, (__int128 *)v161)
      && (v17 == -1 || TSTime::operator>((__int64)&v169, (__int128 *)v94) && !*(_DWORD *)(a1 + 60)) )
    {
      TSTime::EqualizeLocality((char *)v94, (__int128 *)&UniversalTime, (__int128 *)FileTime);
      *(_QWORD *)&v176.wYear = 10000000
                             * *(unsigned int *)(a1 + 48)
                             * ((*((_QWORD *)v94 + 1) - *(_QWORD *)&UniversalTime.wHour)
                              / (10000000LL
                               * *(unsigned int *)(a1 + 48)));
      TSTime::operator+=((__int64)FileTime, (__int64 *)&v176);
      v19 = v95;
    }
    else
    {
      v19 = *(unsigned int *)(a1 + 48);
    }
    *(_QWORD *)&v176.wYear = v19;
  }
  LOBYTE(v149) = *(_BYTE *)(a1 + 72);
  LOBYTE(UniversalTime.wYear) = 0;
  *(_QWORD *)&UniversalTime.wHour = 0LL;
  while ( 2 )
  {
    v146 = v17;
    v20 = v17;
LABEL_24:
    if ( TSTime::operator<=((__int64)FileTime, (__int128 *)v163) )
    {
      if ( TSTime::operator>((__int64)FileTime, (__int128 *)v161)
        || TSTime::operator==((__int64)v161, (__int128 *)v163)
        && TSTime::operator==((__int64)FileTime, (__int128 *)v161) )
      {
        if ( !v166 )
          return 1LL;
        if ( TSTime::operator!=((__int64)&UniversalTime, (__int128 *)FileTime) )
        {
          if ( !a5 )
            return 1LL;
          v21 = *(_DWORD *)(a1 + 56);
          if ( !(_DWORD)v19 || (v22 = v20, !(_BYTE)v149) )
            v22 = 0;
          if ( v22 && (v22 < v21 || !v21) )
            v21 = v22;
          UniversalTime = *(SYSTEMTIME *)&FileTime[0].dwLowDateTime;
          if ( *(_DWORD *)(a1 + 80) )
          {
            v154 = 0;
            rand_s(&v154);
            *(_QWORD *)&v175.wYear = 10000000LL * (v154 % *(_DWORD *)(a1 + 80));
            TSTime::operator+=((__int64)&UniversalTime, (__int64 *)&v175);
            if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x2000) != 0 )
            {
              TSTime::ToString((TSTime *)&UniversalTime, v187, 26);
              if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
                && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x2000) != 0
                && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
              {
                WPP_SF_SD(
                  *((_QWORD *)WPP_GLOBAL_Control + 2),
                  0xAu,
                  (__int64)&WPP_f32e8b4c95493fd2d2cc17cc251c34cf_Traceguids,
                  v187);
              }
            }
          }
          v23 = (FILETIME *)TSTime::ToGMT((__int128 *)&UniversalTime, &v170);
          result = RunList::Add(v166, v23[1], v21, *(_DWORD *)(a1 + 76));
          if ( (int)result < 0 )
            return result;
          ++v156;
          --a5;
          v17 = v157;
          UniversalTime = *(SYSTEMTIME *)&FileTime[0].dwLowDateTime;
        }
      }
      if ( !(_DWORD)v19 )
        goto LABEL_36;
      if ( v17 )
      {
        if ( (unsigned int)v19 > v20 || (_BYTE)v149 && (_DWORD)v19 == v20 )
        {
LABEL_36:
          v25 = *(_DWORD *)(a1 + 60);
          if ( !v25 )
            goto LABEL_37;
          v97 = v25 - 1;
          if ( v97 )
          {
            v98 = v97 - 1;
            if ( v98 )
            {
              v99 = v98 - 1;
              if ( v99 )
              {
                if ( v99 != 1 )
                  return 2147500037LL;
                v100 = v148;
                if ( !v148 )
                {
                  v101 = v147;
                  v102 = 1;
                  if ( v147 )
                  {
                    HIWORD(v111) = HIWORD(v153);
                    LOWORD(v111) = v153 + 1;
                    v153 = v111;
                    if ( (unsigned __int16)v111 < 5u )
                      goto LABEL_187;
                  }
                  else
                  {
                    for ( i = 0; i < 0xCu; ++i )
                    {
                      v104 = wMonth + 1;
                      v105 = wYear + 1;
                      if ( v104 <= 0xCu )
                        v105 = wYear;
                      wYear = v105;
                      v106 = 1;
                      if ( v104 <= 0xCu )
                        v106 = v104;
                      v107 = v106;
                      v108 = v106 - 1LL;
                      if ( v108 >= 0xC )
                        goto LABEL_257;
                      v109 = ((_BYTE)v106 - 1) & 0x1F;
                      v110 = *(&v152 + (v108 >> 5));
                      if ( _bittest(&v110, v109) )
                        break;
                      wMonth = v107;
                    }
                    v101 = v164;
                    LOWORD(v111) = 0;
                    wMonth = v107;
                    v147 = v164;
                    v153 = 0;
LABEL_187:
                    v112 = v111;
                    while ( 1 )
                    {
                      if ( v112 >= 5uLL )
                        goto LABEL_257;
                      v113 = *(&v155 + ((unsigned __int64)v112 >> 5));
                      if ( _bittest(&v113, v112 & 0x1F) )
                        break;
                      if ( ++v112 >= 5u )
                        goto LABEL_193;
                    }
                    LOWORD(v153) = v112;
                    v147 = v101 - 1;
                  }
LABEL_193:
                  SystemTime.wMonth = wMonth;
                  SystemTime.wDay = 1;
                  SystemTime.wYear = wYear;
                  SystemTimeToFileTime(&SystemTime, &FileTime[1]);
                  FileTimeToSystemTime(&FileTime[1], &SystemTime);
                  v100 = v162;
                  v114 = SystemTime.wDayOfWeek;
                  v115 = 0;
                  v148 = v162;
                  goto LABEL_195;
                }
                v114 = v158;
                v102 = v150;
                v115 = 1;
                while ( 1 )
                {
LABEL_195:
                  v116 = v114 + 1;
                  v117 = v102 + 1;
                  if ( !v115 )
                  {
                    v116 = v114;
                    v117 = v102;
                  }
                  v118 = v116 - 7;
                  if ( v116 < 7u )
                    v118 = v116;
                  v119 = v118;
                  if ( v118 >= 7uLL )
                    goto LABEL_257;
                  v120 = *(&v151 + ((unsigned __int64)v118 >> 5));
                  if ( _bittest(&v120, v119 & 0x1F) )
                    break;
                  ++v115;
                  v150 = v117;
                  v114 = v119;
                  if ( (unsigned __int16)v115 > 7u )
                    goto LABEL_205;
                  v102 = v150;
                }
                v148 = v100 - 1;
                wDay = v117 + 7 * v153;
                TSTime::MonthDays(wMonth, wYear, v145);
                if ( wDay > v145[0] )
                  wDay -= 7;
LABEL_205:
                v158 = v119;
                v121 = 0;
                v150 = v117;
              }
              else
              {
                v122 = 0;
                v123 = 0;
                do
                {
                  TSTime::MonthDays(wMonth, wYear, v145);
                  v124 = v145[0];
                  v125 = 1;
                  if ( v145[0] )
                  {
                    while ( 1 )
                    {
                      if ( ++wDay > v124 )
                      {
                        v126 = wMonth + 1;
                        v127 = wYear + 1;
                        wDay = 1;
                        v122 = 1;
                        if ( v126 <= 0xCu )
                          v127 = wYear;
                        wYear = v127;
                        v128 = 1;
                        if ( v126 <= 0xCu )
                          v128 = v126;
                        wMonth = v128;
                        TSTime::MonthDays(v128, wYear, v145);
                        v124 = v145[0];
                      }
                      v129 = wDay - 1LL;
                      if ( v129 >= 0x1F )
                        goto LABEL_257;
                      v130 = v159[v129 >> 5];
                      if ( _bittest(&v130, ((_BYTE)wDay - 1) & 0x1F) || wDay == v124 && *(int *)(a1 + 64) < 0 )
                        break;
                      if ( (unsigned __int16)++v125 > v124 )
                        goto LABEL_221;
                    }
                    v123 = 1;
                  }
LABEL_221:
                  v121 = 0;
                  if ( !v122 && v123 )
                    break;
                  v131 = 1;
                  while ( 1 )
                  {
                    v132 = wMonth;
                    if ( wMonth > 0xCu )
                      wMonth = 1;
                    v133 = wYear + 1;
                    if ( v132 <= 0xCu )
                      v133 = wYear;
                    v134 = wMonth - 1LL;
                    wYear = v133;
                    if ( v134 >= 0xC )
                      goto LABEL_257;
                    v135 = *(&v152 + (v134 >> 5));
                    if ( _bittest(&v135, v134 & 0x1F) )
                      break;
                    ++wMonth;
                    if ( (unsigned __int16)++v131 > 0xCu )
                      goto LABEL_236;
                  }
                  if ( v122 || (unsigned __int16)v131 > 1u )
                  {
                    v123 = 0;
                    wDay = 0;
                  }
                  v122 = 0;
LABEL_236:
                  ;
                }
                while ( !v123 );
                v20 = v146;
              }
              LODWORD(v19) = *(_DWORD *)&v176.wYear;
            }
            else
            {
              v138 = v158;
              v139 = 0;
              v140 = 1;
              while ( 1 )
              {
                v141 = v138;
                v142 = v138 + 1;
                if ( v142 >= 7u )
                  v139 = 1;
                v143 = (unsigned __int16)(v141 + (v142 < 7u ? 1 : -6));
                if ( v143 >= 7 )
                  goto LABEL_257;
                v144 = *(&v151 + ((unsigned __int64)(unsigned __int16)(v141 + (v142 < 7u ? 1 : -6)) >> 5));
                if ( _bittest(&v144, v143 & 0x1F) )
                  break;
                if ( ++v140 > 7u )
                  goto LABEL_253;
                v138 = v143;
              }
              *(_QWORD *)&v175.wYear = 864000000000LL * v140;
              TSTime::operator+=((__int64)v165, (__int64 *)&v175);
LABEL_253:
              if ( v139 )
              {
                *(_QWORD *)&v175.wYear = 10000000LL * (604800 * *(unsigned __int16 *)(a1 + 64) - 604800);
                TSTime::operator+=((__int64)v165, (__int64 *)&v175);
              }
              v158 = v143;
              v121 = 0;
            }
          }
          else
          {
            *(_QWORD *)&v175.wYear = 864000000000LL * *(unsigned __int16 *)(a1 + 64);
            TSTime::operator+=((__int64)v165, (__int64 *)&v175);
          }
          if ( (unsigned int)(*(_DWORD *)(a1 + 60) - 3) <= 1 )
          {
            v172.wHour = LocalTime.wHour;
            v172.wMinute = LocalTime.wMinute;
            v172.wSecond = LocalTime.wSecond;
            v172.wYear = wYear;
            v172.wMonth = wMonth;
            v172.wDay = wDay;
            v172.wMilliseconds = v121;
            v136 = GetTimeZoneInformation(&TimeZoneInformation);
            v137 = &TimeZoneInformation;
            if ( v136 == -1 )
              v137 = 0LL;
            TzSpecificLocalTimeToSystemTime(v137, &v172, &SystemTime);
            SystemTimeToFileTime(&SystemTime, &v165[1]);
          }
          v17 = v157;
          v169 = *(_OWORD *)&v165[0].dwLowDateTime;
          *(_OWORD *)&FileTime[0].dwLowDateTime = *(_OWORD *)&v165[0].dwLowDateTime;
          if ( (_DWORD)v19 )
            continue;
          goto LABEL_24;
        }
        v20 -= v19;
        v146 = v20;
      }
      v96 = TSTime::operator+((__int64)v165, (__int64)v171, v17);
      if ( TSTime::operator>=(v96, (__int128 *)v161) )
      {
        *(_QWORD *)&v175.wYear = 10000000LL * *(unsigned int *)(a1 + 48);
        TSTime::operator+=((__int64)FileTime, (__int64 *)&v175);
        goto LABEL_24;
      }
      goto LABEL_36;
    }
    break;
  }
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x2000) != 0 )
  {
    v186 = 0LL;
    *(_OWORD *)v183 = 0LL;
    v182 = 0LL;
    v184 = 0LL;
    v185 = 0LL;
    *(_OWORD *)v179 = 0LL;
    v180 = 0LL;
    v181 = 0LL;
    TSTime::ToString(v161, v183, 28);
    TSTime::ToString(v163, v179, 28);
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x2000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
    {
      WPP_SF_SSD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0xBu,
        (__int64)&WPP_f32e8b4c95493fd2d2cc17cc251c34cf_Traceguids,
        v183,
        (__int64)v179);
    }
  }
LABEL_37:
  v26 = v156 != 0;
  v156 = -v156;
  return v26 ? 0 : 0x41304;
}
// 18003A9F7: variable 'v72' is possibly undefined
// 18003ACEE: variable 'v12' is possibly undefined
// 18003ADBA: variable 'v95' is possibly undefined
// 18003B33D: variable 'v121' is possibly undefined
// 18003B435: variable 'v139' is possibly undefined
// 18003B460: variable 'v143' is possibly undefined
// 180074500: using guessed type __int64 __fastcall rand_s(_QWORD);
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 1800037B4: using guessed type __int128 var_258;
// 1800037B4: using guessed type char var_210[16];

//----- (0000000180003B1C) ----------------------------------------------------
__int64 __fastcall RunList::Add(__int64 a1, FILETIME a2, int a3, int a4)
{
  int v6; // ecx
  __int64 v8; // rdi
  _QWORD *v9; // rcx
  FILETIME v10; // rax
  int v11; // eax
  void (__fastcall ***v13)(_QWORD, __int64); // rcx
  FILETIME FileTime1; // [rsp+50h] [rbp+8h] BYREF
  FILETIME FileTime2; // [rsp+58h] [rbp+10h] BYREF

  FileTime2 = a2;
  v6 = *(_DWORD *)(a1 + 48);
  if ( !v6 && *(_DWORD *)(a1 + 40) == *(_DWORD *)(a1 + 44) )
    return 2147500037LL;
  v8 = *(_QWORD *)(a1 + 16);
  if ( v6 )
  {
    while ( 1 )
    {
      FileTime1 = *(FILETIME *)(v8 + 24);
      if ( !*(_QWORD *)&FileTime1 || CompareFileTime(&FileTime1, &FileTime2) < 0 )
        break;
      v8 = *(_QWORD *)(v8 + 16);
    }
  }
  v9 = operator new(0x28uLL);
  if ( v9 )
  {
    v10 = FileTime2;
    v9[1] = 0LL;
    v9[2] = 0LL;
    *v9 = &RunListItem::`vftable';
    v9[3] = v10;
    *((_DWORD *)v9 + 8) = a3;
    *((_DWORD *)v9 + 9) = a4;
  }
  else
  {
    v9 = 0LL;
  }
  if ( !v9 )
    return 2147942414LL;
  CDLink::LinkAfter((CDLink *)v9, (struct CDLink *)v8);
  v11 = *(_DWORD *)(a1 + 40);
  if ( v11 == *(_DWORD *)(a1 + 44) )
  {
    CDLink::UnLink(*(CDLink **)(a1 + 16));
    if ( v13 )
      (**v13)(v13, 1LL);
    return 1LL;
  }
  else
  {
    *(_DWORD *)(a1 + 40) = v11 + 1;
    return 0LL;
  }
}
// 18003B5EE: variable 'v13' is possibly undefined
// 180070228: using guessed type void *RunListItem::`vftable';

//----- (0000000180003BE0) ----------------------------------------------------
void __fastcall CDLink::LinkAfter(CDLink *this, struct CDLink *a2)
{
  __int64 v2; // rax

  *((_QWORD *)this + 2) = a2;
  if ( a2 )
  {
    *((_QWORD *)this + 1) = *((_QWORD *)a2 + 1);
    *((_QWORD *)a2 + 1) = this;
    v2 = *((_QWORD *)this + 1);
    if ( v2 )
      *(_QWORD *)(v2 + 16) = this;
  }
  else
  {
    *((_QWORD *)this + 1) = 0LL;
  }
}

//----- (0000000180003C20) ----------------------------------------------------
CDLink *__fastcall CDLink::`vector deleting destructor'(CDLink *this, char a2)
{
  *((_QWORD *)this + 1) = 0LL;
  *((_QWORD *)this + 2) = 0LL;
  *(_QWORD *)this = &RunListItem::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 180070228: using guessed type void *RunListItem::`vftable';

//----- (0000000180003C58) ----------------------------------------------------
__int64 __fastcall RpcServer::Runtimes(
        RTL_SRWLOCK *this,
        char *a2,
        struct _SYSTEMTIME *a3,
        struct _SYSTEMTIME *a4,
        unsigned int a5,
        int a6,
        unsigned int *a7,
        struct _SYSTEMTIME **a8)
{
  const unsigned __int16 *v12; // r8
  __int64 result; // rax
  int CallerToken; // esi
  BOOL v15; // ecx
  __int64 v16; // rax
  __int128 *v17; // rax
  __int128 *v18; // rax
  int v19; // r14d
  unsigned int v20; // eax
  struct _SYSTEMTIME *v21; // r14
  int v22; // r15d
  CDLink *i; // rdi
  CDLink *j; // rcx
  CDLink *v25; // rdi
  void (__fastcall ***v26)(_QWORD, __int64); // rcx
  DWORD LastError; // eax
  BOOL v28; // edx
  __int64 v29; // rax
  DWORD v30; // eax
  __int128 v31; // [rsp+48h] [rbp-C0h] BYREF
  __int128 FileTime_8; // [rsp+58h] [rbp-B0h] BYREF
  HANDLE ClientToken; // [rsp+68h] [rbp-A0h] BYREF
  __int128 v34; // [rsp+78h] [rbp-90h] BYREF
  __int128 v35; // [rsp+88h] [rbp-80h] BYREF
  void **v36; // [rsp+98h] [rbp-70h] BYREF
  CDLink *v37[2]; // [rsp+A0h] [rbp-68h]
  __int64 v38; // [rsp+B0h] [rbp-58h]
  __int64 v39; // [rsp+B8h] [rbp-50h]
  unsigned int v40; // [rsp+C0h] [rbp-48h]
  int v41; // [rsp+C4h] [rbp-44h]
  int v42; // [rsp+C8h] [rbp-40h]
  __int64 v43; // [rsp+D0h] [rbp-38h]
  RTL_SRWLOCK *v44; // [rsp+D8h] [rbp-30h]
  struct _FILETIME v45[7]; // [rsp+E0h] [rbp-28h] BYREF
  __int128 v46; // [rsp+118h] [rbp+10h] BYREF
  char v47[16]; // [rsp+128h] [rbp+20h] BYREF
  char v48[16]; // [rsp+138h] [rbp+30h] BYREF
  wmi::RefBase *v49; // [rsp+148h] [rbp+40h] BYREF
  struct _SYSTEMTIME v50; // [rsp+150h] [rbp+48h] BYREF
  __int128 pExceptionObject; // [rsp+160h] [rbp+58h] BYREF
  const unsigned __int16 *v52; // [rsp+170h] [rbp+68h]
  __int128 v53; // [rsp+178h] [rbp+70h]
  unsigned __int64 v54; // [rsp+188h] [rbp+80h]
  int v55; // [rsp+190h] [rbp+88h]
  unsigned __int16 v56[8]; // [rsp+198h] [rbp+90h] BYREF
  int v57; // [rsp+1A8h] [rbp+A0h]
  wchar_t v58; // [rsp+1ACh] [rbp+A4h]
  __int128 v59; // [rsp+1AEh] [rbp+A6h]
  __int64 v60; // [rsp+1BEh] [rbp+B6h]
  int v61; // [rsp+1C6h] [rbp+BEh]
  __int16 v62; // [rsp+1CAh] [rbp+C2h]
  unsigned __int16 v63[264]; // [rsp+1D8h] [rbp+D0h] BYREF

  v43 = -2LL;
  if ( !a2 || a5 || !a7 || !a8 )
    return 2147942487LL;
  memset_0(v63, 0, 0x20AuLL);
  result = tsched::TaskPathCanonicalize((tsched *)v63, a2, v12);
  if ( (int)result >= 0 )
  {
    ClientToken = 0LL;
    CallerToken = GetCallerToken(L"Runtimes", &ClientToken);
    if ( CallerToken >= 0 )
    {
      v44 = this + 2;
      AcquireSRWLockShared(this + 2);
      CallerToken = TaskAccessCheck(ClientToken, v63, 1u);
      if ( CallerToken >= 0 )
      {
        *a7 = 0;
        *a8 = 0LL;
        if ( a3 )
        {
          LOBYTE(v31) = 1;
          v15 = 1;
          v16 = 0LL;
          *(_QWORD *)&FileTime_8 = 0LL;
          if ( a3->wYear )
          {
            v15 = SystemTimeToFileTime(a3, (LPFILETIME)&FileTime_8);
            v16 = FileTime_8;
          }
          *((_QWORD *)&v31 + 1) = v16;
          if ( !v15 )
          {
            LastError = GetLastError();
            BYTE8(pExceptionObject) = 0;
            *(_QWORD *)&pExceptionObject = &wmi::GenericException::`vftable';
            v52 = &word_18007630E;
            v53 = 0uLL;
            v54 = LastError | 0xFFFFFFFF00000000uLL;
            v55 = -1;
            CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
          }
          v17 = &v31;
        }
        else
        {
          LOBYTE(v35) = 0;
          *((_QWORD *)&v35 + 1) = 0LL;
          v17 = &v35;
        }
        v35 = *v17;
        if ( a4 )
        {
          LOBYTE(v31) = 1;
          v28 = 1;
          v29 = 0LL;
          *(_QWORD *)&FileTime_8 = 0LL;
          if ( a4->wYear )
          {
            v28 = SystemTimeToFileTime(a4, (LPFILETIME)&FileTime_8);
            v29 = FileTime_8;
          }
          *((_QWORD *)&v31 + 1) = v29;
          if ( !v28 )
          {
            v30 = GetLastError();
            BYTE8(pExceptionObject) = 0;
            *(_QWORD *)&pExceptionObject = &wmi::GenericException::`vftable';
            v52 = &word_18007630E;
            v53 = 0uLL;
            v54 = v30 | 0xFFFFFFFF00000000uLL;
            v55 = -1;
            CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
          }
          v18 = &v31;
        }
        else
        {
          LOBYTE(v34) = 0;
          *((_QWORD *)&v34 + 1) = -1LL;
          v18 = &v34;
        }
        v34 = *v18;
        v19 = 4062;
        if ( a6 )
          v19 = a6;
        if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x200) != 0 )
        {
          pExceptionObject = *(_OWORD *)L"::FirstTime";
          v52 = *(const unsigned __int16 **)L"ime";
          v53 = 0LL;
          v54 = 0LL;
          v55 = 0;
          *(_OWORD *)v56 = *(_OWORD *)L"::LastTime";
          v57 = *(_DWORD *)L"me";
          v58 = aLasttime[10];
          v59 = 0LL;
          v60 = 0LL;
          v61 = 0;
          v62 = 0;
          LOBYTE(v31) = 0;
          *((_QWORD *)&v31 + 1) = 0LL;
          if ( TSTime::operator!=((__int64)&v35, &v31) )
            TSTime::ToString((TSTime *)&v35, (unsigned __int16 *)&pExceptionObject, 26);
          LOBYTE(v31) = 0;
          *((_QWORD *)&v31 + 1) = -1LL;
          if ( TSTime::operator!=((__int64)&v34, &v31) )
            TSTime::ToString((TSTime *)&v34, v56, 26);
          if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
            && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x200) != 0
            && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
          {
            WPP_SF_SSSDd(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              0x4Au,
              (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids,
              v63,
              (__int64)&pExceptionObject,
              (__int64)v56);
          }
        }
        Triggers::Trigulator::Trigulator(v45);
        JobMoniker::JobMoniker((JobMoniker *)v47, v63, 0LL);
        CallerToken = JobMoniker::SetExistingId((JobMoniker *)v47);
        if ( CallerToken >= 0 )
        {
          *(_QWORD *)&FileTime_8 = 0LL;
          CallerToken = JobStore::RegOpenTaskKey(
                          (HKEY *)JobStore::m_pCommonStore,
                          (struct JobMoniker *)v47,
                          (HKEY *)&FileTime_8,
                          0x20019u);
          if ( CallerToken < 0
            || (CallerToken = Triggers::Trigulator::StreamIn((wmi::RefBase **)v45, (HKEY)FileTime_8, 6, 0LL),
                CallerToken < 0) )
          {
            wmi::AutoRegKey::Close((HKEY *)&FileTime_8);
          }
          else
          {
            wmi::AutoRegKey::Close((HKEY *)&FileTime_8);
            CallerToken = Triggers::Trigulator::GetBucket((Triggers::Trigulator *)v45, (struct JobMoniker *)v47);
            if ( CallerToken >= 0 )
            {
              v36 = &RunListItem::`vftable';
              v38 = 0LL;
              v39 = 0LL;
              v40 = 0;
              v41 = v19;
              v42 = 1;
              v37[0] = (CDLink *)&v36;
              v37[1] = (CDLink *)&v36;
              v31 = v34;
              FileTime_8 = v35;
              CallerToken = Triggers::Trigulator::GetRunTimes((__int64)v45, &FileTime_8, &v31, (__int64)&v36, v19);
              if ( (unsigned int)CallerToken <= 1 )
              {
                v20 = v40;
                *a7 = v40;
                if ( v20 )
                {
                  *(_QWORD *)&FileTime_8 = 0LL;
                  v21 = (struct _SYSTEMTIME *)operator new(saturated_mul(v20, 0x10uLL));
                  *(_QWORD *)&FileTime_8 = v21;
                  v22 = 0;
                  for ( i = v37[0]; *((_DWORD *)i + 6) || *((_DWORD *)i + 7); i = (CDLink *)*((_QWORD *)i + 1) )
                  {
                    LOBYTE(v31) = 0;
                    *((_QWORD *)&v31 + 1) = *((_QWORD *)i + 3);
                    v31 = *TSTime::ToLocal(&v31, &v46);
                    v21[v22++] = *TSTime::ToSYSTEMTIME((TSTime *)&v31, &v50);
                  }
                  *a8 = v21;
                  operator delete(0LL);
                }
              }
              for ( j = v37[0]; *((_DWORD *)j + 6) || *((_DWORD *)j + 7); j = v25 )
              {
                v25 = (CDLink *)*((_QWORD *)j + 1);
                CDLink::UnLink(j);
                --v40;
                (**v26)(v26, 1LL);
              }
              v36 = &RunListItem::`vftable';
              *(_OWORD *)v37 = 0LL;
            }
          }
        }
        wmi::AutoRef<JobBucket>::Release(&v49);
        _bstr_t::_Free((_bstr_t *)v48);
        Triggers::Trigulator::~Trigulator((Triggers::Trigulator *)v45);
      }
      ReleaseSRWLockShared(this + 2);
    }
    wmi::AutoHandle::Close(&ClientToken);
    return (unsigned int)CallerToken;
  }
  return result;
}
// 180003CF1: variable 'v12' is possibly undefined
// 180003FD6: variable 'v26' is possibly undefined
// 180070228: using guessed type void *RunListItem::`vftable';
// 1800716D8: using guessed type void *wmi::GenericException::`vftable';
// 180080A48: using guessed type wchar_t aFirsttime[12];
// 180080A80: using guessed type wchar_t aLasttime[11];
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 180003C58: using guessed type char var_2F0[16];

//----- (000000018000406C) ----------------------------------------------------
ATL::CSid *__fastcall ATL::CSid::CSid(ATL::CSid *this, struct _SID *a2)
{
  *(_QWORD *)this = &ATL::CSid::`vftable';
  *((_BYTE *)this + 76) = 0;
  *((_DWORD *)this + 20) = 7;
  *((_QWORD *)this + 11) = (*(__int64 (__fastcall **)(__int64 *))(ATL::g_strmgr + 24))(&ATL::g_strmgr) + 24;
  *((_QWORD *)this + 12) = (*(__int64 (__fastcall **)(__int64 *))(ATL::g_strmgr + 24))(&ATL::g_strmgr) + 24;
  *((_QWORD *)this + 13) = (*(__int64 (__fastcall **)(__int64 *))(ATL::g_strmgr + 24))(&ATL::g_strmgr) + 24;
  *((_QWORD *)this + 14) = (*(__int64 (__fastcall **)(__int64 *))(ATL::g_strmgr + 24))(&ATL::g_strmgr) + 24;
  ATL::CSid::Copy(this, a2);
  return this;
}
// 1800703C0: using guessed type void *ATL::CSid::`vftable';
// 1800B0BF0: using guessed type __int64 ATL::g_strmgr;

//----- (0000000180004140) ----------------------------------------------------
__int64 __fastcall JobStore::HammerAcl(
        JobStore *this,
        const struct JobMoniker *a2,
        const struct User *a3,
        const struct User *a4)
{
  unsigned int LastHrError; // edi
  int XmlTaskPath; // r14d
  wchar_t *v10; // rbx
  __int64 FileSafe; // rax
  tsched *v12; // rcx
  signed int SecurityInfo; // eax
  signed int v14; // esi
  struct _ACL *v15; // rsi
  char v16; // r13
  unsigned int v17; // r15d
  unsigned __int8 v18; // r12
  unsigned int v19; // r14d
  unsigned int v20; // esi
  enum _SE_OBJECT_TYPE v21; // edx
  unsigned __int64 v23; // r15
  int v24; // esi
  tsched *v25; // rcx
  unsigned __int16 v26; // dx
  const wchar_t *Path; // r9
  __int64 v28; // rcx
  tsched *v29; // rcx
  JobMoniker *v30; // rsi
  struct _SECURITY_ATTRIBUTES *ppsidGroup; // [rsp+20h] [rbp-288h]
  unsigned __int8 v32[8]; // [rsp+40h] [rbp-268h] BYREF
  struct _SID *v33; // [rsp+48h] [rbp-260h] BYREF
  PSECURITY_DESCRIPTOR ppSecurityDescriptor; // [rsp+50h] [rbp-258h] BYREF
  void *lpMem; // [rsp+58h] [rbp-250h] BYREF
  HANDLE handle[2]; // [rsp+60h] [rbp-248h] BYREF
  __int64 v37[2]; // [rsp+70h] [rbp-238h] BYREF
  char v38; // [rsp+80h] [rbp-228h]
  int v39; // [rsp+84h] [rbp-224h]
  __int64 v40; // [rsp+88h] [rbp-220h] BYREF
  __int64 v41; // [rsp+90h] [rbp-218h]
  __int64 v42; // [rsp+98h] [rbp-210h]
  int v43; // [rsp+A0h] [rbp-208h]
  PACL ppDacl; // [rsp+A8h] [rbp-200h] BYREF
  JobMoniker *v45; // [rsp+B0h] [rbp-1F8h]
  const struct JobMoniker *v46; // [rsp+B8h] [rbp-1F0h]
  const struct User *v47; // [rsp+C0h] [rbp-1E8h]
  const struct User *v48; // [rsp+C8h] [rbp-1E0h]
  __int64 v49; // [rsp+D0h] [rbp-1D8h]
  char v50[128]; // [rsp+E0h] [rbp-1C8h] BYREF
  char v51[128]; // [rsp+160h] [rbp-148h] BYREF
  char v52[128]; // [rsp+1E0h] [rbp-C8h] BYREF

  v49 = -2LL;
  v45 = a2;
  v46 = a2;
  v47 = a3;
  v48 = a4;
  LastHrError = 0;
  if ( !JobStore::GetUseXmlStore(this) || !*(_QWORD *)a3 )
    return 0LL;
  lpMem = 0LL;
  XmlTaskPath = JobStore::GetXmlTaskPath((char **)this, a2, &lpMem);
  if ( XmlTaskPath < 0 )
  {
    operator delete(lpMem);
    return (unsigned int)XmlTaskPath;
  }
  else
  {
    *(_OWORD *)handle = 0LL;
    LODWORD(ppsidGroup) = 3;
    v10 = (wchar_t *)lpMem;
    FileSafe = tsched::CreateFileSafe(
                 (wchar_t *)lpMem,
                 (const unsigned __int16 *)0x42000000,
                 1u,
                 0LL,
                 ppsidGroup,
                 0x80u);
    tsched::JobsAutoHandle::operator=((tsched::JobsAutoHandle *)handle, FileSafe);
    if ( handle[0] == (HANDLE)-1LL )
    {
      LastHrError = tsched::GetLastHrError(v12);
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        WPP_SF_SD(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x3Fu,
          (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
          v10);
      }
      goto LABEL_25;
    }
    handle[1] = v10;
    ppDacl = 0LL;
    ppSecurityDescriptor = 0LL;
    SecurityInfo = GetSecurityInfo(handle[0], SE_FILE_OBJECT, 4u, 0LL, 0LL, &ppDacl, 0LL, &ppSecurityDescriptor);
    v14 = SecurityInfo;
    if ( SecurityInfo )
    {
      if ( SecurityInfo > 0 )
        v14 = (unsigned __int16)SecurityInfo | 0x80070000;
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        WPP_SF_SD(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x40u,
          (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
          v10);
      }
    }
    else
    {
      v37[1] = 0LL;
      v38 = 0;
      v39 = 2;
      v37[0] = (__int64)&ATL::CDacl::`vftable';
      v40 = 0LL;
      v41 = 0LL;
      v42 = 0LL;
      v43 = 0;
      v15 = ppDacl;
      ATL::CDacl::RemoveAllAces((ATL::CDacl *)v37);
      ATL::CDacl::Copy((ATL::CDacl *)v37, v15);
      v33 = 0LL;
      v14 = User::LookupSid(a3, (void **)&v33);
      if ( v14 >= 0 )
      {
        v16 = 1;
        v32[0] = 0;
        ATL::CSid::CSid((ATL::CSid *)v51, v33);
        v17 = v41;
        if ( !(_DWORD)v41 )
        {
          v18 = v32[0];
LABEL_57:
          if ( !ATL::CDacl::AddAllowedAce((ATL::CDacl *)v37, (const struct ATL::CSid *)v51) )
          {
            LastHrError = tsched::GetLastHrError(v25);
            if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
              || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) == 0
              || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
            {
              goto LABEL_24;
            }
            v26 = 66;
            Path = v10;
            v28 = *((_QWORD *)WPP_GLOBAL_Control + 2);
LABEL_62:
            WPP_SF_SD(v28, v26, (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids, Path);
LABEL_24:
            ATL::CSid::~CSid((ATL::CSid *)v51);
            ATL::CDacl::~CDacl((ATL::CDacl *)v37);
            tsched::AutoLocalPtr<unsigned short>::~AutoLocalPtr<unsigned short>(&ppSecurityDescriptor);
LABEL_25:
            tsched::JobsAutoHandle::Close((tsched::JobsAutoHandle *)handle);
            operator delete(v10);
            return LastHrError;
          }
LABEL_22:
          v32[0] = 0;
          if ( !v16 && !v18 )
            goto LABEL_24;
          v32[0] = ATL::AtlSetDacl(handle[0], v21, (const struct ATL::CDacl *)v37);
          v30 = v45;
          if ( v32[0] )
            goto LABEL_24;
          LastHrError = tsched::GetLastHrError(v29);
          if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
            || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) == 0
            || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
          {
            goto LABEL_24;
          }
          Path = JobMoniker::GetPath(v30);
          v26 = 67;
          v28 = *((_QWORD *)WPP_GLOBAL_Control + 2);
          goto LABEL_62;
        }
        ATL::CSid::CSid((ATL::CSid *)v50);
        if ( !a4 || !*(_QWORD *)a4 )
        {
          v18 = v32[0];
          goto LABEL_14;
        }
        v14 = User::LookupSid(a4, (void **)&v33);
        if ( v14 >= 0 )
        {
          ATL::CSid::CSid((ATL::CSid *)v52, v33);
          if ( ATL::operator==((ATL::CSid *)v52, (ATL::CSid *)v51) || (v24 = v17 - 1, (int)(v17 - 1) < 0) )
          {
            v18 = v32[0];
          }
          else
          {
            v18 = v32[0];
            do
            {
              ATL::CAcl::GetAclEntry(
                (ATL::CAcl *)v37,
                (unsigned int)v24,
                (struct ATL::CSid *)v50,
                (unsigned int *)&v33,
                v32);
              if ( (_DWORD)v33 == 1179785 && !v32[0] && ATL::operator==((ATL::CSid *)v50, (ATL::CSid *)v52) )
              {
                v18 = 1;
                ATL::CAtlArray<ATL::CAutoPtr<ATL::CDacl::CAccessAce>,ATL::CAutoPtrElementTraits<ATL::CDacl::CAccessAce>>::RemoveAt(
                  &v40,
                  (unsigned int)v24);
                --v17;
              }
              --v24;
            }
            while ( v24 >= 0 );
          }
          ATL::CSid::~CSid((ATL::CSid *)v52);
LABEL_14:
          v19 = 0;
          if ( v17 )
          {
            while ( 1 )
            {
              ATL::CAcl::GetAclEntry((ATL::CAcl *)v37, v19, (struct ATL::CSid *)v50, (unsigned int *)&v33, v32);
              if ( (_DWORD)v33 == 1179785 && !v32[0] && ATL::operator==((ATL::CSid *)v50, (ATL::CSid *)v51) )
                break;
              if ( ++v19 >= v17 )
                goto LABEL_21;
            }
            v16 = 0;
            v20 = v17 - 1;
            if ( v17 - 1 > v19 )
            {
              v23 = v20;
              do
              {
                ATL::CAcl::GetAclEntry((ATL::CAcl *)v37, v20, (struct ATL::CSid *)v50, (unsigned int *)&v33, v32);
                if ( (_DWORD)v33 == 1179785 && !v32[0] && ATL::operator==((ATL::CSid *)v50, (ATL::CSid *)v51) )
                {
                  v18 = 1;
                  ATL::CAtlArray<ATL::CAutoPtr<ATL::CDacl::CAccessAce>,ATL::CAutoPtrElementTraits<ATL::CDacl::CAccessAce>>::RemoveAt(
                    &v40,
                    v23);
                }
                --v20;
                --v23;
              }
              while ( v20 > v19 );
            }
          }
LABEL_21:
          ATL::CSid::~CSid((ATL::CSid *)v50);
          if ( !v16 )
            goto LABEL_22;
          goto LABEL_57;
        }
        ATL::CSid::~CSid((ATL::CSid *)v50);
        ATL::CSid::~CSid((ATL::CSid *)v51);
      }
      ATL::CDacl::~CDacl((ATL::CDacl *)v37);
    }
    tsched::AutoLocalPtr<unsigned short>::~AutoLocalPtr<unsigned short>(&ppSecurityDescriptor);
    tsched::JobsAutoHandle::Close((tsched::JobsAutoHandle *)handle);
    operator delete(v10);
    return (unsigned int)v14;
  }
}
// 180004140: could not find valid save-restore pair for rbp
// 1800042DF: conditional instruction was optimized away because r14d.4>=0
// 180004202: variable 'ppsidGroup' is possibly undefined
// 18003C6FA: variable 'v12' is possibly undefined
// 18003C903: variable 'v25' is possibly undefined
// 18003C983: variable 'v21' is possibly undefined
// 18003C9B1: variable 'v29' is possibly undefined
// 1800703F8: using guessed type void *ATL::CDacl::`vftable';
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 180004140: using guessed type unsigned __int8 var_268[8];

//----- (0000000180004514) ----------------------------------------------------
void __fastcall ATL::CAcl::GetAclEntry(
        ATL::CAcl *this,
        __int64 a2,
        struct ATL::CSid *a3,
        unsigned int *a4,
        unsigned __int8 *a5)
{
  __int64 v7; // rax
  _DWORD *v8; // rbx

  v7 = (*(__int64 (__fastcall **)(ATL::CAcl *))(*(_QWORD *)this + 32LL))(this);
  v8 = (_DWORD *)v7;
  if ( a3 )
    ATL::CSid::operator=((__int64)a3, v7 + 8);
  if ( a4 )
    *a4 = v8[32];
  if ( a5 )
    *a5 = (*(__int64 (__fastcall **)(_DWORD *))(*(_QWORD *)v8 + 24LL))(v8);
}

//----- (0000000180004580) ----------------------------------------------------
__int64 __fastcall ATL::CSid::operator=(__int64 a1, __int64 a2)
{
  __int64 *v4; // r15
  char *v5; // rdx
  int *v6; // r14
  volatile signed __int32 *v7; // rcx
  char *v8; // rdx
  int *v9; // r14
  volatile signed __int32 *v10; // rcx
  char *v11; // rdx
  int *v12; // r14
  volatile signed __int32 *v13; // rcx
  char v14; // al
  DWORD LengthSid; // eax
  volatile signed __int32 *v17; // rbx
  volatile signed __int32 *v18; // rbx
  volatile signed __int32 *v19; // rbx
  int Error; // eax

  if ( a1 != a2 )
  {
    v4 = (__int64 *)(a1 + 88);
    *(_DWORD *)(a1 + 80) = *(_DWORD *)(a2 + 80);
    v5 = *(char **)(a2 + 88);
    v6 = (int *)(*(_QWORD *)(a1 + 88) - 24LL);
    v7 = (volatile signed __int32 *)(v5 - 24);
    if ( v5 - 24 != (char *)v6 )
    {
      if ( v6[4] >= 0 && *(_QWORD *)v7 == *(_QWORD *)v6 )
      {
        v17 = ATL::CSimpleStringT<unsigned short,0>::CloneData(v7);
        ATL::CStringData::Release((ATL::CStringData *)v6);
        *v4 = (__int64)(v17 + 6);
      }
      else
      {
        ATL::CSimpleStringT<unsigned short,0>::SetString(v4, v5, *((_DWORD *)v5 - 4));
      }
    }
    v8 = *(char **)(a2 + 96);
    v9 = (int *)(*(_QWORD *)(a1 + 96) - 24LL);
    v10 = (volatile signed __int32 *)(v8 - 24);
    if ( v8 - 24 != (char *)v9 )
    {
      if ( v9[4] >= 0 && *(_QWORD *)v10 == *(_QWORD *)v9 )
      {
        v18 = ATL::CSimpleStringT<unsigned short,0>::CloneData(v10);
        ATL::CStringData::Release((ATL::CStringData *)v9);
        *(_QWORD *)(a1 + 96) = v18 + 6;
      }
      else
      {
        ATL::CSimpleStringT<unsigned short,0>::SetString((__int64 *)(a1 + 96), v8, *((_DWORD *)v8 - 4));
      }
    }
    v11 = *(char **)(a2 + 104);
    v12 = (int *)(*(_QWORD *)(a1 + 104) - 24LL);
    v13 = (volatile signed __int32 *)(v11 - 24);
    if ( v11 - 24 != (char *)v12 )
    {
      if ( v12[4] >= 0 && *(_QWORD *)v13 == *(_QWORD *)v12 )
      {
        v19 = ATL::CSimpleStringT<unsigned short,0>::CloneData(v13);
        ATL::CStringData::Release((ATL::CStringData *)v12);
        *(_QWORD *)(a1 + 104) = v19 + 6;
      }
      else
      {
        ATL::CSimpleStringT<unsigned short,0>::SetString((__int64 *)(a1 + 104), v11, *((_DWORD *)v11 - 4));
      }
    }
    v14 = *(_BYTE *)(a2 + 76);
    *(_BYTE *)(a1 + 76) = v14;
    if ( v14 )
    {
      LengthSid = GetLengthSid((PSID)(a2 + 8));
      if ( !CopySid(LengthSid, (PSID)(a1 + 8), (PSID)(a2 + 8)) )
      {
        Error = ATL::AtlHresultFromLastError();
        *(_BYTE *)(a1 + 76) = 0;
        ATL::PrivateAtlThrow(Error);
      }
    }
  }
  return a1;
}

//----- (0000000180004660) ----------------------------------------------------
bool __fastcall ATL::operator==(ATL::CSid *a1, ATL::CSid *a2)
{
  void *v2; // rsi
  void *v4; // rdi
  bool result; // al

  v2 = (char *)a1 + 8;
  result = a1 != (ATL::CSid *)-8LL
        && (v4 = (char *)a2 + 8, a2 != (ATL::CSid *)-8LL)
        && ATL::CSid::IsValid(a1)
        && ATL::CSid::IsValid(a2)
        && EqualSid(v2, v4);
  return result;
}

//----- (00000001800046CC) ----------------------------------------------------
void __fastcall ATL::CDacl::Copy(ATL::CDacl *this, struct _ACL *a2)
{
  DWORD i; // esi
  int v5; // r12d
  _DWORD *v6; // rbx
  bool v7; // r14
  char v8; // r15
  bool v9; // zf
  const struct _GUID *v10; // r14
  const struct _GUID *v11; // rbx
  struct _SID *v12; // rcx
  ATL::CDacl::CAccessObjectAce *v13; // rax
  ATL::CDacl::CAccessObjectAce *v14; // [rsp+48h] [rbp-100h] BYREF
  __int64 v15; // [rsp+50h] [rbp-F8h] BYREF
  LPVOID pAce[2]; // [rsp+58h] [rbp-F0h] BYREF
  PACL pAcl; // [rsp+68h] [rbp-E0h]
  ATL::CDacl::CAccessObjectAce *v18; // [rsp+70h] [rbp-D8h]
  __int64 v19; // [rsp+78h] [rbp-D0h]
  unsigned int pAclInformation[4]; // [rsp+80h] [rbp-C8h] BYREF
  char v21[128]; // [rsp+90h] [rbp-B8h] BYREF

  v19 = -2LL;
  pAce[1] = this;
  pAcl = a2;
  if ( a2 )
  {
    ATL::CSid::CSid((ATL::CSid *)v21);
    v14 = 0LL;
    free(*((void **)this + 1));
    *((_QWORD *)this + 1) = 0LL;
    if ( !GetAclInformation(a2, pAclInformation, 0xCu, AclSizeInformation)
      || !GetAclInformation(a2, &v15, 4u, AclRevisionInformation) )
    {
LABEL_15:
      ATL::AtlThrowLastWin32();
    }
    *((_DWORD *)this + 5) = v15;
    for ( i = 0; ; ++i )
    {
      if ( i >= pAclInformation[0] )
      {
        ATL::CAutoPtr<ATL::CDacl::CAccessAce>::Free((__int64 (__fastcall ****)(_QWORD, __int64))&v14);
        ATL::CSid::~CSid((ATL::CSid *)v21);
        return;
      }
      if ( !GetAce(pAcl, i, pAce) )
        goto LABEL_15;
      v5 = *((_DWORD *)pAce[0] + 1);
      if ( *(_BYTE *)pAce[0] > 1u )
      {
        if ( (unsigned __int8)(*(_BYTE *)pAce[0] - 5) > 1u )
          continue;
        v10 = 0LL;
        v11 = 0LL;
        v12 = (struct _SID *)((char *)pAce[0] + 44);
        if ( (*((_DWORD *)pAce[0] + 2) & 1) != 0 )
          v10 = (const struct _GUID *)((char *)pAce[0] + 12);
        else
          v12 = (struct _SID *)((char *)pAce[0] + 28);
        if ( (*((_BYTE *)pAce[0] + 8) & 2) != 0 )
          v11 = (const struct _GUID *)((char *)pAce[0] + (v10 != 0LL ? 28LL : 12LL));
        else
          v12 = (struct _SID *)((char *)v12 - 16);
        ATL::CSid::operator=((ATL::CSid *)v21, v12);
        v13 = (ATL::CDacl::CAccessObjectAce *)operator new(0xA8uLL);
        v18 = v13;
        if ( v13 )
          v13 = ATL::CDacl::CAccessObjectAce::CAccessObjectAce(
                  v13,
                  (const struct ATL::CSid *)v21,
                  v5,
                  *((_BYTE *)pAce[0] + 1),
                  *(_BYTE *)pAce[0] == 5,
                  v10,
                  v11);
        v14 = v13;
        v9 = v13 == 0LL;
      }
      else
      {
        ATL::CSid::operator=((ATL::CSid *)v21, (struct _SID *)((char *)pAce[0] + 8));
        v6 = operator new(0x98uLL);
        v18 = (ATL::CDacl::CAccessObjectAce *)v6;
        if ( v6 )
        {
          v7 = *(_BYTE *)pAce[0] == 0;
          v8 = *((_BYTE *)pAce[0] + 1);
          *(_QWORD *)v6 = &ATL::CAcl::CAce::`vftable';
          ATL::CSid::CSid((ATL::CSid *)(v6 + 2), (const struct ATL::CSid *)v21);
          v6[32] = v5;
          *((_BYTE *)v6 + 132) = v8;
          *((_QWORD *)v6 + 17) = 0LL;
          *(_QWORD *)v6 = &ATL::CDacl::CAccessAce::`vftable';
          *((_BYTE *)v6 + 144) = v7;
        }
        v14 = (ATL::CDacl::CAccessObjectAce *)v6;
        v9 = v6 == 0LL;
      }
      if ( v9 )
        ATL::PrivateAtlThrow(-2147024882);
      ATL::CAtlArray<ATL::CAutoPtr<ATL::CDacl::CAccessAce>,ATL::CAutoPtrElementTraits<ATL::CDacl::CAccessAce>>::Add(
        (__int64 *)this + 3,
        (__int64 *)&v14);
    }
  }
  (*(void (__fastcall **)(ATL::CDacl *))(*(_QWORD *)this + 16LL))(this);
  *((_BYTE *)this + 16) = 1;
}
// 180070350: using guessed type void *ATL::CDacl::CAccessAce::`vftable';
// 180070388: using guessed type void *ATL::CAcl::CAce::`vftable';
// 1800046CC: using guessed type unsigned int pAclInformation[4];

//----- (00000001800048D0) ----------------------------------------------------
void **__fastcall ATL::CDacl::CAccessAce::`vector deleting destructor'(void **this, char a2)
{
  *this = &ATL::CDacl::CAccessAce::`vftable';
  ATL::CAcl::CAce::~CAce(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 180070350: using guessed type void *ATL::CDacl::CAccessAce::`vftable';

//----- (0000000180004910) ----------------------------------------------------
void __fastcall ATL::CAcl::CAce::~CAce(void **this)
{
  *this = &ATL::CAcl::CAce::`vftable';
  free(this[17]);
  ATL::CSid::~CSid((ATL::CSid *)(this + 1));
}
// 180070388: using guessed type void *ATL::CAcl::CAce::`vftable';

//----- (000000018000494C) ----------------------------------------------------
ATL::CSid *__fastcall ATL::CSid::CSid(ATL::CSid *this, const struct ATL::CSid *a2)
{
  DWORD LengthSid; // eax
  int Error; // eax

  *(_QWORD *)this = &ATL::CSid::`vftable';
  *((_BYTE *)this + 76) = *((_BYTE *)a2 + 76);
  *((_DWORD *)this + 20) = *((_DWORD *)a2 + 20);
  *((_QWORD *)this + 11) = ATL::CSimpleStringT<unsigned short,0>::CloneData((volatile signed __int32 *)(*((_QWORD *)a2 + 11) - 24LL))
                         + 6;
  *((_QWORD *)this + 12) = ATL::CSimpleStringT<unsigned short,0>::CloneData((volatile signed __int32 *)(*((_QWORD *)a2 + 12) - 24LL))
                         + 6;
  *((_QWORD *)this + 13) = ATL::CSimpleStringT<unsigned short,0>::CloneData((volatile signed __int32 *)(*((_QWORD *)a2 + 13) - 24LL))
                         + 6;
  *((_QWORD *)this + 14) = (*(__int64 (__fastcall **)(__int64 *))(ATL::g_strmgr + 24))(&ATL::g_strmgr) + 24;
  if ( *((_BYTE *)a2 + 76) )
  {
    if ( !ATL::CSid::IsValid(a2) )
      ATL::PrivateAtlThrow(-2147024809);
    LengthSid = GetLengthSid((char *)a2 + 8);
    if ( !CopySid(LengthSid, (char *)this + 8, (char *)a2 + 8) )
    {
      Error = ATL::AtlHresultFromLastError();
      ATL::PrivateAtlThrow(Error);
    }
  }
  return this;
}
// 1800703C0: using guessed type void *ATL::CSid::`vftable';
// 1800B0BF0: using guessed type __int64 ATL::g_strmgr;

//----- (0000000180004A5C) ----------------------------------------------------
volatile signed __int32 *__fastcall ATL::CSimpleStringT<unsigned short,0>::CloneData(volatile signed __int32 *a1)
{
  __int64 (__fastcall ***v2)(_QWORD, _QWORD, __int64); // rax
  volatile signed __int32 *v3; // rdi
  __int64 v5; // rax
  rsize_t v6; // r9

  v2 = (__int64 (__fastcall ***)(_QWORD, _QWORD, __int64))(*(__int64 (__fastcall **)(_QWORD))(**(_QWORD **)a1 + 32LL))(*(_QWORD *)a1);
  if ( *((int *)a1 + 4) >= 0 && v2 == *(__int64 (__fastcall ****)(_QWORD, _QWORD, __int64))a1 )
  {
    v3 = a1;
    _InterlockedIncrement(a1 + 4);
  }
  else
  {
    v5 = (**v2)(v2, *((unsigned int *)a1 + 2), 2LL);
    v3 = (volatile signed __int32 *)v5;
    if ( !v5 )
      ATL::CSimpleStringT<unsigned short,0>::ThrowMemoryException();
    *(_DWORD *)(v5 + 8) = *((_DWORD *)a1 + 2);
    v6 = 2LL * (*((_DWORD *)a1 + 2) + 1);
    memcpy_s((void *const)(v5 + 24), v6, (const void *const)(a1 + 6), v6);
  }
  return v3;
}

//----- (0000000180004AB0) ----------------------------------------------------
bool __fastcall ATL::CSid::IsValid(ATL::CSid *this)
{
  return *((_BYTE *)this + 76) && IsValidSid((char *)this + 8);
}

//----- (0000000180004AE0) ----------------------------------------------------
unsigned __int64 __fastcall ATL::CAtlArray<ATL::CAutoPtr<ATL::CDacl::CAccessAce>,ATL::CAutoPtrElementTraits<ATL::CDacl::CAccessAce>>::Add(
        __int64 *a1,
        __int64 *a2)
{
  unsigned __int64 v2; // rdi
  __int64 v5; // rcx
  unsigned __int64 result; // rax
  __int64 v7; // rdx

  v2 = a1[1];
  if ( v2 >= a1[2]
    && !ATL::CAtlArray<ATL::CAutoPtr<ATL::CDacl::CAccessAce>,ATL::CAutoPtrElementTraits<ATL::CDacl::CAccessAce>>::GrowBuffer(
          (__int64)a1,
          v2 + 1) )
  {
    ATL::PrivateAtlThrow(-2147024882);
  }
  v5 = *a2;
  result = v2;
  v7 = *a1;
  *a2 = 0LL;
  *(_QWORD *)(v7 + 8 * v2) = v5;
  ++a1[1];
  return result;
}

//----- (0000000180004B3C) ----------------------------------------------------
ATL::CSid *__fastcall ATL::CSid::operator=(ATL::CSid *this, struct _SID *a2)
{
  if ( !*((_BYTE *)this + 76) || (struct _SID *)((char *)this + 8) != a2 )
  {
    ATL::CSid::Clear(this);
    ATL::CSid::Copy(this, a2);
    *((_DWORD *)this + 20) = 8;
  }
  return this;
}

//----- (0000000180004B88) ----------------------------------------------------
void __fastcall ATL::CSid::Copy(ATL::CSid *this, struct _SID *a2)
{
  DWORD LengthSid; // eax
  int Error; // eax

  if ( !IsValidSid(a2) || (LengthSid = GetLengthSid(a2), LengthSid > 0x44) )
    ATL::PrivateAtlThrow(-2147024809);
  *((_BYTE *)this + 76) = 1;
  if ( !CopySid(LengthSid, (char *)this + 8, a2) )
  {
    Error = ATL::AtlHresultFromLastError();
    *((_BYTE *)this + 76) = 0;
    ATL::PrivateAtlThrow(Error);
  }
}

//----- (0000000180004C00) ----------------------------------------------------
char __fastcall ATL::CAtlArray<ATL::CAutoPtr<ATL::CDacl::CAccessAce>,ATL::CAutoPtrElementTraits<ATL::CDacl::CAccessAce>>::GrowBuffer(
        __int64 a1,
        size_t a2)
{
  size_t v4; // rdx
  size_t v5; // rcx
  void *v6; // rax
  void *v7; // rsi
  errno_t v8; // eax
  void *v10; // rax

  v4 = *(_QWORD *)(a1 + 16);
  if ( a2 <= v4 )
    return 1;
  v5 = *(int *)(a1 + 24);
  if ( *(_QWORD *)a1 )
  {
    if ( !v5 )
    {
      v5 = v4 >> 1;
      if ( a2 - v4 > v4 >> 1 )
        v5 = a2 - v4;
    }
    if ( a2 < v4 + v5 )
      a2 = v4 + v5;
    v6 = calloc(a2, 8uLL);
    v7 = v6;
    if ( v6 )
    {
      v8 = memmove_s(v6, 8LL * *(_QWORD *)(a1 + 8), *(const void *const *)a1, 8LL * *(_QWORD *)(a1 + 8));
      if ( v8 )
      {
        if ( v8 == 12 )
          ATL::PrivateAtlThrow(-2147024882);
        if ( v8 == 22 || v8 == 34 )
          ATL::PrivateAtlThrow(-2147024809);
        if ( v8 != 80 )
          ATL::PrivateAtlThrow(-2147467259);
      }
      free(*(void **)a1);
      *(_QWORD *)a1 = v7;
LABEL_11:
      *(_QWORD *)(a1 + 16) = a2;
      return 1;
    }
  }
  else
  {
    if ( v5 > a2 )
      a2 = v5;
    v10 = calloc(a2, 8uLL);
    *(_QWORD *)a1 = v10;
    if ( v10 )
      goto LABEL_11;
  }
  return 0;
}

//----- (0000000180004CEC) ----------------------------------------------------
void __fastcall ATL::CDacl::~CDacl(ATL::CDacl *this)
{
  __int64 (__fastcall ****v2)(_QWORD, __int64); // rcx
  void *v3; // rcx

  *(_QWORD *)this = &ATL::CDacl::`vftable';
  ATL::CDacl::RemoveAllAces(this);
  v2 = (__int64 (__fastcall ****)(_QWORD, __int64))*((_QWORD *)this + 3);
  if ( v2 )
  {
    ATL::CAtlArray<ATL::CAutoPtr<ATL::CDacl::CAccessAce>,ATL::CAutoPtrElementTraits<ATL::CDacl::CAccessAce>>::CallDestructors(
      v2,
      *((_QWORD *)this + 4));
    free(*((void **)this + 3));
  }
  v3 = (void *)*((_QWORD *)this + 1);
  *(_QWORD *)this = &ATL::CAcl::`vftable';
  free(v3);
}
// 1800703C8: using guessed type void *ATL::CAcl::`vftable';
// 1800703F8: using guessed type void *ATL::CDacl::`vftable';

//----- (0000000180004D40) ----------------------------------------------------
void __fastcall ATL::CDacl::RemoveAllAces(ATL::CDacl *this)
{
  __int64 (__fastcall ****v2)(_QWORD, __int64); // rcx

  v2 = (__int64 (__fastcall ****)(_QWORD, __int64))*((_QWORD *)this + 3);
  if ( v2 )
  {
    ATL::CAtlArray<ATL::CAutoPtr<ATL::CDacl::CAccessAce>,ATL::CAutoPtrElementTraits<ATL::CDacl::CAccessAce>>::CallDestructors(
      v2,
      *((_QWORD *)this + 4));
    free(*((void **)this + 3));
    *((_QWORD *)this + 3) = 0LL;
  }
  *((_QWORD *)this + 4) = 0LL;
  *((_QWORD *)this + 5) = 0LL;
  free(*((void **)this + 1));
  *((_QWORD *)this + 1) = 0LL;
}

//----- (0000000180004D9C) ----------------------------------------------------
__int64 __fastcall JobStore::SaveJobFile(
        JobStore *this,
        wchar_t *a2,
        const unsigned __int16 *a3,
        unsigned int a4,
        unsigned int a5,
        void *a6,
        unsigned int a7)
{
  __int64 v8; // r14
  unsigned int v10; // edi
  struct _SECURITY_ATTRIBUTES *v11; // rax
  __int64 FileSafe; // rax
  tsched *v13; // rcx
  HANDLE v14; // rbx
  tsched *v15; // rcx
  tsched *v16; // rcx
  tsched *v17; // rcx
  tsched *v18; // rcx
  signed int LastHrError; // ebx
  _QWORD *v21; // rcx
  unsigned __int16 v22; // dx
  struct _SECURITY_ATTRIBUTES *lpOverlapped; // [rsp+20h] [rbp-61h]
  DWORD NumberOfBytesWritten; // [rsp+40h] [rbp-41h] BYREF
  __int16 Buffer; // [rsp+44h] [rbp-3Dh] BYREF
  struct _SECURITY_ATTRIBUTES *v26; // [rsp+48h] [rbp-39h] BYREF
  HANDLE hFile[2]; // [rsp+50h] [rbp-31h] BYREF
  char FileInformation[40]; // [rsp+60h] [rbp-21h] BYREF

  v8 = a4;
  v10 = 0;
  if ( JobStore::GetUseXmlStore(this) )
  {
    v11 = 0LL;
    v26 = 0LL;
    if ( a6 )
    {
      v11 = (struct _SECURITY_ATTRIBUTES *)LocalAlloc(0, a7 + 24LL);
      v26 = v11;
      if ( !v11 )
      {
        if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
          && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
          && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
        {
          WPP_SF_SD(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x45u,
            (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
            a2);
        }
        v10 = -2147024882;
        goto LABEL_16;
      }
      v11->lpSecurityDescriptor = a6;
      v11->nLength = a7 + 24;
      v11->bInheritHandle = 0;
    }
    LODWORD(lpOverlapped) = 4;
    *(_OWORD *)hFile = 0LL;
    FileSafe = tsched::CreateFileSafe(a2, (const unsigned __int16 *)0x40000000, 1u, v11, lpOverlapped, 0x8000080u);
    tsched::JobsAutoHandle::operator=((tsched::JobsAutoHandle *)hFile, FileSafe);
    v14 = hFile[0];
    hFile[1] = a2;
    if ( hFile[0] == (HANDLE)-1LL )
    {
      LastHrError = tsched::GetLastHrError(v13);
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        WPP_SF_SD(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x46u,
          (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
          a2);
      }
      if ( LastHrError == -2147024891
        && GetFileAttributesExW(a2, GetFileExInfoStandard, FileInformation)
        && (FileInformation[0] & 0x10) != 0 )
      {
        LastHrError = 183;
      }
      goto LABEL_50;
    }
    if ( SetEndOfFile(hFile[0]) )
    {
      NumberOfBytesWritten = 0;
      Buffer = -257;
      if ( WriteFile(v14, &Buffer, 2u, &NumberOfBytesWritten, 0LL) && NumberOfBytesWritten == 2 )
      {
        if ( WriteFile(v14, a3, 2 * v8, &NumberOfBytesWritten, 0LL) && 2 * v8 == NumberOfBytesWritten )
        {
          if ( FlushFileBuffers(v14) )
          {
            if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
              && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
              && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
            {
              WPP_SF_SD(
                *((_QWORD *)WPP_GLOBAL_Control + 2),
                0x4Bu,
                (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
                a2);
            }
            tsched::JobsAutoHandle::Close((tsched::JobsAutoHandle *)hFile);
            goto LABEL_15;
          }
          LastHrError = tsched::GetLastHrError(v18);
          v21 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
            || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) == 0
            || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
          {
LABEL_50:
            v10 = LastHrError;
LABEL_15:
            tsched::JobsAutoHandle::Close((tsched::JobsAutoHandle *)hFile);
LABEL_16:
            tsched::AutoLocalPtr<unsigned short>::~AutoLocalPtr<unsigned short>((void **)&v26);
            return v10;
          }
          v22 = 74;
        }
        else
        {
          LastHrError = tsched::GetLastHrError(v17);
          v21 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
            || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) == 0
            || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
          {
            goto LABEL_50;
          }
          v22 = 73;
        }
      }
      else
      {
        LastHrError = tsched::GetLastHrError(v16);
        v21 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
          || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) == 0
          || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
        {
          goto LABEL_50;
        }
        v22 = 72;
      }
    }
    else
    {
      LastHrError = tsched::GetLastHrError(v15);
      v21 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
        || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) == 0
        || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
      {
        goto LABEL_50;
      }
      v22 = 71;
    }
    WPP_SF_SD(v21[2], v22, (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids, a2);
    goto LABEL_50;
  }
  return 0LL;
}
// 180004E41: variable 'lpOverlapped' is possibly undefined
// 18003CCE6: variable 'v13' is possibly undefined
// 18003CD68: variable 'v15' is possibly undefined
// 18003CDA7: variable 'v18' is possibly undefined
// 18003CE13: variable 'v17' is possibly undefined
// 18003CE43: variable 'v16' is possibly undefined
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 180004D9C: using guessed type char FileInformation[40];

//----- (0000000180004F74) ----------------------------------------------------
tsched::JobsAutoHandle *__fastcall tsched::JobsAutoHandle::operator=(tsched::JobsAutoHandle *this, __int64 a2)
{
  tsched::JobsAutoHandle *result; // rax

  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
  {
    WPP_SF_q(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x10u, (__int64)&WPP_cb202d2a42b13414d5ff4ecf77487b4e_Traceguids, a2);
  }
  tsched::JobsAutoHandle::Close(this);
  result = this;
  *(_QWORD *)this = a2;
  return result;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180004FC4) ----------------------------------------------------
void __fastcall tsched::JobsAutoHandle::Close(tsched::JobsAutoHandle *this)
{
  void *v2; // rcx

  if ( (unsigned __int64)(*(_QWORD *)this - 1LL) <= 0xFFFFFFFFFFFFFFFDuLL )
  {
    v2 = *(void **)this;
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
    {
      WPP_SF_qS(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xEu, (__int64)&WPP_cb202d2a42b13414d5ff4ecf77487b4e_Traceguids);
      v2 = *(void **)this;
    }
    CloseHandle(v2);
    *(_QWORD *)this = 0LL;
    *((_QWORD *)this + 1) = 0LL;
  }
  else if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
         && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) != 0
         && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
  {
    WPP_SF_S(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0xFu,
      (__int64)&WPP_cb202d2a42b13414d5ff4ecf77487b4e_Traceguids,
      *((const wchar_t **)this + 1));
  }
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180005044) ----------------------------------------------------
__int64 __fastcall tsched::CreateFileSafe(
        wchar_t *String2,
        const unsigned __int16 *a2,
        DWORD a3,
        struct _SECURITY_ATTRIBUTES *a4,
        struct _SECURITY_ATTRIBUTES *dwCreationDisposition,
        DWORD dwFlagsAndAttributes)
{
  HANDLE FileW; // rax
  void *v8; // r8
  __int64 v9; // rbx
  __int64 v10; // rdi

  FileW = CreateFileW(String2, (DWORD)a2, a3, a4, (DWORD)dwCreationDisposition, dwFlagsAndAttributes, 0LL);
  v9 = (__int64)FileW;
  if ( FileW == (HANDLE)-1LL )
    return -1LL;
  if ( tsched::VerifyJobFilePath(String2, FileW, v8) < 0 )
  {
    v10 = -1LL;
    SetLastError(5u);
  }
  else
  {
    v10 = v9;
    v9 = -1LL;
  }
  if ( v9 != -1 )
    CloseHandle((HANDLE)v9);
  return v10;
}
// 18000508A: variable 'v8' is possibly undefined
// 180005044: using guessed type struct _SECURITY_ATTRIBUTES *arg_20;

//----- (00000001800050C8) ----------------------------------------------------
signed int __fastcall tsched::VerifyJobFilePath(wchar_t *String2, HANDLE hFile, void *a3)
{
  tsched *v5; // rcx
  struct _BY_HANDLE_FILE_INFORMATION FileInformation; // [rsp+20h] [rbp-268h] BYREF
  WCHAR szFilePath[264]; // [rsp+60h] [rbp-228h] BYREF

  if ( GetFinalPathNameByHandleW(hFile, szFilePath, 0x105u, 0) - 1 > 0x103 )
    return tsched::GetLastHrError(v5);
  if ( _wcsnicmp(szFilePath, String2, 0x105uLL)
    || !GetFileInformationByHandle(hFile, &FileInformation)
    || FileInformation.nNumberOfLinks > 1 )
  {
    return -2147024735;
  }
  return 0;
}
// 18000515B: variable 'v5' is possibly undefined

//----- (0000000180005188) ----------------------------------------------------
__int64 __fastcall JobStore::GetXmlTaskPath(char **this, JobMoniker *a2, void **a3)
{
  char *Path; // rax

  Path = (char *)JobMoniker::GetPath(a2);
  return JobStore::GetXmlFileSystemPath(this, Path, a3);
}

//----- (00000001800051C0) ----------------------------------------------------
__int64 __fastcall Triggers::SessionChangeTrigger::StreamOutImpl(
        Triggers::SessionChangeTrigger *this,
        __int64 a2,
        unsigned __int8 **a3,
        unsigned __int8 *a4)
{
  __int64 result; // rax
  __int64 v8; // rdx

  result = Triggers::GenericTrigger::StreamOutImpl(this, a2, a3, a4);
  if ( (int)result >= 0 )
  {
    if ( *a3 + 8 > a4 )
    {
      return 2147549183LL;
    }
    else
    {
      *(_QWORD *)*a3 = *((_QWORD *)this + 12);
      *a3 += 8;
      return User::StreamOutImpl((Triggers::SessionChangeTrigger *)((char *)this + 88), v8, a3, a4);
    }
  }
  return result;
}
// 180005202: variable 'v8' is possibly undefined

//----- (0000000180005230) ----------------------------------------------------
__int64 __fastcall Triggers::WnfStateChangeTrigger::StreamOutImpl(
        Triggers::WnfStateChangeTrigger *this,
        __int64 a2,
        unsigned __int8 **a3,
        unsigned __int8 *a4)
{
  __int64 result; // rax
  unsigned __int8 *v8; // rcx
  const void *v9; // rdx

  result = Triggers::GenericTrigger::StreamOutImpl(this, a2, a3, a4);
  if ( (int)result >= 0 )
  {
    if ( &(*a3)[*((_DWORD *)this + 24) + 16] > a4 )
    {
      return 2147549183LL;
    }
    else
    {
      *(_QWORD *)*a3 = *((_QWORD *)this + 11);
      *a3 += 8;
      *(_QWORD *)*a3 = *((_QWORD *)this + 12);
      v8 = *a3 + 8;
      *a3 = v8;
      v9 = (const void *)*((_QWORD *)this + 13);
      if ( v9 )
      {
        memcpy_0(v8, v9, *((unsigned int *)this + 24));
        *a3 += *((unsigned int *)this + 24);
      }
      return 0LL;
    }
  }
  return result;
}

//----- (00000001800052C0) ----------------------------------------------------
__int64 __fastcall ComHandlerBase::StreamOut(
        ComHandlerBase *this,
        __int64 a2,
        unsigned __int8 **a3,
        const unsigned __int8 *a4)
{
  __int64 result; // rax
  __int64 v8; // rax
  __int64 v9[3]; // [rsp+20h] [rbp-18h] BYREF

  result = Task::StreamOut(this, a2, a3, a4);
  if ( (int)result >= 0 )
  {
    if ( *a3 + 16 > a4 )
    {
      return 2147549183LL;
    }
    else
    {
      *(_OWORD *)*a3 = *(_OWORD *)((char *)this + 40);
      *a3 += 16;
      v8 = *((_QWORD *)this + 9);
      v9[0] = v8;
      if ( v8 )
        _InterlockedIncrement((volatile signed __int32 *)(v8 + 16));
      return JobStore::StreamOutBSTR((_bstr_t *)v9, a3, (unsigned __int64)a4);
    }
  }
  return result;
}
// 1800052C0: using guessed type __int64 var_18[3];

//----- (000000018000533C) ----------------------------------------------------
__int64 __fastcall JobStore::UpdateTaskEntry(
        HKEY *this,
        const struct JobMoniker *a2,
        const struct JobSecurity *a3,
        const struct Triggers::Trigulator *a4,
        const struct Actions::ActionCollection *a5,
        BYTE *lpData)
{
  TSTimePeriod *Periodicity; // rax
  BOOL IsEmpty; // ecx
  const struct JobSecurity *v11; // r8
  int v12; // eax
  int v13; // edi
  HKEY v14; // rbx
  JobStore *v15; // rcx
  const unsigned __int16 *Path; // rax
  HKEY hKey[2]; // [rsp+30h] [rbp-20h] BYREF
  char v19[16]; // [rsp+40h] [rbp-10h] BYREF
  HKEY v20; // [rsp+78h] [rbp+28h] BYREF
  int v21; // [rsp+80h] [rbp+30h] BYREF
  int v22; // [rsp+84h] [rbp+34h]

  v21 = (int)a3;
  hKey[1] = HKEY_DYN_DATA|0x7FFFFFF8LL;
  hKey[0] = 0LL;
  v20 = 0LL;
  v22 = 0;
  if ( Triggers::Trigulator::HasTrigger((__int64)a4, 0xFFFF) )
    v21 = 1;
  else
    v21 = 3 - (Triggers::Trigulator::HasTrigger((__int64)a4, 43690) != 0);
  Periodicity = (TSTimePeriod *)JobBucket::GetPeriodicity(*((_QWORD *)a2 + 4), (__int64)v19);
  IsEmpty = TSTimePeriod::IsEmpty(Periodicity);
  v12 = v22;
  if ( !IsEmpty )
    v12 = 4;
  v22 = v12;
  v13 = JobStore::RegOpenTaskEntryForUpdate(this, a2, v11, (const enum JobStore::TaskIndex *)&v21, !IsEmpty + 1, hKey);
  if ( v13 >= 0 )
  {
    if ( !*(_DWORD *)(*((_QWORD *)a2 + 4) + 20LL)
      || (Path = JobMoniker::GetPath(a2),
          v13 = JobStore::RegOpenTaskOverrideKey((JobStore *)this, Path, 0xF003Fu, 1, &v20),
          v13 >= 0)
      && (!v20 || (v13 = Triggers::Trigulator::StreamOut(a4, v20), v13 >= 0)) )
    {
      v14 = hKey[0];
      v13 = Triggers::Trigulator::StreamOut(a4, hKey[0]);
      if ( v13 >= 0 )
      {
        v13 = Actions::ActionCollection::StreamOut(a5, v14);
        if ( v13 >= 0 )
        {
          v15 = (JobStore *)lpData;
          if ( !lpData || (v13 = DynamicTaskInfo::StreamOut(lpData, v14), v13 >= 0) )
            v13 = JobStore::FlushTaskEntryP(v15, v14);
        }
      }
    }
  }
  wmi::AutoRegKey::Close(&v20);
  wmi::AutoRegKey::Close(hKey);
  return (unsigned int)v13;
}
// 1800053E5: variable 'v11' is possibly undefined
// 180005435: variable 'v15' is possibly undefined
// 18000533C: using guessed type char var_10[16];

//----- (0000000180005470) ----------------------------------------------------
LSTATUS __fastcall JobStore::FlushTaskEntryP(JobStore *this, HKEY a2)
{
  LSTATUS result; // eax
  int v3; // ebx

  result = RegFlushKey(a2);
  v3 = result;
  if ( result )
  {
    if ( result > 0 )
      v3 = (unsigned __int16)result | 0x80070000;
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x3Au,
        (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
        v3);
    }
    return v3;
  }
  return result;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (00000001800054A0) ----------------------------------------------------
__int64 __fastcall Triggers::GenericTrigger::StreamOutImpl(
        Triggers::GenericTrigger *this,
        __int64 a2,
        unsigned __int8 **a3,
        unsigned __int8 *a4)
{
  __int64 v6; // rcx
  char v7; // bl
  __int64 v8; // rax
  __int64 result; // rax
  BSTR *v10; // rax
  __int64 v11; // [rsp+40h] [rbp+18h] BYREF

  v6 = (__int64)*a3;
  if ( *a3 + 72 > a4 )
    return 2147549183LL;
  v7 = 0;
  *(_OWORD *)v6 = *(_OWORD *)((char *)this + 8);
  *(_OWORD *)(v6 + 16) = *(_OWORD *)((char *)this + 24);
  *(_OWORD *)(v6 + 32) = *(_OWORD *)((char *)this + 40);
  *(_OWORD *)(v6 + 48) = *(_OWORD *)((char *)this + 56);
  *(_QWORD *)(v6 + 64) = *((_QWORD *)this + 9);
  *a3 += 72;
  v8 = *((_QWORD *)this + 10);
  v11 = v8;
  if ( v8 )
    _InterlockedIncrement((volatile signed __int32 *)(v8 + 16));
  result = JobStore::StreamOutBSTR((_bstr_t *)&v11, a3, (unsigned __int64)a4);
  if ( (int)result >= 0 )
  {
    v10 = (BSTR *)*((_QWORD *)this + 10);
    if ( v10 && *v10 )
      v7 = SysStringLen(*v10);
    if ( ((2 * v7 - 4) & 7) != 0 )
      *a3 += 8 - ((2 * v7 - 4) & 7u);
    return 0LL;
  }
  return result;
}

//----- (0000000180005560) ----------------------------------------------------
__int64 __fastcall Triggers::TimeTrigger::StreamOutImpl(
        Triggers::TimeTrigger *this,
        __int64 a2,
        unsigned __int8 **a3,
        unsigned __int8 *a4)
{
  __int64 v6; // rcx
  char v7; // bl
  __int64 v8; // rax
  __int64 result; // rax
  BSTR *v10; // rax
  __int64 v11; // [rsp+40h] [rbp+18h] BYREF

  v6 = (__int64)*a3;
  if ( *a3 + 88 > a4 )
    return 2147549183LL;
  v7 = 0;
  *(_OWORD *)v6 = *(_OWORD *)((char *)this + 8);
  *(_OWORD *)(v6 + 16) = *(_OWORD *)((char *)this + 24);
  *(_OWORD *)(v6 + 32) = *(_OWORD *)((char *)this + 40);
  *(_OWORD *)(v6 + 48) = *(_OWORD *)((char *)this + 56);
  *(_OWORD *)(v6 + 64) = *(_OWORD *)((char *)this + 72);
  *(_QWORD *)(v6 + 80) = *((_QWORD *)this + 11);
  *a3 += 88;
  v8 = *((_QWORD *)this + 12);
  v11 = v8;
  if ( v8 )
    _InterlockedIncrement((volatile signed __int32 *)(v8 + 16));
  result = JobStore::StreamOutBSTR((_bstr_t *)&v11, a3, (unsigned __int64)a4);
  if ( (int)result >= 0 )
  {
    v10 = (BSTR *)*((_QWORD *)this + 12);
    if ( v10 && *v10 )
      v7 = SysStringLen(*v10);
    if ( ((2 * v7 - 4) & 7) != 0 )
      *a3 += 8 - ((2 * v7 - 4) & 7u);
    return 0LL;
  }
  return result;
}

//----- (0000000180005620) ----------------------------------------------------
__int64 __fastcall Actions::ActionCollection::StreamOut(Actions::ActionCollection *this, HKEY a2)
{
  BSTR *v4; // rax
  UINT v5; // eax
  __int64 cbData; // r15
  __int64 *i; // rbx
  unsigned __int8 *v8; // rax
  unsigned __int8 *lpData; // rbx
  unsigned __int8 *v10; // r13
  int v11; // esi
  unsigned __int64 v12; // r8
  __int64 v13; // rax
  __int64 *v14; // rdi
  __int16 v15; // ax
  int v16; // esi
  int v17; // edi
  __int64 v19; // [rsp+48h] [rbp-58h] BYREF
  unsigned __int8 *v20; // [rsp+50h] [rbp-50h]
  __int64 v21; // [rsp+58h] [rbp-48h]
  unsigned __int8 *v22; // [rsp+C0h] [rbp+20h] BYREF

  v21 = -2LL;
  if ( !*((_QWORD *)this + 1) )
    return 2147549183LL;
  v4 = (BSTR *)*((_QWORD *)this + 2);
  if ( v4 && *v4 )
    v5 = SysStringLen(*v4);
  else
    v5 = 0;
  cbData = 2 * v5 + 6;
  for ( i = *(__int64 **)this;
        ;
        cbData = (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)i[2] + 32LL))(i[2]) + (_DWORD)cbData + 2 )
  {
    i = (__int64 *)*i;
    if ( i == *(__int64 **)this )
      break;
  }
  v8 = (unsigned __int8 *)operator new((unsigned int)cbData);
  lpData = v8;
  v20 = v8;
  if ( v8 )
  {
    v10 = &v8[cbData];
    v22 = v8;
    memset_0(v8, 72, (unsigned int)cbData);
    v11 = JobStore::StreamOutUSHORT(3, &v22, v10);
    if ( v11 < 0 )
      goto LABEL_22;
    v13 = *((_QWORD *)this + 2);
    v19 = v13;
    if ( v13 )
    {
      _InterlockedIncrement((volatile signed __int32 *)(v13 + 16));
      lpData = v20;
    }
    v11 = JobStore::StreamOutBSTR((_bstr_t *)&v19, &v22, v12);
    if ( v11 < 0 )
    {
LABEL_22:
      v17 = v11;
    }
    else
    {
      v14 = *(__int64 **)this;
      while ( 1 )
      {
        v14 = (__int64 *)*v14;
        if ( v14 == *(__int64 **)this )
          break;
        v15 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v14[2] + 24LL))(v14[2]);
        v16 = JobStore::StreamOutUSHORT(v15, &v22, v10);
        if ( v16 >= 0 )
        {
          v16 = (*(__int64 (__fastcall **)(__int64, __int64, unsigned __int8 **, unsigned __int8 *))(*(_QWORD *)v14[2] + 40LL))(
                  v14[2],
                  3LL,
                  &v22,
                  v10);
          if ( v16 >= 0 )
            continue;
        }
        operator delete(lpData);
        return (unsigned int)v16;
      }
      v17 = RegSetValueExW(a2, L"Actions", 0, 3u, lpData, cbData);
      if ( v17
        && WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        WPP_SF_SD(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0xDu,
          (__int64)&WPP_fa1b8c42477831648a2e44d3a9ea2fb6_Traceguids,
          L"Actions");
      }
      if ( v17 > 0 )
        v17 = (unsigned __int16)v17 | 0x80070000;
    }
    operator delete(lpData);
    return (unsigned int)v17;
  }
  else
  {
    operator delete(0LL);
    return 2147942414LL;
  }
}
// 180005620: could not find valid save-restore pair for rbp
// 1800057C0: conditional instruction was optimized away because esi.4>=0
// 180005714: variable 'v12' is possibly undefined
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180005824) ----------------------------------------------------
__int64 __fastcall JobStore::StreamOutUSHORT(__int16 a1, unsigned __int8 **a2, unsigned __int8 *a3)
{
  if ( *a2 + 2 > a3 )
    return 2147549183LL;
  *(_WORD *)*a2 = a1;
  *a2 += 2;
  return 0LL;
}

//----- (0000000180005850) ----------------------------------------------------
__int64 __fastcall Task::StreamOut(Task *this, __int64 a2, unsigned __int8 **a3, const unsigned __int8 *a4)
{
  __int64 v4; // rax
  __int64 v6; // [rsp+30h] [rbp+8h] BYREF

  v4 = *((_QWORD *)this + 2);
  v6 = v4;
  if ( v4 )
    _InterlockedIncrement((volatile signed __int32 *)(v4 + 16));
  return JobStore::StreamOutBSTR((_bstr_t *)&v6, a3, (unsigned __int64)a4);
}

//----- (0000000180005890) ----------------------------------------------------
__int64 __fastcall ExeTask::StreamOut(ExeTask *this, __int64 a2, unsigned __int8 **a3, unsigned __int8 *a4)
{
  unsigned __int16 v6; // bp
  __int64 result; // rax
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // rax
  __int64 v12; // [rsp+20h] [rbp-28h] BYREF
  __int64 v13; // [rsp+28h] [rbp-20h] BYREF
  __int64 v14[3]; // [rsp+30h] [rbp-18h] BYREF

  v6 = a2;
  result = Task::StreamOut(this, a2, a3, a4);
  if ( (int)result >= 0 )
  {
    v9 = *((_QWORD *)this + 6);
    v12 = v9;
    if ( v9 )
      _InterlockedIncrement((volatile signed __int32 *)(v9 + 16));
    result = JobStore::StreamOutBSTR((_bstr_t *)&v12, a3, (unsigned __int64)a4);
    if ( (int)result >= 0 )
    {
      v10 = *((_QWORD *)this + 7);
      v13 = v10;
      if ( v10 )
        _InterlockedIncrement((volatile signed __int32 *)(v10 + 16));
      result = JobStore::StreamOutBSTR((_bstr_t *)&v13, a3, (unsigned __int64)a4);
      if ( (int)result >= 0 )
      {
        v11 = *((_QWORD *)this + 8);
        v14[0] = v11;
        if ( v11 )
          _InterlockedIncrement((volatile signed __int32 *)(v11 + 16));
        result = JobStore::StreamOutBSTR((_bstr_t *)v14, a3, (unsigned __int64)a4);
        if ( (int)result >= 0 && v6 >= 3u )
          return JobStore::StreamOutUSHORT(*((unsigned __int8 *)this + 72), a3, a4);
      }
    }
  }
  return result;
}
// 180005890: using guessed type __int64 var_18[3];

//----- (0000000180005964) ----------------------------------------------------
__int64 __fastcall JobStore::StreamOutBSTR(_bstr_t *a1, _QWORD *a2, unsigned __int64 a3)
{
  unsigned int v4; // ebx
  BSTR *v5; // rcx
  UINT v8; // eax
  __int64 v9; // rcx
  void *v10; // r9
  __int64 v12; // r14
  const void *v13; // rdx

  v4 = 0;
  v5 = *(BSTR **)a1;
  if ( v5 && *v5 )
    v8 = SysStringLen(*v5);
  else
    v8 = 0;
  v9 = 2 * v8;
  if ( *a2 + 4LL > a3 )
    goto LABEL_13;
  *(_DWORD *)*a2 = v9;
  v10 = (void *)(*a2 + 4LL);
  *a2 = v10;
  if ( !(_DWORD)v9 )
    goto LABEL_5;
  v12 = (unsigned int)v9;
  if ( (unsigned __int64)v10 + v9 > a3 )
  {
LABEL_13:
    v4 = -2147418113;
    goto LABEL_5;
  }
  if ( *(_QWORD *)a1 )
    v13 = **(const void ***)a1;
  else
    v13 = 0LL;
  memcpy_0(v10, v13, (unsigned int)v9);
  *a2 += v12;
LABEL_5:
  _bstr_t::_Free(a1);
  return v4;
}

//----- (0000000180005A30) ----------------------------------------------------
__int64 __fastcall Triggers::SessionChangeTrigger::GetStorageSize(Triggers::SessionChangeTrigger *this)
{
  int StorageSize; // ebx

  StorageSize = User::GetStorageSize((Triggers::SessionChangeTrigger *)((char *)this + 88));
  return StorageSize + (unsigned int)Triggers::GenericTrigger::GetStorageSize(this) + 8;
}

//----- (0000000180005A70) ----------------------------------------------------
__int64 __fastcall Triggers::WnfStateChangeTrigger::GetStorageSize(Triggers::WnfStateChangeTrigger *this)
{
  return *((_DWORD *)this + 24) + 16 + (unsigned int)Triggers::GenericTrigger::GetStorageSize(this);
}

//----- (0000000180005AA0) ----------------------------------------------------
__int64 __fastcall Triggers::GenericTrigger::GetStorageSize(Triggers::GenericTrigger *this)
{
  BSTR *v1; // rcx
  UINT v2; // eax
  int v3; // ecx

  v1 = (BSTR *)*((_QWORD *)this + 10);
  v2 = 0;
  if ( v1 && *v1 )
    v2 = SysStringLen(*v1);
  v3 = 2 * v2 + 4;
  if ( ((2 * (_BYTE)v2 + 4) & 7) != 0 )
    v3 += 8 - ((2 * (_BYTE)v2 + 4) & 7);
  return (unsigned int)(v3 + 80);
}

//----- (0000000180005ADC) ----------------------------------------------------
__int64 __fastcall User::StreamOutImpl(User *this, __int64 a2, unsigned __int8 **a3, const unsigned __int8 *a4)
{
  bool v4; // zf
  int v6; // ebx
  int v7; // esi
  unsigned __int64 v8; // r9
  _QWORD *v9; // r10
  void *v10; // rbx
  int LengthSid; // eax
  int v12; // eax
  BSTR *v13; // rbx
  UINT v14; // eax
  int v15; // eax
  UINT v16; // eax
  BSTR v17; // rdx
  __int64 v19[2]; // [rsp+20h] [rbp-10h] BYREF
  BSTR *v20; // [rsp+50h] [rbp+20h] BYREF
  __int64 v21; // [rsp+58h] [rbp+28h] BYREF

  v21 = a2;
  v4 = *(_QWORD *)this == 0LL;
  v19[0] = (__int64)a3;
  v19[1] = (__int64)a4;
  LOBYTE(v21) = v4;
  v6 = DataAligner::WriteFixedSize<bool>((__int64)v19, &v21);
  if ( v6 >= 0 )
  {
    if ( *(_QWORD *)this )
    {
      LOBYTE(v21) = User::IsAlias(this);
      v6 = DataAligner::WriteFixedSize<bool>((__int64)v19, &v21);
      if ( v6 >= 0 )
      {
        v7 = *(_DWORD *)(*(_QWORD *)this + 40LL);
        if ( User::IsAlias(this) )
          goto LABEL_11;
        if ( *v9 + 8LL > v8 )
          return (unsigned int)-2147418113;
        *(_DWORD *)*v9 = v7;
        *v9 += 8LL;
        v10 = *(void **)(*(_QWORD *)this + 32LL);
        if ( v10 )
        {
          LengthSid = GetLengthSid(*(PSID *)(*(_QWORD *)this + 32LL));
          v12 = DataAligner::WriteVarSize((DataAligner *)v19, v10, LengthSid);
        }
        else
        {
          LODWORD(v21) = 0;
          v12 = DataAligner::WriteFixedSize<unsigned long>((__int64)v19, &v21);
        }
        v6 = v12;
        if ( v12 >= 0 )
        {
LABEL_11:
          User::GetDomainAccount(this, (__int64 *)&v20);
          v13 = v20;
          if ( v20 && *v20 )
            v14 = SysStringLen(*v20);
          else
            v14 = 0;
          if ( v14 && (unsigned int)(v7 - 4) > 1 || User::IsAlias(this) )
          {
            if ( v13 && *v13 )
              v16 = SysStringLen(*v13);
            else
              v16 = 0;
            if ( v13 )
              v17 = *v13;
            else
              v17 = 0LL;
            v15 = DataAligner::WriteVarSize((DataAligner *)v19, v17, 2 * v16 + 2);
          }
          else
          {
            LODWORD(v21) = 0;
            v15 = DataAligner::WriteFixedSize<unsigned long>((__int64)v19, &v21);
          }
          v6 = v15;
          _bstr_t::~_bstr_t((_bstr_t *)&v20);
        }
      }
    }
  }
  return (unsigned int)v6;
}
// 180005B5B: variable 'v9' is possibly undefined
// 180005B65: variable 'v8' is possibly undefined

//----- (0000000180005C74) ----------------------------------------------------
__int64 __fastcall DataAligner::WriteFixedSize<bool>(__int64 a1, _BYTE *a2)
{
  _BYTE *v2; // r8

  v2 = **(_BYTE ***)a1;
  if ( (unsigned __int64)(v2 + 8) > *(_QWORD *)(a1 + 8) )
    return 2147549183LL;
  *v2 = *a2;
  **(_QWORD **)a1 += 8LL;
  return 0LL;
}

//----- (0000000180005CA4) ----------------------------------------------------
__int64 __fastcall JobBucket::StreamOutImpl(
        JobBucket *this,
        __int64 a2,
        unsigned __int8 **a3,
        const unsigned __int8 *a4)
{
  unsigned __int8 *v5; // rcx
  __int64 result; // rax
  BSTR *v9; // rax
  UINT v10; // eax
  BSTR *v11; // rax
  UINT v12; // r8d
  BSTR v13; // rdx
  BSTR *v14; // rax
  UINT v15; // eax
  __int64 v16; // rdx
  __int64 v17; // rdx
  __int64 v18; // rdx
  int v19; // r8d
  BSTR *v20; // rax
  UINT v21; // r8d
  BSTR v22; // rdx
  __int64 v23[2]; // [rsp+20h] [rbp-10h] BYREF
  __int64 v24; // [rsp+48h] [rbp+18h] BYREF

  v24 = a2;
  v23[0] = (__int64)a3;
  v5 = *a3;
  v23[1] = (__int64)a4;
  if ( v5 + 8 > a4 )
    return 2147549183LL;
  *(_DWORD *)v5 = *((_DWORD *)this + 4);
  *a3 += 8;
  result = DataAligner::WriteFixedSize<unsigned long>((__int64)v23, (_DWORD *)this + 6);
  if ( (int)result >= 0 )
  {
    v9 = (BSTR *)*((_QWORD *)this + 9);
    if ( v9 && *v9 )
      v10 = SysStringLen(*v9);
    else
      v10 = 0;
    if ( v10 )
    {
      v11 = (BSTR *)*((_QWORD *)this + 9);
      if ( v11 && *v11 )
      {
        v12 = SysStringLen(*v11);
        v11 = (BSTR *)*((_QWORD *)this + 9);
      }
      else
      {
        v12 = 0;
      }
      v13 = v11 ? *v11 : 0LL;
      result = DataAligner::WriteVarSize((DataAligner *)v23, v13, 2 * v12 + 2);
    }
    else
    {
      LODWORD(v24) = 0;
      result = DataAligner::WriteFixedSize<unsigned long>((__int64)v23, &v24);
    }
    if ( (int)result >= 0 )
    {
      v14 = (BSTR *)*((_QWORD *)this + 10);
      if ( v14 && *v14 )
        v15 = SysStringLen(*v14);
      else
        v15 = 0;
      if ( v15 )
      {
        v20 = (BSTR *)*((_QWORD *)this + 10);
        if ( v20 && *v20 )
        {
          v21 = SysStringLen(*v20);
          v20 = (BSTR *)*((_QWORD *)this + 10);
        }
        else
        {
          v21 = 0;
        }
        v22 = v20 ? *v20 : 0LL;
        result = DataAligner::WriteVarSize((DataAligner *)v23, v22, 2 * v21 + 2);
      }
      else
      {
        LODWORD(v24) = 0;
        result = DataAligner::WriteFixedSize<unsigned long>((__int64)v23, &v24);
      }
      if ( (int)result >= 0 )
      {
        result = User::StreamOutImpl((JobBucket *)((char *)this + 64), v16, a3, a4);
        if ( (int)result >= 0 )
        {
          v17 = *((_QWORD *)this + 26);
          if ( v17 )
          {
            if ( TSTimePeriod::IsEmpty((TSTimePeriod *)(v17 + 56))
              && TSTimePeriod::IsEmpty((TSTimePeriod *)(v18 + 70))
              && *(_DWORD *)(v18 + 84) != 1 )
            {
              if ( *(_QWORD *)(v18 + 48) )
                v19 = 56;
              else
                v19 = 44;
            }
            else
            {
              v19 = 88;
            }
            return DataAligner::WriteVarSize((DataAligner *)v23, (void *)v18, v19);
          }
          else
          {
            LODWORD(v24) = 0;
            return DataAligner::WriteFixedSize<unsigned long>((__int64)v23, &v24);
          }
        }
      }
    }
  }
  return result;
}
// 180005DB1: variable 'v16' is possibly undefined
// 180005DD7: variable 'v18' is possibly undefined

//----- (0000000180005E30) ----------------------------------------------------
__int64 __fastcall DataAligner::WriteVarSize(DataAligner *this, void *a2, int a3)
{
  __int64 result; // rax
  void ***v5; // rcx
  size_t v6; // r9
  const void *v7; // r10
  __int64 v8; // rdi
  void *v9; // rcx
  int v10; // [rsp+40h] [rbp+18h] BYREF

  v10 = a3;
  if ( a3 && !a2 )
    return 2147549183LL;
  result = DataAligner::WriteFixedSize<unsigned long>((__int64)this, &v10);
  if ( (int)result >= 0 && (_DWORD)v6 )
  {
    if ( v7 )
    {
      v8 = ((_DWORD)v6 + 7) & 0xFFFFFFF8;
      v9 = **v5;
      if ( (unsigned __int64)v9 + v8 <= *((_QWORD *)this + 1) )
      {
        memcpy_0(v9, v7, v6);
        **(_QWORD **)this += v8;
        return 0LL;
      }
    }
    return 2147549183LL;
  }
  return result;
}
// 180005E63: variable 'v6' is possibly undefined
// 180005E68: variable 'v7' is possibly undefined
// 180005E76: variable 'v5' is possibly undefined

//----- (0000000180005EB4) ----------------------------------------------------
__int64 __fastcall DataAligner::WriteFixedSize<unsigned long>(__int64 a1, _DWORD *a2)
{
  _DWORD *v2; // r8

  v2 = **(_DWORD ***)a1;
  if ( (unsigned __int64)(v2 + 2) > *(_QWORD *)(a1 + 8) )
    return 2147549183LL;
  *v2 = *a2;
  **(_QWORD **)a1 += 8LL;
  return 0LL;
}

//----- (0000000180005EE4) ----------------------------------------------------
signed int __fastcall Triggers::Trigulator::StreamOut(Triggers::Trigulator *this, HKEY a2)
{
  signed int result; // eax
  __int64 cbData; // r15
  __int64 *i; // rbx
  void *v7; // rax
  BYTE *lpData; // rdi
  const unsigned __int8 *v9; // r13
  unsigned __int8 *v10; // rax
  int StorageSize; // eax
  __int64 v12; // rdx
  int v13; // esi
  __int64 *v14; // rbx
  LSTATUS v15; // ebx
  unsigned __int8 *v16; // [rsp+80h] [rbp+40h] BYREF
  BYTE *v17; // [rsp+90h] [rbp+50h] BYREF

  if ( *(_OWORD *)((char *)this + 40) == 0LL )
  {
    v15 = RegSetValueExW(a2, L"Triggers", 0, 3u, &NullData, 8u);
    if ( v15
      && WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_SD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x12u,
        (__int64)&WPP_9c6330531b9f37c0b720c7be8cd79119_Traceguids,
        L"Triggers");
    }
    if ( v15 > 0 )
      return (unsigned __int16)v15 | 0x80070000;
    return v15;
  }
  else
  {
    result = Triggers::Trigulator::WriteRegistrationData(this, a2);
    if ( result >= 0 )
    {
      result = Triggers::Trigulator::WritePackageAndCapabilities(this, a2);
      if ( result >= 0 )
      {
        cbData = (unsigned int)JobBucket::GetStorageSize(*((JobBucket **)this + 6)) + 40;
        for ( i = (__int64 *)*((_QWORD *)this + 4);
              ;
              cbData = (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)i[2] + 88LL))(i[2]) + (unsigned int)cbData )
        {
          i = (__int64 *)*i;
          if ( i == *((__int64 **)this + 4) )
            break;
        }
        v17 = 0LL;
        v7 = operator new((unsigned int)cbData);
        wmi::AutoVectorPtr<unsigned char>::operator=((void **)&v17, v7);
        lpData = v17;
        v9 = &v17[cbData];
        v16 = v17;
        memset_0(v17, 72, (unsigned int)cbData);
        *(_QWORD *)v16 = 23LL;
        v10 = v16 + 8;
        v16 = v10;
        *(_OWORD *)v10 = *(_OWORD *)this;
        *((_OWORD *)v10 + 1) = *((_OWORD *)this + 1);
        v16 += 32;
        StorageSize = JobBucket::GetStorageSize(*((JobBucket **)this + 6));
        if ( &v16[StorageSize] > v9 )
        {
          v13 = -2147418113;
        }
        else
        {
          v13 = JobBucket::StreamOutImpl(*((JobBucket **)this + 6), v12, &v16, v9);
          if ( v13 >= 0 )
          {
            v14 = (__int64 *)*((_QWORD *)this + 4);
            while ( 1 )
            {
              v14 = (__int64 *)*v14;
              if ( v14 == *((__int64 **)this + 4) )
                break;
              v13 = (*(__int64 (__fastcall **)(__int64, __int64, unsigned __int8 **, const unsigned __int8 *))(*(_QWORD *)v14[2] + 96LL))(
                      v14[2],
                      23LL,
                      &v16,
                      v9);
              if ( v13 < 0 )
                goto LABEL_16;
            }
            v13 = RegSetValueExW(a2, L"Triggers", 0, 3u, lpData, cbData);
            if ( v13
              && WPP_GLOBAL_Control != &WPP_GLOBAL_Control
              && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
              && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
            {
              WPP_SF_SD(
                *((_QWORD *)WPP_GLOBAL_Control + 2),
                0x13u,
                (__int64)&WPP_9c6330531b9f37c0b720c7be8cd79119_Traceguids,
                L"Triggers");
            }
            if ( v13 > 0 )
              v13 = (unsigned __int16)v13 | 0x80070000;
          }
        }
LABEL_16:
        operator delete(lpData);
        return v13;
      }
    }
  }
  return result;
}
// 180005FEA: variable 'v12' is possibly undefined
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018000608C) ----------------------------------------------------
__int64 __fastcall JobBucket::GetStorageSize(JobBucket *this)
{
  BSTR *v1; // rax
  UINT v3; // eax
  BSTR *v4; // rax
  UINT v5; // eax
  unsigned int v6; // edi
  BSTR *v7; // rax
  UINT v8; // eax
  int StorageSize; // eax
  __int64 v10; // rdx
  unsigned int v11; // r8d
  __int64 v12; // rdx
  __int64 v13; // rdx
  int v14; // ecx
  BSTR *v16; // rax
  UINT v17; // eax

  v1 = (BSTR *)*((_QWORD *)this + 9);
  if ( v1 && *v1 )
    v3 = SysStringLen(*v1);
  else
    v3 = 0;
  if ( v3 )
  {
    v4 = (BSTR *)*((_QWORD *)this + 9);
    if ( v4 && *v4 )
      v5 = SysStringLen(*v4);
    else
      v5 = 0;
    v6 = ((2 * v5 + 9) & 0xFFFFFFF8) + 24;
  }
  else
  {
    v6 = 24;
  }
  v7 = (BSTR *)*((_QWORD *)this + 10);
  if ( v7 && *v7 )
    v8 = SysStringLen(*v7);
  else
    v8 = 0;
  if ( v8 )
  {
    v16 = (BSTR *)*((_QWORD *)this + 10);
    if ( v16 && *v16 )
      v17 = SysStringLen(*v16);
    else
      v17 = 0;
    v6 += (2 * v17 + 9) & 0xFFFFFFF8;
  }
  StorageSize = User::GetStorageSize((JobBucket *)((char *)this + 64));
  v10 = *((_QWORD *)this + 26);
  v11 = v6 + StorageSize + 8;
  if ( v10 )
  {
    if ( TSTimePeriod::IsEmpty((TSTimePeriod *)(v10 + 56))
      && TSTimePeriod::IsEmpty((TSTimePeriod *)(v12 + 70))
      && *(_DWORD *)(v13 + 84) != 1 )
    {
      v14 = *(_QWORD *)(v13 + 48) != 0LL ? 64 : 56;
    }
    else
    {
      v14 = 96;
    }
  }
  else
  {
    v14 = 8;
  }
  return v11 + v14;
}
// 18000613C: variable 'v12' is possibly undefined
// 180006149: variable 'v13' is possibly undefined
// 180006163: variable 'v11' is possibly undefined

//----- (0000000180006184) ----------------------------------------------------
__int64 __fastcall User::GetStorageSize(User *this)
{
  __int64 result; // rax
  DWORD v3; // edi
  OLECHAR ***DomainAccount; // rax
  OLECHAR *v5; // rcx
  UINT v6; // eax
  UINT v7; // esi
  __int64 v8; // rcx
  int v9; // ebx
  __int64 v10; // [rsp+30h] [rbp+8h] BYREF

  result = 8LL;
  if ( *(_QWORD *)this )
  {
    v3 = 16;
    DomainAccount = (OLECHAR ***)User::GetDomainAccount(this, &v10);
    if ( *DomainAccount && (v5 = **DomainAccount) != 0LL )
      v6 = SysStringLen(v5);
    else
      v6 = 0;
    v7 = v6 + 1;
    _bstr_t::_Free((_bstr_t *)&v10);
    if ( !User::IsAlias(this) )
    {
      v8 = *(_QWORD *)this;
      v9 = *(_DWORD *)(*(_QWORD *)this + 40LL);
      v3 = ((GetLengthSid(*(PSID *)(v8 + 32)) + 7) & 0xFFFFFFF8) + 32;
      if ( (unsigned int)(v9 - 4) <= 1 )
        v7 = 0;
    }
    return v3 + ((2 * v7 + 7) & 0xFFFFFFF8) + 8;
  }
  return result;
}

//----- (0000000180006240) ----------------------------------------------------
__int64 *__fastcall User::GetDomainAccount(User *a1, __int64 *a2)
{
  struct _RTL_CRITICAL_SECTION *v2; // rbx
  unsigned __int8 IsAlias; // al

  v2 = User::s_cs;
  *a2 = 0LL;
  EnterCriticalSection(v2);
  IsAlias = User::IsAlias(a1);
  _bstr_t::operator=(a2, (__int64 *)(*(_QWORD *)a1 + 8LL + 8LL * IsAlias));
  LeaveCriticalSection(v2);
  return a2;
}

//----- (00000001800062B8) ----------------------------------------------------
__int64 __fastcall Triggers::Trigulator::WritePackageAndCapabilities(Triggers::Trigulator *this, HKEY a2)
{
  BYTE *v4; // rbx
  const BYTE *v5; // r9
  LSTATUS v6; // eax
  LSTATUS v7; // edi
  unsigned int v9; // [rsp+60h] [rbp+8h] BYREF
  BYTE *lpData; // [rsp+70h] [rbp+18h] BYREF

  v4 = 0LL;
  lpData = 0LL;
  v5 = *(const BYTE **)(*((_QWORD *)this + 6) + 176LL);
  if ( v5 )
    v5 = *(const BYTE **)v5;
  v6 = Triggers::Trigulator::WriteString(this, a2, L"Package", v5);
  v7 = v6;
  if ( v6 )
  {
    if ( v6 <= 0 )
      goto LABEL_9;
    v7 = (unsigned __int16)v6;
LABEL_19:
    v7 |= 0x80070000;
    goto LABEL_9;
  }
  JobBucket::GetCapabilities(*((_QWORD *)this + 6), (void **)&lpData, &v9);
  v4 = lpData;
  if ( lpData )
  {
    v7 = RegSetValueExW(a2, L"Capabilities", 0, 7u, lpData, 2 * v9);
    if ( !v7 )
      goto LABEL_8;
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_SD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x11u,
        (__int64)&WPP_9c6330531b9f37c0b720c7be8cd79119_Traceguids,
        L"Capabilities");
    }
  }
  else
  {
    v7 = RegDeleteValueW(a2, L"Capabilities");
    if ( v7 == 2 )
      v7 = 0;
  }
  if ( v7 )
  {
    if ( v7 <= 0 )
      goto LABEL_9;
    v7 = (unsigned __int16)v7;
    goto LABEL_19;
  }
LABEL_8:
  v7 = 0;
LABEL_9:
  operator delete(v4);
  return (unsigned int)v7;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180006370) ----------------------------------------------------
__int64 __fastcall JobBucket::GetCapabilities(__int64 a1, void **a2, unsigned int *a3)
{
  __int64 result; // rax
  __int64 v6; // rsi
  wchar_t *v7; // rdi
  unsigned __int64 v8; // r14
  unsigned __int64 v9; // rbx
  int i; // r15d
  unsigned int v11; // r13d
  __int64 v12; // r12
  const unsigned __int16 **v13; // r11
  const unsigned __int16 *v14; // r11
  int v15; // r8d
  const unsigned __int16 *v16; // r11
  unsigned __int64 v17; // r9
  unsigned __int64 v18; // r8
  unsigned __int64 v19; // rcx
  __int64 v20; // rax
  unsigned int v21; // eax
  void *v22; // rax
  unsigned __int64 v23; // [rsp+38h] [rbp-39h] BYREF
  unsigned __int64 v24; // [rsp+40h] [rbp-31h] BYREF
  unsigned __int64 v25; // [rsp+48h] [rbp-29h]
  void **pExceptionObject; // [rsp+50h] [rbp-21h] BYREF
  char v27; // [rsp+58h] [rbp-19h]
  const unsigned __int16 *v28; // [rsp+60h] [rbp-11h]
  __int64 v29; // [rsp+68h] [rbp-9h]
  __int64 v30; // [rsp+70h] [rbp-1h]
  unsigned int v31; // [rsp+78h] [rbp+7h]
  int v32; // [rsp+7Ch] [rbp+Bh]
  int v33; // [rsp+80h] [rbp+Fh]
  unsigned __int16 *v37; // [rsp+F0h] [rbp+7Fh] BYREF

  result = (__int64)wmi::AutoVectorPtr<unsigned char>::operator=(a2, 0LL);
  *a3 = 0;
  v6 = (__int64)(*(_QWORD *)(a1 + 192) - *(_QWORD *)(a1 + 184)) >> 3;
  if ( (_DWORD)v6 )
  {
    v7 = 0LL;
    v37 = 0LL;
    v8 = 0LL;
    v23 = 0LL;
    v9 = 0LL;
    for ( i = 0; i < 2; ++i )
    {
      v11 = 0;
      v12 = 0LL;
      do
      {
        v25 = v9;
        result = *(_QWORD *)(a1 + 184);
        v13 = *(const unsigned __int16 ***)(v12 + result);
        if ( v13 )
          v14 = *v13;
        else
          v14 = 0LL;
        if ( v14 )
        {
          v15 = StringCchLengthW(v14, 0x200uLL, &v24);
          if ( v15 < 0 )
          {
            v33 = -1;
            pExceptionObject = &wmi::GenericException::`vftable';
            v27 = 0;
            v28 = &word_18007630E;
            v29 = 0LL;
            v32 = -1;
            v30 = 0LL;
            v31 = v15;
            CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
          }
          result = -1LL;
          v17 = v9 + v24 + 1;
          if ( v17 >= v9 )
            result = v9 + v24 + 1;
          v9 = result;
          if ( v17 < v25 )
          {
            v31 = v17 < v25 ? 0x80070216 : 0;
            pExceptionObject = &wmi::GenericException::`vftable';
            v33 = -1;
            v28 = &word_18007630E;
            v27 = 0;
            v32 = -1;
            v29 = 0LL;
            v30 = 0LL;
            CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
          }
          if ( v7 )
          {
            result = StringCchCopyExW(v7, v8, v16, &v37, &v23);
            if ( (int)result < 0 )
            {
              v33 = -1;
              pExceptionObject = &wmi::GenericException::`vftable';
              v31 = result;
              v28 = &word_18007630E;
              v27 = 0;
              v32 = -1;
              v29 = 0LL;
              v30 = 0LL;
              CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
            }
            v8 = v23;
            v7 = ++v37;
          }
        }
        ++v11;
        v12 += 8LL;
      }
      while ( v11 < (unsigned int)v6 );
      v18 = v9;
      if ( !v9 )
        break;
      if ( !i )
      {
        v19 = v9 + 1;
        v20 = -1LL;
        if ( v9 + 1 >= v9 )
          v20 = v9 + 1;
        v9 = v20;
        if ( v19 < v18 )
        {
          v30 = 0LL;
          pExceptionObject = &wmi::GenericException::`vftable';
          v31 = v19 < v18 ? 0x80070216 : 0;
          v28 = &word_18007630E;
          v27 = 0;
          v29 = 0LL;
          v32 = -1;
          v33 = -1;
          CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
        }
        v21 = -1;
        if ( v9 <= 0xFFFFFFFF )
          v21 = v9;
        *a3 = v21;
        if ( v9 > 0xFFFFFFFF )
        {
          v30 = 0LL;
          pExceptionObject = &wmi::GenericException::`vftable';
          v31 = v9 > 0xFFFFFFFF ? 0x80070216 : 0;
          v28 = &word_18007630E;
          v27 = 0;
          v29 = 0LL;
          v32 = -1;
          v33 = -1;
          CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
        }
        v22 = operator new(saturated_mul(v21, 2uLL));
        wmi::AutoVectorPtr<unsigned char>::operator=(a2, v22);
        v7 = (wchar_t *)*a2;
        if ( !*a2 )
        {
          v33 = -1;
          v28 = &word_18007630E;
          v27 = 0;
          v32 = -1;
          v29 = 0LL;
          v30 = 0LL;
          pExceptionObject = &wmi::OutOfMemoryException::`vftable';
          v31 = 14;
          CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI4_AVOutOfMemoryException_wmi__);
        }
        v37 = (unsigned __int16 *)*a2;
        v23 = v9;
        v8 = v9;
        result = (__int64)memset_0(v7, 0, 2 * v9);
      }
    }
  }
  return result;
}
// 180041B31: conditional instruction was optimized away because esi.4!=0
// 180041BCE: variable 'v16' is possibly undefined
// 1800716D8: using guessed type void *wmi::GenericException::`vftable';
// 180073740: using guessed type void *wmi::OutOfMemoryException::`vftable';

//----- (00000001800063E8) ----------------------------------------------------
LSTATUS __fastcall Triggers::Trigulator::WriteRegistrationData(Triggers::Trigulator *this, HKEY a2)
{
  LSTATUS v4; // ebx
  Triggers::Trigulator *v5; // rcx
  const BYTE *v6; // r9
  LSTATUS result; // eax
  bool v8; // cc
  Triggers::Trigulator *v9; // rcx
  const BYTE *v10; // r9
  Triggers::Trigulator *v11; // rcx
  const BYTE *v12; // r9
  Triggers::Trigulator *v13; // rcx
  const BYTE *v14; // r9
  Triggers::Trigulator *v15; // rcx
  const BYTE *v16; // r9
  Triggers::Trigulator *v17; // rcx
  const BYTE *v18; // r9
  Triggers::Trigulator *v19; // rcx
  const BYTE *v20; // r9
  Triggers::Trigulator *v21; // rcx
  const BYTE *v22; // r9
  Triggers::Trigulator *v23; // rcx
  const BYTE *v24; // r9
  int v25; // [rsp+40h] [rbp+8h] BYREF

  v25 = *(_DWORD *)(*((_QWORD *)this + 6) + 96LL);
  if ( v25 )
  {
    v4 = RegSetValueExW(a2, L"Schema", 0, 4u, (const BYTE *)&v25, 4u);
    if ( !v4 )
      goto LABEL_3;
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_SD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0xFu,
        (__int64)&WPP_9c6330531b9f37c0b720c7be8cd79119_Traceguids,
        L"Schema");
    }
  }
  else
  {
    v4 = RegDeleteValueW(a2, L"Schema");
    if ( v4 == 2 )
      v4 = 0;
  }
  if ( !v4 )
  {
LABEL_3:
    v5 = *(Triggers::Trigulator **)(*((_QWORD *)this + 6) + 112LL);
    if ( v5 )
      v6 = *(const BYTE **)v5;
    else
      v6 = 0LL;
    result = Triggers::Trigulator::WriteString(v5, a2, L"Version", v6);
    v8 = result <= 0;
    if ( result )
      goto LABEL_36;
    v9 = *(Triggers::Trigulator **)(*((_QWORD *)this + 6) + 104LL);
    v10 = v9 ? *(const BYTE **)v9 : 0LL;
    result = Triggers::Trigulator::WriteString(v9, a2, L"Date", v10);
    v8 = result <= 0;
    if ( result )
      goto LABEL_36;
    v11 = *(Triggers::Trigulator **)(*((_QWORD *)this + 6) + 120LL);
    v12 = v11 ? *(const BYTE **)v11 : 0LL;
    result = Triggers::Trigulator::WriteString(v11, a2, L"SecurityDescriptor", v12);
    v8 = result <= 0;
    if ( result )
      goto LABEL_36;
    v13 = *(Triggers::Trigulator **)(*((_QWORD *)this + 6) + 128LL);
    v14 = v13 ? *(const BYTE **)v13 : 0LL;
    result = Triggers::Trigulator::WriteString(v13, a2, L"Source", v14);
    v8 = result <= 0;
    if ( result )
      goto LABEL_36;
    v15 = *(Triggers::Trigulator **)(*((_QWORD *)this + 6) + 136LL);
    v16 = v15 ? *(const BYTE **)v15 : 0LL;
    result = Triggers::Trigulator::WriteString(v15, a2, L"Author", v16);
    v8 = result <= 0;
    if ( result )
      goto LABEL_36;
    v17 = *(Triggers::Trigulator **)(*((_QWORD *)this + 6) + 144LL);
    v18 = v17 ? *(const BYTE **)v17 : 0LL;
    result = Triggers::Trigulator::WriteString(v17, a2, L"Description", v18);
    v8 = result <= 0;
    if ( result )
      goto LABEL_36;
    v19 = *(Triggers::Trigulator **)(*((_QWORD *)this + 6) + 152LL);
    v20 = v19 ? *(const BYTE **)v19 : 0LL;
    result = Triggers::Trigulator::WriteString(v19, a2, L"Documentation", v20);
    v8 = result <= 0;
    if ( result )
      goto LABEL_36;
    v21 = *(Triggers::Trigulator **)(*((_QWORD *)this + 6) + 160LL);
    v22 = v21 ? *(const BYTE **)v21 : 0LL;
    result = Triggers::Trigulator::WriteString(v21, a2, L"URI", v22);
    v8 = result <= 0;
    if ( result
      || ((v23 = *(Triggers::Trigulator **)(*((_QWORD *)this + 6) + 168LL)) != 0LL
        ? (v24 = *(const BYTE **)v23)
        : (v24 = 0LL),
          result = Triggers::Trigulator::WriteString(v23, a2, L"Data", v24),
          v8 = result <= 0,
          result) )
    {
LABEL_36:
      if ( !v8 )
        return (unsigned __int16)result | 0x80070000;
    }
    return result;
  }
  if ( v4 > 0 )
    return (unsigned __int16)v4 | 0x80070000;
  return v4;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180006624) ----------------------------------------------------
LSTATUS __fastcall Triggers::Trigulator::WriteString(
        Triggers::Trigulator *this,
        HKEY a2,
        const unsigned __int16 *a3,
        const BYTE *lpData)
{
  LSTATUS result; // eax
  __int64 v6; // rax
  LSTATUS v7; // ebx

  if ( lpData )
  {
    v6 = -1LL;
    do
      ++v6;
    while ( *(_WORD *)&lpData[2 * v6] );
    v7 = RegSetValueExW(a2, a3, 0, 1u, lpData, 2 * v6 + 2);
    if ( v7
      && WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_SD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x10u,
        (__int64)&WPP_9c6330531b9f37c0b720c7be8cd79119_Traceguids,
        a3);
    }
    return v7;
  }
  else
  {
    result = RegDeleteValueW(a2, a3);
    if ( result == 2 )
      return 0;
  }
  return result;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (00000001800066B8) ----------------------------------------------------
__int64 __fastcall JobStore::CreateIndexEntryP(
        __int64 a1,
        int a2,
        const unsigned __int16 *a3,
        struct _SECURITY_ATTRIBUTES *a4)
{
  unsigned int v7; // esi
  LSTATUS v8; // eax
  _QWORD *v9; // rcx
  unsigned __int16 v11; // dx
  LPCWSTR lpSubKey; // [rsp+50h] [rbp-28h] BYREF
  HKEY phkResult[3]; // [rsp+58h] [rbp-20h] BYREF
  DWORD dwDisposition; // [rsp+80h] [rbp+8h] BYREF

  phkResult[1] = HKEY_DYN_DATA|0x7FFFFFF8LL;
  v7 = 0;
  lpSubKey = 0LL;
  JobStore::GetIndexKeyPath(a1, a2, (BSTR *)&lpSubKey);
  ATL::CComBSTR::operator+=((const void **)&lpSubKey, L"\\");
  ATL::CComBSTR::operator+=((const void **)&lpSubKey, a3);
  phkResult[0] = 0LL;
  v8 = RegCreateKeyExW(*(HKEY *)(a1 + 16), lpSubKey, 0, 0LL, 0, 0xF003Fu, a4, phkResult, &dwDisposition);
  if ( v8 )
  {
    if ( v8 > 0 )
      v7 = (unsigned __int16)v8 | 0x80070000;
    else
      v7 = v8;
    v9 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      v11 = 59;
LABEL_15:
      WPP_SF_SD(v9[2], v11, (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids, a3);
    }
  }
  else if ( dwDisposition != 1 )
  {
    v7 = -2147024713;
    v9 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      v11 = 60;
      goto LABEL_15;
    }
  }
  wmi::AutoRegKey::Close(phkResult);
  SysFreeString((BSTR)lpSubKey);
  return v7;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 1800066B8: using guessed type HKEY var_20[3];

//----- (00000001800067C4) ----------------------------------------------------
__int64 __fastcall JobStore::RegOpenTaskEntryForUpdate(
        HKEY *this,
        const struct JobMoniker *a2,
        const struct JobSecurity *a3,
        const enum JobStore::TaskIndex *a4,
        int a5,
        HKEY *a6)
{
  const unsigned __int16 *Path; // r12
  __int64 result; // rax
  LSTATUS v11; // eax
  int v12; // edi
  LSTATUS v13; // eax
  int i; // edi
  __int64 v15; // rax
  int v16; // edx
  unsigned int v17; // eax
  int v18; // ecx
  LSTATUS v19; // eax
  __int64 v20; // rdx
  LSTATUS v21; // eax
  HKEY v22; // rax
  int v23; // eax
  const unsigned __int16 *v24; // rax
  unsigned __int16 v25; // dx
  const wchar_t *v26; // r9
  _QWORD *v27; // rcx
  unsigned __int16 v28; // dx
  const wchar_t *v29; // r9
  const unsigned __int16 *v30; // rax
  HKEY hKey; // [rsp+30h] [rbp-D0h] BYREF
  HKEY v32; // [rsp+38h] [rbp-C8h] BYREF
  DWORD Type; // [rsp+40h] [rbp-C0h] BYREF
  LPCWSTR lpSubKey; // [rsp+48h] [rbp-B8h] BYREF
  DWORD cbData; // [rsp+50h] [rbp-B0h] BYREF
  HKEY *v36; // [rsp+58h] [rbp-A8h]
  struct _SECURITY_ATTRIBUTES v37; // [rsp+60h] [rbp-A0h] BYREF
  __int64 v38; // [rsp+78h] [rbp-88h]
  GUID rguid; // [rsp+80h] [rbp-80h] BYREF
  OLECHAR sz[40]; // [rsp+90h] [rbp-70h] BYREF
  wchar_t Data[260]; // [rsp+E0h] [rbp-20h] BYREF
  __int16 v42; // [rsp+2E8h] [rbp+1E8h]

  v38 = -2LL;
  v36 = a6;
  v37.nLength = 24;
  v37.lpSecurityDescriptor = tsched::StoreSecurity::g_pRestrictedKeySecurity;
  v37.bInheritHandle = 0;
  Path = JobMoniker::GetPath(a2);
  rguid = 0LL;
  result = JobStore::RegGetTaskIdWithRecovery(this, a2, &rguid, 0, 0LL);
  if ( (int)result >= 0 )
  {
    if ( !StringFromGUID2(&rguid, sz, 40) )
      return 2147942522LL;
    ATL::CComBSTR::CComBSTR((ATL::CComBSTR *)&lpSubKey, L"TaskCache\\Tasks\\");
    ATL::CComBSTR::operator+=((const void **)&lpSubKey, sz);
    hKey = 0LL;
    v11 = RegOpenKeyExW(this[2], lpSubKey, 0, 0xF003Fu, &hKey);
    v12 = v11;
    if ( v11 )
    {
      if ( v11 > 0 )
        v12 = (unsigned __int16)v11 | 0x80070000;
      if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
        || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) == 0
        || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
      {
        goto LABEL_20;
      }
      v24 = JobMoniker::GetPath(a2);
      v25 = 46;
      v26 = lpSubKey;
    }
    else
    {
      Type = 0;
      memset_0(Data, 0, 0x20AuLL);
      cbData = 522;
      v13 = RegQueryValueExW(hKey, L"Path", 0LL, &Type, (LPBYTE)Data, &cbData);
      v12 = v13;
      if ( !v13 )
      {
        if ( Type == 1 )
        {
          v42 = 0;
          if ( !_wcsicmp(Path, Data) )
          {
            for ( i = 1; i < 5; ++i )
            {
              v15 = 0LL;
              if ( a5 <= 0LL )
              {
LABEL_11:
                v17 = JobStore::RemoveIndexEntryP((__int64)this, i, sz);
                if ( tsched::IsErrorNotFound((tsched *)v17) )
                  v18 = 0;
                if ( v18 < 0 )
                {
                  v12 = v18;
                  goto LABEL_20;
                }
              }
              else
              {
                while ( 1 )
                {
                  v16 = *((_DWORD *)a4 + v15);
                  if ( v16 == i )
                    break;
                  if ( ++v15 >= a5 )
                    goto LABEL_11;
                }
                v23 = JobStore::CreateIndexEntryP((__int64)this, v16, sz, &v37);
                if ( v23 == -2147024713 )
                  v23 = 0;
                if ( v23 < 0 )
                {
                  v12 = v23;
                  goto LABEL_20;
                }
              }
            }
            v32 = 0LL;
            v12 = JobStore::RegTreeEntryOpen(this, Path, &v32);
            if ( v12 < 0 )
            {
              v27 = WPP_GLOBAL_Control;
              if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
                || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) == 0
                || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
              {
                goto LABEL_48;
              }
              v28 = 48;
              v29 = Path;
            }
            else
            {
              v19 = RegSetValueExW(v32, L"Index", 0, 4u, (const BYTE *)a4, 4u);
              v12 = v19;
              if ( !v19 )
              {
                v20 = *((_QWORD *)a2 + 4);
                if ( (-(__int64)(*(_DWORD *)(v20 + 60) != 0) & (v20 + 28)) == 0
                  || (v21 = RegSetValueExW(
                              hKey,
                              L"Hash",
                              0,
                              3u,
                              (const BYTE *)((v20 + 28) & -(__int64)(*(_DWORD *)(v20 + 60) != 0)),
                              0x20u),
                      (v12 = v21) == 0) )
                {
                  v22 = hKey;
                  hKey = 0LL;
                  *v36 = v22;
                  wmi::AutoRegKey::Close(&v32);
                  v12 = 0;
                  goto LABEL_20;
                }
                if ( v21 > 0 )
                  v12 = (unsigned __int16)v21 | 0x80070000;
                if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
                  && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
                  && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
                {
                  v30 = JobMoniker::GetPath(a2);
                  WPP_SF_SSD(
                    *((_QWORD *)WPP_GLOBAL_Control + 2),
                    0x32u,
                    (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
                    L"Hash",
                    (__int64)v30);
                }
                goto LABEL_48;
              }
              if ( v19 > 0 )
                v12 = (unsigned __int16)v19 | 0x80070000;
              if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
                || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) == 0
                || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
              {
LABEL_48:
                wmi::AutoRegKey::Close(&v32);
                goto LABEL_20;
              }
              v29 = JobMoniker::GetPath(a2);
              v28 = 49;
              v27 = WPP_GLOBAL_Control;
            }
            WPP_SF_SD(v27[2], v28, (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids, v29);
            goto LABEL_48;
          }
          v12 = -2147418113;
        }
        else
        {
          v12 = -2147352571;
        }
LABEL_20:
        wmi::AutoRegKey::Close(&hKey);
        SysFreeString((BSTR)lpSubKey);
        return (unsigned int)v12;
      }
      if ( v13 > 0 )
        v12 = (unsigned __int16)v13 | 0x80070000;
      if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
        || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) == 0
        || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
      {
        goto LABEL_20;
      }
      v24 = JobMoniker::GetPath(a2);
      v25 = 47;
      v26 = L"Path";
    }
    WPP_SF_SSD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      v25,
      (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
      v26,
      (__int64)v24);
    goto LABEL_20;
  }
  return result;
}
// 1800069A0: variable 'v18' is possibly undefined
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 1800067C4: using guessed type wchar_t Data[260];

//----- (0000000180006AF4) ----------------------------------------------------
__int64 __fastcall JobStore::RemoveIndexEntryP(__int64 a1, int a2, const wchar_t *a3)
{
  LSTATUS v5; // eax
  unsigned int v6; // ebx
  LSTATUS v7; // eax
  _QWORD *v9; // rcx
  unsigned __int16 v10; // dx
  HKEY hKey; // [rsp+50h] [rbp+8h] BYREF
  LPCWSTR lpSubKey; // [rsp+68h] [rbp+20h] BYREF

  lpSubKey = 0LL;
  JobStore::GetIndexKeyPath(a1, a2, (BSTR *)&lpSubKey);
  hKey = 0LL;
  v5 = RegOpenKeyExW(*(HKEY *)(a1 + 16), lpSubKey, 0, 0x20019u, &hKey);
  v6 = v5;
  if ( v5 )
  {
    if ( v5 > 0 )
      v6 = (unsigned __int16)v5 | 0x80070000;
    if ( !tsched::IsErrorNotFound((tsched *)v6) )
    {
      v9 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        v10 = 61;
LABEL_19:
        WPP_SF_SD(v9[2], v10, (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids, a3);
      }
    }
  }
  else
  {
    v7 = RegDeleteKeyExW(hKey, a3, 0, 0);
    v6 = v7;
    if ( v7 )
    {
      if ( v7 > 0 )
        v6 = (unsigned __int16)v7 | 0x80070000;
      if ( !tsched::IsErrorNotFound((tsched *)v6) )
      {
        v9 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
          && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
          && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
        {
          v10 = 62;
          goto LABEL_19;
        }
      }
    }
    else
    {
      v6 = 0;
    }
  }
  wmi::AutoRegKey::Close(&hKey);
  SysFreeString((BSTR)lpSubKey);
  return v6;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180006BC4) ----------------------------------------------------
__int64 __fastcall JobStore::ComputeHash(struct JobMoniker *a1, unsigned __int8 *a2)
{
  __int64 v2; // rdi
  __int64 v3; // rax
  __int64 result; // rax
  unsigned int v7; // edx
  unsigned __int64 v8; // rdi
  unsigned __int64 i; // r8
  unsigned __int64 v10; // rcx
  int v11; // ebx
  __int64 v12; // rax
  unsigned int v13; // [rsp+30h] [rbp-48h] BYREF
  unsigned __int8 v14[16]; // [rsp+38h] [rbp-40h] BYREF
  __int128 v15; // [rsp+48h] [rbp-30h]

  v2 = -1LL;
  v13 = 32;
  v3 = -1LL;
  do
    ++v3;
  while ( *(_WORD *)&a2[2 * v3] );
  result = HashCompute::ComputeHash((HashCompute *)&v13, a2, 2 * (int)v3, v14, &v13);
  if ( (_DWORD)result )
  {
    if ( (int)result > 0 )
      return (unsigned __int16)result | 0x80070000;
  }
  else
  {
    v7 = -1;
    do
      ++v2;
    while ( *(_WORD *)&a2[2 * v2] );
    v8 = 2 * v2;
    if ( v8 )
    {
      for ( i = 0LL; i < v8; ++i )
      {
        v10 = a2[i];
        v11 = (v7 >> 8) ^ dword_18007D000[(unsigned __int8)v7 ^ v10];
        v7 = v11;
      }
      v7 = v11;
    }
    v12 = *((_QWORD *)a1 + 4);
    *(_OWORD *)(v12 + 28) = *(_OWORD *)v14;
    *(_OWORD *)(v12 + 44) = v15;
    *(_DWORD *)(v12 + 60) = 1;
    *(_DWORD *)(*((_QWORD *)a1 + 4) + 24LL) = v7;
    return 0LL;
  }
  return result;
}
// 180006C36: conditional instruction was optimized away because rdi.8!=0
// 18007D000: using guessed type _DWORD dword_18007D000[256];

//----- (0000000180006CAC) ----------------------------------------------------
__int64 __fastcall HashCompute::ComputeHash(
        HashCompute *this,
        unsigned __int8 *const a2,
        ULONG a3,
        unsigned __int8 *a4,
        unsigned int *a5)
{
  ULONG *v8; // rbx
  int v9; // edi
  _QWORD *v11; // r10
  unsigned __int16 v12; // dx
  ULONG v13; // ebx
  BCRYPT_HASH_HANDLE phHash; // [rsp+60h] [rbp+8h] BYREF

  phHash = 0LL;
  if ( !_InterlockedCompareExchange(&dword_1800B0A40, 0, 0) )
    return 31LL;
  if ( !a2 )
    return 87LL;
  if ( !a4 )
    return 87LL;
  v8 = a5;
  if ( !a5 || *a5 < *(&dwBytes + 1) )
    return 87LL;
  EnterCriticalSection(&CriticalSection);
  v9 = BCryptCreateHash(*(&pbHashObject + 1), &phHash, pbHashObject, dwBytes, 0LL, 0, 0);
  if ( v9 < 0 )
  {
    v11 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      v12 = 14;
LABEL_23:
      WPP_SF_D(v11[2], v12, (__int64)&WPP_2b8d55565e60367fc767d22ca087624d_Traceguids, v9);
    }
  }
  else
  {
    v9 = BCryptHashData(phHash, a2, a3, 0);
    if ( v9 >= 0 )
    {
      v9 = BCryptFinishHash(phHash, a4, *v8, 0);
      if ( v9 >= 0 )
      {
        BCryptDestroyHash(phHash);
        *v8 = *(&dwBytes + 1);
        LeaveCriticalSection(&CriticalSection);
        return 0LL;
      }
      v11 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
        || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) == 0
        || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
      {
        goto LABEL_24;
      }
      v12 = 16;
      goto LABEL_23;
    }
    v11 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      v12 = 15;
      goto LABEL_23;
    }
  }
LABEL_24:
  v13 = RtlNtStatusToDosError(v9);
  if ( phHash )
    BCryptDestroyHash(phHash);
  LeaveCriticalSection(&CriticalSection);
  return v13;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 1800B0A40: using guessed type int dword_1800B0A40;

//----- (0000000180006E04) ----------------------------------------------------
User::UserEntry **__fastcall wmi::AutoRef<User::UserEntry>::operator=(User::UserEntry **a1, User::UserEntry *a2)
{
  struct _RTL_CRITICAL_SECTION *v4; // rbx
  User::UserEntry **result; // rax

  if ( a2 )
  {
    v4 = User::s_cs;
    EnterCriticalSection(User::s_cs);
    ++*((_DWORD *)a2 + 11);
    LeaveCriticalSection(v4);
  }
  if ( *a1 )
    User::UserEntry::Release(*a1);
  result = a1;
  *a1 = a2;
  return result;
}

//----- (0000000180006E9C) ----------------------------------------------------
__int64 __fastcall User::UserEntry::Release(User::UserEntry *this)
{
  struct _RTL_CRITICAL_SECTION *v1; // rbx
  bool v3; // zf
  unsigned int v4; // ebp
  _QWORD *v6; // rsi
  User::UserEntry **v7; // rcx
  User::UserEntry **v8; // r8

  v1 = User::s_cs;
  EnterCriticalSection(User::s_cs);
  v3 = (*((_DWORD *)this + 11))-- == 1;
  v4 = *((_DWORD *)this + 11);
  if ( v3 )
  {
    v6 = User::s_userTable;
    v7 = *(User::UserEntry ***)User::s_userTable;
    v8 = (User::UserEntry **)*((_QWORD *)User::s_userTable + 1);
    while ( v7 != v8 )
    {
      if ( *v7 == this )
      {
        memmove_0(v7, v7 + 1, ((char *)v8 - (char *)(v7 + 1)) & 0xFFFFFFFFFFFFFFF8uLL);
        v6[1] -= 8LL;
        break;
      }
      ++v7;
    }
    operator delete(*((void **)this + 4));
    _bstr_t::_Free((User::UserEntry *)((char *)this + 24));
    _bstr_t::_Free((User::UserEntry *)((char *)this + 16));
    _bstr_t::_Free((User::UserEntry *)((char *)this + 8));
    operator delete(this);
  }
  LeaveCriticalSection(v1);
  return v4;
}

//----- (0000000180006F70) ----------------------------------------------------
__int64 __fastcall ServerXMLUpdateHandler::NetworkOutputHandler::Process(__int64 a1, __int64 a2, int a3, __int64 a4)
{
  int v4; // edx
  char v5; // di
  int v8; // r8d
  int v9; // r8d
  __int64 result; // rax
  OLECHAR sz[40]; // [rsp+20h] [rbp-78h] BYREF

  v4 = 0;
  v5 = 0;
  v8 = a3 - 90;
  if ( !v8 )
  {
    if ( !*(_BYTE *)(a1 + 32) )
    {
      *(_BYTE *)(a1 + 32) = 1;
      v5 = 1;
      goto LABEL_4;
    }
    *(_DWORD *)(*(_QWORD *)(a1 + 8) + 108LL) = 90;
    return 2147750678LL;
  }
  v9 = v8 - 1;
  if ( !v9 )
  {
    if ( *(_BYTE *)(a1 + 32) )
      goto LABEL_4;
    *(_DWORD *)(*(_QWORD *)(a1 + 8) + 108LL) = 91;
    return 2147750678LL;
  }
  if ( v9 == 1 )
  {
    if ( *(_BYTE *)(a1 + 32) )
    {
      v4 = IIDFromString(*(LPCOLESTR *)(*(_QWORD *)(a4 + 48) + 8LL), (LPIID)(a1 + 16));
      if ( v4 < 0 )
      {
        if ( **(_WORD **)(*(_QWORD *)(a4 + 48) + 8LL) != 123 )
        {
          v4 = StringCchPrintfW(sz, 0x28uLL, (size_t *)L"{%s}");
          if ( v4 < 0 )
            goto LABEL_4;
          v4 = IIDFromString(sz, (LPIID)(a1 + 16));
        }
        if ( v4 < 0 )
          goto LABEL_4;
      }
      *(_BYTE *)(a1 + 33) = 1;
      goto LABEL_4;
    }
    *(_DWORD *)(*(_QWORD *)(a1 + 8) + 108LL) = 92;
    return 2147750678LL;
  }
LABEL_4:
  if ( !*(_BYTE *)(a1 + 32) )
    return (unsigned int)v4;
  if ( v5 )
    return (unsigned int)v4;
  result = 1LL;
  if ( v4 < 0 )
    return (unsigned int)v4;
  return result;
}

//----- (0000000180006FEC) ----------------------------------------------------
void __fastcall wmi::AutoRegKey::Close(HKEY *this)
{
  HKEY v2; // rcx

  v2 = *this;
  if ( v2 )
  {
    RegCloseKey(v2);
    *this = 0LL;
  }
}

//----- (0000000180007020) ----------------------------------------------------
__int64 __fastcall _Read__QIStream__StringReader__EEAAJPEAXKPEAK_Z(__int64 a1, _WORD *a2, unsigned int a3, char *a4)
{
  char *v4; // rdi
  __int64 v7; // rdx
  unsigned __int64 v8; // rcx
  size_t v9; // rbx
  _WORD *v11; // rax
  char v12; // [rsp+38h] [rbp+10h] BYREF

  v4 = &v12;
  if ( a4 )
    v4 = a4;
  *(_DWORD *)v4 = 0;
  if ( !a2 )
    return 2147680265LL;
  v7 = *(unsigned int *)(a1 + 24);
  if ( !(_DWORD)v7 )
    return 1LL;
  if ( !a3 )
    return 0LL;
  v8 = *(_QWORD *)(a1 + 16);
  if ( v8 != -1LL )
  {
LABEL_7:
    if ( v8 < 2 * v7 )
    {
      v9 = 2 * v7 - v8;
      if ( v9 >= a3 )
        v9 = a3;
      memcpy_0(a2, (const void *)(v8 + *(_QWORD *)(a1 + 32)), v9);
      *(_DWORD *)v4 = v9;
      *(_QWORD *)(a1 + 16) += v9;
      return 0LL;
    }
    *(_DWORD *)v4 = 0;
    return 1LL;
  }
  if ( (unsigned int)v7 < 2 )
    return 1LL;
  v11 = *(_WORD **)(a1 + 32);
  *(_QWORD *)(a1 + 16) = 0LL;
  v8 = 0LL;
  if ( *v11 == 0xFEFF )
    goto LABEL_7;
  if ( a3 >= 2 )
  {
    *a2 = -257;
    *(_DWORD *)v4 = 2;
    return 0LL;
  }
  return 2147942522LL;
}

//----- (00000001800070F4) ----------------------------------------------------
__int64 __fastcall UbpmParams::NewHostedObject<std::vector<_DAB_WNF_STATE_CHANGE_TRIGGER_PARAMS *>,_DAB_WNF_STATE_CHANGE_TRIGGER_PARAMS>(
        __int64 *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10)
{
  _QWORD *v12; // rax
  char v13; // dl
  __int64 *v14; // rcx
  __int64 v16; // rax
  __int64 v17; // rdi
  _QWORD *v18; // [rsp+50h] [rbp+8h] BYREF

  v12 = operator new(0x18uLL);
  if ( v12 )
  {
    *(_OWORD *)v12 = *(_OWORD *)a2;
    v12[2] = *(_QWORD *)(a2 + 16);
  }
  v18 = v12;
  v13 = 1;
  v14 = (__int64 *)a1[1];
  if ( &v18 >= (_QWORD **)v14 || *a1 > (unsigned __int64)&v18 )
    v13 = 0;
  if ( v13 )
  {
    v16 = *a1;
    v17 = ((__int64)&a10 - *a1) >> 3;
    if ( v14 == (__int64 *)a1[2] )
    {
      std::vector<_DAB_TRIGGER_PARAMS *>::_Reserve(a1);
      v16 = *a1;
      v14 = (__int64 *)a1[1];
    }
    v12 = *(_QWORD **)(v16 + 8 * v17);
  }
  else if ( v14 == (__int64 *)a1[2] )
  {
    std::vector<_DAB_TRIGGER_PARAMS *>::_Reserve(a1);
    v14 = (__int64 *)a1[1];
    v12 = v18;
  }
  *v14 = (__int64)v12;
  a1[1] += 8LL;
  return (__int64)v18;
}

//----- (000000018000719C) ----------------------------------------------------
void __fastcall tsched::DeleteMe<_UBPM_ACTION_EXE_LAUNCH_PARAMS>::~DeleteMe<_UBPM_ACTION_EXE_LAUNCH_PARAMS>(__int64 a1)
{
  void *v1; // rcx

  if ( *(_BYTE *)(a1 + 8) )
  {
    v1 = **(void ***)a1;
    if ( v1 )
      operator delete(v1);
  }
}

//----- (00000001800071B0) ----------------------------------------------------
__int64 __fastcall std::vector<_DAB_TRIGGER_PARAMS *>::_Reserve(_QWORD *a1)
{
  __int64 v2; // rdx
  __int64 result; // rax
  __int64 v4; // rdx
  unsigned __int64 v5; // rdx
  unsigned __int64 v6; // r9
  unsigned __int64 v7; // rcx

  v2 = a1[1];
  result = (a1[2] - v2) >> 3;
  if ( !result )
  {
    v4 = (v2 - *a1) >> 3;
    if ( v4 == 0x1FFFFFFFFFFFFFFFLL )
      std::_Xlength_error("vector<T> too long");
    v5 = v4 + 1;
    v6 = (__int64)(a1[2] - *a1) >> 3;
    v7 = 0LL;
    if ( 0x1FFFFFFFFFFFFFFFLL - (v6 >> 1) >= v6 )
      v7 = v6 + (v6 >> 1);
    if ( v7 >= v5 )
      v5 = v7;
    return (__int64)std::vector<_DAB_SESSION_STATE_CHANGE_TRIGGER_PARAMS *>::_Reallocate((__int64)a1, v5);
  }
  return result;
}

//----- (000000018000722C) ----------------------------------------------------
char *__fastcall std::vector<_DAB_SESSION_STATE_CHANGE_TRIGGER_PARAMS *>::_Reallocate(__int64 a1, unsigned __int64 a2)
{
  char *v4; // rbx
  __int64 v5; // r14
  char *result; // rax

  v4 = 0LL;
  if ( a2 )
  {
    if ( a2 > 0x1FFFFFFFFFFFFFFFLL || (v4 = (char *)operator new(8 * a2)) == 0LL )
      std::_Xbad_alloc();
  }
  memmove_0(v4, *(const void **)a1, (*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) & 0xFFFFFFFFFFFFFFF8uLL);
  v5 = (__int64)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3;
  if ( *(_QWORD *)a1 )
    operator delete(*(void **)a1);
  *(_QWORD *)(a1 + 16) = &v4[8 * a2];
  result = &v4[8 * v5];
  *(_QWORD *)(a1 + 8) = result;
  *(_QWORD *)a1 = v4;
  return result;
}

//----- (00000001800072F0) ----------------------------------------------------
__int64 __fastcall ServerXMLUpdateHandler::RegistrationInfoHandler::EndElement(
        __int64 a1,
        const struct Schema *a2,
        int a3)
{
  if ( a3 == 3 )
  {
    if ( !*(_BYTE *)(a1 + 10) )
    {
      ServerXMLUpdateHandler::WriteURI(*(ServerXMLUpdateHandler **)(a1 + 16), a2, 0LL);
      *(_BYTE *)(a1 + 10) = 1;
    }
    if ( !*(_BYTE *)(a1 + 11) )
    {
      ServerXMLUpdateHandler::WriteSecurityDescriptor(*(ServerXMLUpdateHandler **)(a1 + 16), a2, 0LL);
      *(_BYTE *)(a1 + 11) = 1;
    }
    *(_WORD *)(a1 + 8) = 1;
  }
  else if ( a3 == 1 && !*(_BYTE *)(a1 + 8) )
  {
    ServerXMLUpdateHandler::WritedRegistraionInfoAndOverrides(*(ServerXMLUpdateHandler **)(a1 + 16), a2);
    *(_BYTE *)(a1 + 8) = 1;
    *(_WORD *)(a1 + 10) = 257;
  }
  return 0LL;
}

//----- (0000000180007370) ----------------------------------------------------
__int64 __fastcall ServerXMLUpdateHandler::ContextHandler::EndElement(__int64 a1, int *a2)
{
  __int64 v2; // r9
  __int64 v4; // rcx
  __int64 *v5; // rax
  int v6; // r8d
  __int64 *v7; // rax

  v2 = 0LL;
  if ( *(_BYTE *)(a1 + 18) )
  {
    *(_BYTE *)(a1 + 18) = 0;
    v4 = *(_QWORD *)(a1 + 8);
    v5 = *(__int64 **)(v4 + 96);
    if ( v5 )
      v2 = *v5;
    v6 = 99;
    goto LABEL_10;
  }
  if ( *(_BYTE *)(a1 + 17) )
  {
    *(_BYTE *)(a1 + 17) = 0;
    v4 = *(_QWORD *)(a1 + 8);
    v7 = *(__int64 **)(v4 + 96);
    if ( v7 )
      v2 = *v7;
    v6 = 110;
LABEL_10:
    ServerXMLUpdateHandler::WriteContext(v4, a2, v6, v2);
  }
  return 0LL;
}

//----- (000000018000739C) ----------------------------------------------------
__int64 __fastcall _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::~_com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>(
        __int64 *a1)
{
  __int64 v1; // rcx
  __int64 result; // rax

  v1 = *a1;
  if ( v1 )
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v1 + 16LL))(v1);
  return result;
}

//----- (00000001800073C4) ----------------------------------------------------
void __fastcall std::vector<_bstr_t>::_Tidy(__int64 a1)
{
  _bstr_t *v1; // rbx
  _bstr_t *v3; // rsi

  v1 = *(_bstr_t **)a1;
  if ( *(_QWORD *)a1 )
  {
    v3 = *(_bstr_t **)(a1 + 8);
    if ( v1 != v3 )
    {
      do
      {
        _bstr_t::_Free(v1);
        v1 = (_bstr_t *)((char *)v1 + 8);
      }
      while ( v1 != v3 );
      v1 = *(_bstr_t **)a1;
    }
    operator delete(v1);
    *(_QWORD *)a1 = 0LL;
    *(_QWORD *)(a1 + 8) = 0LL;
    *(_QWORD *)(a1 + 16) = 0LL;
  }
}

//----- (0000000180007430) ----------------------------------------------------
const unsigned __int16 *__fastcall ComHandlerBase::GetName(ComHandlerBase *this)
{
  BSTR *v1; // rax
  __int64 v2; // rbx
  UINT v4; // eax
  BSTR *v5; // rax
  UINT v6; // eax
  __int64 v7; // rax

  v1 = (BSTR *)*((_QWORD *)this + 2);
  v2 = 0LL;
  if ( v1 && *v1 )
    v4 = SysStringLen(*v1);
  else
    v4 = 0;
  if ( v4 )
  {
    v7 = *((_QWORD *)this + 2);
  }
  else
  {
    v5 = (BSTR *)*((_QWORD *)this + 8);
    if ( v5 && *v5 )
      v6 = SysStringLen(*v5);
    else
      v6 = 0;
    if ( !v6 )
      ComHandlerBase::SetDefaultName(this);
    v7 = *((_QWORD *)this + 8);
  }
  if ( v7 )
    return *(const unsigned __int16 **)v7;
  return (const unsigned __int16 *)v2;
}

//----- (00000001800074AC) ----------------------------------------------------
void __fastcall ComHandlerBase::SetDefaultName(ComHandlerBase *this)
{
  HKEY hKey; // [rsp+30h] [rbp-D0h] BYREF
  DWORD cbData; // [rsp+38h] [rbp-C8h] BYREF
  DWORD Type; // [rsp+3Ch] [rbp-C4h] BYREF
  wchar_t v5[19]; // [rsp+40h] [rbp-C0h] BYREF
  char v6[90]; // [rsp+66h] [rbp-9Ah] BYREF
  OLECHAR Data[256]; // [rsp+C0h] [rbp-40h] BYREF

  hKey = 0LL;
  wcscpy(v5, L"Wow6432Node\\CLSID\\");
  memset_0(v6, 0, 0x52uLL);
  if ( StringFromGUID2((const GUID *const)((char *)this + 40), &v5[18], 42) )
  {
    cbData = 510;
    if ( !RegOpenKeyExW(HKEY_CLASSES_ROOT, &v5[12], 0, 0x20019u, &hKey) )
    {
      if ( !RegQueryValueExW(hKey, 0LL, 0LL, &Type, (LPBYTE)Data, &cbData) && Type - 1 <= 1 )
      {
LABEL_5:
        _bstr_t::operator=((_bstr_t::Data_t **)this + 8, Data);
LABEL_6:
        RegCloseKey(hKey);
        return;
      }
      RegCloseKey(hKey);
    }
    cbData = 510;
    if ( !RegOpenKeyExW(HKEY_CLASSES_ROOT, v5, 0, 0x20019u, &hKey) )
    {
      if ( RegQueryValueExW(hKey, 0LL, 0LL, &Type, (LPBYTE)Data, &cbData) || Type - 1 > 1 )
        goto LABEL_6;
      goto LABEL_5;
    }
  }
}
// 18007D400: using guessed type wchar_t aWow6432nodeCls[19];
// 1800074AC: using guessed type char var_26A[90];
// 1800074AC: using guessed type OLECHAR Data[256];

//----- (000000018000767C) ----------------------------------------------------
__int64 __fastcall JobStore::SetSchedulingEngineFlag(
        JobStore *this,
        struct JobMoniker *a2,
        struct Triggers::Trigulator *a3,
        struct Actions::ActionCollection *a4,
        bool *a5,
        int *a6)
{
  bool *v6; // rsi
  int *v8; // r14
  int v11; // edi
  bool v12; // di
  int v13; // edx
  JobStore *v15; // [rsp+50h] [rbp+8h] BYREF

  v15 = this;
  v6 = a5;
  v8 = a6;
  v11 = *(_DWORD *)(*((_QWORD *)a2 + 4) + 16LL);
  *a5 = 0;
  *v8 = 0;
  v12 = (v11 & 0x2000000) != 0;
  v13 = (*((__int64 (__fastcall **)(void ***, struct JobMoniker *, struct Actions::ActionCollection *, JobStore **))UbpmProxySingleton::s_singleton[0]
         + 15))(
          UbpmProxySingleton::s_singleton,
          a2,
          a4,
          &v15);
  if ( v13 >= 0 )
  {
    if ( (_DWORD)v15 )
    {
      *(_DWORD *)(*((_QWORD *)a2 + 4) + 16LL) |= 0x2000000u;
    }
    else
    {
      v13 = (*((__int64 (__fastcall **)(void ***, struct JobMoniker *, struct Triggers::Trigulator *, struct Actions::ActionCollection *, JobStore **))UbpmProxySingleton::s_singleton[0]
             + 16))(
              UbpmProxySingleton::s_singleton,
              a2,
              a3,
              a4,
              &v15);
      if ( v13 < 0 )
        return (unsigned int)v13;
      if ( !(_DWORD)v15 )
        return (unsigned int)-2147216599;
      *(_DWORD *)(*((_QWORD *)a2 + 4) + 16LL) &= ~0x2000000u;
    }
    *v6 = v12 ^ ((*(_DWORD *)(*((_QWORD *)a2 + 4) + 16LL) & 0x2000000) != 0);
    *v8 = 0;
  }
  return (unsigned int)v13;
}
// 1800AFFB0: using guessed type void **UbpmProxySingleton::s_singleton[2];

//----- (0000000180007734) ----------------------------------------------------
_QWORD *__fastcall std::_List_alloc<0,std::_List_base_types<std::vector<unsigned char> *,std::allocator<std::vector<unsigned char> *>>>::_Buynode0(
        __int64 a1,
        _QWORD *a2,
        _QWORD *a3)
{
  _QWORD *result; // rax

  result = operator new(0x18uLL);
  if ( !result )
    std::_Xbad_alloc();
  if ( !a2 )
  {
    a2 = result;
    a3 = result;
  }
  *result = a2;
  result[1] = a3;
  return result;
}

//----- (0000000180007790) ----------------------------------------------------
__int64 __fastcall ServerXMLUpdateHandler::NetworkOutputHandler::EndElement(
        __int64 a1,
        const struct Schema *a2,
        int a3)
{
  int v5; // edi
  __int64 *v7; // [rsp+58h] [rbp+20h] BYREF

  v5 = 0;
  if ( a3 == 90 )
  {
    if ( *(_BYTE *)(a1 + 33) )
    {
      v7 = 0LL;
      v5 = ServerXMLUpdateHandler::NetworkId2Name(
             (ServerXMLUpdateHandler *)a1,
             (const struct _GUID *)(a1 + 16),
             (_bstr_t::Data_t **)&v7);
      if ( v5 >= 0 )
        ServerXMLUpdateHandler::WriteNetworkSettings(
          *(ServerXMLUpdateHandler **)(a1 + 8),
          a2,
          (const struct _GUID *)(a1 + 16),
          &v7);
      _bstr_t::_Free((_bstr_t *)&v7);
    }
    *(_BYTE *)(a1 + 32) = 0;
  }
  return (unsigned int)v5;
}

//----- (00000001800077E0) ----------------------------------------------------
__int64 __fastcall Triggers::TimeTrigger::StreamIn(
        Triggers::TimeTrigger *this,
        unsigned __int64 a2,
        unsigned __int8 **a3,
        unsigned __int8 *a4)
{
  unsigned __int8 *v5; // r8
  BSTR **v6; // rdi
  int v7; // ecx
  char v8; // al
  BSTR *v9; // rcx

  v5 = *a3;
  if ( a4 - v5 < 88 )
    return 2147549183LL;
  *(_OWORD *)((char *)this + 8) = *(_OWORD *)v5;
  *(_OWORD *)((char *)this + 24) = *((_OWORD *)v5 + 1);
  *(_OWORD *)((char *)this + 40) = *((_OWORD *)v5 + 2);
  *(_OWORD *)((char *)this + 56) = *((_OWORD *)v5 + 3);
  *(_OWORD *)((char *)this + 72) = *((_OWORD *)v5 + 4);
  *((_QWORD *)this + 11) = *((_QWORD *)v5 + 10);
  *a3 += 88;
  if ( a2 < 0x16 )
    return 0LL;
  v6 = (BSTR **)((char *)this + 96);
  v7 = JobStore::StreamInBSTR((_bstr_t::Data_t **)this + 12, a3, a4);
  v8 = 0;
  if ( v7 >= 0 )
  {
    v9 = *v6;
    if ( *v6 && *v9 )
      v8 = SysStringLen(*v9);
    if ( ((2 * v8 - 4) & 7) != 0 )
      *a3 += 8 - ((2 * v8 - 4) & 7u);
    return 0LL;
  }
  return (unsigned int)v7;
}

//----- (00000001800078B0) ----------------------------------------------------
__int64 __fastcall StringStream::Release(StringStream *this)
{
  __int64 result; // rax

  result = (unsigned int)(*((_DWORD *)this + 2) - 1);
  *((_DWORD *)this + 2) = result;
  if ( !(_DWORD)result )
  {
    (*(void (__fastcall **)(StringStream *, __int64))(*(_QWORD *)this + 112LL))(this, 1LL);
    return 0LL;
  }
  return result;
}

//----- (00000001800078E4) ----------------------------------------------------
char __fastcall tsched::IsErrorNotFound(tsched *this)
{
  char v1; // dl

  v1 = 1;
  if ( (unsigned int)((_DWORD)this + 2147024894) > 1 )
    return (_DWORD)this == -2147023728;
  return v1;
}

//----- (0000000180007910) ----------------------------------------------------
int __fastcall ComHandlerBase::WriteXml(ComHandlerBase *this, struct TaskXmlWriter *a2)
{
  __int64 *v2; // rax
  __int64 v5; // rdx
  int result; // eax
  _QWORD *v7; // rax
  __int64 v9; // r8
  __int64 v10; // r9
  GUID v11; // [rsp+20h] [rbp-18h] BYREF

  v2 = (__int64 *)*((_QWORD *)this + 2);
  if ( v2 )
    v5 = *v2;
  else
    v5 = 0LL;
  if ( v5 )
  {
    if ( v2 )
      v10 = *v2;
    else
      v10 = 0LL;
    result = TaskXmlWriter::StartElementWithAttribute((__int64)a2, 107, 109, v10);
  }
  else
  {
    result = TaskXmlWriter::StartElement((int *)a2, 107);
  }
  if ( result >= 0 )
  {
    v11 = *(GUID *)((char *)this + 40);
    result = TaskXmlWriter::ElementGUID((__int64)a2, 108, &v11);
    if ( result >= 0 )
    {
      v7 = (_QWORD *)*((_QWORD *)this + 9);
      if ( !(v7 ? *v7 : 0LL) )
        return TaskXmlWriter::EndElement((__int64)a2);
      v9 = v7 ? *v7 : 0LL;
      result = TaskXmlWriter::ElementCData((__int64)a2, 96, v9);
      if ( result >= 0 )
        return TaskXmlWriter::EndElement((__int64)a2);
    }
  }
  return result;
}
// 180007910: using guessed type GUID var_18;

//----- (00000001800079BC) ----------------------------------------------------
int __fastcall TaskXmlWriter::ElementGUID(__int64 a1, int a2, GUID *a3)
{
  int result; // eax
  GUID rguid; // [rsp+20h] [rbp-38h] BYREF

  rguid = *a3;
  result = StringFromGUID2(&rguid, (LPOLESTR)(a1 + 24), 64);
  if ( result >= 0 )
    return TaskXmlWriter::Element(a1, a2, a1 + 24);
  return result;
}

//----- (0000000180007A2C) ----------------------------------------------------
__int64 __fastcall TaskXmlWriter::ElementCData(__int64 a1, int a2, __int64 a3)
{
  __int64 result; // rax
  __int64 v6; // rax

  result = TaskXmlWriter::StartElement((int *)a1, a2);
  if ( (int)result >= 0 )
  {
    if ( (_DWORD)result )
      return TaskXmlWriter::EndElement(a1);
    if ( !a3 )
      return TaskXmlWriter::EndElement(a1);
    v6 = _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::operator->((__int64 *)(a1 + 16));
    result = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v6 + 64LL))(v6, a3);
    if ( (int)result >= 0 )
      return TaskXmlWriter::EndElement(a1);
  }
  return result;
}

//----- (0000000180007A8C) ----------------------------------------------------
Triggers::TimeTrigger *__fastcall Triggers::TimeTrigger::TimeTrigger(
        Triggers::TimeTrigger *this,
        const unsigned __int16 *a2,
        const struct Scheduling::JobSchedule *a3)
{
  *(_QWORD *)this = &Triggers::TimeTrigger::`vftable';
  Scheduling::JobSchedule::JobSchedule((struct _FILETIME *)this + 1);
  *((_QWORD *)this + 12) = 0LL;
  *(_OWORD *)((char *)this + 8) = *(_OWORD *)a3;
  *(_OWORD *)((char *)this + 24) = *((_OWORD *)a3 + 1);
  *(_OWORD *)((char *)this + 40) = *((_OWORD *)a3 + 2);
  *(_OWORD *)((char *)this + 56) = *((_OWORD *)a3 + 3);
  *(_OWORD *)((char *)this + 72) = *((_OWORD *)a3 + 4);
  *((_QWORD *)this + 11) = *((_QWORD *)a3 + 10);
  if ( a2 )
    _bstr_t::operator=((_bstr_t::Data_t **)this + 12, a2);
  return this;
}
// 180070A70: using guessed type void *Triggers::TimeTrigger::`vftable';

//----- (0000000180007B30) ----------------------------------------------------
ExeTask *__fastcall ExeTask::ExeTask(
        ExeTask *this,
        const struct _bstr_t *a2,
        const struct _bstr_t *a3,
        __int64 a4,
        struct _bstr_t *a5,
        struct _bstr_t *a6,
        struct _bstr_t *a7)
{
  char v8; // r9
  _QWORD *v9; // rcx
  __int64 v10; // rcx
  __int64 v11; // rcx
  __int64 v12; // rcx
  BSTR *v13; // rax
  UINT v14; // eax
  BSTR *v15; // rax
  UINT v16; // eax
  void **pExceptionObject; // [rsp+28h] [rbp-40h] BYREF
  char v19; // [rsp+30h] [rbp-38h]
  const unsigned __int16 *v20; // [rsp+38h] [rbp-30h]
  __int64 v21; // [rsp+40h] [rbp-28h]
  int v22; // [rsp+48h] [rbp-20h]
  int v23; // [rsp+4Ch] [rbp-1Ch]
  int v24; // [rsp+50h] [rbp-18h]
  int v25; // [rsp+54h] [rbp-14h]
  int v26; // [rsp+58h] [rbp-10h]

  Task::Task(this, a2, a3);
  *v9 = &ExeTask::`vftable';
  v10 = *(_QWORD *)a5;
  *((_QWORD *)this + 6) = *(_QWORD *)a5;
  if ( v10 )
    _InterlockedIncrement((volatile signed __int32 *)(v10 + 16));
  v11 = *(_QWORD *)a6;
  *((_QWORD *)this + 7) = *(_QWORD *)a6;
  if ( v11 )
    _InterlockedIncrement((volatile signed __int32 *)(v11 + 16));
  v12 = *(_QWORD *)a7;
  *((_QWORD *)this + 8) = *(_QWORD *)a7;
  if ( v12 )
    _InterlockedIncrement((volatile signed __int32 *)(v12 + 16));
  *((_BYTE *)this + 72) = v8;
  *((_QWORD *)this + 10) = 0LL;
  *((_DWORD *)this + 22) = 0;
  v13 = (BSTR *)*((_QWORD *)this + 6);
  if ( v13 && *v13 )
    v14 = SysStringLen(*v13);
  else
    v14 = 0;
  if ( !v14
    || ((v15 = (BSTR *)*((_QWORD *)this + 6)) == 0LL || !*v15 ? (v16 = 0) : (v16 = SysStringLen(*v15)), v16 > 0x104) )
  {
    v19 = 0;
    pExceptionObject = &wmi::GenericException::`vftable';
    v20 = &word_18007630E;
    v21 = 0LL;
    v22 = 0;
    v23 = 0;
    v24 = 87;
    v25 = -1;
    v26 = -1;
    CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
  }
  return this;
}
// 180007B53: variable 'v9' is possibly undefined
// 180007B9A: variable 'v8' is possibly undefined
// 180070078: using guessed type void *ExeTask::`vftable';
// 1800716D8: using guessed type void *wmi::GenericException::`vftable';

//----- (0000000180007C20) ----------------------------------------------------
ExeTask *__fastcall ExeTask::`scalar deleting destructor'(ExeTask *this, char a2)
{
  ExeTask::~ExeTask(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (0000000180007C58) ----------------------------------------------------
void __fastcall ExeTask::~ExeTask(ExeTask *this)
{
  void *v2; // rcx

  *(_QWORD *)this = &ExeTask::`vftable';
  v2 = (void *)*((_QWORD *)this + 10);
  if ( v2 )
    CloseHandle(v2);
  _bstr_t::_Free((ExeTask *)((char *)this + 64));
  _bstr_t::_Free((ExeTask *)((char *)this + 56));
  _bstr_t::_Free((ExeTask *)((char *)this + 48));
  Task::~Task(this);
}
// 180070078: using guessed type void *ExeTask::`vftable';

//----- (0000000180007CA8) ----------------------------------------------------
__int64 __fastcall _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::_AddRef(
        __int64 *a1)
{
  __int64 v1; // rcx
  __int64 result; // rax

  v1 = *a1;
  if ( v1 )
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v1 + 8LL))(v1);
  return result;
}

//----- (0000000180007CD0) ----------------------------------------------------
__int64 __fastcall UbpmParams::NewHostedObject<std::vector<_DAB_ETW_EVENT_TRIGGER_DATA_ITEM *>,_DAB_ETW_EVENT_TRIGGER_DATA_ITEM>(
        __int64 *a1,
        _OWORD *a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10)
{
  _OWORD *v12; // rax
  char v13; // dl
  __int64 *v14; // rcx
  __int64 v16; // rax
  __int64 v17; // rdi
  _OWORD *v18; // [rsp+50h] [rbp+8h] BYREF

  v12 = operator new(0x10uLL);
  if ( v12 )
    *v12 = *a2;
  v18 = v12;
  v13 = 1;
  v14 = (__int64 *)a1[1];
  if ( &v18 >= (_OWORD **)v14 || *a1 > (unsigned __int64)&v18 )
    v13 = 0;
  if ( v13 )
  {
    v16 = *a1;
    v17 = ((__int64)&a10 - *a1) >> 3;
    if ( v14 == (__int64 *)a1[2] )
    {
      std::vector<_DAB_TRIGGER_PARAMS *>::_Reserve(a1);
      v16 = *a1;
      v14 = (__int64 *)a1[1];
    }
    v12 = *(_OWORD **)(v16 + 8 * v17);
  }
  else if ( v14 == (__int64 *)a1[2] )
  {
    std::vector<_DAB_TRIGGER_PARAMS *>::_Reserve(a1);
    v14 = (__int64 *)a1[1];
    v12 = v18;
  }
  *v14 = (__int64)v12;
  a1[1] += 8LL;
  return (__int64)v18;
}

//----- (0000000180007D70) ----------------------------------------------------
__int64 __fastcall ComHandlerBase::StreamIn(
        ComHandlerBase *this,
        __int64 a2,
        unsigned __int8 **a3,
        unsigned __int8 *a4)
{
  __int64 result; // rax

  result = JobStore::StreamInBSTR((_bstr_t::Data_t **)this + 2, a3, a4);
  if ( (int)result >= 0 )
  {
    if ( *a3 + 16 > a4 )
    {
      return 2147549183LL;
    }
    else
    {
      *(_OWORD *)((char *)this + 40) = *(_OWORD *)*a3;
      *a3 += 16;
      return JobStore::StreamInBSTR((_bstr_t::Data_t **)this + 9, a3, a4);
    }
  }
  return result;
}

//----- (0000000180007DE0) ----------------------------------------------------
Triggers::IdleTrigger *__fastcall Triggers::IdleTrigger::`vector deleting destructor'(
        Triggers::IdleTrigger *this,
        char a2)
{
  _bstr_t::_Free((Triggers::IdleTrigger *)((char *)this + 80));
  *(_QWORD *)this = &Triggers::Trigger::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 180070988: using guessed type void *Triggers::Trigger::`vftable';

//----- (0000000180007E24) ----------------------------------------------------
void __fastcall wmi::AutoHandle::Close(void **this)
{
  char *v2; // rcx

  v2 = (char *)*this;
  if ( (unsigned __int64)(v2 - 1) <= 0xFFFFFFFFFFFFFFFDuLL )
  {
    CloseHandle(v2);
    *this = 0LL;
  }
}

//----- (0000000180007E58) ----------------------------------------------------
__int64 __fastcall JobStore::SaveJobFile(
        JobStore *this,
        wchar_t *a2,
        const unsigned __int16 *a3,
        unsigned int a4,
        ULONG SecurityDescriptorSize,
        LPCWSTR StringSecurityDescriptor)
{
  unsigned int v10; // ebx
  PSECURITY_DESCRIPTOR v11; // rax
  tsched *v12; // rcx
  unsigned int LastHrError; // ebx
  unsigned int v15; // [rsp+20h] [rbp-38h]
  PSECURITY_DESCRIPTOR SecurityDescriptor[3]; // [rsp+40h] [rbp-18h] BYREF

  v10 = 0;
  if ( JobStore::GetUseXmlStore(this) )
  {
    v11 = 0LL;
    SecurityDescriptorSize = 0;
    SecurityDescriptor[0] = 0LL;
    if ( StringSecurityDescriptor && *StringSecurityDescriptor )
    {
      if ( !ConvertStringSecurityDescriptorToSecurityDescriptorW(
              StringSecurityDescriptor,
              1u,
              SecurityDescriptor,
              &SecurityDescriptorSize) )
      {
        LastHrError = tsched::GetLastHrError(v12);
        if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
          && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
          && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
        {
          WPP_SF_SD(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x44u,
            (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
            a2);
        }
        goto LABEL_7;
      }
      v10 = SecurityDescriptorSize;
      v11 = SecurityDescriptor[0];
    }
    LastHrError = JobStore::SaveJobFile(this, a2, a3, a4, v15, v11, v10);
LABEL_7:
    tsched::AutoLocalPtr<unsigned short>::~AutoLocalPtr<unsigned short>(SecurityDescriptor);
    return LastHrError;
  }
  return 0LL;
}
// 180007EF1: variable 'v15' is possibly undefined
// 18003900E: variable 'v12' is possibly undefined
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180007F30) ----------------------------------------------------
void __fastcall Idolater::IdleEndCallback(void *a1)
{
  Idolater *v1; // rcx
  __int32 v2; // [rsp+78h] [rbp+18h] BYREF
  int v3; // [rsp+80h] [rbp+20h]

  v2 = 0;
  _InterlockedExchange(&v2, 0);
  _InterlockedIncrement(&ShutdownMgr::s_sync);
  v1 = (Idolater *)(unsigned int)_InterlockedExchange(&v2, _InterlockedCompareExchange(&dword_1800B0A14, 0, 0) != 0);
  if ( _InterlockedCompareExchange(&v2, 0, 0) )
  {
    v3 = 0;
    Idolater::IdleEnd(v1);
  }
  _InterlockedExchange(&v2, 0);
  if ( _InterlockedExchangeAdd(&ShutdownMgr::s_sync, 0xFFFFFFFF) == 1 )
    SetEvent((HANDLE)_InterlockedCompareExchange64((volatile signed __int64 *)&ShutdownMgr::s_hEvent, -1LL, -1LL));
}
// 180007F30: could not find valid save-restore pair for rbp
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 1800B0A10: using guessed type int ShutdownMgr::s_sync;
// 1800B0A14: using guessed type int dword_1800B0A14;

//----- (0000000180007FA0) ----------------------------------------------------
void __fastcall Idolater::IdleEnd(Idolater *this)
{
  char v1; // di
  Idolater *v2; // rcx
  PseudoEventTrap *v3; // rcx
  __int32 v4; // [rsp+48h] [rbp+10h] BYREF

  v4 = 0;
  _InterlockedExchange(&v4, 0);
  _InterlockedIncrement(&ShutdownMgr::s_sync);
  _InterlockedExchange(&v4, _InterlockedCompareExchange(&dword_1800B0A14, 0, 0) != 0);
  if ( _InterlockedCompareExchange(&v4, 0, 0) )
  {
    v1 = 0;
    EnterCriticalSection(&stru_1800B0CA0);
    if ( byte_1800B0C70 )
    {
      byte_1800B0C70 = 0;
      v1 = 1;
    }
    LeaveCriticalSection(&stru_1800B0CA0);
    if ( v1 )
    {
      Idolater::SendUbpmIdleEvent(v2, 0);
      if ( g_pPseudoEventTrap )
        PseudoEventTrap::IdleEnded(v3);
    }
  }
  _InterlockedExchange(&v4, 0);
  if ( _InterlockedExchangeAdd(&ShutdownMgr::s_sync, 0xFFFFFFFF) == 1 )
    SetEvent((HANDLE)_InterlockedCompareExchange64((volatile signed __int64 *)&ShutdownMgr::s_hEvent, -1LL, -1LL));
}
// 1800390EC: variable 'v2' is possibly undefined
// 1800390FE: variable 'v3' is possibly undefined
// 1800B0A10: using guessed type int ShutdownMgr::s_sync;
// 1800B0A14: using guessed type int dword_1800B0A14;
// 1800B0C70: using guessed type char byte_1800B0C70;

//----- (0000000180008050) ----------------------------------------------------
bool __fastcall JobStore::GetUseXmlStore(JobStore *this)
{
  JobStore::WaitForConfiguration(this);
  return *(_DWORD *)(*((_QWORD *)this + 10) + 184LL) != 0;
}

//----- (000000018000807C) ----------------------------------------------------
void __fastcall JobStore::WaitForConfiguration(JobStore *this)
{
  while ( !_InterlockedCompareExchange((volatile signed __int32 *)this + 23, 0, 0) )
    Sleep(0x64u);
}

//----- (00000001800080A4) ----------------------------------------------------
__int64 __fastcall TaskXmlReader::LoadValue(TaskXmlReader *this, struct _GUID *a2)
{
  XmlParserTempString *v2; // rdi
  __int64 result; // rax
  const OLECHAR *NullTerminated; // rax
  int v6; // ebx
  BSTR v7; // rax
  OLECHAR sz[40]; // [rsp+20h] [rbp-68h] BYREF

  v2 = (TaskXmlReader *)((char *)this + 64);
  result = TaskXmlReader::LoadRawValue(this, (TaskXmlReader *)((char *)this + 64));
  if ( (int)result >= 0 )
  {
    NullTerminated = XmlParserTempString::GetNullTerminated(v2);
    v6 = CLSIDFromString(NullTerminated, a2);
    if ( v6 >= 0 )
      return 0LL;
    if ( *XmlParserTempString::GetNullTerminated(v2) != 123 )
    {
      v7 = XmlParserTempString::GetNullTerminated(v2);
      v6 = StringCchPrintfW(sz, 0x28uLL, (size_t *)L"{%s}", v7);
      if ( v6 < 0 )
        return (unsigned int)v6;
      v6 = CLSIDFromString(sz, a2);
    }
    if ( v6 >= 0 )
      return 0LL;
    return (unsigned int)v6;
  }
  return result;
}

//----- (0000000180008130) ----------------------------------------------------
__int64 __fastcall ComHandlerBase::ExportToUbpmFormat(ComHandlerBase *this, struct IUbpmRegistrationParams *a2)
{
  __int64 *v2; // rax
  __int64 v4; // rsi
  char *v5; // rdi
  __int64 v6; // rbx
  __int64 v7; // rax

  v2 = (__int64 *)*((_QWORD *)this + 9);
  if ( v2 )
    v4 = *v2;
  else
    v4 = 0LL;
  v5 = (char *)this + 40;
  v6 = *(_QWORD *)a2;
  v7 = (*(__int64 (__fastcall **)(ComHandlerBase *))(*(_QWORD *)this + 8LL))(this);
  return (*(__int64 (__fastcall **)(struct IUbpmRegistrationParams *, __int64, char *, __int64, _QWORD))(v6 + 24))(
           a2,
           v7,
           v5,
           v4,
           0LL);
}

//----- (00000001800081A8) ----------------------------------------------------
char __fastcall IsOnList(wchar_t *String2, const unsigned __int16 **a2, int a3)
{
  __int64 v3; // rbx
  __int64 v4; // rsi
  wchar_t *v7; // rax
  __int64 v8; // rbp
  __int64 v9; // rsi

  v3 = -1LL;
  v4 = a3;
  do
    ++v3;
  while ( String2[v3] );
  if ( !(_DWORD)v3 )
    return 0;
  v7 = wcschr(String2, 0x22u);
  if ( v7 || (v7 = wcschr(String2, 0x2Cu)) != 0LL )
  {
    if ( v7 == String2 )
      return 0;
    LODWORD(v3) = v7 - String2;
  }
  v8 = v4;
  if ( (int)v4 <= 0 )
    return 0;
  v9 = 0LL;
  while ( _wcsnicmp(a2[v9], String2, (unsigned int)v3) )
  {
    if ( ++v9 >= v8 )
      return 0;
  }
  return 1;
}

//----- (0000000180008270) ----------------------------------------------------
__int64 __fastcall TaskXmlReader::LoadValue(TaskXmlReader *this, unsigned __int16 *a2)
{
  _DWORD *v2; // rbx
  __int64 result; // rax
  int v6; // r8d
  __int16 v7; // r9
  unsigned __int16 v8; // dx
  unsigned __int16 v9; // cx

  v2 = (_DWORD *)((char *)this + 64);
  result = TaskXmlReader::LoadRawValue(this, (TaskXmlReader *)((char *)this + 64));
  v6 = 0;
  if ( (int)result >= 0 )
  {
    *a2 = 0;
    if ( *v2 )
    {
      while ( 1 )
      {
        v7 = *(_WORD *)(*((_QWORD *)this + 9) + 2LL * v6);
        if ( (unsigned __int16)(v7 - 48) > 9u )
          break;
        v8 = *a2;
        v9 = v7 + 10 * *a2 - 48;
        *a2 = v9;
        if ( v9 < v8 )
          break;
        if ( (unsigned int)++v6 >= *v2 )
          return 0LL;
      }
      return 2147750680LL;
    }
    else
    {
      return 0LL;
    }
  }
  return result;
}

//----- (0000000180008300) ----------------------------------------------------
HKEY *__fastcall FolderEnumerator::`vector deleting destructor'(HKEY *this, char a2)
{
  _bstr_t::_Free((_bstr_t *)(this + 5));
  wmi::AutoRegKey::Close(this + 3);
  _bstr_t::_Free((_bstr_t *)(this + 2));
  *this = (HKEY)&wmi::RefBase::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 180070980: using guessed type void *wmi::RefBase::`vftable';

//----- (0000000180008360) ----------------------------------------------------
__int64 __fastcall ServerXMLUpdateHandler::NetworkInputHandler::Process(__int64 a1, __int64 a2, int a3, __int64 a4)
{
  int v4; // esi
  char v5; // r14
  int v8; // r8d
  int v9; // r8d
  __int64 result; // rax
  OLECHAR **v11; // rcx
  OLECHAR *v12; // rcx
  UINT v13; // eax
  OLECHAR sz[40]; // [rsp+20h] [rbp-78h] BYREF

  v4 = 0;
  v5 = 0;
  v8 = a3 - 90;
  if ( !v8 )
  {
    if ( !*(_BYTE *)(a1 + 40) )
    {
      *(_BYTE *)(a1 + 40) = 1;
      v5 = 1;
      goto LABEL_4;
    }
    *(_DWORD *)(*(_QWORD *)(a1 + 8) + 108LL) = 90;
    return 2147750678LL;
  }
  v9 = v8 - 1;
  if ( !v9 )
  {
    if ( *(_BYTE *)(a1 + 40) )
    {
      _bstr_t::operator=((_bstr_t::Data_t **)(a1 + 32), *(const OLECHAR **)(*(_QWORD *)(a4 + 48) + 8LL));
      v11 = *(OLECHAR ***)(a1 + 32);
      if ( v11 && (v12 = *v11) != 0LL )
        v13 = SysStringLen(v12);
      else
        v13 = 0;
      if ( v13 )
        *(_BYTE *)(a1 + 42) = 1;
      goto LABEL_4;
    }
    *(_DWORD *)(*(_QWORD *)(a1 + 8) + 108LL) = 91;
    return 2147750678LL;
  }
  if ( v9 == 1 )
  {
    if ( *(_BYTE *)(a1 + 40) )
    {
      v4 = IIDFromString(*(LPCOLESTR *)(*(_QWORD *)(a4 + 48) + 8LL), (LPIID)(a1 + 16));
      if ( v4 < 0 )
      {
        if ( **(_WORD **)(*(_QWORD *)(a4 + 48) + 8LL) != 123 )
        {
          v4 = StringCchPrintfW(sz, 0x28uLL, (size_t *)L"{%s}");
          if ( v4 < 0 )
            goto LABEL_4;
          v4 = IIDFromString(sz, (LPIID)(a1 + 16));
        }
        if ( v4 < 0 )
          goto LABEL_4;
      }
      *(_BYTE *)(a1 + 41) = 1;
      goto LABEL_4;
    }
    *(_DWORD *)(*(_QWORD *)(a1 + 8) + 108LL) = 92;
    return 2147750678LL;
  }
LABEL_4:
  if ( !*(_BYTE *)(a1 + 40) )
    return (unsigned int)v4;
  if ( v5 )
    return (unsigned int)v4;
  result = 1LL;
  if ( v4 < 0 )
    return (unsigned int)v4;
  return result;
}

//----- (00000001800083E8) ----------------------------------------------------
__int64 __fastcall TaskXmlReader::LoadPeriod(
        const unsigned __int16 **this,
        unsigned int *a2,
        unsigned int *a3,
        unsigned int *a4,
        unsigned int *a5,
        unsigned int *a6,
        unsigned int *a7,
        unsigned int *a8)
{
  __int64 result; // rax
  unsigned __int64 v13; // rdx
  const unsigned __int16 *v14; // rcx
  unsigned int v15; // ecx
  __int64 v16; // [rsp+20h] [rbp-10h] BYREF
  int v17; // [rsp+28h] [rbp-8h]
  unsigned __int16 v18; // [rsp+2Ch] [rbp-4h]

  result = TaskXmlReader::LoadRawValue((TaskXmlReader *)this, (struct XmlParserTempString *)(this + 8));
  if ( (int)result >= 0 )
  {
    v13 = *((unsigned int *)this + 16);
    v14 = this[9];
    v16 = 0LL;
    v17 = 0;
    v18 = 0;
    if ( (int)TSParser::ParseTimePeriod(v14, v13, (struct TSTimePeriod *)&v16) < 0 )
    {
      return 2147750680LL;
    }
    else
    {
      v15 = HIWORD(v16);
      *a2 = (unsigned __int16)v16;
      *a3 = WORD1(v16);
      *a4 = WORD2(v16);
      *a5 = v15;
      *a6 = (unsigned __int16)v17;
      *a7 = HIWORD(v17);
      *a8 = v18;
      return 0LL;
    }
  }
  return result;
}

//----- (00000001800084B0) ----------------------------------------------------
__int64 __fastcall UbpmParams::NewHostedObject<std::vector<_DAB_ETW_EVENT_TRIGGER_PARAMS *>,_DAB_ETW_EVENT_TRIGGER_PARAMS>(
        __int64 *a1,
        _OWORD *a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10)
{
  _OWORD *v12; // rax
  char v13; // dl
  __int64 *v14; // rcx
  __int64 v16; // rax
  __int64 v17; // rdi
  _OWORD *v18; // [rsp+50h] [rbp+8h] BYREF

  v12 = operator new(0x20uLL);
  if ( v12 )
  {
    *v12 = *a2;
    v12[1] = a2[1];
  }
  v18 = v12;
  v13 = 1;
  v14 = (__int64 *)a1[1];
  if ( &v18 >= (_OWORD **)v14 || *a1 > (unsigned __int64)&v18 )
    v13 = 0;
  if ( v13 )
  {
    v16 = *a1;
    v17 = ((__int64)&a10 - *a1) >> 3;
    if ( v14 == (__int64 *)a1[2] )
    {
      std::vector<_DAB_TRIGGER_PARAMS *>::_Reserve(a1);
      v16 = *a1;
      v14 = (__int64 *)a1[1];
    }
    v12 = *(_OWORD **)(v16 + 8 * v17);
  }
  else if ( v14 == (__int64 *)a1[2] )
  {
    std::vector<_DAB_TRIGGER_PARAMS *>::_Reserve(a1);
    v14 = (__int64 *)a1[1];
    v12 = v18;
  }
  *v14 = (__int64)v12;
  a1[1] += 8LL;
  return (__int64)v18;
}

//----- (0000000180008560) ----------------------------------------------------
void __fastcall ItSpIdleDetectionCallback(char *a1)
{
  char v2; // r15
  char v3; // r13
  _QWORD *v4; // r12
  void (__stdcall *v5)(struct _TP_CALLBACK_INSTANCE *, void *, struct _TP_TIMER *); // r8
  int v6; // ebx
  DWORD v7; // eax
  ULONG v8; // r8d
  void *v9; // rdx
  void (__stdcall *v10)(struct _TP_CALLBACK_INSTANCE *, void *, struct _TP_TIMER *); // r8
  unsigned int v11; // r9d
  EventManager *v12; // rcx
  _QWORD *v13; // rbx
  __int64 v14; // r9
  __int128 v15; // xmm1
  __int64 v16; // r8
  DWORD v17; // esi
  EventManager *v18; // rcx
  void (__stdcall *v19)(struct _TP_CALLBACK_INSTANCE *, void *, struct _TP_TIMER *); // r8
  DWORD v20; // esi
  DWORD v21; // esi
  DWORD v22; // esi
  void *v23; // rcx
  unsigned int v24; // r9d
  unsigned int v25; // r9d
  char *v26; // rsi
  char *v27; // rax
  char **v28; // rbx
  __int64 v29; // r9
  __int64 v30; // r8
  EventManager *v31; // rcx
  char *v32; // rcx
  char ***v33; // rax
  char **v34; // rax
  int v35; // [rsp+38h] [rbp-39h] BYREF
  struct _TP_TIMER *v36; // [rsp+40h] [rbp-31h] BYREF
  struct _FILETIME SystemTimeAsFileTime; // [rsp+48h] [rbp-29h] BYREF
  unsigned int v38[4]; // [rsp+50h] [rbp-21h]
  __int128 v39; // [rsp+60h] [rbp-11h]
  HANDLE Handles[5]; // [rsp+70h] [rbp-1h] BYREF

  v2 = 0;
  do
  {
    v35 = 0;
    *(_OWORD *)v38 = 0LL;
    v3 = 0;
    v39 = 0LL;
    if ( (unsigned int)_InterlockedIncrement((volatile signed __int32 *)a1 + 176) > 1 )
      break;
    if ( !v2 )
    {
      EnterCriticalSection((LPCRITICAL_SECTION)a1 + 1);
      v2 = 1;
    }
    if ( *(_DWORD *)a1 != 1147547701 )
    {
      v4 = a1 + 80;
      if ( (_QWORD *)*v4 != v4 || TSchedStartEvent || TSchedStopEvent )
      {
        if ( (a1[708] & 1) != 0 )
          goto LABEL_103;
        if ( a1[416] )
        {
          *((_QWORD *)a1 + 80) = 0LL;
          *((_QWORD *)a1 + 81) = 0LL;
          *((_WORD *)a1 + 334) = 0;
          *((_QWORD *)a1 + 82) = 0LL;
          *((_DWORD *)a1 + 166) = 0;
          *((_DWORD *)a1 + 168) = 8;
          goto LABEL_32;
        }
        GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
        if ( !ItSpAttendedResumeTimeoutIsOver((struct _ITSRV_GLOBAL_CONTEXT *)a1, &SystemTimeAsFileTime) )
        {
          *((_QWORD *)a1 + 80) = 0LL;
          *((_QWORD *)a1 + 81) = 0LL;
          *((_WORD *)a1 + 334) = 0;
          *((_QWORD *)a1 + 82) = 0LL;
          *((_DWORD *)a1 + 166) = 0;
          *((_DWORD *)a1 + 168) = 9;
LABEL_32:
          v35 = 2;
          goto LABEL_14;
        }
        if ( (a1[708] & 1) != 0
          || !(unsigned int)ItSpUpdateSystemSnapshots((struct _ITSRV_GLOBAL_CONTEXT *)a1)
          && !(unsigned int)ItSpIsSystemIdle(
                              (struct _ITSRV_GLOBAL_CONTEXT *)a1,
                              (struct _ITSRV_SYSTEM_SNAPSHOT *)(a1 + 464),
                              (struct _ITSRV_SYSTEM_SNAPSHOT *)(a1 + 552),
                              (enum _ITSRV_IDLE_DETECTION_RESULT *)&v35)
          && v35 == 1 )
        {
LABEL_103:
          if ( (a1[708] & 2) != 0 || *(_DWORD *)a1 == 1147547699 || (v6 = 0, !*((_DWORD *)a1 + 97)) )
          {
LABEL_46:
            v8 = *((_DWORD *)a1 + 94);
            v9 = (void *)*((_QWORD *)a1 + 28);
            v35 = 1;
            ChangeTimerQueueTimer(0LL, v9, v8, v8);
            ResetEvent(*((HANDLE *)a1 + 91));
            ResetEvent(*((HANDLE *)a1 + 92));
            ResetEvent(*((HANDLE *)a1 + 45));
            v11 = *((_DWORD *)a1 + 95);
            if ( v11 )
            {
              if ( ItSpSubmitThreadpoolTimer(&v36, (struct _ITSRV_GLOBAL_CONTEXT *)a1, v10, v11) )
                goto LABEL_14;
              _InterlockedExchange64((volatile __int64 *)a1 + 40, (__int64)v36);
            }
            PubSebLevelEvent(WNF_SEB_SYSTEM_IDLE, 1);
            ItSpLogPerfTrackData((__int64)a1, 1);
            if ( TSchedStartEvent )
              SetEvent(TSchedStartEvent);
            if ( (a1[708] & 0x20) != 0 || !_InterlockedCompareExchange((volatile signed __int32 *)a1 + 200, 0, 0) )
            {
              ItSpUpdateStatus((unsigned int *)a1, 0x44663034u);
              while ( *(_DWORD *)a1 != 1147547701 )
              {
                if ( !v3 )
                {
                  v13 = (_QWORD *)*v4;
                  if ( (_QWORD *)*v4 == v4 )
                  {
                    ItSpUpdateStatus((unsigned int *)a1, 0x44663033u);
                    break;
                  }
                  v14 = *((unsigned int *)v13 + 8);
                  v15 = *(_OWORD *)(v13 + 5);
                  v16 = *((unsigned int *)v13 + 7);
                  v3 = 1;
                  *(_OWORD *)v38 = *(_OWORD *)(v13 + 3);
                  *((_DWORD *)v13 + 5) = 2;
                  v39 = v15;
                  EventManager::EvtReport(v12, &ItSpEvt_ExecuteIdleTask_Start, v16, v14);
                  ResetEvent((HANDLE)v13[8]);
                  SetEvent((HANDLE)v13[7]);
                }
                Handles[0] = *((HANDLE *)a1 + 41);
                Handles[1] = *((HANDLE *)a1 + 12);
                Handles[2] = *((HANDLE *)a1 + 45);
                Handles[3] = *((HANDLE *)a1 + 91);
                Handles[4] = *((HANDLE *)a1 + 92);
                LeaveCriticalSection((LPCRITICAL_SECTION)a1 + 1);
                v17 = WaitForMultipleObjectsEx(5u, Handles, 0, 0xFFFFFFFF, 0);
                EnterCriticalSection((LPCRITICAL_SECTION)a1 + 1);
                v2 = 1;
                if ( !v17 )
                  break;
                v20 = v17 - 1;
                if ( !v20 )
                  break;
                v21 = v20 - 1;
                if ( v21 )
                {
                  v22 = v21 - 1;
                  if ( v22 )
                  {
                    if ( v22 != 1 )
                      goto LABEL_32;
                    if ( (a1[708] & 0x20) == 0
                      && ((unsigned int)ItSpUpdateSystemSnapshots((struct _ITSRV_GLOBAL_CONTEXT *)a1)
                       || (unsigned int)ItSpIsSystemIdle(
                                          (struct _ITSRV_GLOBAL_CONTEXT *)a1,
                                          (struct _ITSRV_SYSTEM_SNAPSHOT *)(a1 + 464),
                                          (struct _ITSRV_SYSTEM_SNAPSHOT *)(a1 + 552),
                                          (enum _ITSRV_IDLE_DETECTION_RESULT *)&v35)
                       || v35 != 1) )
                    {
                      break;
                    }
                    v23 = (void *)*((_QWORD *)a1 + 92);
                  }
                  else
                  {
                    if ( (a1[708] & 0x10) == 0
                      && ((unsigned int)ItSpUpdateSystemSnapshots((struct _ITSRV_GLOBAL_CONTEXT *)a1)
                       || (unsigned int)ItSpIsSystemIdle(
                                          (struct _ITSRV_GLOBAL_CONTEXT *)a1,
                                          (struct _ITSRV_SYSTEM_SNAPSHOT *)(a1 + 464),
                                          (struct _ITSRV_SYSTEM_SNAPSHOT *)(a1 + 552),
                                          (enum _ITSRV_IDLE_DETECTION_RESULT *)&v35)
                       || v35 != 1) )
                    {
                      break;
                    }
                    v24 = *((_DWORD *)a1 + 95);
                    if ( v24 )
                    {
                      if ( ItSpSubmitThreadpoolTimer(&v36, (struct _ITSRV_GLOBAL_CONTEXT *)a1, v19, v24) )
                        break;
                      _InterlockedExchange64((volatile __int64 *)a1 + 40, (__int64)v36);
                    }
                    v23 = (void *)*((_QWORD *)a1 + 91);
                  }
                }
                else
                {
                  v3 = 0;
                  EventManager::EvtReport(v18, &ItSpEvt_ExecuteIdleTask_Stop, v38[1], v38[2]);
                  if ( (a1[708] & 4) == 0
                    && ((unsigned int)ItSpUpdateSystemSnapshots((struct _ITSRV_GLOBAL_CONTEXT *)a1)
                     || (unsigned int)ItSpIsSystemIdle(
                                        (struct _ITSRV_GLOBAL_CONTEXT *)a1,
                                        (struct _ITSRV_SYSTEM_SNAPSHOT *)(a1 + 464),
                                        (struct _ITSRV_SYSTEM_SNAPSHOT *)(a1 + 552),
                                        (enum _ITSRV_IDLE_DETECTION_RESULT *)&v35)
                     || v35 != 1) )
                  {
                    break;
                  }
                  v23 = (void *)*((_QWORD *)a1 + 45);
                }
                ResetEvent(v23);
              }
            }
          }
          else
          {
            while ( 1 )
            {
              LeaveCriticalSection((LPCRITICAL_SECTION)a1 + 1);
              v7 = WaitForSingleObject(*((HANDLE *)a1 + 42), *((_DWORD *)a1 + 96));
              if ( v7 != 258 )
                break;
              EnterCriticalSection((LPCRITICAL_SECTION)a1 + 1);
              v2 = 1;
              if ( *(_DWORD *)a1 == 1147547701
                || (unsigned int)ItSpGetSystemSnapshot(
                                   (struct _ITSRV_GLOBAL_CONTEXT *)a1,
                                   (struct _ITSRV_SYSTEM_SNAPSHOT *)(a1 + 464))
                || (unsigned int)ItSpIsSystemIdle(
                                   (struct _ITSRV_GLOBAL_CONTEXT *)a1,
                                   (struct _ITSRV_SYSTEM_SNAPSHOT *)(a1 + 464),
                                   (struct _ITSRV_SYSTEM_SNAPSHOT *)(a1 + 552),
                                   (enum _ITSRV_IDLE_DETECTION_RESULT *)&v35)
                || v35 != 1 )
              {
                goto LABEL_14;
              }
              if ( (unsigned int)++v6 >= *((_DWORD *)a1 + 97) )
                goto LABEL_46;
            }
            if ( v7 )
              GetLastError();
            EnterCriticalSection((LPCRITICAL_SECTION)a1 + 1);
            v2 = 1;
          }
        }
      }
    }
LABEL_14:
    if ( v35 )
      goto LABEL_15;
    if ( !WaitForSingleObject(*((HANDLE *)a1 + 91), 0) )
    {
      v35 = 2;
LABEL_15:
      if ( v35 == 2 )
        goto LABEL_16;
    }
    if ( !WaitForSingleObject(*((HANDLE *)a1 + 91), 0) )
    {
      v25 = *((_DWORD *)a1 + 95);
      if ( v25 )
      {
        if ( !ItSpSubmitThreadpoolTimer(&v36, (struct _ITSRV_GLOBAL_CONTEXT *)a1, v5, v25) )
          _InterlockedExchange64((volatile __int64 *)a1 + 40, (__int64)v36);
      }
    }
LABEL_16:
    if ( v3 && WaitForSingleObject(*((HANDLE *)a1 + 45), 0) )
    {
      v26 = a1 + 80;
      v27 = (char *)*((_QWORD *)a1 + 10);
      while ( v27 != v26 )
      {
        v28 = (char **)v27;
        v27 = *(char **)v27;
        if ( *((_DWORD *)v28 + 5) == 2 )
        {
          if ( v28 )
          {
            ResetEvent(v28[7]);
            SetEvent(v28[8]);
            v29 = *((unsigned int *)v28 + 8);
            v30 = *((unsigned int *)v28 + 7);
            *((_DWORD *)v28 + 5) = 1;
            EventManager::EvtReport(v31, &ItSpEvt_ExecuteIdleTask_Stop, v30, v29);
            v32 = *v28;
            if ( *((char ***)*v28 + 1) != v28
              || (v33 = (char ***)v28[1], *v33 != v28)
              || (*v33 = (char **)v32, *((_QWORD *)v32 + 1) = v33, v34 = (char **)*((_QWORD *)a1 + 11), *v34 != v26) )
            {
              __fastfail(3u);
            }
            *v28 = v26;
            v28[1] = (char *)v34;
            *v34 = (char *)v28;
            *((_QWORD *)a1 + 11) = v28;
          }
          break;
        }
      }
    }
    if ( v35 == 2 )
    {
      PubSebLevelEvent(WNF_SEB_SYSTEM_IDLE, 0);
      if ( !TSchedStopEvent )
        goto LABEL_21;
      SetEvent(TSchedStopEvent);
    }
    if ( v35 != 1 )
LABEL_21:
      ItSpLogPerfTrackData((__int64)a1, v35);
    if ( *(_DWORD *)a1 == 1147547700 )
      ItSpUpdateStatus((unsigned int *)a1, 0x44663032u);
  }
  while ( (unsigned int)_InterlockedExchange((volatile __int32 *)a1 + 176, 0) > 1 );
  if ( v2 )
    LeaveCriticalSection((LPCRITICAL_SECTION)a1 + 1);
}
// 180008678: conditional instruction was optimized away because r15.1==1
// 180039465: variable 'v10' is possibly undefined
// 18003951E: variable 'v12' is possibly undefined
// 1800396BB: variable 'v19' is possibly undefined
// 1800396EE: variable 'v18' is possibly undefined
// 18003979A: variable 'v5' is possibly undefined
// 18003982F: variable 'v31' is possibly undefined
// 18007D428: using guessed type __int64 WNF_SEB_SYSTEM_IDLE;

//----- (00000001800087DC) ----------------------------------------------------
void __fastcall ItSpLogPerfTrackData(__int64 a1, int a2)
{
  signed __int32 v3; // eax
  int v4; // esi
  int v5; // edx
  bool v6; // zf
  DWORD dwLowDateTime; // eax
  DWORD dwHighDateTime; // ecx
  struct _FILETIME SystemTimeAsFileTime; // [rsp+30h] [rbp+8h] BYREF
  struct _FILETIME v10; // [rsp+40h] [rbp+18h]

  v3 = _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 768), 0, 0);
  if ( a2 == 1 )
  {
    if ( *(_QWORD *)(a1 + 680) )
      return;
    v5 = 3;
    if ( v3 )
    {
      if ( byte_1800B09E9 )
      {
        if ( !byte_1800B09E8 )
          v5 = 2;
      }
      else
      {
        v5 = 1;
      }
    }
    ItSpSendIdleEntryPerftrackNotification(a1, v5);
    GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
    v6 = (*(_BYTE *)(a1 + 468) & 4) == 0;
    dwLowDateTime = SystemTimeAsFileTime.dwLowDateTime;
    dwHighDateTime = SystemTimeAsFileTime.dwHighDateTime;
    *(_DWORD *)(a1 + 680) = SystemTimeAsFileTime.dwLowDateTime;
    *(_DWORD *)(a1 + 688) = dwLowDateTime;
    *(_DWORD *)(a1 + 684) = dwHighDateTime;
    *(_DWORD *)(a1 + 692) = dwHighDateTime;
    if ( !v6 )
    {
      *(_DWORD *)(a1 + 696) = ItSpBatteryLifePercent((struct _ITSRV_SYSTEM_SNAPSHOT *)(a1 + 464));
      return;
    }
LABEL_29:
    *(_DWORD *)(a1 + 696) = 0;
    return;
  }
  if ( !a2 )
  {
    if ( *(_QWORD *)(a1 + 680) )
    {
      GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
      v10 = SystemTimeAsFileTime;
      if ( *(_QWORD *)(a1 + 688) + 33000000000LL < *(_QWORD *)&SystemTimeAsFileTime
        && ItSpResumeTimeoutIsOver((struct _ITSRV_GLOBAL_CONTEXT *)a1, &SystemTimeAsFileTime) )
      {
        ItSpSendIdleEntryPerftrackNotification(a1, 4);
        *(struct _FILETIME *)(a1 + 688) = SystemTimeAsFileTime;
      }
    }
    return;
  }
  if ( a2 != 2 )
    return;
  if ( *(_QWORD *)(a1 + 680) )
  {
    ItSpSendIdleExitPerftrackNotification((struct _ITSRV_GLOBAL_CONTEXT *)a1);
    *(_QWORD *)(a1 + 680) = 0LL;
    *(_QWORD *)(a1 + 688) = 0LL;
    byte_1800B09E9 = 0;
    byte_1800B09E8 = 0;
    goto LABEL_29;
  }
  if ( !v3 )
  {
    byte_1800B09E9 = 0;
    byte_1800B09E8 = 0;
    return;
  }
  if ( byte_1800B09E9 )
  {
    if ( byte_1800B09E8 )
      return;
    v4 = 2;
  }
  else
  {
    v4 = 1;
  }
  ItSpSendIdleEntryPerftrackNotification(a1, v4);
  if ( v4 == 1 )
    byte_1800B09E9 = 1;
  else
    byte_1800B09E8 = 1;
}
// 180008884: conditional instruction was optimized away because esi.4==2
// 1800B09E8: using guessed type char byte_1800B09E8;
// 1800B09E9: using guessed type char byte_1800B09E9;

//----- (0000000180008898) ----------------------------------------------------
bool __fastcall ItSpAttendedResumeTimeoutIsOver(struct _ITSRV_GLOBAL_CONTEXT *a1, struct _FILETIME *a2)
{
  FILETIME FileTime1; // [rsp+30h] [rbp+8h] BYREF

  if ( !*((_DWORD *)a1 + 93) )
    return 0;
  FileTime1 = (FILETIME)_InterlockedCompareExchange64((volatile signed __int64 *)a1 + 107, 0LL, 0LL);
  return CompareFileTime(&FileTime1, a2) == -1;
}

//----- (00000001800088EC) ----------------------------------------------------
__int64 __fastcall PubSebLevelEvent(__int64 a1, char a2)
{
  int v3[1024]; // [rsp+30h] [rbp-1018h] BYREF

  v3[1] = 0;
  v3[0] = (a2 != 0 ? 2 : 0) | 1;
  return RtlPublishWnfStateData(a1, 0LL, v3, 8LL, 0LL);
}
// 180074618: using guessed type __int64 __fastcall RtlPublishWnfStateData(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000018000895C) ----------------------------------------------------
__int64 __fastcall ItSpSendIdleEntryPerftrackNotification(__int64 a1, int a2)
{
  int v2; // r11d
  __int64 result; // rax
  unsigned int v4; // r10d
  __int64 v5; // r9
  __int64 v6; // r8
  int v7; // edx
  EventManager *v8; // rcx

  v2 = 0;
  result = (unsigned int)_InterlockedCompareExchange((volatile signed __int32 *)(a1 + 800), 0, 0);
  if ( (_DWORD)result )
  {
    v4 = *(_DWORD *)(a1 + 656);
    v5 = *(unsigned __int8 *)(a1 + 652) | ((*(unsigned __int8 *)(a1 + 648) | (((*(_DWORD *)(a1 + 640) << 8) | (unsigned int)*(unsigned __int8 *)(a1 + 644)) << 8)) << 8);
    if ( a2 == 1 )
      v4 /= 0xAu;
    v6 = *(unsigned int *)(a1 + 672);
    LOBYTE(v2) = *(_BYTE *)(a1 + 669) != 0;
    v7 = v2 | (16 * (a2 & 0xF | (16 * ((unsigned __int8)v6 | (((v4 << 8) | *(unsigned __int8 *)(a1 + 660)) << 8)))));
    v8 = *(_BYTE *)(a1 + 668) != 0 ? (EventManager *)2 : 0LL;
    return EventManager::EvtReport(
             v8,
             (const struct _EVENT_DESCRIPTOR *)((unsigned int)v8 | v7),
             v6,
             v5,
             (unsigned __int8)v8 | (unsigned __int8)v7);
  }
  return result;
}

//----- (0000000180008990) ----------------------------------------------------
__int64 __fastcall ServerXMLUpdateHandler::PrincipalHandler::Process(__int64 a1, __int64 a2, int a3)
{
  __int64 v4; // rax

  if ( !*(_BYTE *)(a1 + 20) )
  {
    if ( a3 == 98 )
      *(_BYTE *)(a1 + 20) = 1;
    return 0LL;
  }
  if ( a3 == 36 )
  {
LABEL_11:
    v4 = *(_QWORD *)(a1 + 8);
    if ( !v4 || (*(_BYTE *)(v4 + 16) & 1) != 0 || !*(_QWORD *)v4 )
    {
      *(_BYTE *)(a1 + 23) = 1;
      if ( a3 == 111 )
        *(_BYTE *)(a1 + 26) = 1;
      return 0LL;
    }
    return 1LL;
  }
  if ( a3 == 99 )
  {
    *(_BYTE *)(a1 + 22) = 1;
    return 0LL;
  }
  if ( a3 != 100 )
  {
    if ( a3 == 101 )
    {
      *(_BYTE *)(a1 + 25) = 1;
      return 0LL;
    }
    if ( a3 != 111 )
      return 0LL;
    goto LABEL_11;
  }
  if ( !*(_DWORD *)(a1 + 16) )
  {
    *(_BYTE *)(a1 + 24) = 1;
    return 0LL;
  }
  return 1LL;
}

//----- (0000000180008A20) ----------------------------------------------------
__int64 __fastcall ExeTask::WriteXml(ExeTask *this, struct TaskXmlWriter *a2)
{
  __int64 *v2; // rax
  __int64 v5; // rcx
  __int64 result; // rax
  __int64 *v7; // rax
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 *v10; // rax
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 *v13; // rax
  __int64 v14; // rcx
  __int64 v15; // r9
  __int64 v16; // r8

  v2 = (__int64 *)*((_QWORD *)this + 2);
  if ( v2 )
    v5 = *v2;
  else
    v5 = 0LL;
  if ( v5 )
  {
    if ( v2 )
      v15 = *v2;
    else
      v15 = 0LL;
    result = TaskXmlWriter::StartElementWithAttribute((__int64)a2, 103, 109, v15);
  }
  else
  {
    result = TaskXmlWriter::StartElement((int *)a2, 103);
  }
  if ( (int)result >= 0 )
  {
    v7 = (__int64 *)*((_QWORD *)this + 6);
    v8 = v7 ? *v7 : 0LL;
    if ( !v8 || (!v7 ? (v9 = 0LL) : (v9 = *v7), result = TaskXmlWriter::Element((__int64)a2, 104, v9), (int)result >= 0) )
    {
      v10 = (__int64 *)*((_QWORD *)this + 7);
      v11 = v10 ? *v10 : 0LL;
      if ( !v11
        || (!v10 ? (v12 = 0LL) : (v12 = *v10), result = TaskXmlWriter::Element((__int64)a2, 105, v12), (int)result >= 0) )
      {
        v13 = (__int64 *)*((_QWORD *)this + 8);
        if ( v13 )
          v14 = *v13;
        else
          v14 = 0LL;
        if ( !v14
          || (!v13 ? (v16 = 0LL) : (v16 = *v13), result = TaskXmlWriter::Element((__int64)a2, 106, v16),
                                                 (int)result >= 0) )
        {
          if ( !*((_BYTE *)this + 72) )
            return TaskXmlWriter::EndElement((__int64)a2);
          result = TaskXmlWriter::Element((__int64)a2, 148, (__int64)L"true");
          if ( (int)result >= 0 )
            return TaskXmlWriter::EndElement((__int64)a2);
        }
      }
    }
  }
  return result;
}

//----- (0000000180008B00) ----------------------------------------------------
UINT __fastcall _bstr_t::length(BSTR **this)
{
  BSTR *v1; // rcx
  UINT result; // eax

  v1 = *this;
  result = 0;
  if ( v1 )
  {
    if ( *v1 )
      return SysStringLen(*v1);
  }
  return result;
}

//----- (0000000180008B1C) ----------------------------------------------------
void __fastcall std::list<std::vector<unsigned char> *,std::allocator<std::vector<unsigned char> *>>::clear(__int64 a1)
{
  _QWORD *v1; // rax
  _QWORD *v3; // rcx
  _QWORD *v4; // rbx

  v1 = *(_QWORD **)a1;
  v3 = **(_QWORD ***)a1;
  *v1 = v1;
  *(_QWORD *)(*(_QWORD *)a1 + 8LL) = *(_QWORD *)a1;
  *(_QWORD *)(a1 + 8) = 0LL;
  if ( v3 != *(_QWORD **)a1 )
  {
    do
    {
      v4 = (_QWORD *)*v3;
      operator delete(v3);
      v3 = v4;
    }
    while ( v4 != *(_QWORD **)a1 );
  }
}

//----- (0000000180008B5C) ----------------------------------------------------
__int64 __fastcall Triggers::SessionChangeTrigger::SessionChangeTrigger(
        __int64 a1,
        const OLECHAR *a2,
        User::UserEntry **a3,
        __int128 *a4,
        __int128 *a5,
        int a6,
        int a7,
        char a8,
        int a9,
        __int128 *a10)
{
  __int128 v12; // [rsp+50h] [rbp-38h] BYREF
  __int128 v13; // [rsp+60h] [rbp-28h] BYREF
  __int128 v14; // [rsp+70h] [rbp-18h] BYREF

  v12 = *a10;
  v14 = *a4;
  v13 = *a5;
  Triggers::SessionBasedTrigger::SessionBasedTrigger((_QWORD *)a1, a2, a3, &v14, &v13, a6, a7, a8, &v12);
  *(_QWORD *)a1 = &Triggers::SessionChangeTrigger::`vftable';
  *(_DWORD *)(a1 + 96) = a9;
  return a1;
}
// 1800700C0: using guessed type void *Triggers::SessionChangeTrigger::`vftable';
// 180008B5C: using guessed type __int128 var_18;

//----- (0000000180008BF8) ----------------------------------------------------
_QWORD *__fastcall Triggers::LogonTrigger::LogonTrigger(
        _QWORD *a1,
        const OLECHAR *a2,
        User::UserEntry **a3,
        __int128 *a4,
        __int128 *a5,
        int a6,
        int a7,
        char a8,
        __int128 *a9)
{
  __int128 v12; // [rsp+60h] [rbp-38h] BYREF
  __int128 v13; // [rsp+70h] [rbp-28h] BYREF
  __int128 v14; // [rsp+80h] [rbp-18h] BYREF

  v12 = *a9;
  v13 = *a5;
  v14 = *a4;
  Triggers::SessionBasedTrigger::SessionBasedTrigger(a1, a2, a3, &v14, &v13, a6, a7, a8, &v12);
  *a1 = &Triggers::LogonTrigger::`vftable';
  wmi::AutoRef<User::UserEntry>::Release(a3);
  return a1;
}
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);
// 180070138: using guessed type void *Triggers::LogonTrigger::`vftable';
// 180008BF8: using guessed type __int128 anonymous_0;

//----- (0000000180008CAC) ----------------------------------------------------
_QWORD *__fastcall Triggers::SessionBasedTrigger::SessionBasedTrigger(
        _QWORD *a1,
        const OLECHAR *a2,
        User::UserEntry **a3,
        __int128 *a4,
        __int128 *a5,
        int a6,
        int a7,
        char a8,
        __int128 *a9)
{
  User::UserEntry *v11; // rcx
  __int128 v13; // [rsp+40h] [rbp-38h] BYREF
  __int128 v14; // [rsp+50h] [rbp-28h] BYREF
  __int128 v15; // [rsp+60h] [rbp-18h] BYREF

  v13 = *a9;
  v15 = *a4;
  v14 = *a5;
  Triggers::GenericTrigger::GenericTrigger((__int64)a1, a2, &v15, &v14, a6, a7, a8, &v13);
  *a1 = &Triggers::SessionBasedTrigger::`vftable';
  v11 = *a3;
  a1[11] = *a3;
  if ( v11 )
    User::UserEntry::AddRef(v11);
  return a1;
}
// 1800701B0: using guessed type void *Triggers::SessionBasedTrigger::`vftable';
// 180008CAC: using guessed type __int128 var_18;

//----- (0000000180008D58) ----------------------------------------------------
Triggers::SessionBasedTrigger *__fastcall Triggers::SessionBasedTrigger::SessionBasedTrigger(
        Triggers::SessionBasedTrigger *this)
{
  Triggers::SessionBasedTrigger *result; // rax

  Triggers::GenericTrigger::GenericTrigger(this);
  *(_QWORD *)this = &Triggers::SessionBasedTrigger::`vftable';
  result = this;
  *((_QWORD *)this + 11) = 0LL;
  return result;
}
// 1800701B0: using guessed type void *Triggers::SessionBasedTrigger::`vftable';

//----- (0000000180008D90) ----------------------------------------------------
const unsigned __int16 *__fastcall ExeTask::GetName(ExeTask *this)
{
  BSTR *v1; // rax
  __int64 v2; // rbx
  UINT v4; // eax
  __int64 v5; // rax

  v1 = (BSTR *)*((_QWORD *)this + 2);
  v2 = 0LL;
  if ( v1 && *v1 )
    v4 = SysStringLen(*v1);
  else
    v4 = 0;
  if ( v4 )
    v5 = *((_QWORD *)this + 2);
  else
    v5 = *((_QWORD *)this + 6);
  if ( v5 )
    return *(const unsigned __int16 **)v5;
  return (const unsigned __int16 *)v2;
}

//----- (0000000180008DEC) ----------------------------------------------------
__int64 __fastcall TaskXmlWriter::ElementTSDuration(__int64 a1, int a2, unsigned __int16 *a3)
{
  unsigned __int16 *v4; // rdi
  char *v5; // r8
  __int64 v8; // rdx
  _WORD *v9; // rcx
  __int16 v10; // ax
  _WORD *v11; // rax
  __int64 result; // rax
  unsigned int v13; // r10d
  __int64 v14; // rcx
  unsigned __int16 *v15; // rax
  __int64 v16; // r8
  char *v17; // rdx
  __int64 v18; // rcx
  __int64 v19; // rax
  signed __int64 v20; // r9
  __int16 v21; // r8
  char *v22; // rax
  unsigned __int16 v23[12]; // [rsp+20h] [rbp-20h] BYREF

  v4 = (unsigned __int16 *)(a1 + 24);
  v5 = (char *)&aP[-12] - a1;
  v8 = 64LL;
  v9 = (_WORD *)(a1 + 24);
  do
  {
    if ( v8 == -2147483582 )
      break;
    v10 = *(_WORD *)((char *)v9 + (_QWORD)v5);
    if ( !v10 )
      break;
    *v9++ = v10;
    --v8;
  }
  while ( v8 );
  v11 = v9 - 1;
  if ( v8 )
    v11 = v9;
  *v11 = 0;
  if ( !*a3
    || (result = StringCchPrintfW(v23, 0xAuLL, (size_t *)L"%dY", *a3), (int)result >= 0)
    && (result = StringCchCatW(v4, 64LL, (char *)v23), (int)result >= 0) )
  {
    if ( !a3[1]
      || (result = StringCchPrintfW(v23, 0xAuLL, (size_t *)L"%dM", a3[1]), (int)result >= 0)
      && (result = StringCchCatW(v4, 64LL, (char *)v23), (int)result >= 0) )
    {
      if ( !a3[3] && !a3[2]
        || (result = StringCchPrintfW(v23, 0xAuLL, (size_t *)L"%dD", a3[3] + 7 * (unsigned int)a3[2]), (int)result >= 0)
        && (result = StringCchCatW(v4, 64LL, (char *)v23), (int)result >= 0) )
      {
        v13 = a3[4];
        if ( !*((_DWORD *)a3 + 2) && !a3[6] )
          return TaskXmlWriter::Element(a1, a2, (__int64)v4);
        v14 = 64LL;
        v15 = v4;
        do
        {
          if ( !*v15 )
            break;
          ++v15;
          --v14;
        }
        while ( v14 );
        result = v14 == 0 ? 0x80070057 : 0;
        v16 = v14 ? 64 - v14 : 0LL;
        if ( v14 )
        {
          v17 = (char *)&v4[v16];
          v18 = 64 - v16;
          if ( v16 != 64 )
          {
            v19 = 2147483646LL;
            v20 = (char *)L"T" - v17;
            do
            {
              if ( !v19 )
                break;
              v21 = *(_WORD *)&v17[v20];
              if ( !v21 )
                break;
              *(_WORD *)v17 = v21;
              --v19;
              v17 += 2;
              --v18;
            }
            while ( v18 );
          }
          v22 = v17 - 2;
          if ( v18 )
            v22 = v17;
          *(_WORD *)v22 = 0;
          result = v18 == 0 ? 0x8007007A : 0;
          if ( v18 )
          {
            if ( !(_WORD)v13
              || (result = StringCchPrintfW(v23, 0xAuLL, (size_t *)L"%dH", v13), (int)result >= 0)
              && (result = StringCchCatW(v4, 64LL, (char *)v23), (int)result >= 0) )
            {
              if ( !a3[5]
                || (result = StringCchPrintfW(v23, 0xAuLL, (size_t *)L"%dM", a3[5]), (int)result >= 0)
                && (result = StringCchCatW(v4, 64LL, (char *)v23), (int)result >= 0) )
              {
                if ( !a3[6] )
                  return TaskXmlWriter::Element(a1, a2, (__int64)v4);
                result = StringCchPrintfW(v23, 0xAuLL, (size_t *)L"%dS", a3[6]);
                if ( (int)result >= 0 )
                {
                  result = StringCchCatW(v4, 64LL, (char *)v23);
                  if ( (int)result >= 0 )
                    return TaskXmlWriter::Element(a1, a2, (__int64)v4);
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 1800767A4: using guessed type wchar_t aP[2];
// 1800767A8: using guessed type wchar_t aT[2];

//----- (0000000180009014) ----------------------------------------------------
bool __fastcall TSTime::operator==(__int64 a1, __int128 *a2)
{
  __int128 v4; // [rsp+20h] [rbp-18h] BYREF

  TSTime::EqualizeLocality((char *)a1, &v4, a2);
  return *(_QWORD *)(a1 + 8) == *((_QWORD *)&v4 + 1);
}

//----- (0000000180009050) ----------------------------------------------------
void __fastcall operator delete(void *lpMem)
{
  if ( lpMem )
    HeapFree(g_PrivateHeap, 0, lpMem);
}

//----- (0000000180009080) ----------------------------------------------------
__int64 __fastcall Triggers::ImmediateTrigger::ToUbpmFormat(
        Triggers::ImmediateTrigger *this,
        const struct Triggers::TriggerExportOptions *a2,
        struct IUbpmRegistrationParams *a3)
{
  return (*(__int64 (__fastcall **)(struct IUbpmRegistrationParams *, __int64, _QWORD, __int64, _DWORD))(*(_QWORD *)a3 + 80LL))(
           a3,
           4124LL,
           0LL,
           1LL,
           0);
}

//----- (00000001800090B4) ----------------------------------------------------
_QWORD *__fastcall wmi::AutoRef<TaskXmlReader>::operator=(_QWORD *a1, __int64 a2)
{
  if ( a2 )
    _InterlockedIncrement((volatile signed __int32 *)(a2 + 8));
  wmi::AutoRef<FolderEnumerator>::~AutoRef<FolderEnumerator>();
  *a1 = a2;
  return a1;
}
// 1800090EC: using guessed type __int64 wmi::AutoRef<FolderEnumerator>::~AutoRef<FolderEnumerator>(void);

//----- (0000000180009120) ----------------------------------------------------
Triggers::SessionChangeTrigger *__fastcall Triggers::SessionChangeTrigger::`vector deleting destructor'(
        Triggers::SessionChangeTrigger *this,
        char a2)
{
  wmi::AutoRef<User::UserEntry>::Release((char *)this + 88);
  _bstr_t::_Free((Triggers::SessionChangeTrigger *)((char *)this + 80));
  *(_QWORD *)this = &Triggers::Trigger::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);
// 180070988: using guessed type void *Triggers::Trigger::`vftable';

//----- (0000000180009170) ----------------------------------------------------
char __fastcall Triggers::Trigulator::HasTrigger(__int64 a1, int a2)
{
  _QWORD *v2; // rbx
  __int64 v5; // rcx

  v2 = *(_QWORD **)(a1 + 32);
  while ( 1 )
  {
    v2 = (_QWORD *)*v2;
    if ( v2 == *(_QWORD **)(a1 + 32) )
      break;
    v5 = v2[2];
    if ( v5 && a2 == (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v5 + 72LL))(v5) )
      return 1;
  }
  return 0;
}

//----- (00000001800091D0) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int64 __fastcall SchRpcHighestVersion(__int64 a1, _DWORD *a2)
{
  __int64 result; // rax

  result = 0LL;
  if ( !a2 )
    return 2147942487LL;
  *a2 = 65542;
  return result;
}
// 180035A5C: positive sp value 8 has been found

//----- (0000000180009208) ----------------------------------------------------
_QWORD *__fastcall std::_Tree<std::_Tmap_traits<_bstr_t,void *,ValidationXmlHandler::stringless,std::allocator<std::pair<_bstr_t const,void *>>,0>>::_Rrotate(
        __int64 a1,
        _QWORD *a2)
{
  __int64 v2; // r8
  __int64 v3; // rax
  _QWORD *result; // rax

  v2 = *a2;
  *a2 = *(_QWORD *)(*a2 + 16LL);
  v3 = *(_QWORD *)(v2 + 16);
  if ( !*(_BYTE *)(v3 + 25) )
    *(_QWORD *)(v3 + 8) = a2;
  *(_QWORD *)(v2 + 8) = a2[1];
  result = *(_QWORD **)a1;
  if ( a2 == *(_QWORD **)(*(_QWORD *)a1 + 8LL) )
  {
    result[1] = v2;
  }
  else
  {
    result = (_QWORD *)a2[1];
    if ( a2 == (_QWORD *)result[2] )
      result[2] = v2;
    else
      *result = v2;
  }
  *(_QWORD *)(v2 + 16) = a2;
  a2[1] = v2;
  return result;
}

//----- (000000018000925C) ----------------------------------------------------
void __fastcall ATL::CSid::Clear(ATL::CSid *this)
{
  *((_DWORD *)this + 20) = 7;
  ATL::CSimpleStringT<unsigned short,0>::Empty((__int64 *)this + 11);
  ATL::CSimpleStringT<unsigned short,0>::Empty((__int64 *)this + 12);
  ATL::CSimpleStringT<unsigned short,0>::Empty((__int64 *)this + 13);
  ATL::CSimpleStringT<unsigned short,0>::Empty((__int64 *)this + 14);
  *((_BYTE *)this + 76) = 0;
}

//----- (00000001800092A4) ----------------------------------------------------
void __fastcall ATL::CSimpleStringT<unsigned short,0>::Empty(__int64 *a1)
{
  ATL::CStringData *v2; // rcx
  __int64 v3; // rdi

  v2 = (ATL::CStringData *)(*a1 - 24);
  v3 = *(_QWORD *)v2;
  if ( *((_DWORD *)v2 + 2) )
  {
    if ( *((int *)v2 + 4) >= 0 )
    {
      ATL::CStringData::Release(v2);
      *a1 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 24LL))(v3) + 24;
    }
    else
    {
      ATL::CSimpleStringT<unsigned short,0>::SetLength(a1, 0);
    }
  }
}

//----- (00000001800092D8) ----------------------------------------------------
_QWORD *__fastcall std::_Tree<std::_Tmap_traits<_bstr_t,void *,ValidationXmlHandler::stringless,std::allocator<std::pair<_bstr_t const,void *>>,0>>::_Lrotate(
        __int64 a1,
        __int64 a2)
{
  _QWORD *v2; // r8
  _QWORD *result; // rax

  v2 = *(_QWORD **)(a2 + 16);
  *(_QWORD *)(a2 + 16) = *v2;
  if ( !*(_BYTE *)(*v2 + 25LL) )
    *(_QWORD *)(*v2 + 8LL) = a2;
  v2[1] = *(_QWORD *)(a2 + 8);
  result = *(_QWORD **)a1;
  if ( a2 == *(_QWORD *)(*(_QWORD *)a1 + 8LL) )
  {
    result[1] = v2;
  }
  else
  {
    result = *(_QWORD **)(a2 + 8);
    if ( a2 == *result )
      *result = v2;
    else
      result[2] = v2;
  }
  *v2 = a2;
  *(_QWORD *)(a2 + 8) = v2;
  return result;
}

//----- (000000018000932C) ----------------------------------------------------
__int64 __fastcall UbpmParams::NewHostedObject<std::vector<_DAB_SCHEDULE_BY_DAY *>,_DAB_SCHEDULE_BY_DAY>(
        __int64 *a1,
        _WORD *a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10)
{
  _WORD *v12; // rax
  char v13; // dl
  __int64 *v14; // rcx
  __int64 v16; // rax
  __int64 v17; // rdi
  _WORD *v18; // [rsp+50h] [rbp+8h] BYREF

  v12 = operator new(2uLL);
  if ( v12 )
    *v12 = *a2;
  v18 = v12;
  v13 = 1;
  v14 = (__int64 *)a1[1];
  if ( &v18 >= (_WORD **)v14 || *a1 > (unsigned __int64)&a10 )
    v13 = 0;
  if ( v13 )
  {
    v16 = *a1;
    v17 = ((__int64)&a10 - *a1) >> 3;
    if ( v14 == (__int64 *)a1[2] )
    {
      std::vector<_UBPM_ACTION_EXE_LAUNCH_PARAMS *>::_Reserve(a1);
      v16 = *a1;
      v14 = (__int64 *)a1[1];
    }
    v12 = *(_WORD **)(v16 + 8 * v17);
  }
  else if ( v14 == (__int64 *)a1[2] )
  {
    std::vector<_UBPM_ACTION_EXE_LAUNCH_PARAMS *>::_Reserve(a1);
    v14 = (__int64 *)a1[1];
    v12 = v18;
  }
  *v14 = (__int64)v12;
  a1[1] += 8LL;
  return (__int64)v18;
}

//----- (00000001800093C4) ----------------------------------------------------
__int64 __fastcall std::vector<_UBPM_ACTION_EXE_LAUNCH_PARAMS *>::_Reserve(_QWORD *a1)
{
  __int64 v2; // rdx
  __int64 result; // rax
  __int64 v4; // rdx
  unsigned __int64 v5; // rdx
  unsigned __int64 v6; // r9
  unsigned __int64 v7; // rcx

  v2 = a1[1];
  result = (a1[2] - v2) >> 3;
  if ( !result )
  {
    v4 = (v2 - *a1) >> 3;
    if ( v4 == 0x1FFFFFFFFFFFFFFFLL )
      std::_Xlength_error("vector<T> too long");
    v5 = v4 + 1;
    v6 = (__int64)(a1[2] - *a1) >> 3;
    v7 = 0LL;
    if ( 0x1FFFFFFFFFFFFFFFLL - (v6 >> 1) >= v6 )
      v7 = v6 + (v6 >> 1);
    if ( v7 >= v5 )
      v5 = v7;
    return (__int64)std::vector<_CSebiSystemEventCreationParameter *>::_Reallocate((__int64)a1, v5);
  }
  return result;
}

//----- (0000000180009440) ----------------------------------------------------
char *__fastcall std::vector<_CSebiSystemEventCreationParameter *>::_Reallocate(__int64 a1, unsigned __int64 a2)
{
  char *v4; // rbx
  __int64 v5; // r14
  char *result; // rax

  v4 = 0LL;
  if ( a2 )
  {
    if ( a2 > 0x1FFFFFFFFFFFFFFFLL || (v4 = (char *)operator new(8 * a2)) == 0LL )
      std::_Xbad_alloc();
  }
  memmove_0(v4, *(const void **)a1, (*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) & 0xFFFFFFFFFFFFFFF8uLL);
  v5 = (__int64)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3;
  if ( *(_QWORD *)a1 )
    operator delete(*(void **)a1);
  *(_QWORD *)(a1 + 16) = &v4[8 * a2];
  result = &v4[8 * v5];
  *(_QWORD *)(a1 + 8) = result;
  *(_QWORD *)a1 = v4;
  return result;
}

//----- (0000000180009500) ----------------------------------------------------
__int64 __fastcall Auditor::AuditJobOperation(__int64 *a1, int a2, __int64 a3, char *a4)
{
  int v6; // edx
  int v7; // edx
  int v8; // edx
  __int64 v9; // r12
  Auditor *v11; // rcx
  int TokenUserAndStatistics; // eax
  unsigned int v13; // ebx
  DWORD LengthSid; // ebx
  void *v15; // rdi
  __int64 v16; // rax
  unsigned __int64 v17; // rsi
  Auditor *v18; // rcx
  char *v19; // rbx
  unsigned __int64 v20; // r9
  unsigned __int64 v21; // rax
  int v22; // r15d
  unsigned __int64 v23; // rdx
  __int16 v24; // ax
  Auditor *v25; // rax
  int CallerProcessInfo; // eax
  Auditor *v27; // rcx
  unsigned int v28; // esi
  unsigned __int16 *ComputerNameDnsFullyQualified; // rax
  unsigned __int16 *v30; // r15
  const wchar_t *v31; // rcx
  signed int v32; // eax
  _QWORD *v33; // rcx
  unsigned __int16 v34; // dx
  signed int v35; // eax
  signed int LastError; // eax
  int v37; // [rsp+B8h] [rbp-338h]
  unsigned int v38; // [rsp+14Ch] [rbp-2A4h] BYREF
  unsigned int v39; // [rsp+150h] [rbp-2A0h] BYREF
  unsigned int v40; // [rsp+154h] [rbp-29Ch] BYREF
  AUTHZ_AUDIT_EVENT_HANDLE hAuditEvent; // [rsp+158h] [rbp-298h] BYREF
  void *v42; // [rsp+160h] [rbp-290h] BYREF
  unsigned __int64 v43; // [rsp+168h] [rbp-288h] BYREF
  HLOCAL hMem; // [rsp+170h] [rbp-280h] BYREF
  __int64 v45; // [rsp+178h] [rbp-278h]
  __int128 v46; // [rsp+180h] [rbp-270h] BYREF
  int *v47; // [rsp+190h] [rbp-260h]
  __int64 v48; // [rsp+198h] [rbp-258h]
  int v49; // [rsp+1A8h] [rbp-248h] BYREF
  char v50[12]; // [rsp+1ACh] [rbp-244h] BYREF
  void *v51; // [rsp+1B8h] [rbp-238h]
  PSID pSid[14]; // [rsp+308h] [rbp-E8h] BYREF
  struct _TOKEN_STATISTICS v53; // [rsp+378h] [rbp-78h] BYREF

  v48 = -2LL;
  v45 = a3;
  if ( a2 )
  {
    v6 = a2 - 1;
    if ( v6 )
    {
      v7 = v6 - 1;
      if ( v7 )
      {
        v8 = v7 - 1;
        if ( v8 )
        {
          if ( v8 != 1 )
            return 2147549183LL;
          v9 = a1[2];
        }
        else
        {
          v9 = a1[3];
        }
      }
      else
      {
        v9 = a1[4];
      }
    }
    else
    {
      v9 = a1[1];
    }
  }
  else
  {
    v9 = *a1;
  }
  if ( !v9 )
    return 2147549183LL;
  hAuditEvent = 0LL;
  v46 = 0LL;
  v47 = 0LL;
  v49 = 1;
  memset_0(v50, 0, 0x15CuLL);
  hMem = 0LL;
  TokenUserAndStatistics = Auditor::GetTokenUserAndStatistics(v11, (struct _TOKEN_USER *)pSid, &v53);
  v13 = TokenUserAndStatistics;
  if ( TokenUserAndStatistics < 0 )
  {
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x8000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0xAu,
        (__int64)&WPP_0026520f6666348a6128473d4ed545c7_Traceguids,
        TokenUserAndStatistics);
    }
    return v13;
  }
  if ( !pSid[0] )
  {
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x8000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xBu, (__int64)&WPP_0026520f6666348a6128473d4ed545c7_Traceguids);
    }
    return 2147500037LL;
  }
  if ( !IsValidSid(pSid[0]) )
  {
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x8000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xCu, (__int64)&WPP_0026520f6666348a6128473d4ed545c7_Traceguids);
    }
    return 2147500037LL;
  }
  LengthSid = GetLengthSid(pSid[0]);
  v15 = operator new[](LengthSid);
  v42 = v15;
  memset_0(v15, 0, LengthSid);
  memcpy_0(v15, pSid[0], LengthSid);
  v47 = &v49;
  v16 = -1LL;
  do
    ++v16;
  while ( *(_WORD *)(a3 + 2 * v16) );
  v17 = 3500 - v16;
  if ( v16 == 3500 )
  {
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x8000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), v17 + 13, (__int64)&WPP_0026520f6666348a6128473d4ed545c7_Traceguids);
    }
    std::_Tree_comp<0,std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::~_Tree_comp<0,std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>(&v42);
    return 2147549183LL;
  }
  v19 = (char *)operator new[](saturated_mul(v17, 2uLL));
  if ( a4 )
  {
    v20 = v17 - 1;
    v21 = -1LL;
    do
      ++v21;
    while ( *(_WORD *)&a4[2 * v21] );
    if ( v20 >= v21 )
    {
      v20 = -1LL;
      do
        ++v20;
      while ( *(_WORD *)&a4[2 * v20] );
    }
    v22 = StringCchCopyNW(v19, v17, a4, v20);
  }
  else
  {
    v22 = v17 > 0x7FFFFFFF ? 0x80070057 : 0;
    if ( v17 > 0x7FFFFFFF )
    {
      *(_WORD *)v19 = 0;
    }
    else
    {
      v18 = (Auditor *)v19;
      v23 = 2147483646 - v17;
      do
      {
        if ( !(v23 + v17) )
          break;
        v24 = *(_WORD *)((char *)v18 + (char *)&ChannelPath - v19);
        if ( !v24 )
          break;
        *(_WORD *)v18 = v24;
        v18 = (Auditor *)((char *)v18 + 2);
        --v17;
      }
      while ( v17 );
      v25 = (Auditor *)((char *)v18 - 2);
      if ( v17 )
        v25 = v18;
      *(_WORD *)v25 = 0;
      v22 = v17 == 0 ? 0x8007007A : 0;
    }
  }
  if ( v22 < 0 )
  {
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x8000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0xEu,
        (__int64)&WPP_0026520f6666348a6128473d4ed545c7_Traceguids,
        v22);
    }
    operator delete(v19);
    std::_Tree_comp<0,std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::~_Tree_comp<0,std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>(&v42);
    return (unsigned int)v22;
  }
  v40 = 0;
  v43 = 0LL;
  v39 = 0;
  v38 = 0;
  CallerProcessInfo = Auditor::GetCallerProcessInfo(v18, &v40, &v43, &v39, &v38);
  v28 = CallerProcessInfo;
  if ( CallerProcessInfo < 0 )
  {
    v27 = (Auditor *)WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x8000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0xFu,
        (__int64)&WPP_0026520f6666348a6128473d4ed545c7_Traceguids,
        CallerProcessInfo);
    }
  }
  ComputerNameDnsFullyQualified = Auditor::GetComputerNameDnsFullyQualified(v27);
  v30 = ComputerNameDnsFullyQualified;
  v31 = L"Unknown";
  if ( ComputerNameDnsFullyQualified )
    v31 = ComputerNameDnsFullyQualified;
  LOWORD(v37) = 8;
  if ( (unsigned int)AuthziInitializeAuditParams(
                       1LL,
                       &v46,
                       &hMem,
                       L"Security",
                       v37,
                       13,
                       *(_QWORD *)&v53.AuthenticationId,
                       2,
                       v45,
                       2,
                       v19,
                       11,
                       v43,
                       3,
                       v40,
                       3,
                       v39,
                       3,
                       v38,
                       2,
                       v31) )
  {
    v51 = v15;
    if ( (unsigned int)AuthziInitializeAuditEvent(
                         0LL,
                         0LL,
                         v9,
                         &v46,
                         0LL,
                         -1,
                         &ChannelPath,
                         &ChannelPath,
                         &ChannelPath,
                         &ChannelPath,
                         &hAuditEvent) )
    {
      if ( (unsigned int)AuthziLogAuditEvent(0LL, hAuditEvent, 0LL) )
        goto LABEL_90;
      LastError = GetLastError();
      v28 = LastError;
      if ( LastError > 0 )
        v28 = (unsigned __int16)LastError | 0x80070000;
      v33 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
        || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x8000) == 0
        || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
      {
        goto LABEL_90;
      }
      v34 = 18;
    }
    else
    {
      v35 = GetLastError();
      v28 = v35;
      if ( v35 > 0 )
        v28 = (unsigned __int16)v35 | 0x80070000;
      v33 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
        || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x8000) == 0
        || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
      {
        goto LABEL_90;
      }
      v34 = 17;
    }
  }
  else
  {
    v32 = GetLastError();
    v28 = v32;
    if ( v32 > 0 )
      v28 = (unsigned __int16)v32 | 0x80070000;
    v33 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
      || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x8000) == 0
      || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
    {
      goto LABEL_90;
    }
    v34 = 16;
  }
  WPP_SF_D(v33[2], v34, (__int64)&WPP_0026520f6666348a6128473d4ed545c7_Traceguids, v28);
LABEL_90:
  if ( hAuditEvent )
    AuthzFreeAuditEvent(hAuditEvent);
  if ( hMem )
    LocalFree(hMem);
  if ( v30 )
    free(v30);
  operator delete(v19);
  std::_Tree_comp<0,std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::~_Tree_comp<0,std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>(&v42);
  return v28;
}
// 180009500: could not find valid save-restore pair for rbp
// 1800095E1: variable 'v11' is possibly undefined
// 18000990C: variable 'v18' is possibly undefined
// 180009961: variable 'v27' is possibly undefined
// 180009A38: variable 'v37' is possibly undefined
// 180077CD8: using guessed type wchar_t aUnknown[8];
// 180077CE8: using guessed type wchar_t aSecurity[9];
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 1800B9008: using guessed type __int64 __fastcall AuthziInitializeAuditEvent(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 1800B9010: using guessed type __int64 __fastcall AuthziInitializeAuditParams(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD, _QWORD, _DWORD, _QWORD, _DWORD, _QWORD, _DWORD, _QWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _QWORD);
// 1800B9018: using guessed type __int64 __fastcall AuthziLogAuditEvent(_QWORD, _QWORD, _QWORD);
// 180009500: using guessed type char var_244[12];
// 180009500: using guessed type PSID pSid[14];

//----- (0000000180009C3C) ----------------------------------------------------
__int64 __fastcall Auditor::GetTokenUserAndStatistics(
        Auditor *this,
        struct _TOKEN_USER *a2,
        struct _TOKEN_STATISTICS *a3)
{
  HANDLE CurrentThread; // rax
  signed int LastError; // eax
  unsigned int v8; // ebx
  unsigned __int16 v9; // dx
  signed int v10; // eax
  _QWORD *v11; // rcx
  signed int v12; // eax
  void *TokenHandle; // [rsp+30h] [rbp-10h] BYREF
  Auditor *v14; // [rsp+50h] [rbp+10h] BYREF
  DWORD ReturnLength; // [rsp+68h] [rbp+28h] BYREF

  v14 = this;
  TokenHandle = 0LL;
  RpcAutoImpersonate::RpcAutoImpersonate((RpcAutoImpersonate *)&v14, L"Auditor::GetTokenUserAndStatistics", 1);
  CurrentThread = GetCurrentThread();
  if ( !OpenThreadToken(CurrentThread, 8u, 1, &TokenHandle) )
  {
    LastError = GetLastError();
    v8 = LastError;
    if ( LastError > 0 )
      v8 = (unsigned __int16)LastError | 0x80070000;
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x8000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x14u,
        (__int64)&WPP_0026520f6666348a6128473d4ed545c7_Traceguids,
        v8);
    }
    if ( (_DWORD)v14 )
      RpcRevertToSelf();
    return v8;
  }
  if ( (_DWORD)v14 )
    RpcRevertToSelf();
  if ( !GetTokenInformation(TokenHandle, TokenUser, a2, 0x64u, &ReturnLength) )
  {
    CloseHandle(TokenHandle);
    v10 = GetLastError();
    v8 = v10;
    if ( v10 > 0 )
      v8 = (unsigned __int16)v10 | 0x80070000;
    v11 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
      || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x8000) == 0
      || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
    {
      return v8;
    }
    v9 = 21;
    goto LABEL_15;
  }
  if ( GetTokenInformation(TokenHandle, TokenStatistics, a3, 0x38u, &ReturnLength) )
  {
    CloseHandle(TokenHandle);
    return 0LL;
  }
  v12 = GetLastError();
  v8 = v12;
  if ( v12 > 0 )
    v8 = (unsigned __int16)v12 | 0x80070000;
  CloseHandle(TokenHandle);
  v11 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x8000) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
  {
    v9 = 22;
LABEL_15:
    WPP_SF_D(v11[2], v9, (__int64)&WPP_0026520f6666348a6128473d4ed545c7_Traceguids, v8);
  }
  return v8;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180009D3C) ----------------------------------------------------
void __fastcall TaskXmlWriter::~TaskXmlWriter(TaskXmlWriter *this)
{
  __int64 v2; // rcx

  v2 = *((_QWORD *)this + 2);
  if ( v2 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v2 + 16LL))(v2);
  _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::~_com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>((__int64 *)this + 1);
}

//----- (0000000180009D80) ----------------------------------------------------
__int64 __fastcall ServerXMLUpdateHandler::PrincipalHandler::EndElement(__int64 a1, const struct Schema *a2, int a3)
{
  const unsigned __int16 *v4; // r8
  bool v6; // r8
  bool v7; // r9
  const unsigned __int16 *v8; // rcx

  v4 = (const unsigned __int16 *)(unsigned int)(a3 - 1);
  if ( (_DWORD)v4 )
  {
    if ( (_DWORD)v4 == 97 )
    {
      if ( *(_DWORD *)a2 != 0x10000 )
      {
        v6 = *(_BYTE *)(a1 + 25) == 0;
        v7 = *(_BYTE *)(a1 + 24) == 0;
        if ( *(_BYTE *)(a1 + 23) )
          v8 = 0LL;
        else
          v8 = **(const unsigned __int16 ***)(a1 + 8);
        ServerXMLUpdateHandler::WritePrincipal(
          *(ServerXMLUpdateHandler **)(a1 + 32),
          a2,
          0,
          0LL,
          v8,
          *(_DWORD *)(a1 + 16),
          v7,
          v6);
      }
      *(_WORD *)(a1 + 20) = 256;
    }
  }
  else
  {
    if ( !*(_BYTE *)(a1 + 21) )
    {
      if ( *(_DWORD *)a2 == 0x10000 )
        ServerXMLUpdateHandler::WritePrincipals(*(ServerXMLUpdateHandler **)(a1 + 32), a2, v4, L"@AtServiceAccount", 1);
      else
        ServerXMLUpdateHandler::WritePrincipals(
          *(ServerXMLUpdateHandler **)(a1 + 32),
          a2,
          v4,
          **(const unsigned __int16 ***)(a1 + 8),
          *(_DWORD *)(a1 + 16));
    }
    *(_BYTE *)(a1 + 21) = 1;
  }
  return 0LL;
}
// 180082510: using guessed type wchar_t aAtserviceaccou_0[18];

//----- (0000000180009E0C) ----------------------------------------------------
void __fastcall ServerXMLUpdateHandler::WritePrincipal(
        ServerXMLUpdateHandler *this,
        const struct Schema *a2,
        char a3,
        const unsigned __int16 *a4,
        const unsigned __int16 *a5,
        int a6,
        bool a7,
        bool a8)
{
  int v12; // edi
  int v13; // eax
  __int64 v14; // rdx
  __int64 v15; // rsi
  int v16; // esi
  int v17; // eax
  int v18; // eax
  int v19; // eax
  int started; // eax
  int v21; // eax
  int v22; // ecx
  int v23; // edi
  int v24; // eax
  int v25; // eax
  int v26; // eax
  int v27; // eax
  char v28[32]; // [rsp+38h] [rbp-D0h] BYREF
  int v29; // [rsp+58h] [rbp-B0h]
  int *v30; // [rsp+68h] [rbp-A0h]
  void *lpMem; // [rsp+70h] [rbp-98h]
  __int64 v32; // [rsp+88h] [rbp-80h]
  int v33; // [rsp+98h] [rbp-70h] BYREF
  const unsigned __int16 *v34; // [rsp+A0h] [rbp-68h]
  __int16 v35; // [rsp+A8h] [rbp-60h]
  char v36; // [rsp+4AAh] [rbp+3A2h]

  v32 = -2LL;
  if ( a3 )
  {
    v19 = _ProcessElement__QITaskXmlHandler__TriggersXmlHandler__MEAAJAEBUSchema__W4TaskXmlNodeId___Z(
            (__int64)this,
            (int *)a2,
            98);
    if ( v19 < 0 && *((int *)this + 268) >= 0 )
      *((_DWORD *)this + 268) = v19;
    started = TaskXmlWriter::StartElement(*((int **)this + 131), 98);
    if ( started < 0 && *((int *)this + 268) >= 0 )
      *((_DWORD *)this + 268) = started;
    if ( a4 )
      ServerXMLUpdateHandler::WriteContext((__int64)this, (int *)a2, 99, (__int64)a4);
  }
  v12 = a6;
  if ( a5 )
  {
    ITaskXmlHandler::Data::Data((ITaskXmlHandler::Data *)v28);
    memset_0(v28, 0, 0x48uLL);
    v15 = -1LL;
    do
      ++v15;
    while ( a5[v15] );
    v36 &= 0xFCu;
    v33 = 0;
    v34 = 0LL;
    v35 = 0;
    XmlParserTempString::Clear((XmlParserTempString *)&v33);
    v33 = v15;
    v34 = a5;
    v30 = &v33;
    v16 = 111;
    if ( a6 != 4 )
      v16 = 36;
    v17 = _ProcessValue__QITaskXmlHandler__TriggersXmlHandler__MEAAJAEBUSchema__W4TaskXmlNodeId__AEBUData_1__N_Z(
            this,
            (int *)a2,
            v16,
            (__int64)v28);
    if ( v17 < 0 && *((int *)this + 268) >= 0 )
      *((_DWORD *)this + 268) = v17;
    v18 = TaskXmlWriter::Element(*((_QWORD *)this + 131), v16, (__int64)a5);
    if ( v18 < 0 && *((int *)this + 268) >= 0 )
      *((_DWORD *)this + 268) = v18;
    XmlParserTempString::Clear((XmlParserTempString *)&v33);
    operator delete(lpMem);
  }
  if ( a7 )
  {
    if ( *((_BYTE *)this + 850) )
    {
      v12 = 4;
    }
    else if ( !a6 )
    {
      v12 = 3;
      if ( *(int *)a2 < 65538 )
        v12 = 6;
    }
    ITaskXmlHandler::Data::Data((ITaskXmlHandler::Data *)v28);
    memset_0(v28, 0, 0x48uLL);
    switch ( v12 )
    {
      case 1:
        v29 = 0x40000;
        break;
      case 2:
        v29 = 0x4000;
        break;
      case 3:
        v29 = 0x10000;
        break;
      case 4:
        v29 = 0x8000;
        break;
      case 5:
        v29 = 0x20000;
        break;
      case 6:
        v29 = 0x80000;
        break;
      default:
        v29 = 0;
        break;
    }
    v13 = _ProcessValue__QITaskXmlHandler__TriggersXmlHandler__MEAAJAEBUSchema__W4TaskXmlNodeId__AEBUData_1__N_Z(
            this,
            (int *)a2,
            100,
            (__int64)v28);
    if ( v13 < 0 && *((int *)this + 268) >= 0 )
      *((_DWORD *)this + 268) = v13;
    if ( (unsigned int)(v12 - 4) > 1 )
    {
      v21 = TaskXmlWriter::ElementLogonType(*((_QWORD *)this + 131), v14, v12);
      if ( v21 < 0 && *((int *)this + 268) >= 0 )
        *((_DWORD *)this + 268) = v21;
    }
    operator delete(lpMem);
  }
  if ( a8 )
  {
    ITaskXmlHandler::Data::Data((ITaskXmlHandler::Data *)v28);
    memset_0(v28, 0, 0x48uLL);
    v22 = *(_DWORD *)(*((_QWORD *)this + 5) + 16LL) & 0x1000000;
    v29 = v22 != 0 ? 0x1000000 : 0;
    v23 = v22 != 0;
    v24 = _ProcessValue__QITaskXmlHandler__TriggersXmlHandler__MEAAJAEBUSchema__W4TaskXmlNodeId__AEBUData_1__N_Z(
            this,
            (int *)a2,
            101,
            (__int64)v28);
    if ( v24 < 0 && *((int *)this + 268) >= 0 )
      *((_DWORD *)this + 268) = v24;
    v25 = TaskXmlWriter::ElementRunLevel(*((_QWORD *)this + 131), 101, v23);
    if ( v25 < 0 && *((int *)this + 268) >= 0 )
      *((_DWORD *)this + 268) = v25;
    operator delete(lpMem);
  }
  if ( a3 )
  {
    v26 = _ProcessElementEnd__QITaskXmlHandler__TriggersXmlHandler__MEAAJAEBUSchema__W4TaskXmlNodeId___Z(
            (__int64)this,
            (int *)a2,
            98);
    if ( v26 < 0 && *((int *)this + 268) >= 0 )
      *((_DWORD *)this + 268) = v26;
    v27 = TaskXmlWriter::EndElement(*((_QWORD *)this + 131));
    if ( v27 < 0 && *((int *)this + 268) >= 0 )
      *((_DWORD *)this + 268) = v27;
  }
}
// 180039F48: variable 'v14' is possibly undefined

//----- (000000018000A02C) ----------------------------------------------------
__int64 __fastcall TaskXmlWriter::ElementInt(__int64 a1, int a2, unsigned int a3)
{
  __int64 result; // rax

  result = StringCchPrintfW((unsigned __int16 *)(a1 + 24), 0x40uLL, (size_t *)L"%d", a3);
  if ( (int)result >= 0 )
    return TaskXmlWriter::Element(a1, a2, a1 + 24);
  return result;
}

//----- (000000018000A084) ----------------------------------------------------
__int64 __fastcall ItSpCopySystemSnapshot(struct _ITSRV_SYSTEM_SNAPSHOT *a1, struct _ITSRV_SYSTEM_SNAPSHOT *a2)
{
  unsigned int v2; // edi
  void *v5; // r14
  unsigned int v6; // eax
  void *v7; // rbx
  unsigned int v8; // eax
  int v9; // eax
  unsigned int v11; // ebx
  HANDLE v12; // rax
  HANDLE ProcessHeap; // rax
  HANDLE v14; // rax
  HANDLE v15; // rax

  v2 = 0;
  v5 = 0LL;
  if ( (*((_BYTE *)a2 + 4) & 1) == 0
    || (v6 = *((_DWORD *)a2 + 4), v6 <= *((_DWORD *)a1 + 4))
    || (v11 = 4 * v6, v12 = GetProcessHeap(), (v5 = HeapAlloc(v12, 0, v11)) != 0LL) )
  {
    v7 = (void *)*((_QWORD *)a1 + 3);
    v8 = *((_DWORD *)a1 + 4);
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *((_OWORD *)a1 + 1) = *((_OWORD *)a2 + 1);
    *((_OWORD *)a1 + 2) = *((_OWORD *)a2 + 2);
    *((_OWORD *)a1 + 3) = *((_OWORD *)a2 + 3);
    *((_OWORD *)a1 + 4) = *((_OWORD *)a2 + 4);
    *((_QWORD *)a1 + 10) = *((_QWORD *)a2 + 10);
    *((_QWORD *)a1 + 3) = v7;
    *((_DWORD *)a1 + 4) = v8;
    if ( (*((_BYTE *)a2 + 4) & 1) != 0 )
    {
      if ( *((_DWORD *)a2 + 4) > v8 )
      {
        if ( v7 )
        {
          ProcessHeap = GetProcessHeap();
          HeapFree(ProcessHeap, 0, v7);
        }
        *((_QWORD *)a1 + 3) = v5;
        v7 = v5;
        v5 = 0LL;
      }
      v9 = *((_DWORD *)a2 + 4);
      if ( v9 )
      {
        if ( v7 )
          memcpy_0(v7, *((const void **)a2 + 3), (unsigned int)(4 * v9));
      }
      else
      {
        if ( v7 )
        {
          v14 = GetProcessHeap();
          HeapFree(v14, 0, v7);
        }
        *((_QWORD *)a1 + 3) = 0LL;
      }
      *((_DWORD *)a1 + 4) = *((_DWORD *)a2 + 4);
    }
    if ( v5 )
    {
      v15 = GetProcessHeap();
      HeapFree(v15, 0, v5);
    }
  }
  else
  {
    return 8;
  }
  return v2;
}

//----- (000000018000A1B0) ----------------------------------------------------
__int64 __fastcall SchRpcGetTaskInfo(__int64 a1, char *a2, int a3, _DWORD *a4, _DWORD *a5)
{
  int *v6; // r9
  int v7; // esi
  _DWORD *v8; // rbx
  enum tsched::InternalTaskState *v9; // r8
  int State; // edx
  __int64 v12[3]; // [rsp+48h] [rbp-18h] BYREF
  int v13; // [rsp+80h] [rbp+20h] BYREF

  v12[1] = -2LL;
  LODWORD(v12[0]) = 0;
  v13 = 0;
  v6 = (int *)((unsigned __int64)v12 & -(__int64)(a4 != 0LL));
  v7 = a3 & 0x10000000;
  v8 = a5;
  if ( (a3 & 0x10000000) != 0 && a5 )
    v9 = (enum tsched::InternalTaskState *)&v13;
  else
    v9 = 0LL;
  State = RpcServer::GetState((RTL_SRWLOCK *)&RpcServer::s_singleton, a2, v9, v6);
  if ( State >= 0 )
  {
    if ( v7 && v8 )
    {
      if ( v13 )
      {
        switch ( v13 )
        {
          case 1:
            *v8 = 2;
            break;
          case 2:
            *v8 = 4;
            break;
          case 3:
            *v8 = 3;
            break;
          case 4:
            *v8 = 1;
            break;
        }
      }
      else
      {
        *v8 = 0;
      }
    }
    if ( a4 )
      *a4 = v12[0];
  }
  return (unsigned int)State;
}
// 18000A1B0: could not find valid save-restore pair for rbp
// 1800B0D48: using guessed type __int64 RpcServer::s_singleton;

//----- (000000018000A248) ----------------------------------------------------
__int64 __fastcall RpcServer::GetState(RTL_SRWLOCK *this, char *a2, enum tsched::InternalTaskState *a3, int *a4)
{
  const unsigned __int16 *v8; // r8
  __int64 result; // rax
  const unsigned __int16 *v10; // rdx
  int CallerToken; // edi
  wmi::RefBase *v12; // rdx
  HANDLE ClientToken[3]; // [rsp+30h] [rbp-D0h] BYREF
  char v14[16]; // [rsp+48h] [rbp-B8h] BYREF
  char v15[16]; // [rsp+58h] [rbp-A8h] BYREF
  wmi::RefBase *v16; // [rsp+68h] [rbp-98h] BYREF
  unsigned __int16 v17[264]; // [rsp+70h] [rbp-90h] BYREF

  ClientToken[1] = (HANDLE)-2LL;
  if ( !a2 )
    return 2147942487LL;
  memset_0(v17, 0, 0x20AuLL);
  result = tsched::TaskPathCanonicalize((tsched *)v17, a2, v8);
  if ( (int)result < 0 )
    return result;
  if ( tsched::IsRoot((tsched *)v17, v10) )
    return 2147942487LL;
  ClientToken[0] = 0LL;
  CallerToken = GetCallerToken(L"GetState", ClientToken);
  if ( CallerToken >= 0 )
  {
    JobMoniker::JobMoniker((JobMoniker *)v14, v17, 0LL);
    ClientToken[2] = &this[2];
    AcquireSRWLockShared(this + 2);
    CallerToken = TaskAccessCheck(ClientToken[0], v17, 1u);
    if ( CallerToken < 0 )
    {
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x200) != 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        WPP_SF_SD(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x4Eu,
          (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids,
          v17);
      }
    }
    else
    {
      CallerToken = JobStore::LoadBucketFromRegistry((HKEY *)JobStore::m_pCommonStore, v17, 2, (__int64)v14, 0LL, 0LL);
      if ( CallerToken >= 0 )
      {
        ReleaseSRWLockShared(this + 2);
        v12 = v16;
        if ( a3 )
        {
          if ( (*((_DWORD *)v16 + 4) & 0x2000000) != 0 )
          {
            CallerToken = (*((__int64 (__fastcall **)(void ***, char *, enum tsched::InternalTaskState *))UbpmProxySingleton::s_singleton[0]
                           + 11))(
                            UbpmProxySingleton::s_singleton,
                            v14,
                            a3);
            if ( CallerToken == -2147023728 )
              CallerToken = 0;
            if ( CallerToken < 0 )
              goto LABEL_11;
            v12 = v16;
          }
          if ( !*(_DWORD *)a3 )
            *(_DWORD *)a3 = 4 - ((*((_DWORD *)v12 + 4) & 0x400000) != 0);
        }
        if ( a4 )
          *a4 = (*((_DWORD *)v12 + 4) >> 22) & 1;
        CallerToken = 0;
LABEL_11:
        wmi::AutoRef<JobBucket>::Release(&v16);
        _bstr_t::_Free((_bstr_t *)v15);
        goto LABEL_12;
      }
    }
    ReleaseSRWLockShared(this + 2);
    goto LABEL_11;
  }
LABEL_12:
  wmi::AutoHandle::Close(ClientToken);
  return (unsigned int)CallerToken;
}
// 18000A2AE: variable 'v8' is possibly undefined
// 18000A2C0: variable 'v10' is possibly undefined
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 1800AFFB0: using guessed type void **UbpmProxySingleton::s_singleton[2];
// 18000A248: using guessed type char var_268[16];

//----- (000000018000A3E0) ----------------------------------------------------
BSTR *__fastcall JobStore::GetIndexKeyPath(__int64 a1, int a2, BSTR *a3)
{
  int v3; // edx
  int v4; // edx
  int v5; // edx
  const OLECHAR *v6; // rdx
  BSTR *result; // rax

  v3 = a2 - 1;
  if ( !v3 )
  {
    v6 = L"TaskCache\\Boot";
    return ATL::CComBSTR::operator=(a3, v6);
  }
  v4 = v3 - 1;
  if ( !v4 )
  {
    v6 = L"TaskCache\\Logon";
    return ATL::CComBSTR::operator=(a3, v6);
  }
  v5 = v4 - 1;
  if ( !v5 )
  {
    v6 = L"TaskCache\\Plain";
    return ATL::CComBSTR::operator=(a3, v6);
  }
  if ( v5 == 1 )
  {
    v6 = L"TaskCache\\Maintenance";
    return ATL::CComBSTR::operator=(a3, v6);
  }
  return result;
}
// 180075408: using guessed type wchar_t aTaskcacheBoot[15];
// 180075428: using guessed type wchar_t aTaskcacheLogon[16];
// 180075448: using guessed type wchar_t aTaskcachePlain[16];
// 180075468: using guessed type wchar_t aTaskcacheMaint[22];

//----- (000000018000A430) ----------------------------------------------------
BSTR *__fastcall ATL::CComBSTR::operator=(BSTR *a1, const OLECHAR *a2)
{
  BSTR v4; // rax

  if ( a2 != *a1 )
  {
    SysFreeString(*a1);
    if ( a2 )
    {
      v4 = SysAllocString(a2);
      *a1 = v4;
      if ( !v4 )
        ATL::PrivateAtlThrow(-2147024882);
    }
    else
    {
      *a1 = 0LL;
    }
  }
  return a1;
}

//----- (000000018000A490) ----------------------------------------------------
BSTR __fastcall ATL::CComBSTR::Copy(LPCSTR *this)
{
  CHAR *v2; // rcx
  UINT v3; // eax

  v2 = (CHAR *)*this;
  if ( !v2 )
    return 0LL;
  v3 = SysStringByteLen((BSTR)v2);
  return SysAllocStringByteLen(*this, v3);
}

//----- (000000018000A4D4) ----------------------------------------------------
void __fastcall AutoThreadUIPreferredLanguages::~AutoThreadUIPreferredLanguages(WCHAR **this)
{
  WCHAR *v2; // rcx
  ULONG pulNumLanguages; // [rsp+30h] [rbp+8h] BYREF

  v2 = *this;
  if ( v2 )
  {
    pulNumLanguages = 0;
    SetThreadPreferredUILanguages(8u, v2, &pulNumLanguages);
    v2 = *this;
  }
  operator delete(v2);
}

//----- (000000018000A518) ----------------------------------------------------
__int64 __fastcall TSTimePeriod::IsLessThen(TSTimePeriod *this, const struct TSTimePeriod *a2, bool *a3)
{
  unsigned __int64 v4; // rbx
  unsigned __int64 v5; // rdi
  unsigned __int64 v6; // r8
  int v7; // ecx
  unsigned __int64 v9; // rdi
  unsigned __int64 v10; // r8
  unsigned __int64 v11; // rbx
  unsigned __int64 v12; // rdx

  v4 = *((unsigned __int16 *)this + 1) + 12LL * *(unsigned __int16 *)this;
  v5 = *((unsigned __int16 *)a2 + 1) + 12LL * *(unsigned __int16 *)a2;
  v6 = *((unsigned __int16 *)this + 6)
     + 60
     * (*((unsigned __int16 *)this + 5)
      + 60
      * (*((unsigned __int16 *)this + 4) + 24 * (*((unsigned __int16 *)this + 3) + 7 * *((unsigned __int16 *)this + 2))));
  v7 = *((unsigned __int16 *)a2 + 6)
     + 60
     * (*((unsigned __int16 *)a2 + 5)
      + 60 * (*((unsigned __int16 *)a2 + 4) + 24 * (*((unsigned __int16 *)a2 + 3) + 7 * *((unsigned __int16 *)a2 + 2))));
  if ( v4 >= v5 )
  {
    if ( v4 <= v5 )
    {
      *a3 = v6 < v7;
      return 0LL;
    }
    if ( v6 < v7 )
    {
      v11 = v4 - v5;
      v12 = v7 - v6;
      if ( v12 > 2419200 * v11 )
      {
        if ( v12 > 2678400 * v11 )
        {
LABEL_12:
          *a3 = 1;
          return 0LL;
        }
        return 2147500037LL;
      }
    }
LABEL_13:
    *a3 = 0;
    return 0LL;
  }
  if ( v6 <= v7 )
    goto LABEL_12;
  v9 = v5 - v4;
  v10 = v6 - v7;
  if ( v10 < 2419200 * v9 )
    goto LABEL_12;
  if ( v10 >= 2678400 * v9 )
    goto LABEL_13;
  return 2147500037LL;
}

//----- (000000018000A5E4) ----------------------------------------------------
bool __fastcall JobMoniker::HasEqualTaskHardeningSettings(JobMoniker *this, const struct JobMoniker *a2)
{
  __int64 v2; // r8
  __int64 v3; // rax
  __int64 v4; // rcx
  __int64 v5; // rcx
  __int64 v6; // r9
  __int64 v7; // rdx
  unsigned int v8; // r8d
  bool result; // al

  v2 = *((_QWORD *)this + 4);
  v3 = 0LL;
  v4 = *(_QWORD *)(v2 + 208);
  if ( v4 )
    v5 = *(_QWORD *)(v4 + 48);
  else
    v5 = 0LL;
  v6 = *((_QWORD *)a2 + 4);
  v7 = *(_QWORD *)(v6 + 208);
  if ( v7 )
    v3 = *(_QWORD *)(v7 + 48);
  if ( v5 != v3 )
    return 0;
  v8 = *(_DWORD *)(v2 + 16);
  result = 1;
  if ( (((v8 >> 27) ^ (*(_DWORD *)(v6 + 16) >> 27)) & 1) != 0 || (((v8 >> 28) ^ (*(_DWORD *)(v6 + 16) >> 28)) & 1) != 0 )
    return 0;
  return result;
}

//----- (000000018000A650) ----------------------------------------------------
__int64 __fastcall ServerXMLUpdateHandler::NetworkInputHandler::EndElement(__int64 a1, const struct Schema *a2, int a3)
{
  int v5; // edi
  char v7; // al
  const struct _GUID *v8; // rdx
  const wchar_t **v9; // rax
  const wchar_t *v10; // rdx
  const wchar_t *v11; // rcx
  int v12; // eax
  const wchar_t **v13; // [rsp+58h] [rbp+20h] BYREF

  v5 = 0;
  if ( a3 != 90 )
    return (unsigned int)v5;
  v7 = *(_BYTE *)(a1 + 42);
  if ( !*(_BYTE *)(a1 + 41) )
  {
    if ( !v7 )
      goto LABEL_20;
    v12 = ServerXMLUpdateHandler::NetworkName2Id(
            (ServerXMLUpdateHandler *)a1,
            (const wchar_t ***)(a1 + 32),
            (struct _GUID *)(a1 + 16));
    goto LABEL_18;
  }
  v8 = (const struct _GUID *)(a1 + 16);
  if ( !v7 )
  {
    v12 = ServerXMLUpdateHandler::NetworkId2Name((ServerXMLUpdateHandler *)a1, v8, (_bstr_t::Data_t **)(a1 + 32));
LABEL_18:
    v5 = v12;
LABEL_19:
    if ( v5 < 0 )
    {
LABEL_23:
      *(_BYTE *)(a1 + 40) = 0;
      return (unsigned int)v5;
    }
LABEL_20:
    if ( *(_BYTE *)(a1 + 41) || *(_BYTE *)(a1 + 42) )
      ServerXMLUpdateHandler::WriteNetworkSettings(
        *(ServerXMLUpdateHandler **)(a1 + 8),
        a2,
        (const struct _GUID *)(a1 + 16),
        (__int64 **)(a1 + 32));
    goto LABEL_23;
  }
  v13 = 0LL;
  v5 = ServerXMLUpdateHandler::NetworkId2Name((ServerXMLUpdateHandler *)a1, v8, (_bstr_t::Data_t **)&v13);
  if ( v5 < 0
    || ((v9 = *(const wchar_t ***)(a1 + 32)) == 0LL ? (v10 = 0LL) : (v10 = *v9),
        !v13 ? (v11 = 0LL) : (v11 = *v13),
        !_wcsicmp(v11, v10)) )
  {
    _bstr_t::_Free((_bstr_t *)&v13);
    goto LABEL_19;
  }
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 108LL) = 91;
  _bstr_t::_Free((_bstr_t *)&v13);
  return 2147750680LL;
}

//----- (000000018000A6A0) ----------------------------------------------------
__int64 __fastcall Triggers::LogonTrigger::WriteXml(Triggers::LogonTrigger *this, struct TaskXmlWriter *a2)
{
  OLECHAR **v4; // rcx
  OLECHAR *v5; // rcx
  UINT v6; // eax
  __int64 result; // rax
  int v8; // ebx
  __int64 *v9; // rax
  __int64 v10; // r9
  _QWORD *v11; // r8
  __int64 v12; // [rsp+40h] [rbp+8h] BYREF

  v4 = (OLECHAR **)*((_QWORD *)this + 10);
  if ( v4 && (v5 = *v4) != 0LL )
    v6 = SysStringLen(v5);
  else
    v6 = 0;
  if ( v6 )
  {
    v9 = (__int64 *)*((_QWORD *)this + 10);
    if ( v9 )
      v10 = *v9;
    else
      v10 = 0LL;
    result = TaskXmlWriter::StartElementWithAttribute((__int64)a2, 35, 109, v10);
  }
  else
  {
    result = TaskXmlWriter::StartElement((int *)a2, 35);
  }
  if ( (int)result >= 0 )
  {
    v8 = Triggers::GenericTrigger::WriteInnerXml(this, a2);
    if ( v8 >= 0 && *((_QWORD *)this + 11) )
    {
      v11 = (_QWORD *)*User::GetDomainAccount((Triggers::LogonTrigger *)((char *)this + 88), &v12);
      if ( v11 )
        v11 = (_QWORD *)*v11;
      v8 = TaskXmlWriter::Element((__int64)a2, 36, (__int64)v11);
      _bstr_t::_Free((_bstr_t *)&v12);
      if ( v8 >= 0 )
        return TaskXmlWriter::EndElement((__int64)a2);
    }
    if ( v8 >= 0 )
      return TaskXmlWriter::EndElement((__int64)a2);
    else
      return (unsigned int)v8;
  }
  return result;
}

//----- (000000018000A760) ----------------------------------------------------
__int64 __fastcall Triggers::LogXTrigger::StreamIn(
        User::UserEntry **this,
        unsigned __int64 a2,
        unsigned __int8 **a3,
        unsigned __int8 *a4)
{
  __int64 result; // rax
  WCHAR **v8; // rdx

  result = Triggers::GenericTrigger::StreamIn((Triggers::GenericTrigger *)this, a2, a3, a4);
  if ( (int)result >= 0 )
    return User::StreamIn(this + 11, v8, a3, (unsigned __int8 **)a4);
  return result;
}
// 18000A78B: variable 'v8' is possibly undefined

//----- (000000018000A7A8) ----------------------------------------------------
char RpcServer::CheckIntegrityLevel(void)
{
  int v0; // ebx
  HANDLE CurrentThread; // rax
  NTSTATUS v2; // eax
  int v3; // edi
  NTSTATUS v5; // ecx
  ULONG LastError; // eax
  char v7[4]; // [rsp+68h] [rbp-39h] BYREF
  DWORD TokenInformationLength; // [rsp+6Ch] [rbp-35h] BYREF
  PSID Sid; // [rsp+70h] [rbp-31h] BYREF
  void *TokenHandle; // [rsp+78h] [rbp-29h] BYREF
  struct _SID_IDENTIFIER_AUTHORITY IdentifierAuthority; // [rsp+80h] [rbp-21h] BYREF
  __int64 TokenInformation[12]; // [rsp+88h] [rbp-19h] BYREF

  TokenInformationLength = 88;
  TokenHandle = 0LL;
  v0 = 0;
  v7[0] = 0;
  CurrentThread = GetCurrentThread();
  if ( OpenThreadToken(CurrentThread, 8u, 1, &TokenHandle) )
  {
    if ( GetTokenInformation(
           TokenHandle,
           TokenIntegrityLevel,
           TokenInformation,
           TokenInformationLength,
           &TokenInformationLength) )
    {
      *(_DWORD *)IdentifierAuthority.Value = 0;
      *(_WORD *)&IdentifierAuthority.Value[4] = 4096;
      Sid = 0LL;
      v2 = RtlAllocateAndInitializeSid(&IdentifierAuthority, 1u, 0x2000u, 0, 0, 0, 0, 0, 0, 0, &Sid);
      if ( v2 < 0 )
      {
        v5 = v2;
      }
      else
      {
        v3 = RtlSidDominates(TokenInformation[0], Sid, v7);
        RtlFreeSid(Sid);
        if ( v3 >= 0 )
        {
          if ( !v7[0] )
            v0 = 5;
          goto LABEL_7;
        }
        v5 = v3;
      }
      LastError = RtlNtStatusToDosError(v5);
    }
    else
    {
      LastError = GetLastError();
    }
    v0 = LastError;
LABEL_7:
    CloseHandle(TokenHandle);
    goto LABEL_8;
  }
  v0 = GetLastError();
LABEL_8:
  if ( !v0 )
    return 1;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x200) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
  {
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x1Bu, (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids, v0);
  }
  return 0;
}
// 180074630: using guessed type __int64 __fastcall RtlSidDominates(_QWORD, _QWORD, _QWORD);
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 18000A7A8: using guessed type char var_90[4];
// 18000A7A8: using guessed type __int64 TokenInformation[12];

//----- (000000018000A918) ----------------------------------------------------
char __fastcall User::IsLocalSystem(wchar_t *String1)
{
  char v2; // bl

  v2 = 0;
  if ( !_wcsicmp(String1, L"System") || !_wcsicmp(String1, L"NT AUTHORITY\\System") || !_wcsicmp(String1, L"S-1-5-18") )
    return 1;
  return v2;
}

//----- (000000018000A98C) ----------------------------------------------------
__int64 __fastcall JobSecurity::GetSddl(PSECURITY_DESCRIPTOR *this, SECURITY_INFORMATION a2, unsigned __int16 **a3)
{
  tsched *v4; // rcx
  char *v5; // rbx
  int LastHrError; // edi
  unsigned __int16 *v7; // rax
  unsigned __int64 v9; // [rsp+50h] [rbp+8h] BYREF
  unsigned __int16 *v10; // [rsp+68h] [rbp+20h] BYREF

  LODWORD(v9) = 0;
  v10 = 0LL;
  if ( ConvertSecurityDescriptorToStringSecurityDescriptorW(*this, 1u, a2, &v10, (PULONG)&v9) )
  {
    v5 = (char *)operator new(saturated_mul((unsigned int)(v9 + 1), 2uLL));
    LastHrError = StringCchCopyNW(v5, (unsigned int)(v9 + 1), (char *)v10, (unsigned int)v9);
    if ( LastHrError >= 0 )
    {
      v7 = (unsigned __int16 *)v5;
      v5 = 0LL;
      *a3 = v7;
      LastHrError = 0;
    }
    operator delete(v5);
  }
  else
  {
    LastHrError = tsched::GetLastHrError(v4);
  }
  tsched::AutoLocalPtr<unsigned short>::~AutoLocalPtr<unsigned short>((void **)&v10);
  return (unsigned int)LastHrError;
}
// 18000AA49: variable 'v4' is possibly undefined

//----- (000000018000AA60) ----------------------------------------------------
__int64 __fastcall Triggers::SessionChangeTrigger::StreamIn(
        User::UserEntry **this,
        unsigned __int64 a2,
        unsigned __int8 **a3,
        unsigned __int8 *a4)
{
  __int64 result; // rax
  WCHAR **v8; // rdx

  result = Triggers::GenericTrigger::StreamIn((Triggers::GenericTrigger *)this, a2, a3, a4);
  if ( (int)result >= 0 )
  {
    if ( a4 - *a3 < 8 )
    {
      return 2147549183LL;
    }
    else
    {
      this[12] = *(User::UserEntry **)*a3;
      *a3 += 8;
      return User::StreamIn(this + 11, v8, a3, (unsigned __int8 **)a4);
    }
  }
  return result;
}
// 18000AAA5: variable 'v8' is possibly undefined

//----- (000000018000AAD0) ----------------------------------------------------
__int64 __fastcall RpcServer::SecurityCallback(RPC_IF_HANDLE InterfaceUuid, void *Context)
{
  unsigned int v3; // edi
  tsched *v4; // rcx
  RPC_STATUS Status; // [rsp+48h] [rbp-B8h] BYREF
  unsigned int v7; // [rsp+4Ch] [rbp-B4h]
  char v8[4]; // [rsp+50h] [rbp-B0h] BYREF
  int v9; // [rsp+54h] [rbp-ACh]
  __int64 v10; // [rsp+58h] [rbp-A8h]
  int RpcCallAttributes; // [rsp+68h] [rbp-98h] BYREF
  char v12[36]; // [rsp+6Ch] [rbp-94h] BYREF
  unsigned int v13; // [rsp+90h] [rbp-70h]
  int v14; // [rsp+A0h] [rbp-60h]
  UUID Uuid1; // [rsp+C4h] [rbp-3Ch] BYREF

  v10 = -2LL;
  memset_0(v12, 0, 0x74uLL);
  RpcCallAttributes = 3;
  v3 = 5;
  v7 = 5;
  Status = RpcServerInqCallAttributesW(Context, &RpcCallAttributes);
  if ( !Status && v13 >= 6 )
  {
    if ( v14 == 3 )
    {
      return 0;
    }
    else if ( UuidEqual(&Uuid1, (UUID *)&Uuid2, &Status) && !Status )
    {
      v9 = -2147467259;
      RpcAutoImpersonate::RpcAutoImpersonate((RpcAutoImpersonate *)v8, L"RpcServer::SecurityCallback", 1);
      if ( (unsigned int)tsched::IsUserAdmin(v4) )
        v3 = 0;
      v7 = v3;
      RpcAutoImpersonate::~RpcAutoImpersonate((RpcAutoImpersonate *)v8);
    }
  }
  return v3;
}
// 18000AAD0: could not find valid save-restore pair for rbp
// 18000AB9B: variable 'v4' is possibly undefined
// 18000AAD0: using guessed type char var_94[36];

//----- (000000018000ABF0) ----------------------------------------------------
__int64 __fastcall _delayLoadHelper2(__int64 a1, __int64 a2)
{
  return ResolveDelayLoadedAPI(
           &_ImageBase,
           a1,
           _pfnDefaultDliFailureHook2,
           DelayLoadFailureHook,
           a2,
           _ResolveDelayLoadedAPIFlags);
}
// 180073DE8: using guessed type __int64 __fastcall ResolveDelayLoadedAPI(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 180080E48: using guessed type int _ResolveDelayLoadedAPIFlags;
// 180080E50: using guessed type __int64 _pfnDefaultDliFailureHook2;

//----- (000000018000AC34) ----------------------------------------------------
NTSTATUS __fastcall LUAIsElevatedToken(HANDLE TokenHandle, _DWORD *a2, _DWORD *a3)
{
  NTSTATUS result; // eax
  int TokenInformation; // [rsp+58h] [rbp+10h] BYREF
  ULONG ReturnLength; // [rsp+60h] [rbp+18h] BYREF
  int v9; // [rsp+68h] [rbp+20h] BYREF

  *a3 = 1;
  *a2 = 0;
  TokenInformation = 1;
  result = NtQueryInformationToken(TokenHandle, TokenElevationType, &TokenInformation, 4u, &ReturnLength);
  if ( result >= 0 )
  {
    if ( TokenInformation == 2
      || TokenInformation == 1
      && (*a3 = 0, result = NtQueryInformationToken(TokenHandle, TokenElevation, &v9, 4u, &ReturnLength), result >= 0)
      && v9 )
    {
      *a2 = 1;
    }
  }
  return result;
}

//----- (000000018000ACE0) ----------------------------------------------------
__int64 __fastcall Triggers::TimeTrigger::ToUbpmFormat(
        Triggers::TimeTrigger *this,
        const struct Triggers::TriggerExportOptions *a2,
        struct IUbpmRegistrationParams *a3)
{
  return (*(__int64 (__fastcall **)(struct IUbpmRegistrationParams *, char *))(*(_QWORD *)a3 + 104LL))(
           a3,
           (char *)this + 8);
}

//----- (000000018000AD00) ----------------------------------------------------
void __fastcall ItSpPowerNotificationWorker(PTP_CALLBACK_INSTANCE Instance, char *Context, PTP_WORK Work)
{
  ULONG v5; // r9d

  SetEvent(*((HANDLE *)Context + 92));
  RtlAcquireSRWLockShared(Context + 408);
  if ( _InterlockedCompareExchange((volatile signed __int32 *)Context + 192, 0, 0) )
    v5 = *((_DWORD *)Context + 96);
  else
    v5 = *((_DWORD *)Context + 94);
  ChangeTimerQueueTimer(0LL, *((HANDLE *)Context + 28), 0x32u, v5);
  RtlReleaseSRWLockShared(Context + 408);
  if ( Work )
    CloseThreadpoolWork(Work);
}
// 180074650: using guessed type __int64 __fastcall RtlReleaseSRWLockShared(_QWORD);
// 180074658: using guessed type __int64 __fastcall RtlAcquireSRWLockShared(_QWORD);

//----- (000000018000ADBC) ----------------------------------------------------
char *__fastcall tsched::PathCopy(tsched *this, const unsigned __int16 *a2)
{
  __int64 v3; // r14
  char *v4; // rax
  char *v5; // rdi
  void **pExceptionObject; // [rsp+20h] [rbp-40h] BYREF
  char v8; // [rsp+28h] [rbp-38h]
  const unsigned __int16 *v9; // [rsp+30h] [rbp-30h]
  __int64 v10; // [rsp+38h] [rbp-28h]
  __int64 v11; // [rsp+40h] [rbp-20h]
  int v12; // [rsp+48h] [rbp-18h]
  int v13; // [rsp+4Ch] [rbp-14h]
  int v14; // [rsp+50h] [rbp-10h]
  unsigned __int64 v15; // [rsp+88h] [rbp+28h] BYREF

  v15 = 0LL;
  if ( (int)StringCchLengthW((const unsigned __int16 *)this, 0x105uLL, &v15) < 0 )
  {
    v13 = -1;
    pExceptionObject = &wmi::GenericException::`vftable';
    v8 = 0;
    v9 = &word_18007630E;
    v10 = 0LL;
    v11 = 0LL;
    v12 = 87;
    v14 = -1;
    CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
  }
  if ( !v15 )
  {
    v13 = -1;
    pExceptionObject = &wmi::GenericException::`vftable';
    v8 = 0;
    v9 = &word_18007630E;
    v10 = 0LL;
    v11 = 0LL;
    v12 = 87;
    v14 = -1;
    CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
  }
  v3 = v15 + 1;
  v4 = (char *)operator new(saturated_mul(v15 + 1, 2uLL));
  v5 = v4;
  if ( !v4 )
  {
    v13 = -1;
    pExceptionObject = &wmi::GenericException::`vftable';
    v8 = 0;
    v9 = &word_18007630E;
    v10 = 0LL;
    v11 = 0LL;
    v12 = 8;
    v14 = -1;
    CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
  }
  StringCchCopyW(v4, v3, (char *)this);
  return v5;
}
// 1800716D8: using guessed type void *wmi::GenericException::`vftable';

//----- (000000018000AE60) ----------------------------------------------------
__int64 __fastcall SchRpcRegisterTask(
        __int64 a1,
        unsigned __int16 *a2,
        struct _EVENT_DESCRIPTOR *a3,
        unsigned int a4,
        unsigned __int16 *a5,
        unsigned int a6,
        unsigned int a7,
        const struct _TASK_USER_CRED *a8,
        unsigned __int16 **a9,
        struct _TASK_XML_ERROR_INFO **a10)
{
  return RpcServer::RegisterTask((void **)&RpcServer::s_singleton, a2, a3, a4, a5, a6, a7, a8, 0LL, a9, a10);
}
// 18000AE60: could not find valid save-restore pair for rbp
// 1800B0D48: using guessed type __int64 RpcServer::s_singleton;

//----- (000000018000AEE4) ----------------------------------------------------
__int64 __fastcall UbpmProxySingleton::OpenConsumer(
        UbpmProxySingleton *this,
        const struct JobMoniker *a2,
        struct AutoUbpmConsumerHandle *a3)
{
  _QWORD *v4; // rdx
  int v5; // eax
  signed int v6; // ebx

  v4 = (_QWORD *)*((_QWORD *)a2 + 2);
  if ( v4 )
    v4 = (_QWORD *)*v4;
  v5 = UbpmOpenTriggerConsumer(a2, v4, a3);
  v6 = v5;
  if ( v5 > 0 )
    v6 = (unsigned __int16)v5 | 0x80070000;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0
    && *((unsigned __int8 *)WPP_GLOBAL_Control + 25) >= (int)(((v6 >> 31) & 0xFFFFFFFE) + 4) )
  {
    WPP_SF_SD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0xAu,
      (__int64)&WPP_ffeb42fce81a3445f9740a981b62c86a_Traceguids,
      *((const wchar_t **)a2 + 3));
  }
  return (unsigned int)v6;
}
// 180073D78: using guessed type __int64 __fastcall UbpmOpenTriggerConsumer(_QWORD, _QWORD, _QWORD);
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018000AF4C) ----------------------------------------------------
bool __fastcall TSTime::operator<=(__int64 a1, __int128 *a2)
{
  __int128 v4; // [rsp+20h] [rbp-18h] BYREF

  TSTime::EqualizeLocality((char *)a1, &v4, a2);
  return *(_QWORD *)(a1 + 8) <= *((_QWORD *)&v4 + 1);
}

//----- (000000018000AF7C) ----------------------------------------------------
User *__fastcall User::User(User *this, User::UserEntry **a2)
{
  User::UserEntry *v3; // rcx

  v3 = *a2;
  *(_QWORD *)this = *a2;
  if ( v3 )
    User::UserEntry::AddRef(v3);
  return this;
}

//----- (000000018000AFA8) ----------------------------------------------------
ATL::CSid *__fastcall ATL::CSid::CSid(ATL::CSid *this)
{
  *((_BYTE *)this + 76) = 0;
  *(_QWORD *)this = &ATL::CSid::`vftable';
  *((_DWORD *)this + 20) = 7;
  *((_QWORD *)this + 11) = (*(__int64 (__fastcall **)(__int64 *))(ATL::g_strmgr + 24))(&ATL::g_strmgr) + 24;
  *((_QWORD *)this + 12) = (*(__int64 (__fastcall **)(__int64 *))(ATL::g_strmgr + 24))(&ATL::g_strmgr) + 24;
  *((_QWORD *)this + 13) = (*(__int64 (__fastcall **)(__int64 *))(ATL::g_strmgr + 24))(&ATL::g_strmgr) + 24;
  *((_QWORD *)this + 14) = (*(__int64 (__fastcall **)(__int64 *))(ATL::g_strmgr + 24))(&ATL::g_strmgr) + 24;
  return this;
}
// 1800703C0: using guessed type void *ATL::CSid::`vftable';
// 1800B0BF0: using guessed type __int64 ATL::g_strmgr;

//----- (000000018000B058) ----------------------------------------------------
void __fastcall ATL::CSid::~CSid(ATL::CSid *this)
{
  *(_QWORD *)this = &ATL::CSid::`vftable';
  ATL::CStringData::Release((ATL::CStringData *)(*((_QWORD *)this + 14) - 24LL));
  ATL::CStringData::Release((ATL::CStringData *)(*((_QWORD *)this + 13) - 24LL));
  ATL::CStringData::Release((ATL::CStringData *)(*((_QWORD *)this + 12) - 24LL));
  ATL::CStringData::Release((ATL::CStringData *)(*((_QWORD *)this + 11) - 24LL));
}
// 1800703C0: using guessed type void *ATL::CSid::`vftable';

//----- (000000018000B0AC) ----------------------------------------------------
void __fastcall ATL::CStringData::Release(ATL::CStringData *this)
{
  if ( _InterlockedExchangeAdd((volatile signed __int32 *)this + 4, 0xFFFFFFFF) <= 1 )
    (*(void (__fastcall **)(_QWORD, ATL::CStringData *))(**(_QWORD **)this + 8LL))(*(_QWORD *)this, this);
}

//----- (000000018000B0E0) ----------------------------------------------------
__int64 __fastcall _Unregister__QEventTriggerRegistrar__EventTrapMap__UEAAJAEBVJobMoniker___Z(
        __int64 a1,
        JobMoniker *a2)
{
  __int64 v2; // rdi
  unsigned int v4; // r13d
  __int64 v5; // r12
  struct _RTL_CRITICAL_SECTION *v6; // rbx
  __int64 *v7; // r15
  __int64 v8; // rax
  __int64 *v9; // rsi
  __int64 *v10; // r14
  EVT_HANDLE **i; // rbx
  const wchar_t *Path; // rax
  __int64 v14; // rdi
  __int64 v15; // rdi
  EVT_HANDLE *v16; // rdi
  void *lpMem[2]; // [rsp+28h] [rbp-20h] BYREF
  __int64 v18; // [rsp+38h] [rbp-10h]
  __int64 v19; // [rsp+90h] [rbp+48h] BYREF
  JobMoniker *v20; // [rsp+98h] [rbp+50h]
  __int64 v21; // [rsp+A0h] [rbp+58h]
  __int64 v22; // [rsp+A8h] [rbp+60h]

  v20 = a2;
  v2 = (__int64)a2;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
  {
    Path = JobMoniker::GetPath(a2);
    WPP_SF_S(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xDu, (__int64)&WPP_16de8f11014e3cd60e9c758468ee516f_Traceguids, Path);
  }
  v4 = 1;
  *(_OWORD *)lpMem = 0LL;
  v5 = 0LL;
  v18 = 0LL;
  v6 = (struct _RTL_CRITICAL_SECTION *)(a1 + 8);
  v22 = a1 + 8;
  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 8));
  v7 = (__int64 *)(a1 + 48);
  v8 = 255LL;
  v21 = 255LL;
  v9 = 0LL;
  v10 = 0LL;
  do
  {
    if ( *v7 )
    {
      if ( !(unsigned int)_bstr_t::_Compare((BSTR **)(*v7 + 24), (BSTR **)(v2 + 16)) )
      {
        v14 = *v7;
        v19 = *v7;
        *v7 = 0LL;
        if ( &v19 >= v9 || v10 > &v19 )
        {
          if ( v9 == (__int64 *)v5 )
          {
            std::vector<_DAB_REGISTRATION_TRIGGER_PARAMS *>::_Reserve(lpMem);
            v5 = v18;
            v9 = (__int64 *)lpMem[1];
            v10 = (__int64 *)lpMem[0];
          }
          *v9 = v14;
        }
        else
        {
          v15 = &v19 - v10;
          if ( v9 == (__int64 *)v5 )
          {
            std::vector<_DAB_REGISTRATION_TRIGGER_PARAMS *>::_Reserve(lpMem);
            v5 = v18;
            v9 = (__int64 *)lpMem[1];
            v10 = (__int64 *)lpMem[0];
          }
          *v9 = v10[v15];
        }
        lpMem[1] = ++v9;
        v4 = 0;
        v2 = (__int64)v20;
      }
      v8 = v21;
    }
    ++v7;
    v21 = --v8;
  }
  while ( v8 );
  LeaveCriticalSection(v6);
  if ( v10 != v9 )
  {
    for ( i = (EVT_HANDLE **)v10; i != (EVT_HANDLE **)v9; ++i )
    {
      v16 = *i;
      EvtClose(**i);
      EventTrap::`scalar deleting destructor'((EventTrap *)v16);
    }
  }
  if ( v10 )
    operator delete(v10);
  return v4;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018000B1D8) ----------------------------------------------------
__int64 __fastcall _bstr_t::_Compare(BSTR **this, BSTR **a2)
{
  BSTR *v2; // rcx
  BSTR *v3; // rdx

  v2 = *this;
  v3 = *a2;
  if ( v2 == v3 )
    return 0LL;
  if ( !v2 )
    return 0xFFFFFFFFLL;
  if ( v3 )
    return _bstr_t::Data_t::Compare(v2, v3);
  return 1LL;
}

//----- (000000018000B208) ----------------------------------------------------
__int64 __fastcall _bstr_t::Data_t::Compare(BSTR *this, BSTR *a2)
{
  BSTR v2; // rax
  unsigned int v3; // ebx
  UINT v6; // esi
  UINT v7; // eax
  BSTR v8; // rcx
  UINT v9; // edx
  signed __int64 v10; // r8
  int v11; // r9d
  int v12; // r10d

  v2 = *a2;
  v3 = 0;
  if ( !*this )
    return (unsigned int)-(v2 != 0LL);
  if ( !v2 )
    return 1LL;
  v6 = SysStringLen(*this);
  v7 = SysStringLen(*a2);
  v8 = *this;
  v9 = v6;
  if ( v6 > v7 )
    v9 = v7;
  if ( v9 )
  {
    v10 = (char *)*a2 - (char *)v8;
    while ( 1 )
    {
      v11 = *v8;
      --v9;
      v12 = *(BSTR)((char *)v8++ + v10);
      if ( (_WORD)v11 != (_WORD)v12 )
        return (unsigned int)(v11 - v12);
      if ( !v9 )
        goto LABEL_9;
    }
  }
  else
  {
LABEL_9:
    if ( v6 < v7 )
      return (unsigned int)-1;
    else
      LOBYTE(v3) = v6 != v7;
    return v3;
  }
}

//----- (000000018000B2BC) ----------------------------------------------------
void __fastcall SelfDestructingTraps::~SelfDestructingTraps(EVT_HANDLE ***this)
{
  EVT_HANDLE **v1; // rbx
  EVT_HANDLE *v3; // rdi

  v1 = *this;
  if ( *this != this[1] )
  {
    while ( v1 != this[1] )
    {
      v3 = *v1;
      EvtClose(**v1);
      EventTrap::`scalar deleting destructor'((EventTrap *)v3);
      ++v1;
    }
    v1 = *this;
  }
  if ( v1 )
  {
    operator delete(v1);
    *this = 0LL;
    this[1] = 0LL;
    this[2] = 0LL;
  }
}

//----- (000000018000B300) ----------------------------------------------------
__int64 __fastcall ItSpGetSystemSnapshot(struct _ITSRV_GLOBAL_CONTEXT *a1, struct _ITSRV_SYSTEM_SNAPSHOT *a2)
{
  void *v4; // rcx
  int CPUAvailableTime; // eax
  int v6; // ecx
  unsigned int v7; // ecx
  NTSTATUS v8; // eax
  int v9; // ecx
  unsigned int v10; // ecx
  NTSTATUS v11; // eax
  int v12; // ecx
  unsigned int v13; // ecx
  NTSTATUS v14; // eax
  int v15; // ecx
  unsigned int v16; // ecx

  v4 = (void *)*((_QWORD *)a1 + 54);
  if ( v4 )
  {
    if ( (unsigned int)ItSpGetWmiDiskPerformanceData(
                         v4,
                         (struct _ITSRV_DISK_PERFORMANCE_DATA **)a2 + 3,
                         (unsigned int *)a2 + 4,
                         (void **)a1 + 55,
                         (unsigned int *)a1 + 112)
      || !*((_QWORD *)a2 + 3) )
    {
      *((_DWORD *)a2 + 1) &= ~1u;
    }
    else
    {
      *((_DWORD *)a2 + 1) |= 1u;
    }
  }
  else
  {
    *((_DWORD *)a2 + 1) &= ~1u;
  }
  CPUAvailableTime = ItSpQueryCPUAvailableTime(*((void **)a1 + 57), (unsigned __int64 *)a2 + 1);
  v6 = *((_DWORD *)a2 + 1);
  if ( CPUAvailableTime < 0 )
    v7 = v6 & 0xFFFFFFFD;
  else
    v7 = v6 | 2;
  *((_DWORD *)a2 + 1) = v7;
  v8 = NtPowerInformation(SystemBatteryState, 0LL, 0, (char *)a2 + 32, 0x20u);
  v9 = *((_DWORD *)a2 + 1);
  if ( v8 < 0 )
    v10 = v9 & 0xFFFFFFFB;
  else
    v10 = v9 | 4;
  *((_DWORD *)a2 + 1) = v10;
  v11 = NtPowerInformation(SystemPowerInformation, 0LL, 0, (char *)a2 + 64, 0x10u);
  v12 = *((_DWORD *)a2 + 1);
  if ( v11 < 0 )
    v13 = v12 & 0xFFFFFFF7;
  else
    v13 = v12 | 8;
  *((_DWORD *)a2 + 1) = v13;
  v14 = NtPowerInformation(SystemExecutionState, 0LL, 0, (char *)a2 + 80, 4u);
  v15 = *((_DWORD *)a2 + 1);
  if ( v14 < 0 )
    v16 = v15 & 0xFFFFFFEF;
  else
    v16 = v15 | 0x10;
  *((_DWORD *)a2 + 21) = 0;
  *((_DWORD *)a2 + 1) = v16 | 0x20;
  *(_DWORD *)a2 = GetTickCount();
  return 0LL;
}

//----- (000000018000B440) ----------------------------------------------------
__int64 __fastcall ItSpQueryCPUAvailableTime(void *a1, unsigned __int64 *a2)
{
  __int64 result; // rax
  char *v4; // rcx
  char *v5; // rbx
  char *v6; // rcx
  unsigned __int64 *v7; // rcx
  char v8[16]; // [rsp+20h] [rbp-428h] BYREF
  char v9[4]; // [rsp+30h] [rbp-418h] BYREF
  int v10; // [rsp+34h] [rbp-414h]
  int v11; // [rsp+38h] [rbp-410h]
  __int64 v12[3]; // [rsp+430h] [rbp-18h] BYREF

  result = PcwCollectData(a1, v9, 1024LL, v8);
  if ( (int)result >= 0 )
  {
    v4 = &v9[v10];
    if ( v4 + 32 <= (char *)v12
      && v11
      && (v5 = &v4[*((unsigned int *)v4 + 1)], v5 + 20 <= (char *)v12)
      && *((_DWORD *)v4 + 2) == 1
      && !wcscmp_0((const wchar_t *)v5 + 8, L"_Total")
      && (v6 = &v5[*((unsigned int *)v5 + 2)], v6 + 12 <= (char *)v12)
      && *((_DWORD *)v5 + 3) == 1
      && *((_WORD *)v6 + 2) == 15
      && *((_WORD *)v6 + 3) == 8
      && (v7 = (unsigned __int64 *)(v6 + 8), v7 >= (unsigned __int64 *)v9)
      && v7 + 1 <= (unsigned __int64 *)v12 )
    {
      *a2 = *v7;
      return 0LL;
    }
    else
    {
      return 3221225701LL;
    }
  }
  return result;
}
// 180073FD8: using guessed type __int64 __fastcall PcwCollectData(_QWORD, _QWORD, _QWORD, _QWORD);
// 18000B440: using guessed type char var_428[16];

//----- (000000018000B56C) ----------------------------------------------------
__int64 __fastcall ItSpGetWmiDiskPerformanceData(
        void *a1,
        struct _ITSRV_DISK_PERFORMANCE_DATA **a2,
        unsigned int *a3,
        void **a4,
        unsigned int *a5)
{
  void *v6; // rax
  _DWORD *v7; // rdi
  unsigned int v8; // r14d
  char v9; // r12
  unsigned int v10; // r15d
  int v11; // eax
  unsigned int v12; // ebx
  _DWORD *v13; // rbx
  unsigned int v14; // r15d
  unsigned int *v15; // rax
  HANDLE v16; // rax
  struct _ITSRV_DISK_PERFORMANCE_DATA *v17; // rsi
  struct _ITSRV_DISK_PERFORMANCE_DATA **v18; // rax
  struct _ITSRV_DISK_PERFORMANCE_DATA *v19; // rbx
  _DWORD *v20; // rbx
  struct _DISK_PERFORMANCE *v21; // rsi
  unsigned int v23; // ebx
  HANDLE v24; // rax
  HANDLE v25; // rax
  HANDLE ProcessHeap; // rax
  HANDLE v27; // rax
  unsigned int dwBytes; // [rsp+24h] [rbp-54h] BYREF
  unsigned int dwBytes_4; // [rsp+28h] [rbp-50h]
  int v30; // [rsp+2Ch] [rbp-4Ch]
  LPVOID lpMem; // [rsp+30h] [rbp-48h]
  LPVOID v32; // [rsp+38h] [rbp-40h]

  v6 = a1;
  v7 = 0LL;
  lpMem = 0LL;
  v8 = 0;
  dwBytes_4 = 0;
  v9 = 0;
  v32 = 0LL;
  if ( a4 )
  {
    if ( a5 )
    {
      v9 = 1;
      v7 = *a4;
      lpMem = *a4;
      v8 = *a5;
      dwBytes_4 = *a5;
    }
    v6 = a1;
  }
  v10 = 0;
  while ( 1 )
  {
    dwBytes = v8;
    v11 = WmiQueryAllDataW(v6, &dwBytes, v7);
    v12 = v11;
    v30 = v11;
    if ( !v11 )
      break;
    if ( v11 != 122 )
      goto LABEL_27;
    if ( v8 )
    {
      ProcessHeap = GetProcessHeap();
      HeapFree(ProcessHeap, 0, v7);
      v8 = 0;
    }
    v23 = dwBytes;
    v24 = GetProcessHeap();
    v7 = HeapAlloc(v24, 0, v23);
    lpMem = v7;
    if ( !v7 )
      goto LABEL_38;
    v8 = dwBytes;
    dwBytes_4 = dwBytes;
    ++v10;
    v6 = a1;
    if ( v10 >= 0x10 )
      goto LABEL_39;
  }
  if ( v7 )
  {
    v13 = v7;
    if ( !v7[13] )
    {
LABEL_36:
      v12 = 11;
      goto LABEL_27;
    }
    v14 = 0;
    while ( 1 )
    {
      if ( *v13 < 0x48u )
        goto LABEL_36;
      if ( ItSpIsPhysicalDrive((struct _DISK_PERFORMANCE *const)((char *)v13 + (unsigned int)v13[12])) )
        ++v14;
      if ( !v13[3] )
        break;
      v13 = (_DWORD *)((char *)v13 + (unsigned int)v13[3]);
    }
    v15 = a3;
    if ( v14 <= *a3 )
    {
LABEL_20:
      v20 = v7;
      *v15 = 0;
      while ( 1 )
      {
        v21 = (struct _DISK_PERFORMANCE *)((char *)v20 + (unsigned int)v20[12]);
        if ( ItSpIsPhysicalDrive(v21) )
        {
          if ( *a3 >= v14 )
          {
            v12 = 1;
            goto LABEL_27;
          }
          *((_DWORD *)*a2 + (*a3)++) = v21->IdleTime.QuadPart / 10000;
        }
        if ( !v20[3] )
        {
          v12 = 0;
          goto LABEL_27;
        }
        v20 = (_DWORD *)((char *)v20 + (unsigned int)v20[3]);
      }
    }
    v16 = GetProcessHeap();
    v17 = (struct _ITSRV_DISK_PERFORMANCE_DATA *)HeapAlloc(v16, 0, 4LL * v14);
    if ( v17 )
    {
      v18 = a2;
      v19 = *a2;
      if ( *a2 )
      {
        v25 = GetProcessHeap();
        HeapFree(v25, 0, v19);
        v18 = a2;
      }
      *v18 = v17;
      v15 = a3;
      goto LABEL_20;
    }
LABEL_38:
    v12 = 8;
  }
  else
  {
LABEL_39:
    v12 = 1;
  }
LABEL_27:
  if ( v9 )
  {
    *a4 = v7;
    *a5 = v8;
  }
  else if ( v7 )
  {
    v27 = GetProcessHeap();
    HeapFree(v27, 0, v7);
  }
  return v12;
}
// 18000B779: conditional instruction was optimized away because rsi.8==0
// 1800B90A8: using guessed type __int64 __fastcall WmiQueryAllDataW(_QWORD, _QWORD, _QWORD);

//----- (000000018000B800) ----------------------------------------------------
bool __fastcall ItSpIsPhysicalDrive(struct _DISK_PERFORMANCE *const a1)
{
  WCHAR *StorageManagerName; // rbx

  StorageManagerName = a1->StorageManagerName;
  return !wcsncmp(a1->StorageManagerName, L"Partmgr ", 8uLL) || !wcsncmp(StorageManagerName, L"PhysDisk", 8uLL);
}

//----- (000000018000B860) ----------------------------------------------------
__int64 __fastcall tsched::IsUserAdmin(tsched *this)
{
  void *v1; // rax
  unsigned int v2; // edi
  WINBOOL IsMember; // [rsp+40h] [rbp+8h] BYREF
  DWORD cbSid; // [rsp+48h] [rbp+10h] BYREF
  PSID pSid; // [rsp+50h] [rbp+18h] BYREF

  IsMember = 0;
  pSid = 0LL;
  cbSid = 48;
  v1 = operator new(0x30uLL);
  wmi::AutoVectorPtr<unsigned char>::operator=(&pSid, v1);
  if ( CreateWellKnownSid(WinBuiltinAdministratorsSid, 0LL, pSid, &cbSid) )
    CheckTokenMembership(0LL, pSid, &IsMember);
  v2 = IsMember;
  operator delete(pSid);
  return v2;
}
// 18000C0C4: using guessed type __int64 __fastcall wmi::AutoVectorPtr<unsigned char>::operator=(_QWORD, _QWORD);

//----- (000000018000B8E8) ----------------------------------------------------
__int64 __fastcall IsPrincipalAllowed(User *a1, unsigned int a2)
{
  int v3; // r15d
  unsigned int v4; // r14d
  int v5; // r12d
  int v6; // esi
  tsched *v7; // rcx
  int v8; // edi
  bool v9; // di
  const WCHAR *v11; // rdi
  SC_HANDLE v12; // rax
  SC_HANDLE v13; // rsi
  SC_HANDLE v14; // rdi
  int v15; // [rsp+78h] [rbp+48h] BYREF
  __int64 v16; // [rsp+80h] [rbp+50h] BYREF
  void *v17; // [rsp+88h] [rbp+58h] BYREF

  v16 = 0LL;
  v3 = a2 & 0x8000;
  v4 = a2 >> 31;
  v5 = a2 & 0x10000;
  v6 = a2 & 0x100000;
  RpcAutoImpersonate::RpcAutoImpersonate((RpcAutoImpersonate *)&v15, L"IsPrincipalAllowed", 1);
  v8 = User::FromImpersonationToken((struct User *)&v16, 0LL);
  if ( v8 >= 0 )
  {
    v9 = (unsigned int)tsched::IsUserAdmin(v7) || User::IsLocalSystem((User *)&v16);
    if ( v15 )
      RpcRevertToSelf();
    if ( v9 && v6 )
      goto LABEL_11;
    v17 = 0LL;
    if ( (int)User::LookupSid(a1, &v17) >= 0 && v17 )
    {
      if ( User::operator==(a1, (User *)&v16) || v9 && (v5 || v3 || (_BYTE)v4 || User::IsService(a1)) )
      {
LABEL_11:
        v8 = 0;
        goto LABEL_12;
      }
      if ( User::IsServiceSid(a1) )
      {
        v11 = (const WCHAR *)*User::GetAccount((__int64)a1, (__int64 *)&v17);
        if ( v11 )
          v11 = *(const WCHAR **)v11;
        _bstr_t::_Free((_bstr_t *)&v17);
        RpcAutoImpersonate::RpcAutoImpersonate((RpcAutoImpersonate *)&v15, L"IsPrincipalAllowed", 1);
        v12 = OpenSCManagerW(0LL, 0LL, 1u);
        v13 = v12;
        if ( v12 )
        {
          v14 = OpenServiceW(v12, v11, 0xF01FFu);
          CloseServiceHandle(v13);
          if ( v14 )
          {
            CloseServiceHandle(v14);
            if ( v15 )
              RpcRevertToSelf();
            goto LABEL_11;
          }
        }
        if ( v15 )
          RpcRevertToSelf();
      }
    }
    v8 = -2147024891;
    goto LABEL_12;
  }
  if ( v15 )
    RpcRevertToSelf();
LABEL_12:
  wmi::AutoRef<User::UserEntry>::Release(&v16);
  wmi::AutoRef<User::UserEntry>::Release(a1);
  return (unsigned int)v8;
}
// 18000B95D: variable 'v7' is possibly undefined
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);

//----- (000000018000BA00) ----------------------------------------------------
char __fastcall User::IsServiceSid(User *this)
{
  struct _RTL_CRITICAL_SECTION *v2; // rbx
  char v3; // di
  User *v4; // rcx
  int v5; // esi
  PSID v6; // rsi
  PSID_IDENTIFIER_AUTHORITY SidIdentifierAuthority; // rax
  int v8; // ecx
  PUCHAR SidSubAuthorityCount; // rax
  PDWORD SidSubAuthority; // rax
  void **pExceptionObject; // [rsp+20h] [rbp-60h] BYREF
  char v13; // [rsp+28h] [rbp-58h]
  const unsigned __int16 *v14; // [rsp+30h] [rbp-50h]
  __int64 v15; // [rsp+38h] [rbp-48h]
  __int64 v16; // [rsp+40h] [rbp-40h]
  int v17; // [rsp+48h] [rbp-38h]
  int v18; // [rsp+4Ch] [rbp-34h]
  int v19; // [rsp+50h] [rbp-30h]
  __int64 v20; // [rsp+58h] [rbp-28h]
  LPCRITICAL_SECTION v21; // [rsp+60h] [rbp-20h]
  PSID pSid; // [rsp+68h] [rbp-18h] BYREF

  v20 = -2LL;
  v2 = User::s_cs;
  v21 = User::s_cs;
  EnterCriticalSection(User::s_cs);
  v3 = 0;
  if ( *(_QWORD *)this && !User::IsAlias(this) )
  {
    v5 = User::LookupSid(v4, &pSid);
    if ( v5 < 0 )
    {
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && *((char *)WPP_GLOBAL_Control + 28) < 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        WPP_SF_D(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x1Fu,
          (__int64)&WPP_0a02ad6f637a3dce55ae09b3fc909c99_Traceguids,
          v5);
      }
      v13 = 0;
      pExceptionObject = &wmi::GenericException::`vftable';
      v14 = &word_18007630E;
      v15 = 0LL;
      v16 = 0LL;
      v17 = v5;
      v18 = -1;
      v19 = -1;
      CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
    }
    v6 = pSid;
    SidIdentifierAuthority = GetSidIdentifierAuthority(pSid);
    if ( SidIdentifierAuthority )
    {
      LODWORD(pSid) = 0;
      WORD2(pSid) = 1280;
      v8 = *(_DWORD *)SidIdentifierAuthority->Value;
      if ( !*(_DWORD *)SidIdentifierAuthority->Value )
        v8 = *(unsigned __int16 *)&SidIdentifierAuthority->Value[4] - WORD2(pSid);
      if ( !v8 )
      {
        SidSubAuthorityCount = GetSidSubAuthorityCount(v6);
        if ( SidSubAuthorityCount )
        {
          if ( *SidSubAuthorityCount == 6 )
          {
            SidSubAuthority = GetSidSubAuthority(v6, 0);
            if ( SidSubAuthority )
            {
              if ( *SidSubAuthority == 80 )
                v3 = 1;
            }
          }
        }
      }
    }
  }
  LeaveCriticalSection(v2);
  return v3;
}
// 18000BA65: variable 'v4' is possibly undefined
// 1800716D8: using guessed type void *wmi::GenericException::`vftable';
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018000BB04) ----------------------------------------------------
__int64 __fastcall JobStore::GetXmlFileSystemPath(char **this, char *a2, void **a3)
{
  void *v6; // rax
  _WORD *v7; // rdx
  char *v8; // r8
  __int64 v9; // r9
  __int16 v10; // ax
  _WORD *v11; // rax
  _QWORD *v13; // rcx
  unsigned __int16 v14; // dx

  v6 = operator new(0x20AuLL);
  wmi::AutoVectorPtr<unsigned char>::operator=(a3, v6);
  v7 = *a3;
  v8 = (char *)((char *)L"\\\\?\\" - (_BYTE *)*a3);
  v9 = 261LL;
  do
  {
    if ( v9 == -2147483385 )
      break;
    v10 = *(_WORD *)((char *)v7 + (_QWORD)v8);
    if ( !v10 )
      break;
    *v7++ = v10;
    --v9;
  }
  while ( v9 );
  v11 = v7 - 1;
  if ( v9 )
    v11 = v7;
  *v11 = 0;
  if ( !v9 )
  {
    v13 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
      || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) == 0
      || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
    {
      return 2147942561LL;
    }
    v14 = 19;
    goto LABEL_39;
  }
  if ( (int)StringCchCatW((unsigned __int16 *)*a3, 261LL, *this) < 0 )
  {
    v13 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
      || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) == 0
      || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
    {
      return 2147942561LL;
    }
    v14 = 20;
    goto LABEL_39;
  }
  if ( a2 && *(_WORD *)a2 && (*((_WORD *)a2 + 1) || *(_WORD *)a2 != 92) )
  {
    if ( *(_WORD *)a2 != 92 && (int)StringCchCatW((unsigned __int16 *)*a3, 261LL, (char *)L"\\") < 0 )
    {
      v13 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
        || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) == 0
        || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
      {
        return 2147942561LL;
      }
      v14 = 21;
      goto LABEL_39;
    }
    if ( (int)StringCchCatW((unsigned __int16 *)*a3, 261LL, a2) < 0 )
    {
      v13 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
        || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) == 0
        || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
      {
        return 2147942561LL;
      }
      v14 = 22;
      goto LABEL_39;
    }
  }
  if ( JobStore::RealPathIsValid(this, (const unsigned __int16 *)*a3) )
    return 0LL;
  v13 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
  {
    v14 = 23;
LABEL_39:
    WPP_SF_SD(v13[2], v14, (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids, (const wchar_t *)a2);
  }
  return 2147942561LL;
}
// 1800764B0: using guessed type wchar_t asc_1800764B0[5];
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018000BC10) ----------------------------------------------------
bool __fastcall JobStore::RealPathIsValid(char **this, const unsigned __int16 *a2)
{
  WCHAR *v3; // rdx
  __int64 v4; // r8
  WCHAR v5; // ax
  WCHAR *v6; // rax
  WCHAR pszPrefix[264]; // [rsp+20h] [rbp-228h] BYREF

  v3 = pszPrefix;
  v4 = 261LL;
  do
  {
    if ( v4 == -2147483385 )
      break;
    v5 = *(WCHAR *)((char *)v3 + (char *)L"\\\\?\\" - (char *)pszPrefix);
    if ( !v5 )
      break;
    *v3++ = v5;
    --v4;
  }
  while ( v4 );
  v6 = v3 - 1;
  if ( v4 )
    v6 = v3;
  *v6 = 0;
  return v4 && (int)StringCchCatW(pszPrefix, 261LL, *this) >= 0 && PathIsPrefixW(pszPrefix, a2);
}
// 1800764B0: using guessed type wchar_t asc_1800764B0[5];

//----- (000000018000BCE0) ----------------------------------------------------
__int64 __fastcall TaskXmlReader::LoadTranslatedString(const wchar_t **a1)
{
  const wchar_t *v2; // rcx
  __int64 v3; // rdi
  wchar_t *v4; // rbx
  wchar_t *v5; // rax
  wchar_t *v6; // r14
  __int64 v7; // rbx
  char *v8; // rax
  WCHAR *v9; // rsi
  unsigned __int64 v10; // rdi
  char *v11; // rbp
  int v12; // r14d
  int v13; // r13d
  WCHAR *v14; // rax
  WCHAR *v15; // rbx
  HMODULE Library; // r12
  WCHAR *v17; // rax
  WCHAR *v18; // rdi
  WCHAR *v19; // rdx

  v2 = *a1;
  v3 = -1LL;
  do
    ++v3;
  while ( v2[v3] );
  if ( (unsigned int)v3 < 8 )
    return 1LL;
  if ( *v2 != 36 )
    return 1LL;
  if ( v2[1] != 40 )
    return 1LL;
  if ( v2[2] != 64 )
    return 1LL;
  v4 = wcschr(v2, 0x2Cu);
  v5 = wcschr(*a1, 0x2Du);
  v6 = v5;
  if ( !v4 || !v5 || (((char *)v5 - (char *)v4) & 0xFFFFFFFFFFFFFFFEuLL) != 2 )
    return 1LL;
  v7 = v4 - *a1;
  v8 = (char *)operator new(saturated_mul(v7 - 2, 2uLL));
  v9 = (WCHAR *)v8;
  if ( v8 && (int)StringCchCopyNW(v8, v7 - 2, (char *)*a1 + 6, v7 - 3) >= 0 )
  {
    v10 = (unsigned int)v3 - (v6 - *a1);
    v11 = (char *)operator new(saturated_mul(v10 + 1, 2uLL));
    v12 = StringCchCopyNW(v11, v10 + 1, (char *)v6 + 2, v10);
    if ( v12 >= 0 && (v13 = _wtol((const wchar_t *)v11)) != 0 )
    {
      v14 = (WCHAR *)operator new(0x208uLL);
      v15 = v14;
      if ( v14 && ExpandEnvironmentStringsW(v9, v14, 0x103u) && (Library = LoadLibraryExW(v15, 0LL, 2u)) != 0LL )
      {
        v17 = (WCHAR *)operator new(0xA000uLL);
        v18 = v17;
        if ( v17 && LoadStringW(Library, v13, v17, 20479) )
        {
          v19 = v18;
          v18 = 0LL;
          wmi::AutoVectorPtr<unsigned char>::operator=((void **)a1, v19);
        }
        else
        {
          v12 = 1;
        }
        operator delete(v18);
        FreeLibrary(Library);
      }
      else
      {
        v12 = 1;
      }
      operator delete(v15);
    }
    else
    {
      v12 = 1;
    }
    operator delete(v11);
  }
  else
  {
    v12 = 1;
  }
  operator delete(v9);
  return (unsigned int)v12;
}

//----- (000000018000BF58) ----------------------------------------------------
unsigned __int16 *__fastcall UbpmParams::CreateHostedVirtualUserName(UbpmParams *this, const struct JobMoniker *a2)
{
  unsigned __int16 *v3; // r8
  unsigned __int64 v4; // rcx
  char *v5; // rax
  _WORD *v6; // rbx
  __int16 *v7; // rax
  __int16 i; // cx
  _WORD *v10; // [rsp+40h] [rbp+8h] BYREF

  v10 = 0LL;
  v3 = (unsigned __int16 *)(JobMoniker::GetPath(a2) + 1);
  v5 = UbpmParams::NewHostedString(v4, (__int64 *)this + 15, v3, 0x7FFFFFFFuLL);
  wmi::AutoVectorPtr<unsigned char>::operator=((void **)&v10, v5);
  v6 = v10;
  v7 = v10;
  for ( i = *v10; i; i = *v7 )
  {
    if ( i == 92 )
      *v7 = 45;
    ++v7;
  }
  operator delete(0LL);
  return v6;
}
// 18000BF8C: variable 'v4' is possibly undefined

//----- (000000018000BFE4) ----------------------------------------------------
AutoThreadUIPreferredLanguages *__fastcall AutoThreadUIPreferredLanguages::AutoThreadUIPreferredLanguages(
        AutoThreadUIPreferredLanguages *this,
        const unsigned __int16 *a2,
        unsigned int *a3)
{
  void *v6; // rax
  DWORD LastError; // eax
  DWORD v9; // ebx
  DWORD v10; // eax
  ULONG pulNumLanguages; // [rsp+20h] [rbp-50h] BYREF
  __int64 v12; // [rsp+28h] [rbp-48h]
  void **pExceptionObject; // [rsp+30h] [rbp-40h] BYREF
  char v14; // [rsp+38h] [rbp-38h]
  const unsigned __int16 *v15; // [rsp+40h] [rbp-30h]
  __int64 v16; // [rsp+48h] [rbp-28h]
  __int64 v17; // [rsp+50h] [rbp-20h]
  DWORD v18; // [rsp+58h] [rbp-18h]
  int v19; // [rsp+5Ch] [rbp-14h]
  int v20; // [rsp+60h] [rbp-10h]
  ULONG pcchLanguagesBuffer; // [rsp+B8h] [rbp+48h] BYREF

  v12 = -2LL;
  *(_QWORD *)this = 0LL;
  pulNumLanguages = 0;
  pcchLanguagesBuffer = 0;
  if ( !GetThreadPreferredUILanguages(0x48u, &pulNumLanguages, 0LL, &pcchLanguagesBuffer) )
  {
    LastError = GetLastError();
    v14 = 0;
    pExceptionObject = &wmi::GenericException::`vftable';
    v15 = &word_18007630E;
    v16 = 0LL;
    v17 = 0LL;
    v18 = LastError;
    v19 = -1;
    v20 = -1;
    CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
  }
  v6 = operator new(saturated_mul(pcchLanguagesBuffer, 2uLL));
  wmi::AutoVectorPtr<unsigned char>::operator=((void **)this, v6);
  if ( !GetThreadPreferredUILanguages(0x48u, &pulNumLanguages, *(PZZWSTR *)this, &pcchLanguagesBuffer) )
  {
    v9 = GetLastError();
    wmi::AutoVectorPtr<unsigned char>::operator=((void **)this, 0LL);
    v14 = 0;
    pExceptionObject = &wmi::GenericException::`vftable';
    v15 = &word_18007630E;
    v16 = 0LL;
    v17 = 0LL;
    v18 = v9;
    v19 = -1;
    v20 = -1;
    CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
  }
  if ( !SetThreadPreferredUILanguages(8u, a2, a3) )
  {
    v10 = GetLastError();
    v14 = 0;
    pExceptionObject = &wmi::GenericException::`vftable';
    v15 = &word_18007630E;
    v16 = 0LL;
    v17 = 0LL;
    v18 = v10;
    v19 = -1;
    v20 = -1;
    CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
  }
  return this;
}
// 1800716D8: using guessed type void *wmi::GenericException::`vftable';

//----- (000000018000C0C4) ----------------------------------------------------
void **__fastcall wmi::AutoVectorPtr<unsigned char>::operator=(void **a1, void *a2)
{
  void *v4; // rcx

  v4 = *a1;
  if ( v4 )
    operator delete(v4);
  *a1 = a2;
  return a1;
}

//----- (000000018000C0FC) ----------------------------------------------------
const struct User *User::GetLocalAdmin(void)
{
  struct _RTL_CRITICAL_SECTION *v0; // rbx
  User *v1; // rdi
  User::UserEntry **v3; // r14
  void *v4; // rsi
  User *v5; // rax
  User *v6; // rcx
  User::UserEntry *v7; // rcx
  void **pExceptionObject; // [rsp+28h] [rbp-38h] BYREF
  char v9; // [rsp+30h] [rbp-30h]
  const unsigned __int16 *v10; // [rsp+38h] [rbp-28h]
  __int64 v11; // [rsp+40h] [rbp-20h]
  int v12; // [rsp+48h] [rbp-18h]
  int v13; // [rsp+4Ch] [rbp-14h]
  int v14; // [rsp+50h] [rbp-10h]
  int v15; // [rsp+54h] [rbp-Ch]
  int v16; // [rsp+58h] [rbp-8h]
  __int64 v17; // [rsp+90h] [rbp+30h] BYREF
  LPCRITICAL_SECTION v18; // [rsp+98h] [rbp+38h]
  User *v19; // [rsp+A0h] [rbp+40h]

  v0 = User::s_cs;
  v18 = User::s_cs;
  EnterCriticalSection(User::s_cs);
  v1 = (User *)*((_QWORD *)User::s_userCache + 3);
  if ( !v1 )
  {
    v3 = (User::UserEntry **)User::CreateLocalAdmin(&v17);
    v4 = User::s_userCache;
    v5 = (User *)operator new(8uLL);
    v1 = v5;
    v19 = v5;
    if ( v5 )
    {
      v7 = *v3;
      *(_QWORD *)v5 = *v3;
      if ( v7 )
        User::UserEntry::AddRef(v7);
    }
    if ( !v1 )
    {
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && *((char *)WPP_GLOBAL_Control + 28) < 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xAu, (__int64)&WPP_0a02ad6f637a3dce55ae09b3fc909c99_Traceguids);
      }
      v9 = 0;
      v10 = &word_18007630E;
      v11 = 0LL;
      v12 = 0;
      v13 = 0;
      v14 = 14;
      v15 = -1;
      v16 = -1;
      pExceptionObject = &wmi::OutOfMemoryException::`vftable';
      CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI4_AVOutOfMemoryException_wmi__);
    }
    v6 = (User *)*((_QWORD *)v4 + 3);
    if ( v1 != v6 && v6 )
      User::`scalar deleting destructor'(v6);
    *((_QWORD *)v4 + 3) = v1;
    wmi::AutoRef<User::UserEntry>::Release(&v17);
  }
  LeaveCriticalSection(v0);
  return v1;
}
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);
// 180073740: using guessed type void *wmi::OutOfMemoryException::`vftable';
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018000C1BC) ----------------------------------------------------
__int64 __fastcall JobBucket::GetDeadline(__int64 a1, __int64 a2)
{
  __int64 v2; // r8
  __int16 v3; // ax
  int v4; // eax

  v2 = *(_QWORD *)(a1 + 208);
  v3 = 0;
  if ( v2 )
  {
    v4 = *(_DWORD *)(v2 + 78);
    *(_QWORD *)a2 = *(_QWORD *)(v2 + 70);
    *(_DWORD *)(a2 + 8) = v4;
    v3 = *(_WORD *)(v2 + 82);
  }
  else
  {
    *(_QWORD *)a2 = 0LL;
    *(_DWORD *)(a2 + 8) = 0;
  }
  *(_WORD *)(a2 + 12) = v3;
  return a2;
}

//----- (000000018000C1F8) ----------------------------------------------------
#error "18000C22A: call analysis failed (funcsize=15)"

//----- (000000018000C23C) ----------------------------------------------------
__int64 __fastcall UbpmParams::NewHostedObject<std::vector<_DAB_SID_INFO *>,_DAB_SID_INFO>(
        __int64 *a1,
        _OWORD *a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10)
{
  _OWORD *v12; // rax
  char v13; // dl
  __int64 *v14; // rcx
  __int64 v16; // rax
  __int64 v17; // rdi
  _OWORD *v18; // [rsp+50h] [rbp+8h] BYREF

  v12 = operator new(0x10uLL);
  if ( v12 )
    *v12 = *a2;
  v18 = v12;
  v13 = 1;
  v14 = (__int64 *)a1[1];
  if ( &v18 >= (_OWORD **)v14 || *a1 > (unsigned __int64)&a10 )
    v13 = 0;
  if ( v13 )
  {
    v16 = *a1;
    v17 = ((__int64)&a10 - *a1) >> 3;
    if ( v14 == (__int64 *)a1[2] )
    {
      std::vector<_UBPM_ACTION_EXE_LAUNCH_PARAMS *>::_Reserve(a1);
      v16 = *a1;
      v14 = (__int64 *)a1[1];
    }
    v12 = *(_OWORD **)(v16 + 8 * v17);
  }
  else if ( v14 == (__int64 *)a1[2] )
  {
    std::vector<_UBPM_ACTION_EXE_LAUNCH_PARAMS *>::_Reserve(a1);
    v14 = (__int64 *)a1[1];
    v12 = v18;
  }
  *v14 = (__int64)v12;
  a1[1] += 8LL;
  return (__int64)v18;
}

//----- (000000018000C2D8) ----------------------------------------------------
__int64 *__fastcall _com_ptr_t<_com_IIID<IStream,&__s_GUID const _GUID_0000000c_0000_0000_c000_000000000046>>::_com_ptr_t<_com_IIID<IStream,&__s_GUID const _GUID_0000000c_0000_0000_c000_000000000046>>(
        __int64 *a1,
        _QWORD *a2)
{
  int v3; // eax
  void **pExceptionObject; // [rsp+20h] [rbp-28h] BYREF
  int v6; // [rsp+28h] [rbp-20h]
  __int128 v7; // [rsp+30h] [rbp-18h]

  *a1 = 0LL;
  if ( *a2 )
  {
    v3 = _com_ptr_t<_com_IIID<IStream,&__s_GUID const _GUID_0000000c_0000_0000_c000_000000000046>>::_QueryInterface<ATL::CComPtr<IStream>>(
           a1,
           a2);
    if ( (int)(v3 + 0x80000000) >= 0 && v3 != -2147467262 )
    {
      v6 = v3;
      pExceptionObject = &_com_error::`vftable';
      v7 = 0LL;
      CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI1_AV_com_error__);
    }
  }
  return a1;
}
// 180071858: using guessed type void *_com_error::`vftable';

//----- (000000018000C318) ----------------------------------------------------
__int64 __fastcall _com_ptr_t<_com_IIID<IStream,&__s_GUID const _GUID_0000000c_0000_0000_c000_000000000046>>::_QueryInterface<ATL::CComPtr<IStream>>(
        __int64 *a1,
        _QWORD *a2)
{
  int v3; // esi
  __int64 v4; // rbx
  __int64 v6; // [rsp+38h] [rbp+10h] BYREF

  if ( *a2 )
  {
    v3 = (**(__int64 (__fastcall ***)(_QWORD, GUID *, __int64 *))*a2)(
           *a2,
           &GUID_0000000c_0000_0000_c000_000000000046,
           &v6);
    if ( v3 < 0 )
    {
      _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::~_com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>(a1);
      *a1 = 0LL;
    }
    else
    {
      v4 = v6;
      _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::~_com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>(a1);
      *a1 = v4;
    }
  }
  else
  {
    _com_ptr_t<_com_IIID<IStream,&__s_GUID const _GUID_0000000c_0000_0000_c000_000000000046>>::operator=(a1);
    return (unsigned int)-2147467262;
  }
  return (unsigned int)v3;
}

//----- (000000018000C384) ----------------------------------------------------
bool __fastcall User::operator==(User *this, User *a2)
{
  struct _RTL_CRITICAL_SECTION *v2; // rbx
  bool v5; // di
  __int64 v6; // r8
  __int64 v7; // r8
  __int64 v8; // r9
  void *v9; // rcx
  void *v10; // rdx
  int v11; // eax
  __int64 v13; // r8
  const wchar_t ***v14; // rcx
  __int64 v15; // r9
  const wchar_t *v16; // rdx
  const wchar_t **v17; // rax
  const wchar_t *v18; // rcx

  v2 = User::s_cs;
  EnterCriticalSection(User::s_cs);
  v5 = 0;
  v6 = *(_QWORD *)a2;
  if ( !*(_QWORD *)this )
  {
    if ( v6 )
      goto LABEL_10;
    goto LABEL_11;
  }
  if ( !v6 )
    goto LABEL_10;
  if ( User::IsAlias(this) || User::IsAlias(a2) )
  {
    if ( !User::IsAlias(this) || !User::IsAlias(a2) )
      goto LABEL_10;
    goto LABEL_16;
  }
  if ( v8 == v7 )
  {
LABEL_11:
    v5 = 1;
    goto LABEL_10;
  }
  v9 = *(void **)(v8 + 32);
  if ( v9 )
  {
    v10 = *(void **)(v7 + 32);
    if ( v10 )
    {
      v11 = EqualSid(v9, v10);
LABEL_9:
      v5 = v11 != 0;
      goto LABEL_10;
    }
  }
LABEL_16:
  if ( !_bstr_t::operator!((_QWORD *)(v8 + 8)) && !_bstr_t::operator!((_QWORD *)(v13 + 8)) )
  {
    if ( *v14 )
      v16 = **v14;
    else
      v16 = 0LL;
    v17 = *(const wchar_t ***)(v15 + 8);
    if ( v17 )
      v18 = *v17;
    else
      v18 = 0LL;
    v11 = _wcsicmp(v18, v16);
    goto LABEL_9;
  }
LABEL_10:
  LeaveCriticalSection(v2);
  return v5;
}
// 18000C3EE: variable 'v8' is possibly undefined
// 18000C3EE: variable 'v7' is possibly undefined
// 180042A3F: variable 'v13' is possibly undefined
// 180042A50: variable 'v14' is possibly undefined
// 180042A60: variable 'v15' is possibly undefined

//----- (000000018000C450) ----------------------------------------------------
__int64 __fastcall UbpmParams::GetUbpmLogonType(UbpmParams *this, const struct JobMoniker *a2)
{
  int v2; // ecx

  v2 = *(_DWORD *)(*((_QWORD *)a2 + 4) + 16LL);
  if ( (v2 & 0x10000) != 0 )
    return 2LL;
  if ( (v2 & 0x20000) != 0 )
    return 5LL;
  return (unsigned int)(v2 < 0) + 4;
}

//----- (000000018000C47C) ----------------------------------------------------
ServerXMLUpdateHandler *__fastcall ServerXMLUpdateHandler::ServerXMLUpdateHandler(
        ServerXMLUpdateHandler *this,
        char a2,
        char a3,
        const unsigned __int16 *a4,
        unsigned __int16 *a5,
        const struct _TASK_USER_CRED *a6,
        unsigned int a7,
        const struct JobMoniker *a8,
        User::UserEntry **a9,
        struct Triggers::Trigulator *a10,
        struct Actions::ActionCollection *a11,
        bool a12,
        struct ATL::CComBSTR *a13,
        struct ATL::CComBSTR *a14,
        unsigned int a15)
{
  const struct _TASK_USER_CRED *v19; // rax
  int v20; // eax
  void **pExceptionObject; // [rsp+48h] [rbp-28h] BYREF
  int v23; // [rsp+50h] [rbp-20h]
  __int128 v24; // [rsp+58h] [rbp-18h]

  TriggersXmlHandler::TriggersXmlHandler(this, a8, a9, a10, a11, a15, a13, a14);
  *(_QWORD *)this = &ServerXMLUpdateHandler::`vftable';
  *((_QWORD *)this + 98) = 0LL;
  *((_QWORD *)this + 99) = 0LL;
  *((_QWORD *)this + 100) = 0LL;
  _bstr_t::_bstr_t((ServerXMLUpdateHandler *)((char *)this + 808), a4);
  _bstr_t::_bstr_t((ServerXMLUpdateHandler *)((char *)this + 816), a5);
  *((_QWORD *)this + 103) = &ServerXMLUpdateHandler::ISubHandler::`vftable';
  *((_QWORD *)this + 103) = &ServerXMLUpdateHandler::PrincipalHandler::`vftable';
  *((_QWORD *)this + 104) = a6;
  *((_DWORD *)this + 210) = a7;
  *((_DWORD *)this + 211) = 0;
  *((_WORD *)this + 424) = 0;
  *((_BYTE *)this + 850) = 0;
  *((_QWORD *)this + 107) = this;
  *((_QWORD *)this + 108) = &ServerXMLUpdateHandler::ISubHandler::`vftable';
  *((_QWORD *)this + 108) = &ServerXMLUpdateHandler::ContextHandler::`vftable';
  *((_QWORD *)this + 109) = this;
  *((_WORD *)this + 440) = 1;
  *((_BYTE *)this + 882) = 0;
  *((_QWORD *)this + 111) = &ServerXMLUpdateHandler::ISubHandler::`vftable';
  *((_QWORD *)this + 111) = &ServerXMLUpdateHandler::EnableHandler::`vftable';
  *((_BYTE *)this + 896) = 0;
  *((_BYTE *)this + 897) = a3;
  *((_BYTE *)this + 898) = 0;
  *((_QWORD *)this + 113) = this;
  *((_BYTE *)this + 912) = a2;
  *((_QWORD *)this + 115) = &ServerXMLUpdateHandler::ISubHandler::`vftable';
  *((_QWORD *)this + 115) = &ServerXMLUpdateHandler::RegistrationInfoHandler::`vftable';
  *((_WORD *)this + 464) = 0;
  *((_BYTE *)this + 930) = 0;
  *((_QWORD *)this + 117) = this;
  *((_QWORD *)this + 118) = &ServerXMLUpdateHandler::ISubHandler::`vftable';
  *((_QWORD *)this + 118) = &ServerXMLUpdateHandler::WriterHandler::`vftable';
  *((_QWORD *)this + 119) = this;
  *((_QWORD *)this + 120) = &ServerXMLUpdateHandler::NetworkInputHandler::`vftable';
  *((_QWORD *)this + 121) = this;
  *((_QWORD *)this + 124) = 0LL;
  *((_WORD *)this + 500) = 0;
  *((_OWORD *)this + 61) = 0LL;
  *((_BYTE *)this + 1002) = 0;
  *((_QWORD *)this + 126) = &ServerXMLUpdateHandler::NetworkOutputHandler::`vftable';
  *((_QWORD *)this + 127) = this;
  *((_WORD *)this + 520) = 0;
  *((_OWORD *)this + 64) = 0LL;
  *((_QWORD *)this + 131) = 0LL;
  *((_QWORD *)this + 132) = 0LL;
  *((_QWORD *)this + 133) = 0LL;
  *((_DWORD *)this + 268) = 0;
  v19 = (const struct _TASK_USER_CRED *)operator new(0x28uLL);
  a6 = v19;
  if ( v19 )
    v19 = CBstrWriter::CBstrWriter(v19);
  *((_QWORD *)this + 132) = v19;
  v20 = _com_ptr_t<_com_IIID<IStream,&__s_GUID const _GUID_0000000c_0000_0000_c000_000000000046>>::_QueryInterface<ATL::CComPtr<IStream>>(
          (__int64 *)this + 133,
          (_QWORD *)this + 132);
  if ( (int)(v20 + 0x80000000) >= 0 && v20 != -2147467262 )
  {
    pExceptionObject = &_com_error::`vftable';
    v23 = v20;
    v24 = 0LL;
    CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI1_AV_com_error__);
  }
  if ( (unsigned __int64)((__int64)(*((_QWORD *)this + 100) - *((_QWORD *)this + 98)) >> 3) < 6 )
    std::vector<_CSebiSystemEventCreationParameter *>::_Reallocate((__int64)this + 784, 6uLL);
  a6 = (ServerXMLUpdateHandler *)((char *)this + 920);
  std::vector<ServerXMLUpdateHandler::ISubHandler *>::push_back((__int64 *)this + 98, (__int64 *)&a6);
  if ( *((_QWORD *)this + 104) )
  {
    a6 = (ServerXMLUpdateHandler *)((char *)this + 824);
    std::vector<ServerXMLUpdateHandler::ISubHandler *>::push_back((__int64 *)this + 98, (__int64 *)&a6);
  }
  if ( *((_BYTE *)this + 880) )
  {
    a6 = (ServerXMLUpdateHandler *)((char *)this + 864);
    std::vector<ServerXMLUpdateHandler::ISubHandler *>::push_back((__int64 *)this + 98, (__int64 *)&a6);
  }
  if ( *((_BYTE *)this + 912) )
  {
    a6 = (ServerXMLUpdateHandler *)((char *)this + 888);
    std::vector<ServerXMLUpdateHandler::ISubHandler *>::push_back((__int64 *)this + 98, (__int64 *)&a6);
  }
  if ( a12 )
    a6 = (ServerXMLUpdateHandler *)((char *)this + 960);
  else
    a6 = (ServerXMLUpdateHandler *)((char *)this + 1008);
  std::vector<ServerXMLUpdateHandler::ISubHandler *>::push_back((__int64 *)this + 98, (__int64 *)&a6);
  a6 = (ServerXMLUpdateHandler *)((char *)this + 944);
  std::vector<ServerXMLUpdateHandler::ISubHandler *>::push_back((__int64 *)this + 98, (__int64 *)&a6);
  return this;
}
// 180070630: using guessed type void *ServerXMLUpdateHandler::NetworkInputHandler::`vftable';
// 180070640: using guessed type void *ServerXMLUpdateHandler::PrincipalHandler::`vftable';
// 180070650: using guessed type void *ServerXMLUpdateHandler::`vftable';
// 180071858: using guessed type void *_com_error::`vftable';
// 1800736E0: using guessed type void *ServerXMLUpdateHandler::ISubHandler::`vftable';
// 1800736F0: using guessed type void *ServerXMLUpdateHandler::NetworkOutputHandler::`vftable';
// 180073700: using guessed type void *ServerXMLUpdateHandler::WriterHandler::`vftable';
// 180073710: using guessed type void *ServerXMLUpdateHandler::RegistrationInfoHandler::`vftable';
// 180073720: using guessed type void *ServerXMLUpdateHandler::EnableHandler::`vftable';
// 180073730: using guessed type void *ServerXMLUpdateHandler::ContextHandler::`vftable';

//----- (000000018000C790) ----------------------------------------------------
__int64 __fastcall std::vector<ServerXMLUpdateHandler::ISubHandler *>::push_back(__int64 *a1, __int64 *a2)
{
  __int64 *v4; // rcx
  __int64 result; // rax
  __int64 v7; // rax
  __int64 v8; // rdi

  v4 = (__int64 *)a1[1];
  if ( a2 < v4 && *a1 <= (unsigned __int64)a2 )
  {
    v7 = *a1;
    v8 = ((__int64)a2 - *a1) >> 3;
    if ( v4 == (__int64 *)a1[2] )
    {
      std::vector<ServerXMLUpdateHandler::ISubHandler *>::_Reserve(a1);
      v7 = *a1;
      v4 = (__int64 *)a1[1];
    }
    result = *(_QWORD *)(v7 + 8 * v8);
  }
  else
  {
    if ( v4 == (__int64 *)a1[2] )
    {
      std::vector<ServerXMLUpdateHandler::ISubHandler *>::_Reserve(a1);
      v4 = (__int64 *)a1[1];
    }
    result = *a2;
  }
  *v4 = result;
  a1[1] += 8LL;
  return result;
}

//----- (000000018000C7E4) ----------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
__int64 __fastcall StringReader::CreateStream(__int64 a1, __int64 *a2)
{
  __int64 v4; // rbx
  _DWORD *v5; // rax
  void **pExceptionObject; // [rsp+28h] [rbp-38h] BYREF
  char v8; // [rsp+30h] [rbp-30h]
  const unsigned __int16 *v9; // [rsp+38h] [rbp-28h]
  __int64 v10; // [rsp+40h] [rbp-20h]
  __int64 v11; // [rsp+48h] [rbp-18h]
  _DWORD *v12; // [rsp+80h] [rbp+20h] BYREF

  if ( !a1 )
    return 2147942487LL;
  v4 = -1LL;
  do
    ++v4;
  while ( *(_WORD *)(a1 + 2 * v4) );
  v5 = operator new(0x28uLL);
  v12 = v5;
  if ( v5 )
  {
    v5[2] = 0;
    *(_QWORD *)v5 = &StringReader::`vftable';
    *((_QWORD *)v5 + 2) = -1LL;
    v5[6] = v4;
    *((_QWORD *)v5 + 4) = a1;
  }
  else
  {
    v5 = 0LL;
  }
  v12 = v5;
  _com_ptr_t<_com_IIID<IStream,&__s_GUID const _GUID_0000000c_0000_0000_c000_000000000046>>::operator=<StringReader *>(
    a2,
    &v12);
  if ( !*a2 )
  {
    v8 = 0;
    v9 = &word_18007630E;
    v10 = 0LL;
    v11 = 0LL;
    pExceptionObject = &wmi::OutOfMemoryException::`vftable';
    CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI4_AVOutOfMemoryException_wmi__);
  }
  return 0LL;
}
// 180042B36: ignored the value written to the shadow area of the succeeding call
// 180042B32: ignored the value written to the shadow area of the succeeding call
// 180042B2B: ignored the value written to the shadow area of the succeeding call
// 180042B50: bad sp value at call
// 180070670: using guessed type void *StringReader::`vftable';
// 180073740: using guessed type void *wmi::OutOfMemoryException::`vftable';

//----- (000000018000C890) ----------------------------------------------------
StringReader *__fastcall StringReader::`scalar deleting destructor'(StringReader *this, char a2)
{
  *(_QWORD *)this = &StringReader::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 180070670: using guessed type void *StringReader::`vftable';

//----- (000000018000C8C0) ----------------------------------------------------
__int64 *__fastcall _com_ptr_t<_com_IIID<IStream,&__s_GUID const _GUID_0000000c_0000_0000_c000_000000000046>>::operator=<StringReader *>(
        __int64 *a1,
        _QWORD *a2)
{
  int v3; // esi
  __int64 v4; // rbx
  void **pExceptionObject; // [rsp+20h] [rbp-28h] BYREF
  int v7; // [rsp+28h] [rbp-20h]
  __int128 v8; // [rsp+30h] [rbp-18h]
  __int64 v9; // [rsp+58h] [rbp+10h] BYREF

  if ( *a2 )
  {
    v3 = (**(__int64 (__fastcall ***)(_QWORD, GUID *, __int64 *))*a2)(
           *a2,
           &GUID_0000000c_0000_0000_c000_000000000046,
           &v9);
    if ( v3 < 0 )
    {
      _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::~_com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>(a1);
      *a1 = 0LL;
    }
    else
    {
      v4 = v9;
      _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::~_com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>(a1);
      *a1 = v4;
    }
  }
  else
  {
    _com_ptr_t<_com_IIID<IStream,&__s_GUID const _GUID_0000000c_0000_0000_c000_000000000046>>::operator=(a1);
    v3 = -2147467262;
  }
  if ( (int)(v3 + 0x80000000) >= 0 && v3 != -2147467262 )
  {
    v7 = v3;
    pExceptionObject = &_com_error::`vftable';
    v8 = 0LL;
    CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI1_AV_com_error__);
  }
  return a1;
}
// 180071858: using guessed type void *_com_error::`vftable';

//----- (000000018000C944) ----------------------------------------------------
TriggersXmlHandler *__fastcall TriggersXmlHandler::TriggersXmlHandler(
        TriggersXmlHandler *this,
        const struct JobMoniker *a2,
        User::UserEntry **a3,
        struct Triggers::Trigulator *a4,
        struct Actions::ActionCollection *a5,
        unsigned int a6,
        struct ATL::CComBSTR *a7,
        struct ATL::CComBSTR *a8)
{
  User::UserEntry *v11; // rcx
  TriggersXmlHandler *result; // rax

  ValidationXmlHandler::ValidationXmlHandler(this, a2, a6, a7, a8);
  *(_QWORD *)this = &TriggersXmlHandler::`vftable';
  *((_BYTE *)this + 512) = 0;
  v11 = *a3;
  *((_QWORD *)this + 65) = *a3;
  if ( v11 )
    User::UserEntry::AddRef(v11);
  *((_QWORD *)this + 67) = a5;
  result = this;
  *((_QWORD *)this + 66) = a4;
  *((_QWORD *)this + 68) = 0LL;
  *((_QWORD *)this + 71) = 0LL;
  *((_QWORD *)this + 73) = 0LL;
  *((_QWORD *)this + 74) = 0LL;
  *((_QWORD *)this + 75) = 0LL;
  *((_QWORD *)this + 76) = 0LL;
  *((_QWORD *)this + 77) = 0LL;
  *((_QWORD *)this + 78) = 0LL;
  *((_QWORD *)this + 79) = 0LL;
  *((_QWORD *)this + 80) = 0LL;
  *((_QWORD *)this + 81) = 0LL;
  *((_QWORD *)this + 82) = 0LL;
  *((_QWORD *)this + 83) = 0LL;
  *((_QWORD *)this + 84) = 0LL;
  *((_QWORD *)this + 85) = 0LL;
  *((_QWORD *)this + 86) = 0LL;
  *((_QWORD *)this + 87) = 0LL;
  *((_QWORD *)this + 88) = 0LL;
  *((_QWORD *)this + 89) = 0LL;
  *((_QWORD *)this + 90) = 0LL;
  *((_QWORD *)this + 91) = 0LL;
  *((_QWORD *)this + 92) = 0LL;
  *((_QWORD *)this + 93) = 0LL;
  *((_QWORD *)this + 94) = 0LL;
  *((_QWORD *)this + 95) = 0LL;
  *((_QWORD *)this + 96) = 0LL;
  *((_QWORD *)this + 97) = 0LL;
  return result;
}
// 1800706E8: using guessed type void *TriggersXmlHandler::`vftable';

//----- (000000018000CA98) ----------------------------------------------------
JobMoniker *__fastcall JobMoniker::JobMoniker(JobMoniker *this, const struct JobMoniker *a2, __int64 a3)
{
  JobMoniker *result; // rax

  *((_QWORD *)this + 2) = 0LL;
  *((_QWORD *)this + 4) = 0LL;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x40) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
  {
    WPP_SF_qq(*((_QWORD *)WPP_GLOBAL_Control + 2), (__int64)a2, a3, this, a2);
  }
  wmi::AutoRef<JobBucket>::operator=((wmi::RefBase **)this + 4, *((volatile signed __int32 **)a2 + 4));
  _bstr_t::operator=((__int64 *)this + 2, (__int64 *)a2 + 2);
  *((_QWORD *)this + 3) = *((_QWORD *)a2 + 3);
  result = this;
  *(_OWORD *)this = *(_OWORD *)a2;
  return result;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018000CB24) ----------------------------------------------------
ValidationXmlHandler *__fastcall ValidationXmlHandler::ValidationXmlHandler(
        ValidationXmlHandler *this,
        const struct JobMoniker *a2,
        __int64 a3,
        struct ATL::CComBSTR *a4,
        struct ATL::CComBSTR *a5)
{
  int v6; // ebx

  v6 = a3;
  *(_QWORD *)this = &ValidationXmlHandler::`vftable';
  JobMoniker::JobMoniker((ValidationXmlHandler *)((char *)this + 8), a2, a3);
  *((_DWORD *)this + 12) = v6;
  *((_QWORD *)this + 7) = a4;
  *((_QWORD *)this + 8) = a5;
  *((_QWORD *)this + 9) = 0LL;
  *((_QWORD *)this + 10) = 0LL;
  *((_QWORD *)this + 11) = 0LL;
  _bstr_t::_bstr_t((ValidationXmlHandler *)((char *)this + 96), L"Author");
  *((_WORD *)this + 52) = 0;
  *((_DWORD *)this + 27) = 0;
  ValidationXmlHandler::CurrentTrigger::CurrentTrigger((ValidationXmlHandler *)((char *)this + 112));
  *((_BYTE *)this + 416) = 0;
  *((_QWORD *)this + 53) = 0LL;
  *((_DWORD *)this + 108) = -1;
  *(_QWORD *)((char *)this + 436) = 0LL;
  *((_QWORD *)this + 56) = 0LL;
  *((_QWORD *)this + 57) = 0LL;
  *((_QWORD *)this + 58) = 0LL;
  *((_QWORD *)this + 59) = 0LL;
  *((_QWORD *)this + 60) = 0LL;
  *((_WORD *)this + 244) = 0;
  *((_QWORD *)this + 62) = 0LL;
  *((_QWORD *)this + 63) = 0LL;
  *((_QWORD *)this + 62) = std::_Tree_alloc<0,std::_Tree_base_types<std::pair<User const,LogonJob *>>>::_Buyheadnode();
  return this;
}
// 180070708: using guessed type void *ValidationXmlHandler::`vftable';

//----- (000000018000CC18) ----------------------------------------------------
__int64 __fastcall StringCchCopyExW(
        STRSAFE_LPWSTR pszDest,
        size_t a2,
        const unsigned __int16 *a3,
        unsigned __int16 **a4,
        unsigned __int64 *a5)
{
  unsigned __int16 *v5; // rdi
  HRESULT v6; // r10d
  unsigned __int64 v8; // rbx
  size_t v10; // [rsp+20h] [rbp-28h]
  size_t v11[3]; // [rsp+30h] [rbp-18h] BYREF

  v5 = pszDest;
  v6 = 0;
  if ( a2 - 1 > 0x7FFFFFFE )
    v6 = -2147024809;
  v8 = a2;
  if ( v6 < 0 )
  {
    if ( a2 )
      *pszDest = 0;
  }
  else
  {
    v6 = 0;
    if ( a2 )
    {
      v11[0] = 0LL;
      v6 = StringCopyWorkerW(pszDest, a2, v11, a3, v10);
      v8 -= v11[0];
      v5 += v11[0];
      if ( (int)(v6 + 0x80000000) >= 0 && v6 != -2147024774 )
        return (unsigned int)v6;
    }
    else if ( *a3 )
    {
      if ( !pszDest )
        return (unsigned int)-2147024809;
      v6 = -2147024774;
    }
    if ( a4 )
      *a4 = v5;
    if ( a5 )
      *a5 = v8;
  }
  return (unsigned int)v6;
}
// 18000CC70: variable 'v10' is possibly undefined
// 18000CC18: using guessed type size_t var_18[3];

//----- (000000018000CCD0) ----------------------------------------------------
HRESULT __stdcall StringCopyWorkerW(
        STRSAFE_LPWSTR pszDest,
        size_t cchDest,
        size_t *pcchNewDestLength,
        STRSAFE_PCNZWCH pszSrc,
        size_t cchToCopy)
{
  STRSAFE_LPWSTR v5; // r10
  size_t v6; // r11
  __int64 v7; // rax
  signed __int64 v8; // r9
  wchar_t v9; // cx
  STRSAFE_LPWSTR v10; // rcx
  HRESULT result; // eax
  size_t v12; // rcx

  v5 = pszDest;
  v6 = 0LL;
  if ( cchDest )
  {
    v7 = 2147483646LL;
    v8 = (char *)pszSrc - (char *)pszDest;
    do
    {
      if ( !v7 )
        break;
      v9 = *(STRSAFE_LPWSTR)((char *)v5 + v8);
      if ( !v9 )
        break;
      *v5 = v9;
      --v7;
      ++v5;
      ++v6;
      --cchDest;
    }
    while ( cchDest );
  }
  v10 = v5 - 1;
  result = cchDest == 0 ? 0x8007007A : 0;
  if ( cchDest )
    v10 = v5;
  *v10 = 0;
  if ( pcchNewDestLength )
  {
    v12 = v6 - 1;
    if ( cchDest )
      v12 = v6;
    *pcchNewDestLength = v12;
  }
  return result;
}

//----- (000000018000CD50) ----------------------------------------------------
__int64 __fastcall SchRpcEnumTasks(
        __int64 a1,
        char *a2,
        int a3,
        unsigned int *a4,
        unsigned int a5,
        unsigned int *a6,
        unsigned __int16 ***a7)
{
  return RpcServer::EnumFolder((RpcServer *)&RpcServer::s_singleton, a2, 0, a3, a4, a5, a6, a7);
}
// 18000CD50: could not find valid save-restore pair for rbp
// 1800B0D48: using guessed type __int64 RpcServer::s_singleton;

//----- (000000018000CDB4) ----------------------------------------------------
FolderEnumerator *__fastcall FolderEnumerator::FolderEnumerator(
        FolderEnumerator *this,
        const unsigned __int16 *a2,
        char a3)
{
  const unsigned __int16 *v5; // rdx
  int v6; // eax
  void **pExceptionObject; // [rsp+28h] [rbp-40h] BYREF
  char v9; // [rsp+30h] [rbp-38h]
  const unsigned __int16 *v10; // [rsp+38h] [rbp-30h]
  __int64 v11; // [rsp+40h] [rbp-28h]
  int v12; // [rsp+48h] [rbp-20h]
  int v13; // [rsp+4Ch] [rbp-1Ch]
  int v14; // [rsp+50h] [rbp-18h]
  int v15; // [rsp+54h] [rbp-14h]
  int v16; // [rsp+58h] [rbp-10h]

  *(_QWORD *)this = &wmi::RefBase::`vftable';
  *((_DWORD *)this + 2) = 0;
  *(_QWORD *)this = &FolderEnumerator::`vftable';
  _bstr_t::_bstr_t((FolderEnumerator *)((char *)this + 16), a2);
  *((_QWORD *)this + 3) = 0LL;
  *((_BYTE *)this + 32) = a3;
  *((_QWORD *)this + 5) = 0LL;
  v5 = (const unsigned __int16 *)*((_QWORD *)this + 2);
  if ( v5 )
    v5 = *(const unsigned __int16 **)v5;
  v6 = JobStore::RegFolderEntryOpen((HKEY *)JobStore::m_pCommonStore, v5, (HKEY *)this + 3);
  if ( v6 < 0 )
  {
    v9 = 0;
    pExceptionObject = &wmi::GenericException::`vftable';
    v10 = &word_18007630E;
    v11 = 0LL;
    v12 = 0;
    v13 = 0;
    v14 = v6;
    v15 = -1;
    v16 = -1;
    CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
  }
  *((_DWORD *)this + 9) = -1;
  return this;
}
// 180070728: using guessed type void *FolderEnumerator::`vftable';
// 180070980: using guessed type void *wmi::RefBase::`vftable';
// 1800716D8: using guessed type void *wmi::GenericException::`vftable';

//----- (000000018000CE50) ----------------------------------------------------
__int64 __fastcall JobStore::RegFolderEntryOpen(HKEY *this, const unsigned __int16 *a2, HKEY *a3)
{
  const unsigned __int16 *v6; // rdx
  const WCHAR *v7; // rdx
  LSTATUS v8; // eax
  unsigned int v9; // ebx
  const WCHAR **v11; // [rsp+50h] [rbp+8h] BYREF
  BSTR *v12; // [rsp+58h] [rbp+10h] BYREF

  _bstr_t::_bstr_t((_bstr_t *)&v11, L"TaskCache\\Tree\\");
  if ( a2 )
  {
    v6 = a2 + 1;
    if ( *a2 != 92 )
      v6 = a2;
    _bstr_t::_bstr_t((_bstr_t *)&v12, v6);
    _bstr_t::operator+=((OLECHAR ***)&v11, &v12);
    _bstr_t::_Free((_bstr_t *)&v12);
  }
  if ( v11 )
    v7 = *v11;
  else
    v7 = 0LL;
  v8 = RegOpenKeyExW(this[2], v7, 0, 0x20019u, a3);
  v9 = v8;
  if ( v8 > 0 )
    v9 = (unsigned __int16)v8 | 0x80070000;
  _bstr_t::_Free((_bstr_t *)&v11);
  return v9;
}

//----- (000000018000CF14) ----------------------------------------------------
__int64 __fastcall UbpmParams::NewHostedObject<std::vector<_CSebiSystemEventCreationParameter *>,_CSebiSystemEventCreationParameter>(
        __int64 *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10)
{
  _OWORD *v12; // rax
  char v13; // dl
  __int64 *v14; // rcx
  __int64 v16; // rax
  __int64 v17; // rdi
  _OWORD *v18; // [rsp+50h] [rbp+8h] BYREF

  v12 = operator new(0x38uLL);
  if ( v12 )
  {
    *v12 = *(_OWORD *)a2;
    v12[1] = *(_OWORD *)(a2 + 16);
    v12[2] = *(_OWORD *)(a2 + 32);
    *((_QWORD *)v12 + 6) = *(_QWORD *)(a2 + 48);
  }
  v18 = v12;
  v13 = 1;
  v14 = (__int64 *)a1[1];
  if ( &v18 >= (_OWORD **)v14 || *a1 > (unsigned __int64)&a10 )
    v13 = 0;
  if ( v13 )
  {
    v16 = *a1;
    v17 = ((__int64)&a10 - *a1) >> 3;
    if ( v14 == (__int64 *)a1[2] )
    {
      std::vector<_UBPM_ACTION_EXE_LAUNCH_PARAMS *>::_Reserve(a1);
      v16 = *a1;
      v14 = (__int64 *)a1[1];
    }
    v12 = *(_OWORD **)(v16 + 8 * v17);
  }
  else if ( v14 == (__int64 *)a1[2] )
  {
    std::vector<_UBPM_ACTION_EXE_LAUNCH_PARAMS *>::_Reserve(a1);
    v14 = (__int64 *)a1[1];
    v12 = v18;
  }
  *v14 = (__int64)v12;
  a1[1] += 8LL;
  return (__int64)v18;
}

//----- (000000018000CFC8) ----------------------------------------------------
unsigned __int16 **__fastcall UbpmParams::GetActionIdArray(UbpmParams *this)
{
  void **v1; // rsi
  __int64 v2; // rbx
  char *v3; // rdx
  void *v6; // rax
  __int64 *i; // rax
  __int64 v8; // rcx

  v1 = (void **)((char *)this + 376);
  v2 = 0LL;
  v3 = (char *)*((_QWORD *)this + 47);
  if ( !v3 )
  {
    *((_DWORD *)this + 92) = 1;
    v6 = operator new(saturated_mul((__int64)(*((_QWORD *)this + 44) - *((_QWORD *)this + 43)) >> 3, 8uLL));
    wmi::AutoVectorPtr<unsigned char>::operator=(v1, v6);
    for ( i = (__int64 *)*((_QWORD *)this + 43); ; ++i )
    {
      v3 = (char *)*v1;
      if ( i == *((__int64 **)this + 44) )
        break;
      v8 = *i;
      *(_QWORD *)&v3[v2] = v8;
      v2 += 8LL;
    }
  }
  return (unsigned __int16 **)v3;
}

//----- (000000018000D070) ----------------------------------------------------
__int64 __fastcall UbpmParams::AddCSEBTrigger(__int64 *a1, int a2, __int64 a3, __int64 a4, int a5)
{
  __int64 v7; // [rsp+20h] [rbp-31h]
  __int64 v8; // [rsp+28h] [rbp-29h]
  __int128 v9; // [rsp+30h] [rbp-21h] BYREF
  int v10; // [rsp+50h] [rbp-1h]
  int v11; // [rsp+54h] [rbp+3h]
  unsigned __int16 **ActionIdArray; // [rsp+58h] [rbp+7h]
  __int64 v13; // [rsp+60h] [rbp+Fh] BYREF
  int v14; // [rsp+68h] [rbp+17h]
  int v15; // [rsp+6Ch] [rbp+1Bh]
  int v16; // [rsp+70h] [rbp+1Fh]
  int v17; // [rsp+74h] [rbp+23h]
  __int64 v18; // [rsp+78h] [rbp+27h]
  __int128 v19; // [rsp+80h] [rbp+2Fh]
  __int64 v20; // [rsp+90h] [rbp+3Fh]

  v10 = 0;
  v13 = 0LL;
  v14 = a2;
  v18 = 0LL;
  v20 = 0LL;
  v19 = 0LL;
  v15 = a3;
  v16 = a4;
  v17 = a5;
  *((_QWORD *)&v9 + 1) = UbpmParams::NewHostedObject<std::vector<_CSebiSystemEventCreationParameter *>,_CSebiSystemEventCreationParameter>(
                           a1 + 75,
                           (__int64)&v13,
                           a3,
                           a4,
                           v7,
                           v8,
                           2LL,
                           *((__int64 *)&v9 + 1),
                           0xFFFFFFFF00000000uLL,
                           0LL);
  v11 = (a1[44] - a1[43]) >> 3;
  ActionIdArray = UbpmParams::GetActionIdArray((UbpmParams *)a1);
  std::vector<_UBPM_TRIGGER_PARAMS>::push_back(a1 + 112, &v9);
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
  {
    WPP_SF_SdD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x14u,
      (__int64)&WPP_f0f7296807f33a7e423f6d049324e537_Traceguids,
      *(const wchar_t **)(a1[1] + 24));
  }
  return 0LL;
}
// 18000D0D5: variable 'v7' is possibly undefined
// 18000D0D5: variable 'v8' is possibly undefined
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018000D178) ----------------------------------------------------
__int64 __fastcall JobBucket::GetExpiration(JobBucket *this)
{
  __int64 v1; // rax

  v1 = *((_QWORD *)this + 26);
  if ( v1 )
    return *(unsigned int *)(v1 + 12);
  else
    return 0xFFFFFFFFLL;
}

//----- (000000018000D194) ----------------------------------------------------
__int64 __fastcall Actions::ActionCollection::ExportToUbpmFormat(__int64 **this, struct IUbpmRegistrationParams *a2)
{
  __int64 result; // rax
  __int64 *v5; // rbx

  result = 0LL;
  v5 = *this;
  do
  {
    v5 = (__int64 *)*v5;
    if ( v5 == *this )
      break;
    result = (*(__int64 (__fastcall **)(__int64, struct IUbpmRegistrationParams *))(*(_QWORD *)v5[2] + 64LL))(v5[2], a2);
  }
  while ( (int)result >= 0 );
  return result;
}
// 18000D194: could not find valid save-restore pair for rbp

//----- (000000018000D200) ----------------------------------------------------
char __fastcall std::vector<_UBPM_ACTION_PARAMS>::push_back(__int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 v4; // rcx
  char result; // al
  __int64 v6; // xmm0_8
  __int64 v7; // r8
  __int64 v8; // rdi

  v4 = a1[1];
  result = a2 < v4 && *a1 <= a2;
  if ( result )
  {
    v7 = *a1;
    v8 = (__int64)(a2 - *a1) / 40;
    if ( v4 == a1[2] )
    {
      std::vector<_UBPM_ACTION_PARAMS>::_Reserve(a1);
      v7 = *a1;
      v4 = a1[1];
    }
    result = 5 * v8;
    *(_OWORD *)v4 = *(_OWORD *)(v7 + 40 * v8);
    *(_OWORD *)(v4 + 16) = *(_OWORD *)(v7 + 40 * v8 + 16);
    v6 = *(_QWORD *)(v7 + 40 * v8 + 32);
  }
  else
  {
    if ( v4 == a1[2] )
    {
      result = std::vector<_UBPM_ACTION_PARAMS>::_Reserve(a1);
      v4 = a1[1];
    }
    *(_OWORD *)v4 = *(_OWORD *)a2;
    *(_OWORD *)(v4 + 16) = *(_OWORD *)(a2 + 16);
    v6 = *(_QWORD *)(a2 + 32);
  }
  *(_QWORD *)(v4 + 32) = v6;
  a1[1] += 40LL;
  return result;
}

//----- (000000018000D270) ----------------------------------------------------
__int64 __fastcall std::vector<_UBPM_ACTION_PARAMS>::_Reallocate(__int64 *a1, unsigned __int64 a2)
{
  LPVOID v4; // rbx
  __int64 v5; // r14
  __int64 result; // rax

  v4 = 0LL;
  if ( a2 )
  {
    if ( a2 > 0x666666666666666LL || (v4 = operator new(40 * a2)) == 0LL )
      std::_Xbad_alloc();
  }
  std::_Uninit_move<_UBPM_ACTION_PARAMS *,_UBPM_ACTION_PARAMS *,std::allocator<_UBPM_ACTION_PARAMS>,_UBPM_ACTION_PARAMS>(
    *a1,
    a1[1],
    (__int64)v4);
  v5 = (a1[1] - *a1) / 40;
  if ( *a1 )
    operator delete((void *)*a1);
  a1[2] = (__int64)v4 + 40 * a2;
  result = 5 * v5;
  a1[1] = (__int64)v4 + 40 * v5;
  *a1 = (__int64)v4;
  return result;
}

//----- (000000018000D350) ----------------------------------------------------
__int64 __fastcall std::_Uninit_move<_UBPM_ACTION_PARAMS *,_UBPM_ACTION_PARAMS *,std::allocator<_UBPM_ACTION_PARAMS>,_UBPM_ACTION_PARAMS>(
        __int64 a1,
        __int64 a2,
        __int64 a3)
{
  while ( a1 != a2 )
  {
    *(_OWORD *)a3 = *(_OWORD *)a1;
    *(_OWORD *)(a3 + 16) = *(_OWORD *)(a1 + 16);
    *(_QWORD *)(a3 + 32) = *(_QWORD *)(a1 + 32);
    a3 += 40LL;
    a1 += 40LL;
  }
  return a3;
}

//----- (000000018000D378) ----------------------------------------------------
__int64 __fastcall UbpmParams::GetPtr(UbpmParams *this, unsigned __int8 **a2)
{
  __int64 v2; // rax
  __int64 v4; // r8
  __int64 v5; // rax
  __int64 v6; // rdx
  unsigned __int64 v7; // rdx
  __int128 v8; // xmm0

  v2 = *((_QWORD *)this + 112);
  v4 = *((_QWORD *)this + 113);
  if ( v2 != v4 )
  {
    *((_QWORD *)this + 5) = *((_QWORD *)this + 112);
    *((_DWORD *)this + 9) = (v4 - v2) / 48;
  }
  v5 = *((_QWORD *)this + 33);
  v6 = *((_QWORD *)this + 34);
  if ( v5 != v6 )
  {
    v7 = (__int64)((unsigned __int128)((v6 - v5) * (__int128)0x6666666666666667LL) >> 64) >> 4;
    *((_QWORD *)this + 7) = *((_QWORD *)this + 33);
    *((_DWORD *)this + 12) = (v7 >> 63) + v7;
  }
  v8 = *(_OWORD *)((char *)this + 424);
  *((_QWORD *)this + 8) = *((_QWORD *)this + 115);
  *(_OWORD *)((char *)this + 100) = v8;
  *a2 = (unsigned __int8 *)this + 16;
  return 0LL;
}

//----- (000000018000D424) ----------------------------------------------------
__int64 __fastcall std::vector<_UBPM_ACTION_PARAMS>::_Reserve(__int64 *a1)
{
  __int64 v2; // rcx
  __int64 v3; // r8
  __int64 result; // rax
  __int64 v5; // rdx
  unsigned __int64 v6; // r8
  __int64 v7; // rdx
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // rdx

  v2 = a1[2];
  v3 = a1[1];
  result = (unsigned __int64)((unsigned __int128)((v2 - v3) * (__int128)0x6666666666666667LL) >> 64) >> 63;
  if ( !((v2 - v3) / 40) )
  {
    v5 = (v3 - *a1) / 40;
    if ( v5 == 0x666666666666666LL )
      std::_Xlength_error("vector<T> too long");
    v6 = v5 + 1;
    v7 = (unsigned __int128)((v2 - *a1) * (__int128)0x6666666666666667LL) >> 64;
    v8 = 0LL;
    v9 = ((unsigned __int64)v7 >> 63) + (v7 >> 4);
    if ( 0x666666666666666LL - (v9 >> 1) >= v9 )
      v8 = v9 + (v9 >> 1);
    if ( v8 >= v6 )
      v6 = v8;
    return std::vector<_UBPM_ACTION_PARAMS>::_Reallocate(a1, v6);
  }
  return result;
}

//----- (000000018000D4DC) ----------------------------------------------------
unsigned __int8 __fastcall std::vector<_UBPM_TRIGGER_PARAMS>::push_back(__int64 *a1, _OWORD *a2)
{
  _OWORD *v4; // rcx
  unsigned __int8 result; // al
  __int128 v6; // xmm0
  __int64 v7; // r8
  __int64 v8; // rdi

  v4 = (_OWORD *)a1[1];
  result = a2 < v4 && *a1 <= (unsigned __int64)a2;
  if ( result )
  {
    v7 = *a1;
    v8 = ((__int64)a2 - *a1) / 48;
    if ( v4 == (_OWORD *)a1[2] )
    {
      std::vector<_UBPM_TRIGGER_PARAMS>::_Reserve((__int64)a1);
      v7 = *a1;
      v4 = (_OWORD *)a1[1];
    }
    result = 6 * v8;
    *v4 = *(_OWORD *)(v7 + 48 * v8);
    v4[1] = *(_OWORD *)(v7 + 48 * v8 + 16);
    v6 = *(_OWORD *)(v7 + 48 * v8 + 32);
  }
  else
  {
    if ( v4 == (_OWORD *)a1[2] )
    {
      result = (unsigned __int8)std::vector<_UBPM_TRIGGER_PARAMS>::_Reserve((__int64)a1);
      v4 = (_OWORD *)a1[1];
    }
    *v4 = *a2;
    v4[1] = a2[1];
    v6 = a2[2];
  }
  v4[2] = v6;
  a1[1] += 48LL;
  return result;
}

//----- (000000018000D548) ----------------------------------------------------
_OWORD *__fastcall std::vector<_UBPM_TRIGGER_PARAMS>::_Reallocate(void **a1, unsigned __int64 a2)
{
  _OWORD *v4; // rbx
  __int64 v5; // r14
  _OWORD *result; // rax

  v4 = 0LL;
  if ( a2 )
  {
    if ( a2 > 0x555555555555555LL || (v4 = operator new(48 * a2)) == 0LL )
      std::_Xbad_alloc();
  }
  std::_Uninit_move<_UBPM_TRIGGER_PARAMS *,_UBPM_TRIGGER_PARAMS *,std::allocator<_UBPM_TRIGGER_PARAMS>,_UBPM_TRIGGER_PARAMS>(
    *a1,
    a1[1],
    v4);
  v5 = ((_BYTE *)a1[1] - (_BYTE *)*a1) / 48;
  if ( *a1 )
    operator delete(*a1);
  a1[2] = &v4[3 * a2];
  result = &v4[3 * v5];
  a1[1] = result;
  *a1 = v4;
  return result;
}

//----- (000000018000D62C) ----------------------------------------------------
_OWORD *__fastcall std::_Uninit_move<_UBPM_TRIGGER_PARAMS *,_UBPM_TRIGGER_PARAMS *,std::allocator<_UBPM_TRIGGER_PARAMS>,_UBPM_TRIGGER_PARAMS>(
        _OWORD *a1,
        _OWORD *a2,
        _OWORD *a3)
{
  while ( a1 != a2 )
  {
    *a3 = *a1;
    a3[1] = a1[1];
    a3[2] = a1[2];
    a3 += 3;
    a1 += 3;
  }
  return a3;
}

//----- (000000018000D674) ----------------------------------------------------
_OWORD *__fastcall std::vector<_UBPM_TRIGGER_PARAMS>::_Reserve(__int64 a1)
{
  __int64 v2; // rcx
  __int64 v3; // r8
  _OWORD *result; // rax
  __int64 v5; // rdx
  unsigned __int64 v6; // r8
  __int64 v7; // rdx
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // rdx

  v2 = *(_QWORD *)(a1 + 16);
  v3 = *(_QWORD *)(a1 + 8);
  result = (_OWORD *)((unsigned __int64)((unsigned __int128)((v2 - v3) * (__int128)0x2AAAAAAAAAAAAAABLL) >> 64) >> 63);
  if ( !((v2 - v3) / 48) )
  {
    v5 = (v3 - *(_QWORD *)a1) / 48;
    if ( v5 == 0x555555555555555LL )
      std::_Xlength_error("vector<T> too long");
    v6 = v5 + 1;
    v7 = (unsigned __int128)((v2 - *(_QWORD *)a1) * (__int128)0x2AAAAAAAAAAAAAABLL) >> 64;
    v8 = 0LL;
    v9 = ((unsigned __int64)v7 >> 63) + (v7 >> 3);
    if ( 0x555555555555555LL - (v9 >> 1) >= v9 )
      v8 = v9 + (v9 >> 1);
    if ( v8 >= v6 )
      v6 = v8;
    return std::vector<_UBPM_TRIGGER_PARAMS>::_Reallocate((void **)a1, v6);
  }
  return result;
}

//----- (000000018000D730) ----------------------------------------------------
__int64 __fastcall UbpmProxySingleton::RegisterTask(
        UbpmProxySingleton *this,
        int a2,
        const wchar_t **a3,
        int a4,
        JobBucket **a5,
        __int64 **a6,
        unsigned int a7,
        unsigned int a8,
        unsigned __int64 a9,
        unsigned __int16 *a10)
{
  JobBucket *v14; // rcx
  int Ptr; // ebx
  int v16; // r14d
  JobBucket *v17; // rbx
  __int64 v18; // rcx
  const wchar_t *Path; // rbx
  tsched *v20; // rcx
  unsigned __int8 *v21; // rcx
  int v22; // eax
  int v23; // eax
  __int64 v24; // rdx
  __int64 v26; // [rsp+38h] [rbp-D0h] BYREF
  ULONG SecurityDescriptorSize[2]; // [rsp+40h] [rbp-C8h] BYREF
  PSECURITY_DESCRIPTOR SecurityDescriptor; // [rsp+48h] [rbp-C0h] BYREF
  __int128 SecurityDescriptor_8; // [rsp+50h] [rbp-B8h] BYREF
  unsigned __int8 *v30; // [rsp+60h] [rbp-A8h] BYREF
  __int64 v31[2]; // [rsp+68h] [rbp-A0h] BYREF
  _DWORD v32[2]; // [rsp+78h] [rbp-90h] BYREF
  unsigned __int64 v33; // [rsp+80h] [rbp-88h]
  __int64 v34; // [rsp+88h] [rbp-80h]
  char v35[928]; // [rsp+98h] [rbp-70h] BYREF

  v34 = -2LL;
  UbpmParams::UbpmParams((UbpmParams *)v35, (const struct JobMoniker *)a3, a2);
  v26 = 0LL;
  v32[0] = a7;
  v32[1] = a8;
  v33 = a9;
  v30 = 0LL;
  SecurityDescriptor = 0LL;
  TSTime::TSTime((TSTime *)&SecurityDescriptor_8);
  if ( (unsigned int)JobBucket::GetExpiration(a5[6]) == -1 )
    goto LABEL_2;
  SecurityDescriptor_8 = *((_OWORD *)a5 + 1);
  v31[0] = 10000000LL * (unsigned int)JobBucket::GetExpiration(v14);
  TSTime::operator+=((__int64)&SecurityDescriptor_8, v31);
  TSTime::TSTime((TSTime *)v31);
  if ( !TSTime::operator>=((__int64)v31, &SecurityDescriptor_8) )
  {
    Triggers::Trigulator::ScheduleExpiredTaskDeletion((Triggers::Trigulator *)a5, (const struct JobMoniker *)a3);
LABEL_2:
    Ptr = UbpmParams::Init((UbpmParams *)v35, (const struct JobMoniker *)a3, a10);
    if ( Ptr >= 0 )
    {
      Ptr = Actions::ActionCollection::ExportToUbpmFormat(a6, (struct IUbpmRegistrationParams *)v35);
      if ( Ptr >= 0 )
      {
        Ptr = UbpmParams::SetActionConstraints((UbpmParams *)v35, (const struct JobMoniker *)a3);
        if ( Ptr >= 0 )
        {
          v16 = 0;
          v17 = a5[4];
          while ( 1 )
          {
            v17 = *(JobBucket **)v17;
            if ( v17 == a5[4] )
              break;
            v18 = *((_QWORD *)v17 + 2);
            if ( v18 )
            {
              if ( (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v18 + 72LL))(v18) == 52428 )
                ++v16;
            }
          }
          Ptr = Triggers::Trigulator::ExportToUbpmFormat(
                  (__int64 **)a5,
                  a3,
                  (const struct Triggers::TriggerExportOptions *)v32,
                  (struct IUbpmRegistrationParams *)v35);
          if ( Ptr >= 0 )
          {
            Ptr = UbpmParams::GetPtr((UbpmParams *)v35, &v30);
            if ( Ptr >= 0 )
            {
              Path = JobMoniker::GetPath((JobMoniker *)a3);
              if ( !ConvertStringSecurityDescriptorToSecurityDescriptorW(
                      L"D:(A;;GA;;;SY)(A;;GR;;;LS)(A;;GR;;;NS)(A;;GR;;;BA)",
                      1u,
                      &SecurityDescriptor,
                      SecurityDescriptorSize) )
              {
                tsched::GetLastHrError(v20);
                if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
                  && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
                  && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
                {
                  WPP_SF_SD(
                    *((_QWORD *)WPP_GLOBAL_Control + 2),
                    0x24u,
                    (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
                    Path);
                }
              }
              if ( dword_1800B0BCC > *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer
                                                 + (unsigned int)tls_index)
                                               + 4LL) )
              {
                Init_thread_header(&dword_1800B0BCC);
                if ( dword_1800B0BCC == -1 )
                {
                  InitializeSRWLock(&stru_1800B0BD0);
                  Init_thread_footer(&dword_1800B0BCC);
                }
              }
              v31[0] = (__int64)&stru_1800B0BD0;
              AcquireSRWLockExclusive(&stru_1800B0BD0);
              v21 = v30;
              if ( !a4 )
                *((_DWORD *)v30 + 4) |= 0x100u;
              v22 = UbpmTriggerConsumerRegister(v21, &v26);
              Ptr = v22;
              if ( v22 > 0 )
                Ptr = (unsigned __int16)v22 | 0x80070000;
              if ( Ptr >= 0 )
              {
                if ( !v16
                  || (Ptr = Triggers::Trigulator::RegisterAllUbpmEmulatedTriggers((Triggers::Trigulator *)a5, a3),
                      Ptr >= 0) )
                {
                  *((_QWORD *)&SecurityDescriptor_8 + 1) = SecurityDescriptor;
                  LODWORD(SecurityDescriptor_8) = SecurityDescriptorSize[0];
                  v23 = UbpmTriggerConsumerSetStatePublishingSecurity(v26, &SecurityDescriptor_8);
                  Ptr = v23;
                  if ( v23 > 0 )
                    Ptr = (unsigned __int16)v23 | 0x80070000;
                }
              }
              ReleaseSRWLockExclusive(&stru_1800B0BD0);
            }
          }
        }
      }
    }
    goto LABEL_23;
  }
  JobStore::DeleteExpiredTask(JobStore::m_pCommonStore, (const struct JobMoniker *)a3);
  if ( !a2 )
    (*(void (__fastcall **)(UbpmProxySingleton *, const wchar_t **))(*(_QWORD *)this + 8LL))(this, a3);
  Ptr = 0;
LABEL_23:
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0
    && *((unsigned __int8 *)WPP_GLOBAL_Control + 25) >= (int)(((Ptr >> 31) & 0xFFFFFFFE) + 4) )
  {
    WPP_SF_SD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0xBu,
      (__int64)&WPP_ffeb42fce81a3445f9740a981b62c86a_Traceguids,
      a3[3]);
  }
  tsched::AutoLocalPtr<unsigned short>::~AutoLocalPtr<unsigned short>(&SecurityDescriptor);
  if ( v26 )
  {
    UbpmCloseTriggerConsumer(v26, v24);
    v26 = 0LL;
  }
  UbpmParams::~UbpmParams((UbpmParams *)v35);
  return (unsigned int)Ptr;
}
// 18000D9BD: variable 'v24' is possibly undefined
// 180042DA8: variable 'v14' is possibly undefined
// 180042E23: variable 'v20' is possibly undefined
// 180073D60: using guessed type __int64 __fastcall UbpmCloseTriggerConsumer(_QWORD, _QWORD);
// 180073D80: using guessed type __int64 __fastcall UbpmTriggerConsumerSetStatePublishingSecurity(_QWORD, _QWORD);
// 180073D88: using guessed type __int64 __fastcall UbpmTriggerConsumerRegister(_QWORD, _QWORD);
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 1800B0898: using guessed type int tls_index;
// 1800B0BCC: using guessed type int dword_1800B0BCC;

//----- (000000018000DA6C) ----------------------------------------------------
__int64 __fastcall UbpmParams::GetUbpmAccountType(UbpmParams *this, const struct JobMoniker *a2)
{
  __int64 v2; // rbx
  int v3; // eax
  unsigned int v4; // ecx
  User *LocalAdmin; // rax
  bool v7; // al

  v2 = *((_QWORD *)a2 + 4);
  v3 = *(_DWORD *)(v2 + 16);
  if ( (v3 & 0x10000) != 0 || (v3 & 0x80000) != 0 || (v3 & 0x8000) != 0 )
  {
    if ( (v3 & 0x1000000) != 0 )
      return 1;
    LocalAdmin = User::GetLocalAdmin();
    v7 = User::operator==((User *)(v2 + 64), LocalAdmin);
    v4 = 2;
    if ( v7 )
      return 1;
  }
  else
  {
    return 0;
  }
  return v4;
}

//----- (000000018000DAC4) ----------------------------------------------------
char __fastcall User::SupportsTaskHardening(User *this)
{
  char v2; // bl

  v2 = 0;
  if ( User::IsLocalService(this) || User::IsNetworkService(this) )
    return 1;
  return v2;
}

//----- (000000018000DB00) ----------------------------------------------------
bool __fastcall User::IsNetworkService(User *this)
{
  struct _RTL_CRITICAL_SECTION *v2; // rbx
  User *v3; // rcx
  int v4; // edi
  bool v5; // di
  void **pExceptionObject; // [rsp+28h] [rbp-38h] BYREF
  char v8; // [rsp+30h] [rbp-30h]
  const unsigned __int16 *v9; // [rsp+38h] [rbp-28h]
  __int64 v10; // [rsp+40h] [rbp-20h]
  int v11; // [rsp+48h] [rbp-18h]
  int v12; // [rsp+4Ch] [rbp-14h]
  int v13; // [rsp+50h] [rbp-10h]
  int v14; // [rsp+54h] [rbp-Ch]
  int v15; // [rsp+58h] [rbp-8h]
  PSID pSid; // [rsp+70h] [rbp+10h] BYREF
  LPCRITICAL_SECTION v17; // [rsp+78h] [rbp+18h]

  v2 = User::s_cs;
  v17 = User::s_cs;
  EnterCriticalSection(User::s_cs);
  if ( !*(_QWORD *)this || User::IsAlias(this) )
  {
    LeaveCriticalSection(v2);
    return 0;
  }
  else
  {
    v4 = User::LookupSid(v3, &pSid);
    if ( v4 < 0 )
    {
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && *((char *)WPP_GLOBAL_Control + 28) < 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        WPP_SF_D(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x1Eu,
          (__int64)&WPP_0a02ad6f637a3dce55ae09b3fc909c99_Traceguids,
          v4);
      }
      v8 = 0;
      pExceptionObject = &wmi::GenericException::`vftable';
      v9 = &word_18007630E;
      v10 = 0LL;
      v11 = 0;
      v12 = 0;
      v13 = v4;
      v14 = -1;
      v15 = -1;
      CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
    }
    v5 = IsWellKnownSid(pSid, WinNetworkServiceSid);
    LeaveCriticalSection(v2);
    return v5;
  }
}
// 18000DB57: variable 'v3' is possibly undefined
// 1800716D8: using guessed type void *wmi::GenericException::`vftable';
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018000DBAC) ----------------------------------------------------
bool __fastcall User::IsLocalService(User *this)
{
  struct _RTL_CRITICAL_SECTION *v2; // rbx
  User *v3; // rcx
  int v4; // edi
  bool v5; // di
  void **pExceptionObject; // [rsp+28h] [rbp-38h] BYREF
  char v8; // [rsp+30h] [rbp-30h]
  const unsigned __int16 *v9; // [rsp+38h] [rbp-28h]
  __int64 v10; // [rsp+40h] [rbp-20h]
  int v11; // [rsp+48h] [rbp-18h]
  int v12; // [rsp+4Ch] [rbp-14h]
  int v13; // [rsp+50h] [rbp-10h]
  int v14; // [rsp+54h] [rbp-Ch]
  int v15; // [rsp+58h] [rbp-8h]
  PSID pSid; // [rsp+70h] [rbp+10h] BYREF
  LPCRITICAL_SECTION v17; // [rsp+78h] [rbp+18h]

  v2 = User::s_cs;
  v17 = User::s_cs;
  EnterCriticalSection(User::s_cs);
  if ( !*(_QWORD *)this || User::IsAlias(this) )
  {
    LeaveCriticalSection(v2);
    return 0;
  }
  else
  {
    v4 = User::LookupSid(v3, &pSid);
    if ( v4 < 0 )
    {
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && *((char *)WPP_GLOBAL_Control + 28) < 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        WPP_SF_D(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x1Du,
          (__int64)&WPP_0a02ad6f637a3dce55ae09b3fc909c99_Traceguids,
          v4);
      }
      v8 = 0;
      pExceptionObject = &wmi::GenericException::`vftable';
      v9 = &word_18007630E;
      v10 = 0LL;
      v11 = 0;
      v12 = 0;
      v13 = v4;
      v14 = -1;
      v15 = -1;
      CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
    }
    v5 = IsWellKnownSid(pSid, WinLocalServiceSid);
    LeaveCriticalSection(v2);
    return v5;
  }
}
// 18000DC03: variable 'v3' is possibly undefined
// 1800716D8: using guessed type void *wmi::GenericException::`vftable';
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018000DC58) ----------------------------------------------------
__int64 __fastcall User::LookupSid(User *this, void **a2)
{
  User *v4; // rcx
  __int64 v5; // r8
  __int64 result; // rax

  if ( !*(_QWORD *)this || User::IsAlias(this) )
    return 2147549183LL;
  if ( *(_QWORD *)(v5 + 32) || (result = User::UpdateEntry(v4), (int)result >= 0) )
  {
    result = 0LL;
    *a2 = *(void **)(*(_QWORD *)this + 32LL);
  }
  return result;
}
// 18000DC79: variable 'v5' is possibly undefined
// 180042FEA: variable 'v4' is possibly undefined

//----- (000000018000DCAC) ----------------------------------------------------
char __fastcall User::IsAlias(User *this)
{
  char result; // al

  result = 0;
  if ( *(_QWORD *)this )
  {
    if ( **(_BYTE **)this )
      return 1;
  }
  return result;
}

//----- (000000018000DCC8) ----------------------------------------------------
__int64 __fastcall Triggers::Trigulator::ExportToUbpmFormat(
        __int64 **this,
        const wchar_t **a2,
        const struct Triggers::TriggerExportOptions *a3,
        struct IUbpmRegistrationParams *a4)
{
  int v8; // edi
  __int64 v9; // r9
  Triggers::GenericTrigger *v10; // rax
  struct Triggers::Trigger *v11; // rbx
  TSTimePeriod *Periodicity; // rax
  const wchar_t *v13; // r9
  int v14; // ecx
  __int64 *i; // rbx
  Triggers::GenericTrigger *v17; // rax
  struct Triggers::Trigger *v18; // rbx
  LPVOID v19; // rbx
  struct Triggers::Trigger *v20; // rax
  __int128 v21; // [rsp+58h] [rbp-49h] BYREF
  __int64 v22[2]; // [rsp+68h] [rbp-39h] BYREF
  int v23; // [rsp+78h] [rbp-29h]
  __int64 v24; // [rsp+7Ch] [rbp-25h]
  __int64 v25; // [rsp+84h] [rbp-1Dh]
  __int64 v26[3]; // [rsp+90h] [rbp-11h] BYREF
  __int128 v27; // [rsp+A8h] [rbp+7h] BYREF
  __int128 v28; // [rsp+B8h] [rbp+17h] BYREF
  __int128 v29; // [rsp+C8h] [rbp+27h] BYREF

  v26[2] = -2LL;
  v22[0] = 3LL;
  v24 = 0LL;
  v22[1] = 0LL;
  v25 = 0LL;
  v23 = 0;
  v8 = JobStore::SetTaskCreationTime(JobStore::m_pCommonStore, (struct JobMoniker *)a2, (struct DynamicTaskInfo *)v22);
  if ( v8 >= 0 )
  {
    (*(void (__fastcall **)(struct IUbpmRegistrationParams *, __int64 *))(*(_QWORD *)a4 + 112LL))(a4, v22);
    v9 = (__int64)a2[4];
    if ( (*(_DWORD *)(v9 + 16) & 0x100) != 0 )
    {
      v10 = (Triggers::GenericTrigger *)operator new(0x58uLL);
      v11 = v10;
      v26[0] = (__int64)v10;
      if ( v10 )
      {
        Triggers::GenericTrigger::GenericTrigger(v10);
        *(_QWORD *)v11 = &Triggers::ImmediateTrigger::`vftable';
      }
      else
      {
        v11 = 0LL;
      }
      Triggers::Trigulator::AddTrigger((Triggers::Trigulator *)this, v11);
      v9 = (__int64)a2[4];
    }
    Periodicity = (TSTimePeriod *)JobBucket::GetPeriodicity(v9, (__int64)v26);
    if ( !TSTimePeriod::IsEmpty(Periodicity) )
    {
      v17 = (Triggers::GenericTrigger *)operator new(0x58uLL);
      v18 = v17;
      v26[0] = (__int64)v17;
      if ( v17 )
      {
        Triggers::GenericTrigger::GenericTrigger(v17);
        *(_QWORD *)v18 = &Triggers::MaintenanceTrigger::`vftable';
      }
      else
      {
        v18 = 0LL;
      }
      Triggers::Trigulator::AddTrigger((Triggers::Trigulator *)this, v18);
      v13 = a2[4];
    }
    v14 = *((_DWORD *)v13 + 4);
    if ( (v13[8] & 2) != 0 && (v14 & 4) != 0 && (v14 & 8) != 0 )
    {
      v19 = operator new(0x60uLL);
      v26[0] = (__int64)v19;
      if ( v19 )
      {
        *(_QWORD *)&v21 = 0LL;
        DWORD2(v21) = 0;
        BYTE12(v21) = 0;
        v28 = v21;
        *((_QWORD *)&v21 + 1) = -1LL;
        TSTime::TSTime((TSTime *)&v27);
        v29 = v27;
        v20 = (struct Triggers::Trigger *)Triggers::IdleTrigger::IdleTrigger(
                                            (__int64)v19,
                                            0LL,
                                            &v29,
                                            &v21,
                                            0,
                                            0,
                                            1,
                                            &v28,
                                            1);
      }
      else
      {
        v20 = 0LL;
      }
      Triggers::Trigulator::AddTrigger((Triggers::Trigulator *)this, v20);
    }
    if ( this[5] )
    {
      for ( i = this[4];
            ;
            v8 = (*(__int64 (__fastcall **)(__int64, const struct Triggers::TriggerExportOptions *, struct IUbpmRegistrationParams *))(*(_QWORD *)i[2] + 64LL))(
                   i[2],
                   a3,
                   a4) )
      {
        i = (__int64 *)*i;
        if ( i == this[4] || v8 < 0 )
          break;
      }
    }
  }
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0
    && *((unsigned __int8 *)WPP_GLOBAL_Control + 25) >= (int)(((v8 >> 31) & 0xFFFFFFFE) + 4) )
  {
    WPP_SF_SD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x14u,
      (__int64)&WPP_9c6330531b9f37c0b720c7be8cd79119_Traceguids,
      a2[3]);
  }
  return (unsigned int)v8;
}
// 18000DDAC: variable 'v13' is possibly undefined
// 1800705B8: using guessed type void *Triggers::MaintenanceTrigger::`vftable';
// 180070730: using guessed type void *Triggers::ImmediateTrigger::`vftable';
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018000DF28) ----------------------------------------------------
struct _GUID *__fastcall JobBucket::GetNetworkId(JobBucket *this, struct _GUID *__return_ptr retstr)
{
  __int64 v2; // rax
  struct _GUID v3; // xmm0
  struct _GUID *result; // rax

  v2 = *((_QWORD *)this + 26);
  if ( v2 )
    v3 = *(struct _GUID *)(v2 + 28);
  else
    v3 = 0LL;
  result = retstr;
  *retstr = v3;
  return result;
}

//----- (000000018000DF50) ----------------------------------------------------
__int64 __fastcall UbpmProxySingleton::IsUbpmCompatible(
        UbpmProxySingleton *this,
        const wchar_t **a2,
        __int64 **a3,
        int *a4)
{
  __int64 *v7; // rbx
  __int64 v8; // r8
  _bstr_t::Data_t *v10; // [rsp+60h] [rbp+18h] BYREF

  _bstr_t::_bstr_t((_bstr_t *)&v10, L"compatible");
  v7 = *a3;
  while ( 1 )
  {
    v7 = (__int64 *)*v7;
    if ( v7 == *a3 )
      break;
    if ( (*(unsigned __int16 (__fastcall **)(__int64))(*(_QWORD *)v7[2] + 24LL))(v7[2]) == 0x9999
      || (*(unsigned __int16 (__fastcall **)(__int64))(*(_QWORD *)v7[2] + 24LL))(v7[2]) == 0x8888 )
    {
      *a4 = 0;
      _bstr_t::operator=(&v10, L"NOT compatible (actions)");
      goto LABEL_7;
    }
  }
  *a4 = 1;
LABEL_7:
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
  {
    if ( v10 )
      v8 = *(_QWORD *)v10;
    else
      v8 = 0LL;
    WPP_SF_SSD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x10u,
      (__int64)&WPP_ffeb42fce81a3445f9740a981b62c86a_Traceguids,
      a2[3],
      v8);
  }
  _bstr_t::_Free((_bstr_t *)&v10);
  return 0LL;
}
// 1800782D8: using guessed type wchar_t aNotCompatibleA[25];
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018000E064) ----------------------------------------------------
UbpmParams *__fastcall UbpmParams::UbpmParams(UbpmParams *this, const struct JobMoniker *a2, int a3)
{
  __int64 v6; // rcx
  __int64 v7; // rcx
  unsigned __int64 v8; // rcx
  __int64 v9; // rax
  unsigned __int16 **v10; // r8
  unsigned __int16 *v11; // r8
  int v12; // edx
  int v13; // eax
  int v14; // ecx
  int v15; // ecx

  *(_QWORD *)this = &UbpmParams::`vftable';
  *((_QWORD *)this + 1) = a2;
  *((_QWORD *)this + 15) = 0LL;
  *((_QWORD *)this + 16) = 0LL;
  *((_QWORD *)this + 17) = 0LL;
  *((_QWORD *)this + 18) = 0LL;
  *((_QWORD *)this + 19) = 0LL;
  *((_QWORD *)this + 20) = 0LL;
  *((_QWORD *)this + 21) = 0LL;
  *((_QWORD *)this + 22) = 0LL;
  *((_QWORD *)this + 23) = 0LL;
  *((_QWORD *)this + 24) = 0LL;
  *((_QWORD *)this + 25) = 0LL;
  *((_QWORD *)this + 26) = 0LL;
  *((_QWORD *)this + 27) = 0LL;
  *((_QWORD *)this + 28) = 0LL;
  *((_QWORD *)this + 27) = std::_List_alloc<0,std::_List_base_types<std::vector<unsigned char> *,std::allocator<std::vector<unsigned char> *>>>::_Buynode0(
                             (__int64)this,
                             0LL,
                             0LL);
  *((_QWORD *)this + 29) = 0LL;
  *((_QWORD *)this + 30) = 0LL;
  *((_QWORD *)this + 29) = std::_List_alloc<0,std::_List_base_types<std::vector<unsigned char> *,std::allocator<std::vector<unsigned char> *>>>::_Buynode0(
                             v6,
                             0LL,
                             0LL);
  *((_QWORD *)this + 31) = 0LL;
  *((_QWORD *)this + 32) = 0LL;
  *((_QWORD *)this + 31) = std::_List_alloc<0,std::_List_base_types<std::vector<unsigned char> *,std::allocator<std::vector<unsigned char> *>>>::_Buynode0(
                             v7,
                             0LL,
                             0LL);
  *((_QWORD *)this + 33) = 0LL;
  *((_QWORD *)this + 34) = 0LL;
  *((_QWORD *)this + 35) = 0LL;
  *((_QWORD *)this + 36) = 0LL;
  *((_QWORD *)this + 37) = 0LL;
  *((_QWORD *)this + 38) = 0LL;
  *((_QWORD *)this + 39) = 0LL;
  *((_QWORD *)this + 40) = 0LL;
  *((_QWORD *)this + 41) = 0LL;
  *((_DWORD *)this + 84) = 1;
  *((_QWORD *)this + 43) = 0LL;
  *((_QWORD *)this + 44) = 0LL;
  *((_QWORD *)this + 45) = 0LL;
  *((_DWORD *)this + 92) = 0;
  *((_QWORD *)this + 47) = 0LL;
  *((_QWORD *)this + 70) = 0LL;
  *((_QWORD *)this + 72) = 0LL;
  *((_QWORD *)this + 73) = 0LL;
  *((_QWORD *)this + 74) = 0LL;
  *((_QWORD *)this + 75) = 0LL;
  *((_QWORD *)this + 76) = 0LL;
  *((_QWORD *)this + 77) = 0LL;
  *((_QWORD *)this + 78) = 0LL;
  *((_QWORD *)this + 79) = 0LL;
  *((_QWORD *)this + 80) = 0LL;
  *((_QWORD *)this + 81) = 0LL;
  *((_QWORD *)this + 82) = 0LL;
  *((_QWORD *)this + 83) = 0LL;
  *((_QWORD *)this + 84) = 0LL;
  *((_QWORD *)this + 85) = 0LL;
  *((_QWORD *)this + 86) = 0LL;
  *((_QWORD *)this + 87) = 0LL;
  *((_QWORD *)this + 88) = 0LL;
  *((_QWORD *)this + 89) = 0LL;
  *((_QWORD *)this + 90) = 0LL;
  *((_QWORD *)this + 91) = 0LL;
  *((_QWORD *)this + 92) = 0LL;
  *((_QWORD *)this + 93) = 0LL;
  *((_QWORD *)this + 94) = 0LL;
  *((_QWORD *)this + 95) = 0LL;
  *((_QWORD *)this + 96) = 0LL;
  *((_QWORD *)this + 97) = 0LL;
  *((_QWORD *)this + 98) = 0LL;
  *((_QWORD *)this + 99) = 0LL;
  *((_QWORD *)this + 100) = 0LL;
  *((_QWORD *)this + 101) = 0LL;
  *((_QWORD *)this + 102) = 0LL;
  *((_QWORD *)this + 103) = 0LL;
  *((_QWORD *)this + 104) = 0LL;
  *((_QWORD *)this + 105) = 0LL;
  *((_QWORD *)this + 106) = 0LL;
  *((_QWORD *)this + 107) = 0LL;
  *((_DWORD *)this + 216) = 1;
  *((_QWORD *)this + 109) = 0LL;
  *((_QWORD *)this + 110) = 0LL;
  *((_QWORD *)this + 111) = 0LL;
  *((_QWORD *)this + 112) = 0LL;
  *((_QWORD *)this + 113) = 0LL;
  *((_QWORD *)this + 114) = 0LL;
  *((_QWORD *)this + 115) = 0LL;
  memset_0((char *)this + 16, 0, 0x68uLL);
  *((_OWORD *)this + 24) = 0LL;
  *((_OWORD *)this + 25) = 0LL;
  *((_OWORD *)this + 26) = 0LL;
  *((_QWORD *)this + 54) = 0LL;
  *((_DWORD *)this + 110) = 0;
  memset_0((char *)this + 448, 0, 0x80uLL);
  v9 = *((_QWORD *)this + 1);
  *((_QWORD *)this + 2) = v9;
  v10 = *(unsigned __int16 ***)(v9 + 16);
  if ( v10 )
    v11 = *v10;
  else
    v11 = 0LL;
  *((_QWORD *)this + 3) = UbpmParams::NewHostedString(v8, (__int64 *)this + 15, v11, 0x7FFFFFFFuLL);
  v12 = *(_DWORD *)(*((_QWORD *)a2 + 4) + 16LL);
  v13 = (v12 & 0x400000) == 0;
  if ( (v12 & 0x400) != 0 )
  {
    v13 |= 4u;
  }
  else if ( (v12 & 0x1000) != 0 )
  {
    v13 |= 8u;
  }
  else if ( (v12 & 0x2000) != 0 )
  {
    v13 |= 0x10u;
  }
  else if ( (v12 & 0x800) != 0 )
  {
    v13 |= 0x20u;
  }
  v14 = v13 | 0x80;
  if ( (v12 & 0x40) == 0 )
    v14 = v13;
  v15 = v14 | 2;
  *((_DWORD *)this + 8) = v15;
  if ( a3 )
    *((_DWORD *)this + 8) = v15 | 0x40;
  return this;
}
// 18000E12A: variable 'v6' is possibly undefined
// 18000E14A: variable 'v7' is possibly undefined
// 18000E369: variable 'v8' is possibly undefined
// 1800707A8: using guessed type void *UbpmParams::`vftable';

//----- (000000018000E3F0) ----------------------------------------------------
__int64 __fastcall JobStore::SetTaskCreationTime(JobStore *this, struct JobMoniker *a2, struct DynamicTaskInfo *a3)
{
  int DynamicTaskInfo; // eax
  signed int v7; // ebx
  TSTimePeriod *Periodicity; // rax
  int v10; // r9d
  char v11; // al
  TSTimePeriod *v12; // rax
  int v13; // r9d
  unsigned __int16 *v14; // rax
  __int64 v15; // rcx
  unsigned __int16 *v16; // rax
  unsigned __int64 v17; // rbx
  unsigned __int16 *v18; // rax
  __int64 v19[4]; // [rsp+38h] [rbp-19h] BYREF
  char v20; // [rsp+58h] [rbp+7h] BYREF
  __int64 v21; // [rsp+60h] [rbp+Fh]
  BYTE Data[16]; // [rsp+68h] [rbp+17h] BYREF
  _OWORD v23[2]; // [rsp+78h] [rbp+27h] BYREF
  HKEY hKey; // [rsp+D0h] [rbp+7Fh] BYREF

  v19[2] = -2LL;
  *(_QWORD *)Data = 3LL;
  *(_QWORD *)&Data[8] = 0LL;
  memset(v23, 0, 20);
  hKey = 0LL;
  DynamicTaskInfo = JobStore::GetDynamicTaskInfo(this, a2, (struct DynamicTaskInfo *)Data, 0x2001Bu, &hKey);
  v7 = DynamicTaskInfo;
  if ( DynamicTaskInfo < 0 )
    goto LABEL_7;
  if ( DynamicTaskInfo == 1 )
  {
LABEL_12:
    v10 = *(_DWORD *)&Data[4];
    goto LABEL_13;
  }
  if ( *(_DWORD *)&Data[8] || (v10 = *(_DWORD *)&Data[4]) != 0 )
  {
    Periodicity = (TSTimePeriod *)JobBucket::GetPeriodicity(*((_QWORD *)a2 + 4), (__int64)v19);
    if ( TSTimePeriod::IsEmpty(Periodicity) || (unsigned int)JobStore::IsMTRCompleted(this) )
    {
LABEL_5:
      if ( a3 )
      {
        *(_OWORD *)a3 = *(_OWORD *)Data;
        *((_OWORD *)a3 + 1) = v23[0];
        *((_DWORD *)a3 + 8) = v23[1];
      }
      goto LABEL_7;
    }
    goto LABEL_12;
  }
LABEL_13:
  v20 = 0;
  v21 = *(_QWORD *)&Data[4];
  if ( *(_DWORD *)&Data[8] || (v11 = 1, v10) )
    v11 = 0;
  if ( v11 )
    TSTime::TSTime((TSTime *)&v20);
  v12 = (TSTimePeriod *)JobBucket::GetPeriodicity(*((_QWORD *)a2 + 4), (__int64)v19);
  if ( !TSTimePeriod::IsEmpty(v12) && (!*(_DWORD *)&Data[8] && !v13 || !(unsigned int)JobStore::IsMTRCompleted(this)) )
  {
    v14 = (unsigned __int16 *)JobBucket::GetPeriodicity(*((_QWORD *)a2 + 4), (__int64)v19);
    v15 = *((_QWORD *)a2 + 4);
    if ( v14[1] + 12 * *v14 )
    {
      v18 = (unsigned __int16 *)JobBucket::GetPeriodicity(v15, (__int64)v19);
      v17 = 28 * (v18[1] + 12LL * *v18);
    }
    else
    {
      v16 = (unsigned __int16 *)JobBucket::GetPeriodicity(v15, (__int64)v19);
      v17 = (v16[6] + 60 * (v16[5] + 60 * (v16[4] + 24 * (v16[3] + 7 * v16[2])))) / 0x15180uLL;
    }
    if ( v17 > 1 )
    {
      v19[0] = -864000000000LL * (rand() % v17);
      TSTime::operator+=((__int64)&v20, v19);
    }
  }
  *(_QWORD *)&Data[4] = v21;
  v7 = DynamicTaskInfo::StreamOut(Data, hKey);
  if ( v7 >= 0 )
    goto LABEL_5;
LABEL_7:
  wmi::AutoRegKey::Close(&hKey);
  return (unsigned int)v7;
}
// 1800430C0: variable 'v13' is possibly undefined

//----- (000000018000E4E4) ----------------------------------------------------
bool __fastcall TSTimePeriod::IsEmpty(TSTimePeriod *this)
{
  bool result; // al

  result = 0;
  if ( !*(_WORD *)this
    && !*((_WORD *)this + 1)
    && !*((_WORD *)this + 2)
    && !*((_WORD *)this + 3)
    && !*((_WORD *)this + 4)
    && !*((_WORD *)this + 5) )
  {
    return *((_WORD *)this + 6) == 0;
  }
  return result;
}

//----- (000000018000E51C) ----------------------------------------------------
__int64 __fastcall UbpmParams::Init(UbpmParams *this, const struct JobMoniker *a2, const unsigned __int16 *a3)
{
  __int64 v6; // r9
  int v7; // eax
  User::UserEntry **v8; // rcx
  int AliasCredId; // r14d
  UbpmParams *v10; // rcx
  UbpmParams *v11; // rcx
  struct _DAB_SID_INFO *HostedSidInfo; // rax
  __int64 v13; // rax
  int v14; // r8d
  int v15; // edx
  int v16; // eax
  _QWORD *v17; // rax
  TSTimePeriod *Periodicity; // rax
  _QWORD *v19; // rcx
  char *v21; // rbx
  __int64 v22; // rcx
  int v23; // eax
  char *v24; // rcx
  __int64 v25; // rcx
  __int64 v26; // rax
  __int64 v27; // rax
  char *v28; // rcx
  void *v29; // rcx
  void *v30; // rbx
  const unsigned __int16 *v31; // rdx
  unsigned __int16 v32; // dx
  unsigned __int64 v33; // rcx
  unsigned __int16 *v34; // r8
  void *v35; // [rsp+30h] [rbp-20h] BYREF
  __int64 v36; // [rsp+38h] [rbp-18h] BYREF
  __int16 v37; // [rsp+40h] [rbp-10h]
  __int16 v38; // [rsp+42h] [rbp-Eh]
  __int16 v39; // [rsp+44h] [rbp-Ch]
  __int64 v40; // [rsp+48h] [rbp-8h]
  User::UserEntry *v41; // [rsp+88h] [rbp+38h] BYREF
  void *lpMem; // [rsp+98h] [rbp+48h] BYREF

  v40 = -2LL;
  v35 = 0LL;
  v41 = 0LL;
  v6 = *((_QWORD *)a2 + 4);
  v7 = *(_DWORD *)(v6 + 16);
  if ( (v7 & 0x40000) == 0 && (v7 & 0x80000) == 0 || v7 < 0 || (unsigned int)UbpmParams::GetUbpmLogonType(this, a2) != 4 )
  {
    if ( User::IsAlias((User *)(v6 + 64)) )
    {
      v31 = (const unsigned __int16 *)*User::GetAccount((__int64)v8, (__int64 *)&lpMem);
      if ( v31 )
        v31 = *(const unsigned __int16 **)v31;
      AliasCredId = CredStore::ResolveAlias((HKEY *)CredStore::g_pCommonStore, v31, &v41);
      _bstr_t::_Free((_bstr_t *)&lpMem);
      if ( AliasCredId < 0 )
        goto LABEL_55;
    }
    else
    {
      wmi::AutoRef<User::UserEntry>::operator=(&v41, *v8);
    }
    goto LABEL_5;
  }
  lpMem = 0LL;
  wmi::AutoRef<User::UserEntry>::operator=(&v41, *(User::UserEntry **)(v6 + 64));
  if ( User::IsAlias((User *)&v41) )
  {
    v28 = (char *)*User::GetAccount((__int64)&v41, &v36);
    if ( v28 )
      v28 = *(char **)v28;
    AliasCredId = CredStore::GetAliasCredId(v28, &lpMem);
    _bstr_t::_Free((_bstr_t *)&v36);
  }
  else
  {
    AliasCredId = CredStore::GetCredId((User *)&v41, &lpMem);
  }
  if ( AliasCredId >= 0 )
  {
    v30 = lpMem;
    AliasCredId = MarshalCredential((__int64)lpMem, (LPWSTR *)this + 70);
    v29 = v30;
    if ( AliasCredId < 0 )
      goto LABEL_49;
    operator delete(v30);
LABEL_5:
    AliasCredId = User::LookupSid((User *)&v41, &v35);
    if ( AliasCredId < 0 )
      goto LABEL_55;
    *((_DWORD *)this + 142) = 1;
    v10 = (UbpmParams *)(*(_DWORD *)(*((_QWORD *)a2 + 4) + 16LL) & 0xFC000);
    if ( (_DWORD)v10 == 0x8000 )
    {
      *((_DWORD *)this + 112) = 2;
      HostedSidInfo = UbpmParams::CreateHostedSidInfo(this, v35);
      *((_DWORD *)this + 120) = 2;
    }
    else
    {
      *((_DWORD *)this + 112) = 1;
      *((_DWORD *)this + 120) = UbpmParams::GetUbpmLogonType(v10, a2);
      if ( User::IsLocalSystem((User *)(*((_QWORD *)a2 + 4) + 64LL)) )
        HostedSidInfo = 0LL;
      else
        HostedSidInfo = UbpmParams::CreateHostedSidInfo(this, v35);
    }
    *((_QWORD *)this + 57) = HostedSidInfo;
    v13 = *((_QWORD *)this + 70);
    *((_QWORD *)this + 58) = v13;
    if ( !v13 )
      *((_QWORD *)this + 59) = a3;
    *((_DWORD *)this + 121) = UbpmParams::GetUbpmAccountType(v11, a2);
    v14 = *(_DWORD *)(*((_QWORD *)a2 + 4) + 16LL);
    v15 = ((unsigned int)v14 >> 14) & 1 | 2;
    if ( v14 >= 0 )
      v15 = (*(_DWORD *)(*((_QWORD *)a2 + 4) + 16LL) >> 14) & 1;
    v16 = v15 | 4;
    if ( (v14 & 0x80000) == 0 )
      v16 = v15;
    *((_DWORD *)this + 131) = v16;
    if ( !User::SupportsTaskHardening((User *)&v41) )
    {
      *((_QWORD *)this + 61) = 0LL;
      *((_BYTE *)this + 497) = 0;
      v17 = *(_QWORD **)(*((_QWORD *)a2 + 4) + 176LL);
      if ( v17 )
        v17 = (_QWORD *)*v17;
      if ( v17 )
      {
        *((_QWORD *)this + 66) = UbpmParams::CreateHostedPackageSid(this, a2);
        v34 = *(unsigned __int16 **)(*((_QWORD *)a2 + 4) + 176LL);
        if ( v34 )
          v34 = *(unsigned __int16 **)v34;
        *((_QWORD *)this + 67) = UbpmParams::NewHostedString(v33, (__int64 *)this + 15, v34, 0x7FFFFFFFuLL);
        if ( (unsigned int)((__int64)(*(_QWORD *)(*((_QWORD *)a2 + 4) + 192LL) - *(_QWORD *)(*((_QWORD *)a2 + 4) + 184LL)) >> 3) )
        {
          *((_QWORD *)this + 69) = UbpmParams::CreateHostedCapabilitiesSidArray(this, a2);
          *((_DWORD *)this + 136) = (__int64)(*(_QWORD *)(*((_QWORD *)a2 + 4) + 192LL)
                                            - *(_QWORD *)(*((_QWORD *)a2 + 4) + 184LL)) >> 3;
        }
      }
LABEL_19:
      Periodicity = (TSTimePeriod *)JobBucket::GetPeriodicity(*((_QWORD *)a2 + 4), (__int64)&v36);
      if ( !TSTimePeriod::IsEmpty(Periodicity) )
      {
        v21 = (char *)operator new(0x1EuLL);
        if ( !v21 )
        {
          AliasCredId = -2147024882;
          goto LABEL_55;
        }
        JobBucket::GetPeriodicity(*((_QWORD *)a2 + 4), (__int64)&v36);
        *(_QWORD *)v21 = v36;
        *((_WORD *)v21 + 4) = v37;
        *((_WORD *)v21 + 5) = v38;
        *((_WORD *)v21 + 6) = v39;
        JobBucket::GetDeadline(*((_QWORD *)a2 + 4), (__int64)&v36);
        *(_QWORD *)(v21 + 14) = v36;
        *((_WORD *)v21 + 11) = v37;
        *((_WORD *)v21 + 12) = v38;
        *((_WORD *)v21 + 13) = v39;
        v22 = *(_QWORD *)(*((_QWORD *)a2 + 4) + 208LL);
        if ( v22 )
          v23 = *(_DWORD *)(v22 + 84);
        else
          v23 = 0;
        v21[28] = v23 != 0;
        v24 = (char *)*((_QWORD *)this + 115);
        if ( v21 != v24 )
          operator delete(v24);
        *((_QWORD *)this + 115) = v21;
      }
      goto LABEL_20;
    }
    v25 = *(_QWORD *)(*((_QWORD *)a2 + 4) + 208LL);
    if ( v25 )
      v26 = *(_QWORD *)(v25 + 48);
    else
      v26 = 0LL;
    if ( v26 )
    {
      if ( v25 )
      {
        v27 = *(_QWORD *)(v25 + 48);
LABEL_37:
        *((_QWORD *)this + 61) = v27;
        if ( (*(_DWORD *)(*((_QWORD *)a2 + 4) + 16LL) & 0x8000000) != 0 )
        {
          *((_BYTE *)this + 497) = 0;
        }
        else
        {
          *((_BYTE *)this + 497) = 1;
          *((_QWORD *)this + 63) = L"NT TASK";
          *((_QWORD *)this + 64) = UbpmParams::CreateHostedVirtualUserName(this, a2);
          *((_DWORD *)this + 130) = 87;
        }
        goto LABEL_19;
      }
    }
    else
    {
      *((_BYTE *)this + 496) = 1;
    }
    v27 = 0LL;
    goto LABEL_37;
  }
  v29 = lpMem;
LABEL_49:
  operator delete(v29);
LABEL_20:
  if ( AliasCredId >= 0 )
  {
    v19 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
    {
      v32 = 16;
      goto LABEL_59;
    }
    goto LABEL_23;
  }
LABEL_55:
  v19 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
  {
    v32 = 15;
LABEL_59:
    WPP_SF_SD(v19[2], v32, (__int64)&WPP_f0f7296807f33a7e423f6d049324e537_Traceguids, *((const wchar_t **)a2 + 3));
  }
LABEL_23:
  wmi::AutoRef<User::UserEntry>::Release(&v41);
  return (unsigned int)AliasCredId;
}
// 18000E568: variable 'v6' is possibly undefined
// 18000E579: variable 'v8' is possibly undefined
// 18000E610: variable 'v11' is possibly undefined
// 180043341: variable 'v33' is possibly undefined
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);
// 180076720: using guessed type wchar_t aNtTask[8];
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018000E87C) ----------------------------------------------------
__int64 __fastcall JobBucket::GetPeriodicity(__int64 a1, __int64 a2)
{
  __int64 v2; // r8
  __int16 v3; // ax
  int v4; // eax

  v2 = *(_QWORD *)(a1 + 208);
  v3 = 0;
  if ( v2 )
  {
    v4 = *(_DWORD *)(v2 + 64);
    *(_QWORD *)a2 = *(_QWORD *)(v2 + 56);
    *(_DWORD *)(a2 + 8) = v4;
    v3 = *(_WORD *)(v2 + 68);
  }
  else
  {
    *(_QWORD *)a2 = 0LL;
    *(_DWORD *)(a2 + 8) = 0;
  }
  *(_WORD *)(a2 + 12) = v3;
  return a2;
}

//----- (000000018000E8B8) ----------------------------------------------------
__int64 __fastcall JobStore::GetDynamicTaskInfo(
        JobStore *this,
        struct JobMoniker *a2,
        struct DynamicTaskInfo *a3,
        unsigned int a4,
        HKEY *a5)
{
  int v6; // ebx
  HKEY v7; // rax
  HKEY v9[3]; // [rsp+20h] [rbp-18h] BYREF

  v9[1] = HKEY_DYN_DATA|0x7FFFFFF8LL;
  v9[0] = 0LL;
  v6 = JobStore::RegOpenTaskKey(this, a2, v9, a4);
  if ( v6 >= 0 )
  {
    v6 = DynamicTaskInfo::StreamIn(a3, v9[0]);
    if ( v6 >= 0 )
    {
      if ( a5 )
      {
        v7 = v9[0];
        v9[0] = 0LL;
        *a5 = v7;
      }
    }
  }
  wmi::AutoRegKey::Close(v9);
  return (unsigned int)v6;
}
// 18000E8B8: using guessed type HKEY var_18[3];

//----- (000000018000E92C) ----------------------------------------------------
int __fastcall DynamicTaskInfo::StreamIn(DynamicTaskInfo *this, HKEY a2)
{
  int result; // eax
  DWORD v4; // [rsp+50h] [rbp+18h] BYREF
  DWORD v5; // [rsp+58h] [rbp+20h] BYREF

  v4 = 0;
  v5 = 36;
  result = RegQueryValueExW(a2, L"DynamicInfo", 0LL, &v4, (LPBYTE)this, &v5);
  if ( result )
  {
    if ( result == 2 )
    {
      *(_QWORD *)((char *)this + 4) = 0LL;
      result = 1;
      *(_QWORD *)((char *)this + 12) = 0LL;
      *(_QWORD *)((char *)this + 20) = 0LL;
      *(_QWORD *)((char *)this + 28) = 0LL;
      *(_DWORD *)this = 3;
    }
    else if ( result > 0 )
    {
      return (unsigned __int16)result | 0x80070000;
    }
  }
  else if ( v4 != 3 || *(_DWORD *)this != 3 )
  {
    return -2147216621;
  }
  return result;
}

//----- (000000018000E998) ----------------------------------------------------
ITaskXmlHandler::Data *__fastcall ITaskXmlHandler::Data::Data(ITaskXmlHandler::Data *this)
{
  TSTime::TSTime(this);
  *((_QWORD *)this + 2) = 0LL;
  *((_DWORD *)this + 6) = 0;
  *((_WORD *)this + 14) = 0;
  *((_QWORD *)this + 7) = 0LL;
  return this;
}

//----- (000000018000E9C8) ----------------------------------------------------
__int64 __fastcall Triggers::Trigulator::operator=(__int64 a1, __int64 a2)
{
  __int64 result; // rax

  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  std::list<Triggers::Trigger *>::operator=((__int64 *)(a1 + 32), (__int64 *)(a2 + 32));
  wmi::AutoRef<JobBucket>::Release((wmi::RefBase **)(a1 + 48));
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
  result = a1;
  *(_QWORD *)(a2 + 48) = 0LL;
  return result;
}

//----- (000000018000EA28) ----------------------------------------------------
__int64 *__fastcall std::list<Triggers::Trigger *>::operator=(__int64 *a1, __int64 *a2)
{
  __int64 v4; // r8
  __int64 v5; // r8

  if ( a1 != a2 )
  {
    std::list<Triggers::Trigger *>::clear((__int64)a1);
    v4 = *a1;
    *a1 = *a2;
    *a2 = v4;
    v5 = a1[1];
    a1[1] = a2[1];
    a2[1] = v5;
  }
  return a1;
}

//----- (000000018000EA74) ----------------------------------------------------
__int64 __fastcall Triggers::Trigulator::StreamInWithOverrides(
        HKEY a1,
        HKEY a2,
        char a3,
        char a4,
        __int64 a5,
        _QWORD *a6)
{
  int v10; // ebx
  unsigned __int64 v12[2]; // [rsp+28h] [rbp-39h] BYREF
  struct _FILETIME v13[4]; // [rsp+38h] [rbp-29h] BYREF
  __int64 v14[3]; // [rsp+58h] [rbp-9h] BYREF
  struct _FILETIME v15[4]; // [rsp+70h] [rbp+Fh] BYREF
  __int64 v16[3]; // [rsp+90h] [rbp+2Fh] BYREF

  v12[1] = -2LL;
  Triggers::Trigulator::Trigulator(v13);
  Triggers::Trigulator::Trigulator(v15);
  v10 = Triggers::Trigulator::StreamIn((wmi::RefBase **)v13, a1, a3, v12);
  if ( v10 >= 0 )
  {
    if ( a2 )
    {
      v10 = Triggers::Trigulator::StreamIn((wmi::RefBase **)v15, a2, a3, v12);
      if ( v10 < 0 )
        goto LABEL_6;
      if ( (a4 & 1) != 0 )
        std::list<Triggers::Trigger *>::operator=(v14, v16);
      if ( (a4 & 2) != 0 )
        *(_DWORD *)(v14[2] + 16) = *(_DWORD *)(v16[2] + 16);
    }
    Triggers::Trigulator::operator=(a5, (__int64)v13);
    if ( a6 )
      *a6 = v12[0];
    v10 = 0;
  }
LABEL_6:
  Triggers::Trigulator::~Trigulator((Triggers::Trigulator *)v15);
  Triggers::Trigulator::~Trigulator((Triggers::Trigulator *)v13);
  return (unsigned int)v10;
}

//----- (000000018000EB38) ----------------------------------------------------
__int64 __fastcall Triggers::Trigulator::WriteXml(Triggers::Trigulator *this, struct TaskXmlWriter *a2)
{
  __int64 result; // rax
  __int64 *v5; // rbx

  result = TaskXmlWriter::StartElement((int *)a2, 12);
  if ( (int)result >= 0 )
  {
    v5 = (__int64 *)*((_QWORD *)this + 4);
    while ( 1 )
    {
      v5 = (__int64 *)*v5;
      if ( v5 == *((__int64 **)this + 4) )
        break;
      result = (*(__int64 (__fastcall **)(__int64, struct TaskXmlWriter *))(*(_QWORD *)v5[2] + 40LL))(v5[2], a2);
      if ( (int)result < 0 )
        return result;
    }
    return TaskXmlWriter::EndElement((__int64)a2);
  }
  return result;
}

//----- (000000018000EBA4) ----------------------------------------------------
struct _FILETIME *__fastcall Triggers::Trigulator::Trigulator(struct _FILETIME *this)
{
  __int64 v2; // rcx

  LOBYTE(this->dwLowDateTime) = 0;
  GetSystemTimeAsFileTime(this + 1);
  LOBYTE(this[2].dwLowDateTime) = 0;
  GetSystemTimeAsFileTime(this + 3);
  this[4] = 0LL;
  this[5] = 0LL;
  this[4] = (struct _FILETIME)std::_List_alloc<0,std::_List_base_types<Triggers::Trigger *>>::_Buynode0(v2, 0LL, 0LL);
  this[6] = 0LL;
  Triggers::Trigulator::Clear((Triggers::Trigulator *)this);
  return this;
}
// 18000EBEF: variable 'v2' is possibly undefined

//----- (000000018000EC1C) ----------------------------------------------------
void __fastcall Triggers::Trigulator::~Trigulator(Triggers::Trigulator *this)
{
  Triggers::Trigulator::Clear(this);
  wmi::AutoRef<JobBucket>::Release((wmi::RefBase **)this + 6);
  std::list<Triggers::Trigger *>::clear((__int64)this + 32);
  operator delete(*((void **)this + 4));
}

//----- (000000018000EC50) ----------------------------------------------------
void __fastcall Triggers::Trigulator::Clear(Triggers::Trigulator *this)
{
  _QWORD *v1; // rdi
  __int128 v3; // xmm0
  _QWORD *v4; // rbx
  void (__fastcall ***v5)(_QWORD, __int64); // rcx
  __int128 v6; // [rsp+20h] [rbp-18h]

  v1 = (_QWORD *)((char *)this + 32);
  if ( *((_QWORD *)this + 5) )
  {
    v4 = (_QWORD *)*v1;
    while ( 1 )
    {
      v4 = (_QWORD *)*v4;
      if ( v4 == (_QWORD *)*v1 )
        break;
      v5 = (void (__fastcall ***)(_QWORD, __int64))v4[2];
      if ( v5 )
      {
        (**v5)(v5, 1LL);
        v4[2] = 0LL;
      }
    }
    std::list<Triggers::Trigger *>::clear((__int64)v1);
  }
  *((_QWORD *)&v6 + 1) = -1LL;
  LOBYTE(v6) = 0;
  v3 = v6;
  LOBYTE(v6) = 0;
  *(_OWORD *)this = v3;
  *((_OWORD *)this + 1) = (unsigned __int64)v6;
}
// 18000EC7D: variable 'v6' is possibly undefined

//----- (000000018000ECE4) ----------------------------------------------------
void __fastcall std::list<Triggers::Trigger *>::clear(__int64 a1)
{
  _QWORD *v1; // rax
  _QWORD *v3; // rcx
  _QWORD *v4; // rbx

  v1 = *(_QWORD **)a1;
  v3 = **(_QWORD ***)a1;
  *v1 = v1;
  *(_QWORD *)(*(_QWORD *)a1 + 8LL) = *(_QWORD *)a1;
  *(_QWORD *)(a1 + 8) = 0LL;
  if ( v3 != *(_QWORD **)a1 )
  {
    do
    {
      v4 = (_QWORD *)*v3;
      operator delete(v3);
      v3 = v4;
    }
    while ( v4 != *(_QWORD **)a1 );
  }
}

//----- (000000018000ED30) ----------------------------------------------------
ValidationXmlHandler::CurrentTrigger *__fastcall ValidationXmlHandler::CurrentTrigger::CurrentTrigger(
        ValidationXmlHandler::CurrentTrigger *this)
{
  *(_DWORD *)this = 0;
  *((_QWORD *)this + 1) = 0LL;
  *((_BYTE *)this + 16) = 1;
  *((_DWORD *)this + 5) = 0;
  *((_DWORD *)this + 6) = -1;
  *((_BYTE *)this + 28) = 0;
  *((_QWORD *)this + 4) = 0LL;
  *((_QWORD *)this + 6) = 0LL;
  *((_QWORD *)this + 7) = 0LL;
  *((_QWORD *)this + 8) = 0LL;
  *((_QWORD *)this + 7) = std::_Tree_alloc<0,std::_Tree_base_types<std::pair<User const,LogonJob *>>>::_Buyheadnode();
  *((_QWORD *)this + 9) = 0LL;
  *((_QWORD *)this + 10) = 0LL;
  *((_QWORD *)this + 11) = 0LL;
  Scheduling::JobSchedule::JobSchedule((struct _FILETIME *)this + 12);
  TSTime::TSTime((ValidationXmlHandler::CurrentTrigger *)((char *)this + 184));
  TSTime::TSTime((ValidationXmlHandler::CurrentTrigger *)((char *)this + 200));
  *((_DWORD *)this + 54) = 0;
  *((_DWORD *)this + 57) = 0;
  *((_QWORD *)this + 30) = 0LL;
  *((_QWORD *)this + 31) = 0LL;
  *((_QWORD *)this + 32) = 0LL;
  *((_QWORD *)this + 33) = 0LL;
  *((_QWORD *)this + 34) = 0LL;
  *((_QWORD *)this + 35) = 0LL;
  *((_QWORD *)this + 36) = 0LL;
  *((_QWORD *)this + 37) = 0LL;
  return this;
}

//----- (000000018000EE14) ----------------------------------------------------
TSTime *__fastcall TSTime::TSTime(TSTime *this)
{
  *(_BYTE *)this = 0;
  GetSystemTimeAsFileTime((LPFILETIME)this + 1);
  return this;
}

//----- (000000018000EE40) ----------------------------------------------------
__int64 __fastcall Triggers::WnfStateChangeTrigger::WnfStateChangeTrigger(
        __int64 a1,
        const OLECHAR *a2,
        __int128 *a3,
        __int128 *a4,
        int a5,
        int a6,
        char a7,
        __int128 *a8,
        __int64 a9,
        int a10,
        void *Src,
        unsigned int dwBytes)
{
  void *v14; // rax
  __int128 v15; // [rsp+50h] [rbp-38h] BYREF
  __int128 v16; // [rsp+60h] [rbp-28h] BYREF
  __int128 v17; // [rsp+70h] [rbp-18h] BYREF

  v15 = *a8;
  v16 = *a4;
  v17 = *a3;
  Triggers::GenericTrigger::GenericTrigger(a1, a2, &v17, &v16, a5, a6, a7, &v15);
  *(_QWORD *)a1 = &Triggers::WnfStateChangeTrigger::`vftable';
  *(_DWORD *)(a1 + 96) = dwBytes;
  *(_DWORD *)(a1 + 100) = a10;
  if ( dwBytes )
  {
    v14 = operator new(dwBytes);
    *(_QWORD *)(a1 + 104) = v14;
    memcpy_0(v14, Src, *(unsigned int *)(a1 + 96));
  }
  else
  {
    *(_QWORD *)(a1 + 104) = 0LL;
  }
  *(_QWORD *)(a1 + 88) = a9;
  return a1;
}
// 1800709F8: using guessed type void *Triggers::WnfStateChangeTrigger::`vftable';
// 18000EE40: using guessed type __int128 var_18;

//----- (000000018000EF20) ----------------------------------------------------
char __fastcall FolderEnumerator::FindNext(FolderEnumerator *this)
{
  DWORD v2; // edi
  HKEY i; // rcx
  LSTATUS v4; // eax
  LSTATUS v5; // ecx
  bool v6; // zf
  DWORD Type; // [rsp+48h] [rbp-C0h] BYREF
  DWORD cbData; // [rsp+4Ch] [rbp-BCh] BYREF
  void **pExceptionObject; // [rsp+50h] [rbp-B8h] BYREF
  char v11; // [rsp+58h] [rbp-B0h]
  const unsigned __int16 *v12; // [rsp+60h] [rbp-A8h]
  __int64 v13; // [rsp+68h] [rbp-A0h]
  __int64 v14; // [rsp+70h] [rbp-98h]
  LSTATUS v15; // [rsp+78h] [rbp-90h]
  int v16; // [rsp+7Ch] [rbp-8Ch]
  int v17; // [rsp+80h] [rbp-88h]
  DWORD cchName; // [rsp+88h] [rbp-80h] BYREF
  HKEY phkResult; // [rsp+90h] [rbp-78h] BYREF
  BYTE Data[4]; // [rsp+98h] [rbp-70h] BYREF
  __int64 v21; // [rsp+A0h] [rbp-68h]
  WCHAR Name[264]; // [rsp+A8h] [rbp-60h] BYREF

  v21 = -2LL;
  v2 = *((_DWORD *)this + 9) + 1;
  phkResult = 0LL;
  for ( i = (HKEY)*((_QWORD *)this + 3); ; i = (HKEY)*((_QWORD *)this + 3) )
  {
    cchName = 261;
    v4 = RegEnumKeyExW(i, v2, Name, &cchName, 0LL, 0LL, 0LL, 0LL);
    if ( v4 == 259 )
      break;
    if ( v4 )
    {
      v11 = 0;
      pExceptionObject = &wmi::GenericException::`vftable';
      v12 = &word_18007630E;
      v13 = 0LL;
      v14 = 0LL;
      v15 = v4;
      v16 = -1;
      v17 = -1;
      CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
    }
    v5 = RegOpenKeyExW(*((HKEY *)this + 3), Name, 0, 0x20019u, &phkResult);
    if ( v5 )
    {
      v11 = 0;
      pExceptionObject = &wmi::GenericException::`vftable';
      v12 = &word_18007630E;
      v13 = 0LL;
      v14 = 0LL;
      v15 = v5;
      v16 = -1;
      v17 = -1;
      CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
    }
    Type = 1;
    cbData = 0;
    if ( RegQueryValueExW(phkResult, L"Id", 0LL, &Type, 0LL, &cbData) == 2 )
    {
      v6 = *((_BYTE *)this + 32) == 0;
    }
    else
    {
      if ( Type != 1 )
      {
        v11 = 0;
        pExceptionObject = &wmi::GenericException::`vftable';
        v12 = &word_18007630E;
        v13 = 0LL;
        v14 = 0LL;
        v15 = 1359;
        v16 = -1;
        v17 = -1;
        CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
      }
      if ( cbData > 0x50 )
      {
        v11 = 0;
        pExceptionObject = &wmi::GenericException::`vftable';
        v12 = &word_18007630E;
        v13 = 0LL;
        v14 = 0LL;
        v15 = 1359;
        v16 = -1;
        v17 = -1;
        CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
      }
      if ( *((_BYTE *)this + 32) )
        goto LABEL_15;
      Type = 4;
      cbData = 4;
      if ( RegQueryValueExW(phkResult, L"Index", 0LL, &Type, Data, &cbData) )
      {
        v11 = 0;
        pExceptionObject = &wmi::GenericException::`vftable';
        v12 = &word_18007630E;
        v13 = 0LL;
        v14 = 0LL;
        v15 = 1359;
        v16 = -1;
        v17 = -1;
        CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
      }
      if ( Type != 4 )
      {
        v11 = 0;
        pExceptionObject = &wmi::GenericException::`vftable';
        v12 = &word_18007630E;
        v13 = 0LL;
        v14 = 0LL;
        v15 = 1359;
        v16 = -1;
        v17 = -1;
        CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
      }
      if ( cbData != 4 )
      {
        v11 = 0;
        pExceptionObject = &wmi::GenericException::`vftable';
        v12 = &word_18007630E;
        v13 = 0LL;
        v14 = 0LL;
        v15 = 1359;
        v16 = -1;
        v17 = -1;
        CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
      }
      v6 = *(_DWORD *)Data == 0;
    }
    if ( !v6 )
    {
      wmi::AutoRegKey::Close(&phkResult);
      *((_DWORD *)this + 9) = v2;
      _bstr_t::operator=((_bstr_t::Data_t **)this + 5, Name);
      return 1;
    }
LABEL_15:
    ++v2;
    wmi::AutoRegKey::Close(&phkResult);
    phkResult = 0LL;
  }
  wmi::AutoRegKey::Close(&phkResult);
  return 0;
}
// 1800716D8: using guessed type void *wmi::GenericException::`vftable';

//----- (000000018000F11C) ----------------------------------------------------
__int64 __fastcall RpcServer::EnumFolder(
        RpcServer *this,
        char *a2,
        char a3,
        int a4,
        unsigned int *a5,
        unsigned int a6,
        unsigned int *a7,
        unsigned __int16 ***a8)
{
  unsigned int v11; // r13d
  FolderEnumerator *v12; // r15
  const unsigned __int16 *v13; // r8
  __int64 result; // rax
  int CallerToken; // esi
  RTL_SRWLOCK *v16; // rdi
  HKEY *v17; // rbx
  FolderEnumerator *v18; // rax
  unsigned int v19; // ebx
  __int64 v20; // r12
  unsigned int v21; // ecx
  __int64 v22; // r14
  char *v23; // rbx
  wchar_t *v24; // r13
  unsigned __int64 v25; // r14
  char v26; // cl
  __int64 v27; // r12
  unsigned __int16 *v28; // rdx
  tsched **v29; // rcx
  tsched *v30; // rax
  JobStore *v31; // rdi
  int TreeInfo; // eax
  DWORD v33; // r8d
  HANDLE v34; // rcx
  unsigned __int64 v35; // r14
  unsigned __int16 *v36; // r8
  unsigned __int64 v37; // rax
  unsigned __int16 **v38; // rax
  JobStore *v39; // rdi
  char v40; // r12
  unsigned __int16 *v41; // rdx
  tsched **v42; // rax
  tsched *v43; // r9
  int v44; // eax
  DWORD v45; // r8d
  HANDLE v46; // rcx
  int v47; // r14d
  unsigned __int16 ***v48; // r12
  char Next; // [rsp+38h] [rbp-D0h]
  HANDLE ClientToken; // [rsp+40h] [rbp-C8h] BYREF
  HKEY v51; // [rsp+48h] [rbp-C0h] BYREF
  HKEY v52; // [rsp+50h] [rbp-B8h] BYREF
  __int64 v53; // [rsp+58h] [rbp-B0h]
  unsigned __int16 *v54; // [rsp+60h] [rbp-A8h] BYREF
  unsigned __int64 v55; // [rsp+68h] [rbp-A0h] BYREF
  RTL_SRWLOCK *v56; // [rsp+70h] [rbp-98h]
  JobStore *v57; // [rsp+78h] [rbp-90h]
  unsigned __int16 ***v58; // [rsp+80h] [rbp-88h]
  unsigned int *v59; // [rsp+88h] [rbp-80h]
  unsigned int *v60; // [rsp+90h] [rbp-78h]
  void *v61[5]; // [rsp+98h] [rbp-70h] BYREF
  struct _FILETIME v62[7]; // [rsp+C0h] [rbp-48h] BYREF
  struct _FILETIME v63[7]; // [rsp+F8h] [rbp-10h] BYREF
  struct _GUID v64; // [rsp+130h] [rbp+28h] BYREF
  char v65[16]; // [rsp+140h] [rbp+38h] BYREF
  char v66[16]; // [rsp+150h] [rbp+48h] BYREF
  wmi::RefBase *v67; // [rsp+160h] [rbp+58h] BYREF
  char v68[16]; // [rsp+168h] [rbp+60h] BYREF
  char v69[16]; // [rsp+178h] [rbp+70h] BYREF
  wmi::RefBase *v70; // [rsp+188h] [rbp+80h] BYREF
  struct _GUID v71; // [rsp+190h] [rbp+88h] BYREF
  struct _GUID v72; // [rsp+1A0h] [rbp+98h] BYREF
  unsigned __int16 v73[264]; // [rsp+1B8h] [rbp+B0h] BYREF
  unsigned __int16 v74[264]; // [rsp+3C8h] [rbp+2C0h] BYREF

  v61[2] = (void *)-2LL;
  LODWORD(v53) = a4;
  v60 = a5;
  v11 = a6;
  v59 = a7;
  v58 = a8;
  v12 = 0LL;
  if ( !a7 )
    return 2147942487LL;
  if ( !a8 )
    return 2147942487LL;
  if ( !a5 )
    return 2147942487LL;
  *a7 = 0;
  *a8 = 0LL;
  if ( (a4 & 0xFFFFFFFE) != 0 )
    return 2147942487LL;
  memset_0(v74, 0, 0x20AuLL);
  result = tsched::TaskPathCanonicalize((tsched *)v74, a2, v13);
  if ( (int)result >= 0 )
  {
    ClientToken = 0LL;
    CallerToken = GetCallerToken(L"EnumFolder", &ClientToken);
    if ( CallerToken < 0 )
      goto LABEL_44;
    v16 = (RTL_SRWLOCK *)((char *)this + 16);
    v56 = v16;
    AcquireSRWLockShared(v16);
    v17 = (HKEY *)JobStore::m_pCommonStore;
    v57 = JobStore::m_pCommonStore;
    JobSecurity::JobSecurity((JobSecurity *)v61);
    CallerToken = JobStore::RegJobSecurityQuery(v17, v74, v61);
    if ( CallerToken < 0 )
      goto LABEL_43;
    if ( (int)JobStore::RegGetTreeInfo(v17, v74, &v72, 0LL) >= 0
      || (CallerToken = 1, (int)TaskAccessCheck(ClientToken, v74, 1u) < 0)
      && (int)TaskAccessCheck(ClientToken, v74, 2u) < 0 )
    {
      CallerToken = -2147024893;
      goto LABEL_43;
    }
    v18 = (FolderEnumerator *)operator new(0x30uLL);
    *(_QWORD *)&v64.Data1 = v18;
    if ( v18 )
      v12 = FolderEnumerator::FolderEnumerator(v18, v74, a3);
    v61[3] = v12;
    if ( v12 )
    {
      _InterlockedAdd((volatile signed __int32 *)v12 + 2, 1u);
      v16 = v56;
    }
    memset_0(v73, 0, 0x20AuLL);
    v19 = *v60;
    if ( !*v60 )
    {
LABEL_15:
      if ( a6 - 1 > 0x1FF )
        v11 = 512;
      LODWORD(v52) = v11;
      v20 = v11;
      v21 = 0x10000;
      if ( 528 * (unsigned __int64)v11 <= 0x10000 )
        v21 = 528 * v11;
      v22 = v21;
      v23 = (char *)operator new(v21);
      v61[4] = v23;
      if ( !v23 )
      {
        CallerToken = -2147024882;
        goto LABEL_40;
      }
      v24 = (wchar_t *)&v23[8 * v11];
      v54 = (unsigned __int16 *)&v23[8 * v20];
      v25 = (unsigned __int64)(v22 - 8 * v20) >> 1;
      v55 = v25;
      v26 = 0;
      Next = 0;
      v27 = 0LL;
      if ( !(_DWORD)v52 )
        goto LABEL_48;
      while ( 1 )
      {
        if ( !v25 || (Next = FolderEnumerator::FindNext(v12)) == 0 )
        {
LABEL_37:
          v16 = v56;
          v26 = Next;
          if ( (_DWORD)v27 )
          {
            v38 = (unsigned __int16 **)v23;
            v23 = 0LL;
            goto LABEL_39;
          }
LABEL_48:
          v38 = 0LL;
LABEL_39:
          *v58 = v38;
          *v59 = v27;
          *v60 += v27;
          CallerToken = v26 != 0;
LABEL_40:
          operator delete(v23);
LABEL_41:
          if ( v12 )
            wmi::RefBase::Release(v12);
LABEL_43:
          tsched::AutoLocalPtr<unsigned short>::~AutoLocalPtr<unsigned short>(v61);
          ReleaseSRWLockShared(v16);
LABEL_44:
          wmi::AutoHandle::Close(&ClientToken);
          return (unsigned int)CallerToken;
        }
        v29 = (tsched **)*((_QWORD *)v12 + 5);
        if ( v29 )
          v30 = *v29;
        else
          v30 = 0LL;
        *(_QWORD *)&v64.Data1 = v30;
        if ( (int)tsched::SafePathAppend((tsched *)v73, v28, (tsched *)v74, v30) < 0 )
          goto LABEL_36;
        v71 = 0LL;
        v31 = v57;
        TreeInfo = JobStore::RegGetTreeInfo((HKEY *)v57, v73, &v71, 0LL);
        v33 = 1;
        v34 = ClientToken;
        if ( TreeInfo >= 0 )
          break;
        LODWORD(v51) = 0;
        if ( (int)TaskAccessCheck(ClientToken, v73, 1u) < 0 )
        {
          v33 = 2;
          v34 = ClientToken;
LABEL_28:
          if ( (int)TaskAccessCheck(v34, v73, v33) < 0 )
            goto LABEL_36;
        }
        if ( (v53 & 1) != 0 || !(_DWORD)v51 )
          goto LABEL_30;
        JobMoniker::JobMoniker((JobMoniker *)v68, v73, &v71);
        v51 = 0LL;
        if ( (int)JobStore::RegOpenTaskKey((HKEY *)v31, (struct JobMoniker *)v68, &v51, 0x20019u) < 0 )
          goto LABEL_84;
        Triggers::Trigulator::Trigulator(v63);
        if ( (int)Triggers::Trigulator::StreamIn((wmi::RefBase **)v63, v51, 2, 0LL) < 0
          || (int)Triggers::Trigulator::GetBucket((Triggers::Trigulator *)v63, (struct JobMoniker *)v68) < 0
          || (*((_DWORD *)v70 + 4) & 0x800000) == 0 )
        {
          Triggers::Trigulator::~Trigulator((Triggers::Trigulator *)v63);
LABEL_84:
          wmi::AutoRegKey::Close(&v51);
          wmi::AutoRef<JobBucket>::Release(&v70);
          _bstr_t::_Free((_bstr_t *)v69);
LABEL_30:
          if ( (int)StringCchCopyExW(v24, v25, *(const unsigned __int16 **)&v64.Data1, &v54, &v55) < 0 )
            goto LABEL_37;
          *(_QWORD *)&v23[8 * v27] = v24;
          v27 = (unsigned int)(v27 + 1);
          v35 = v55;
          v36 = v54;
          if ( v55 )
          {
            v36 = v54 + 1;
            v35 = v55 - 1;
          }
          v37 = 4 * ((v36 - v24 + 3) / 4) - (v36 - v24);
          if ( v37 >= v35 )
          {
            v24 = &v36[v35];
            v25 = 0LL;
          }
          else
          {
            v24 = &v36[v37];
            v25 = v35 - v37;
          }
          v55 = v25;
          v54 = v24;
          goto LABEL_36;
        }
        Triggers::Trigulator::~Trigulator((Triggers::Trigulator *)v63);
        wmi::AutoRegKey::Close(&v51);
        wmi::AutoRef<JobBucket>::Release(&v70);
        _bstr_t::_Free((_bstr_t *)v69);
LABEL_36:
        if ( (unsigned int)v27 >= (unsigned int)v52 )
          goto LABEL_37;
      }
      LODWORD(v51) = 1;
      goto LABEL_28;
    }
    v39 = v57;
    v40 = v53;
    while ( 1 )
    {
      if ( !FolderEnumerator::FindNext(v12) )
      {
LABEL_71:
        v16 = v56;
        v48 = v58;
        if ( v19 )
        {
          *v59 = 0;
          *v48 = 0LL;
          goto LABEL_41;
        }
        goto LABEL_15;
      }
      v42 = (tsched **)*((_QWORD *)v12 + 5);
      if ( v42 )
        v43 = *v42;
      else
        v43 = 0LL;
      if ( (int)tsched::SafePathAppend((tsched *)v73, v41, (tsched *)v74, v43) < 0 )
        goto LABEL_70;
      v64 = 0LL;
      v44 = JobStore::RegGetTreeInfo((HKEY *)v39, v73, &v64, 0LL);
      v45 = 1;
      v46 = ClientToken;
      if ( v44 >= 0 )
        break;
      v47 = 0;
      if ( (int)TaskAccessCheck(ClientToken, v73, 1u) < 0 )
      {
        v45 = 2;
        v46 = ClientToken;
        goto LABEL_59;
      }
LABEL_60:
      if ( (v40 & 1) != 0 || !v47 )
        goto LABEL_69;
      JobMoniker::JobMoniker((JobMoniker *)v65, v73, &v64);
      v52 = 0LL;
      if ( (int)JobStore::RegOpenTaskKey((HKEY *)v39, (struct JobMoniker *)v65, &v52, 0x20019u) < 0 )
        goto LABEL_68;
      Triggers::Trigulator::Trigulator(v62);
      if ( (int)Triggers::Trigulator::StreamIn((wmi::RefBase **)v62, v52, 2, 0LL) < 0
        || (int)Triggers::Trigulator::GetBucket((Triggers::Trigulator *)v62, (struct JobMoniker *)v65) < 0
        || (*((_DWORD *)v67 + 4) & 0x800000) == 0 )
      {
        Triggers::Trigulator::~Trigulator((Triggers::Trigulator *)v62);
LABEL_68:
        wmi::AutoRegKey::Close(&v52);
        wmi::AutoRef<JobBucket>::Release(&v67);
        _bstr_t::_Free((_bstr_t *)v66);
LABEL_69:
        --v19;
        goto LABEL_70;
      }
      Triggers::Trigulator::~Trigulator((Triggers::Trigulator *)v62);
      wmi::AutoRegKey::Close(&v52);
      wmi::AutoRef<JobBucket>::Release(&v67);
      _bstr_t::_Free((_bstr_t *)v66);
LABEL_70:
      if ( !v19 )
        goto LABEL_71;
    }
    v47 = 1;
LABEL_59:
    if ( (int)TaskAccessCheck(v46, v73, v45) < 0 )
      goto LABEL_70;
    goto LABEL_60;
  }
  return result;
}
// 18000F1E2: variable 'v13' is possibly undefined
// 18000F3B6: variable 'v28' is possibly undefined
// 180043691: variable 'v41' is possibly undefined
// 18000F11C: using guessed type unsigned __int16 var_240[264];

//----- (000000018000F578) ----------------------------------------------------
__int64 __fastcall JobStore::RegOpenTaskKey(HKEY *this, struct JobMoniker *a2, HKEY *a3, REGSAM a4)
{
  int v5; // ebx
  HKEY v6; // rcx
  HKEY v8[3]; // [rsp+30h] [rbp-18h] BYREF

  v8[1] = HKEY_DYN_DATA|0x7FFFFFF8LL;
  v8[0] = 0LL;
  v5 = JobStore::RegOpenTaskKeyP(this, 0, a2, v8, a4);
  if ( v5 >= 0 )
  {
    v6 = v8[0];
    v8[0] = 0LL;
    *a3 = v6;
  }
  wmi::AutoRegKey::Close(v8);
  return (unsigned int)v5;
}
// 18000F578: using guessed type HKEY var_18[3];

//----- (000000018000F5D8) ----------------------------------------------------
__int64 __fastcall JobStore::RegOpenTaskKeyP(
        HKEY *this,
        unsigned __int8 a2,
        struct JobMoniker *a3,
        HKEY *a4,
        REGSAM samDesired)
{
  int TaskIdWithRecovery; // eax
  int v10; // edi
  wchar_t *v11; // rbx
  LSTATUS v12; // eax
  HKEY v13; // rax
  __int64 result; // rax
  const wchar_t *v15; // rax
  const unsigned __int16 *Path; // rax
  HKEY phkResult; // [rsp+38h] [rbp-61h] BYREF
  LPCWSTR lpSubKey[2]; // [rsp+40h] [rbp-59h] BYREF
  GUID rguid; // [rsp+50h] [rbp-49h] BYREF
  OLECHAR sz[40]; // [rsp+68h] [rbp-31h] BYREF

  lpSubKey[1] = (LPCWSTR)-2LL;
  rguid = 0LL;
  TaskIdWithRecovery = JobStore::RegGetTaskIdWithRecovery(this, a3, &rguid, a2, 0LL);
  v10 = TaskIdWithRecovery;
  if ( !a2 )
  {
LABEL_2:
    if ( v10 >= 0 )
    {
      ATL::CComBSTR::CComBSTR((ATL::CComBSTR *)lpSubKey, L"TaskCache\\Tasks\\");
      memset_0(sz, 0, 0x4EuLL);
      if ( StringFromGUID2(&rguid, sz, 39) )
      {
        ATL::CComBSTR::operator+=((const void **)lpSubKey, sz);
        phkResult = 0LL;
        v11 = (wchar_t *)lpSubKey[0];
        v12 = RegOpenKeyExW(this[2], lpSubKey[0], 0, samDesired, &phkResult);
        v10 = v12;
        if ( v12 )
        {
          if ( v12 > 0 )
            v10 = (unsigned __int16)v12 | 0x80070000;
          if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
            && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
            && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
          {
            Path = JobMoniker::GetPath(a3);
            WPP_SF_SSD(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              0x2Du,
              (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
              v11,
              (__int64)Path);
          }
        }
        else
        {
          v13 = phkResult;
          phkResult = 0LL;
          *a4 = v13;
        }
        wmi::AutoRegKey::Close(&phkResult);
      }
      else
      {
        v10 = -2147024774;
        v11 = (wchar_t *)lpSubKey[0];
      }
      SysFreeString(v11);
    }
    return (unsigned int)v10;
  }
  if ( TaskIdWithRecovery != -2147216621 )
  {
    if ( !(unsigned int)JobStore::IsMigrationCleanupCompleted((JobStore *)this) )
      v10 = JobStore::MigrateDynamicTaskInfo((__int64 **)this, a3, &rguid);
    goto LABEL_2;
  }
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
  {
    v15 = JobMoniker::GetPath(a3);
    WPP_SF_S(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x2Cu, (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids, v15);
  }
  JobStore::MigrateDynamicTaskInfo((__int64 **)this, a3, &rguid);
  result = JobStore::RemoveTaskEntryP((__int64)this, a3, 2);
  if ( (int)result >= 0 )
    return 2147750670LL;
  return result;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018000F738) ----------------------------------------------------
const void **__fastcall ATL::CComBSTR::operator+=(const void **a1, const unsigned __int16 *a2)
{
  __int64 v3; // rax
  int v4; // eax

  if ( a2 )
  {
    v3 = -1LL;
    do
      ++v3;
    while ( a2[v3] );
  }
  else
  {
    LODWORD(v3) = 0;
  }
  v4 = ATL::CComBSTR::Append(a1, a2, v3);
  if ( v4 < 0 )
    ATL::PrivateAtlThrow(v4);
  return a1;
}

//----- (000000018000F788) ----------------------------------------------------
__int64 __fastcall ATL::CComBSTR::Append(const void **this, const unsigned __int16 *a2, int a3)
{
  __int64 v3; // rbp
  OLECHAR *v6; // rcx
  signed int v7; // eax
  __int64 v8; // r14
  signed int v9; // esi
  BSTR v10; // rdi
  errno_t v11; // eax
  errno_t v12; // eax

  v3 = a3;
  if ( !a2 )
    return 0LL;
  v6 = (OLECHAR *)*this;
  if ( v6 )
  {
    if ( !a3 )
      return 0LL;
  }
  v7 = SysStringLen(v6);
  v8 = v7;
  v9 = v7 + v3;
  if ( v7 + (int)v3 >= v7 )
  {
    v10 = SysAllocStringLen(0LL, v9);
    if ( v10 )
    {
      if ( SysStringLen((BSTR)*this) )
      {
        v11 = memcpy_s(v10, 2LL * v9, *this, 2 * v8);
        if ( v11 )
        {
          if ( v11 == 12 )
            goto LABEL_22;
          if ( v11 == 22 || v11 == 34 )
            goto LABEL_21;
          if ( v11 != 80 )
            goto LABEL_20;
        }
      }
      v12 = memcpy_s(&v10[v8], 2 * v3, a2, 2 * v3);
      if ( !v12 )
      {
LABEL_9:
        v10[v9] = 0;
        SysFreeString((BSTR)*this);
        *this = v10;
        return 0LL;
      }
      if ( v12 != 12 )
      {
        if ( v12 != 22 && v12 != 34 )
        {
          if ( v12 == 80 )
            goto LABEL_9;
LABEL_20:
          ATL::PrivateAtlThrow(-2147467259);
        }
LABEL_21:
        ATL::PrivateAtlThrow(-2147024809);
      }
LABEL_22:
      ATL::PrivateAtlThrow(-2147024882);
    }
  }
  return 2147942414LL;
}

//----- (000000018000F8A4) ----------------------------------------------------
ATL::CComBSTR *__fastcall ATL::CComBSTR::CComBSTR(ATL::CComBSTR *this, const unsigned __int16 *a2)
{
  BSTR v3; // rax

  if ( a2 )
  {
    v3 = SysAllocString(a2);
    *(_QWORD *)this = v3;
    if ( !v3 )
      ATL::PrivateAtlThrow(-2147024882);
  }
  else
  {
    *(_QWORD *)this = 0LL;
  }
  return this;
}

//----- (000000018000F8E4) ----------------------------------------------------
__int64 __fastcall JobStore::RegGetTaskIdWithRecovery(HKEY *a1, JobMoniker *a2, struct _GUID *a3, int a4, _DWORD *a5)
{
  struct _GUID v5; // xmm6
  const unsigned __int16 *Path; // rax
  enum JobStore::TaskIndex *v10; // r12
  __int64 v11; // rcx
  __int64 result; // rax
  struct _GUID v13; // xmm0
  __int64 v14; // rax
  __int64 v15; // rbx
  __int64 v16; // rax
  const wchar_t *v17; // rax
  int v18; // [rsp+20h] [rbp-50h] BYREF
  JobMoniker *v19; // [rsp+28h] [rbp-48h]
  struct _GUID v20; // [rsp+30h] [rbp-40h] BYREF
  struct _GUID v21; // [rsp+40h] [rbp-30h]

  v5 = *(struct _GUID *)a2;
  v19 = a2;
  v21 = v5;
  Path = JobMoniker::GetPath(a2);
  v10 = (enum JobStore::TaskIndex *)&v18;
  v18 = 0;
  if ( !a5 )
    v10 = 0LL;
  v20 = 0LL;
  v11 = *(_QWORD *)&GUID_NULL.Data1 - *(_QWORD *)&v5.Data1;
  if ( *(_QWORD *)&GUID_NULL.Data1 == *(_QWORD *)&v5.Data1 )
    v11 = *(_QWORD *)GUID_NULL.Data4 - *(_QWORD *)v21.Data4;
  if ( !v11 || a5 || a4 == 1 )
  {
    result = JobStore::RegGetTreeInfo(a1, Path, &v20, v10);
    if ( (int)result < 0 )
      return result;
    if ( a4 != 2 )
      goto LABEL_14;
    v16 = *(_QWORD *)&v5.Data1 - *(_QWORD *)&v20.Data1;
    if ( *(_QWORD *)&v5.Data1 == *(_QWORD *)&v20.Data1 )
      v16 = *(_QWORD *)v21.Data4 - *(_QWORD *)v20.Data4;
    if ( v16 )
    {
      v13 = v5;
      v20 = v5;
    }
    else
    {
LABEL_14:
      v13 = v20;
    }
    v14 = *(_QWORD *)&GUID_NULL.Data1 - *(_QWORD *)&v5.Data1;
    if ( *(_QWORD *)&GUID_NULL.Data1 == *(_QWORD *)&v5.Data1 )
      v14 = *(_QWORD *)GUID_NULL.Data4 - *(_QWORD *)v21.Data4;
    if ( v14 )
    {
      v15 = *(_QWORD *)&v5.Data1 - *(_QWORD *)&v20.Data1;
      if ( *(_QWORD *)&v5.Data1 == *(_QWORD *)&v20.Data1 )
        v15 = *(_QWORD *)v21.Data4 - *(_QWORD *)v20.Data4;
      if ( v15 )
      {
        *a3 = v13;
        return 2147750675LL;
      }
    }
    else
    {
      v5 = v13;
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 3u )
      {
        v17 = JobMoniker::GetPath(v19);
        WPP_SF_S(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x51u,
          (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
          v17);
      }
    }
  }
  *a3 = v5;
  if ( a5 )
    *a5 = *(_DWORD *)v10;
  return 0LL;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018000FA40) ----------------------------------------------------
__int64 __fastcall StringStream::QueryInterface(StringStream *this, const struct _GUID *a2, void **a3)
{
  __int64 v3; // rax
  __int64 v4; // rax
  __int64 v5; // rax

  v3 = *(_QWORD *)&a2->Data1 - *(_QWORD *)&IID_IUnknown.Data1;
  if ( *(_QWORD *)&a2->Data1 == *(_QWORD *)&IID_IUnknown.Data1 )
    v3 = *(_QWORD *)a2->Data4 - *(_QWORD *)IID_IUnknown.Data4;
  if ( !v3 )
    goto LABEL_11;
  v4 = *(_QWORD *)&a2->Data1 - *(_QWORD *)&IID_ISequentialStream.Data1;
  if ( *(_QWORD *)&a2->Data1 == *(_QWORD *)&IID_ISequentialStream.Data1 )
    v4 = *(_QWORD *)a2->Data4 - *(_QWORD *)IID_ISequentialStream.Data4;
  if ( !v4 )
    goto LABEL_11;
  v5 = *(_QWORD *)&a2->Data1 - *(_QWORD *)&IID_IStream.Data1;
  if ( *(_QWORD *)&a2->Data1 == *(_QWORD *)&IID_IStream.Data1 )
    v5 = *(_QWORD *)a2->Data4 - *(_QWORD *)IID_IStream.Data4;
  if ( v5 )
  {
    *a3 = 0LL;
    return 2147500034LL;
  }
  else
  {
LABEL_11:
    *a3 = this;
    (*(void (__fastcall **)(StringStream *))(*(_QWORD *)this + 8LL))(this);
    return 0LL;
  }
}

//----- (000000018000FAC4) ----------------------------------------------------
const unsigned __int16 *__fastcall JobMoniker::GetPath(JobMoniker *this)
{
  BSTR *v1; // rax
  __int64 v2; // rbx
  UINT v4; // eax
  __int64 *v5; // rax

  v1 = (BSTR *)*((_QWORD *)this + 2);
  v2 = 0LL;
  if ( v1 && *v1 )
    v4 = SysStringLen(*v1);
  else
    v4 = 0;
  if ( !v4 )
    return 0LL;
  v5 = (__int64 *)*((_QWORD *)this + 2);
  if ( v5 )
    v2 = *v5;
  return (const unsigned __int16 *)(v2 + 14);
}

//----- (000000018000FB20) ----------------------------------------------------
__int64 __fastcall ExeTask::StreamIn(ExeTask *this, unsigned __int16 a2, unsigned __int8 **a3, unsigned __int8 *a4)
{
  __int64 result; // rax
  int v9; // r10d

  result = JobStore::StreamInBSTR((_bstr_t::Data_t **)this + 2, a3, a4);
  if ( (int)result >= 0 )
  {
    result = JobStore::StreamInBSTR((_bstr_t::Data_t **)this + 6, a3, a4);
    if ( (int)result >= 0 )
    {
      result = JobStore::StreamInBSTR((_bstr_t::Data_t **)this + 7, a3, a4);
      if ( (int)result >= 0 )
      {
        v9 = JobStore::StreamInBSTR((_bstr_t::Data_t **)this + 8, a3, a4);
        if ( v9 >= 0 && a2 >= 3u )
          JobStore::StreamInUSHORT((unsigned __int16 *)this + 36, (unsigned __int16 **)a3, a4);
        return (unsigned int)v9;
      }
    }
  }
  return result;
}
// 18000FBA4: variable 'v9' is possibly undefined

//----- (000000018000FBD0) ----------------------------------------------------
ComHandlerTask *__fastcall ComHandlerTask::`vector deleting destructor'(ComHandlerTask *this, char a2)
{
  *(_QWORD *)this = &ComHandlerTask::`vftable';
  ComHandlerBase::~ComHandlerBase(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 180070820: using guessed type void *ComHandlerTask::`vftable';

//----- (000000018000FC10) ----------------------------------------------------
void __fastcall ComHandlerBase::~ComHandlerBase(ComHandlerBase *this)
{
  __int64 v2; // rcx

  *(_QWORD *)this = &ComHandlerBase::`vftable';
  v2 = *((_QWORD *)this + 7);
  if ( v2 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v2 + 16LL))(v2);
  _bstr_t::_Free((ComHandlerBase *)((char *)this + 72));
  _bstr_t::_Free((ComHandlerBase *)((char *)this + 64));
  Task::~Task(this);
}
// 180070870: using guessed type void *ComHandlerBase::`vftable';

//----- (000000018000FC60) ----------------------------------------------------
Task *__fastcall Task::Task(Task *this, const struct _bstr_t *a2, const struct _bstr_t *a3)
{
  __int64 v3; // rax
  __int64 v4; // rax

  *((_DWORD *)this + 2) = 0;
  *((_DWORD *)this + 3) = 0;
  *(_QWORD *)this = &Task::`vftable';
  v3 = *(_QWORD *)a2;
  *((_QWORD *)this + 2) = *(_QWORD *)a2;
  if ( v3 )
    _InterlockedIncrement((volatile signed __int32 *)(v3 + 16));
  v4 = *(_QWORD *)a3;
  *((_QWORD *)this + 3) = *(_QWORD *)a3;
  if ( v4 )
    _InterlockedIncrement((volatile signed __int32 *)(v4 + 16));
  *((_BYTE *)this + 32) = 1;
  return this;
}
// 1800708B8: using guessed type void *Task::`vftable';

//----- (000000018000FCA8) ----------------------------------------------------
void __fastcall Task::~Task(Task *this)
{
  *(_QWORD *)this = &Task::`vftable';
  _bstr_t::_Free((Task *)((char *)this + 24));
  _bstr_t::_Free((Task *)((char *)this + 16));
}
// 1800708B8: using guessed type void *Task::`vftable';

//----- (000000018000FCD8) ----------------------------------------------------
__int64 __fastcall Triggers::Trigulator::ReadDWORD(
        Triggers::Trigulator *this,
        HKEY a2,
        const unsigned __int16 *a3,
        __int64 a4,
        unsigned int *a5)
{
  unsigned int *v5; // rdi
  LSTATUS v6; // eax
  unsigned int v7; // ebx
  DWORD v9; // [rsp+50h] [rbp+18h] BYREF
  int v10; // [rsp+54h] [rbp+1Ch]
  DWORD v11; // [rsp+58h] [rbp+20h] BYREF

  v10 = HIDWORD(a3);
  v5 = a5;
  v9 = 4;
  v11 = 4;
  v6 = RegQueryValueExW(a2, L"Schema", 0LL, &v11, (LPBYTE)a5, &v9);
  v7 = v6;
  if ( v6 == 2 )
  {
    *v5 = 0;
    return 0LL;
  }
  if ( !v6 && v11 == 4 && v9 == 4 )
    return 0LL;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
  {
    WPP_SF_SD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0xAu,
      (__int64)&WPP_9c6330531b9f37c0b720c7be8cd79119_Traceguids,
      L"Schema");
  }
  return v7;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018000FD6C) ----------------------------------------------------
__int64 __fastcall Triggers::Trigulator::ReadHashData(JobBucket **this, HKEY a2, unsigned __int8 *a3, DWORD a4)
{
  void *v7; // rbx
  LSTATUS v8; // eax
  unsigned __int64 v9; // rcx
  unsigned int v10; // edi
  void *v12; // rax
  int v13; // ecx
  int v14; // edi
  DWORD Type; // [rsp+30h] [rbp-28h] BYREF
  void *v16[4]; // [rsp+38h] [rbp-20h] BYREF
  DWORD cbData; // [rsp+78h] [rbp+20h] BYREF

  cbData = a4;
  v16[1] = (void *)-2LL;
  v7 = 0LL;
  v16[0] = 0LL;
  Type = 0;
  if ( a4 < 0x20 )
  {
    v12 = operator new(0x20uLL);
    wmi::AutoVectorPtr<unsigned char>::operator=(v16, v12);
    v7 = v16[0];
    if ( !v16[0] )
    {
      v10 = 8;
      goto LABEL_7;
    }
    a3 = (unsigned __int8 *)v16[0];
    cbData = 32;
  }
  v8 = RegQueryValueExW(a2, L"Hash", 0LL, &Type, a3, &cbData);
  v9 = (unsigned int)v8;
  if ( !v8 && cbData == 32 && Type == 3 )
  {
    JobBucket::SetHash(this[6], a3);
LABEL_6:
    v10 = 0;
    goto LABEL_7;
  }
  *((_DWORD *)this[6] + 15) = 0;
  if ( v8 > 0 )
    v9 = (unsigned __int16)v8 | 0x80070000;
  v14 = 0;
  if ( !tsched::IsErrorNotFound((tsched *)v9) )
    v14 = v13;
  if ( v14 >= 0 )
    goto LABEL_6;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
  {
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xDu, (__int64)&WPP_9c6330531b9f37c0b720c7be8cd79119_Traceguids, v14);
  }
  v10 = -2147216607;
LABEL_7:
  operator delete(v7);
  return v10;
}
// 180043BCD: variable 'v13' is possibly undefined
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018000FE2C) ----------------------------------------------------
__int64 __fastcall Triggers::Trigulator::ReadTriggerBlobData(
        __int64 a1,
        HKEY a2,
        BYTE *lpData,
        _DWORD *a4,
        BYTE **a5,
        BYTE **a6)
{
  BYTE *v8; // rdi
  LSTATUS v9; // ebx
  int v10; // ecx
  void *v12; // rax
  BYTE **v13; // rbx
  __int64 cbData; // [rsp+50h] [rbp+8h] BYREF
  DWORD Type; // [rsp+60h] [rbp+18h] BYREF

  cbData = a1;
  LODWORD(cbData) = *a4;
  v8 = lpData;
  v9 = RegQueryValueExW(a2, L"Triggers", 0LL, &Type, lpData, (LPDWORD)&cbData);
  if ( v9 == 234 )
  {
    v12 = operator new((unsigned int)cbData);
    v13 = a5;
    wmi::AutoVectorPtr<unsigned char>::operator=((void **)a5, v12);
    v8 = *v13;
    if ( !*v13 )
      return (unsigned int)-2147024882;
    v9 = RegQueryValueExW(a2, L"Triggers", 0LL, &Type, v8, (LPDWORD)&cbData);
  }
  if ( v9 )
  {
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_Sdd(*((_QWORD *)WPP_GLOBAL_Control + 2));
    }
    if ( v9 > 0 )
      return (unsigned __int16)v9 | 0x80070000;
  }
  else if ( Type == 3 && ((v10 = cbData, (unsigned int)cbData >= 0x28) || (_DWORD)cbData == 8) )
  {
    v9 = 0;
    *a6 = v8;
    *a4 = v10;
  }
  else
  {
    return (unsigned int)-2147418113;
  }
  return (unsigned int)v9;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018000FF20) ----------------------------------------------------
__int64 __fastcall Triggers::Trigulator::StreamIn(wmi::RefBase **this, HKEY a2, char a3, unsigned __int64 *a4)
{
  int PackageAndCapabilities; // edi
  unsigned __int8 *v9; // rax
  __int64 v10; // rcx
  unsigned int v12; // [rsp+40h] [rbp-C0h] BYREF
  unsigned __int8 *v13; // [rsp+48h] [rbp-B8h] BYREF
  __int128 v14; // [rsp+50h] [rbp-B0h] BYREF
  void *lpMem[2]; // [rsp+60h] [rbp-A0h] BYREF
  __int128 v16; // [rsp+70h] [rbp-90h] BYREF
  unsigned __int16 v17[512]; // [rsp+80h] [rbp-80h] BYREF

  lpMem[1] = (void *)-2LL;
  PackageAndCapabilities = 0;
  lpMem[0] = 0LL;
  memset_0(v17, 0, sizeof(v17));
  v9 = (unsigned __int8 *)operator new(0xD8uLL);
  v13 = v9;
  if ( v9 )
    v9 = (unsigned __int8 *)JobBucket::JobBucket((JobBucket *)v9);
  wmi::AutoRef<JobBucket>::operator=(this + 6, (volatile signed __int32 *)v9);
  if ( this[6] )
  {
    if ( (a3 & 1) == 0
      || (PackageAndCapabilities = Triggers::Trigulator::ReadHashData(this, a2, (unsigned __int8 *)v17, 0x400u),
          PackageAndCapabilities >= 0) )
    {
      if ( (a3 & 8) == 0
        || (PackageAndCapabilities = Triggers::Trigulator::ReadRegistrationData(
                                       (Triggers::Trigulator *)this,
                                       a2,
                                       v17,
                                       1024LL),
            PackageAndCapabilities >= 0) )
      {
        if ( (a3 & 6) != 0 )
        {
          v12 = 1024;
          PackageAndCapabilities = Triggers::Trigulator::ReadTriggerBlobData(
                                     v10,
                                     a2,
                                     (BYTE *)v17,
                                     &v12,
                                     (BYTE **)lpMem,
                                     &v13);
          if ( PackageAndCapabilities >= 0 )
          {
            LOBYTE(v14) = 0;
            *((_QWORD *)&v14 + 1) = -1LL;
            v16 = v14;
            LOBYTE(v14) = 0;
            *((_QWORD *)&v14 + 1) = 0LL;
            PackageAndCapabilities = Triggers::Trigulator::ParseTriggerBlobData(
                                       (__int64)this,
                                       (unsigned __int64 *)v13,
                                       v12,
                                       &v14,
                                       &v16,
                                       a3,
                                       a4);
            if ( PackageAndCapabilities >= 0 )
              PackageAndCapabilities = Triggers::Trigulator::ReadPackageAndCapabilities(
                                         (_bstr_t ***)this,
                                         a2,
                                         v13,
                                         0x400u);
          }
        }
      }
    }
  }
  else
  {
    PackageAndCapabilities = -2147024882;
  }
  operator delete(lpMem[0]);
  return (unsigned int)PackageAndCapabilities;
}
// 180010049: variable 'v10' is possibly undefined
// 18000FF20: using guessed type unsigned __int16 var_440[512];

//----- (00000001800100D8) ----------------------------------------------------
__int64 __fastcall Triggers::Trigulator::ReadPackageAndCapabilities(
        _bstr_t ***this,
        HKEY a2,
        unsigned __int8 *a3,
        DWORD a4)
{
  signed int v8; // eax
  unsigned int v9; // ebx
  bool v10; // cc
  __int64 v11; // rcx
  __int64 v12; // r8
  DWORD v14; // [rsp+30h] [rbp-48h]
  DWORD v15; // [rsp+30h] [rbp-48h]
  unsigned int v16[2]; // [rsp+50h] [rbp-28h] BYREF
  void *lpMem; // [rsp+58h] [rbp-20h] BYREF
  unsigned __int16 *v18[2]; // [rsp+60h] [rbp-18h] BYREF

  v18[1] = (unsigned __int16 *)-2LL;
  lpMem = 0LL;
  v8 = Triggers::Trigulator::ReadString((__int64)this, a2, L"Package", a3, a4, &lpMem, v14, v16);
  v9 = v8;
  v10 = v8 <= 0;
  if ( v8
    || (_bstr_t::operator=(this[6] + 22, *(const OLECHAR **)v16),
        v8 = Triggers::Trigulator::ReadMultiString(v11, a2, v12, a3, a4, &lpMem, v15, v18, v16),
        v9 = v8,
        v10 = v8 <= 0,
        v8) )
  {
    if ( !v10 )
      v9 = (unsigned __int16)v8 | 0x80070000;
  }
  else
  {
    JobBucket::SetCapabilities(this[6], v18[0], v16[0]);
  }
  operator delete(lpMem);
  return v9;
}
// 180010129: variable 'v14' is possibly undefined
// 180010175: variable 'v11' is possibly undefined
// 180010175: variable 'v12' is possibly undefined
// 180010175: variable 'v15' is possibly undefined

//----- (00000001800101C8) ----------------------------------------------------
void __fastcall JobBucket::SetCapabilities(_bstr_t **this, const unsigned __int16 *a2, unsigned int a3)
{
  unsigned __int64 v4; // rdi
  int v6; // eax
  void **pExceptionObject; // [rsp+20h] [rbp-40h] BYREF
  char v8; // [rsp+28h] [rbp-38h]
  const unsigned __int16 *v9; // [rsp+30h] [rbp-30h]
  __int64 v10; // [rsp+38h] [rbp-28h]
  __int64 v11; // [rsp+40h] [rbp-20h]
  int v12; // [rsp+48h] [rbp-18h]
  int v13; // [rsp+4Ch] [rbp-14h]
  int v14; // [rsp+50h] [rbp-10h]
  unsigned __int64 v15; // [rsp+80h] [rbp+20h] BYREF

  v4 = a3;
  std::vector<_bstr_t>::clear(this + 23);
  if ( a2 && (_DWORD)v4 )
  {
    v15 = 0LL;
    do
    {
      if ( !*a2 )
        break;
      JobBucket::AddCapability((JobBucket *)this, a2);
      v6 = StringCchLengthW(a2, v4, &v15);
      if ( v6 < 0 )
      {
        v13 = -1;
        v14 = -1;
        pExceptionObject = &wmi::GenericException::`vftable';
        v9 = &word_18007630E;
        v8 = 0;
        v10 = 0LL;
        v11 = 0LL;
        v12 = v6;
        CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
      }
      a2 += v15 + 1;
      v4 += -1LL - v15;
    }
    while ( v4 );
  }
}
// 180043CB7: conditional instruction was optimized away because rdi.8 is in (1..FFFFFFFF)
// 1800716D8: using guessed type void *wmi::GenericException::`vftable';

//----- (000000018001021C) ----------------------------------------------------
__int64 __fastcall Triggers::Trigulator::ReadMultiString(
        __int64 a1,
        HKEY a2,
        __int64 a3,
        BYTE *lpData,
        DWORD cbData,
        void **a6,
        DWORD Type,
        _QWORD *a8,
        DWORD *a9)
{
  LSTATUS v11; // eax
  unsigned int v12; // ebx
  DWORD v14; // ecx
  void **v15; // rdi
  void *v16; // rax

  v11 = RegQueryValueExW(a2, L"Capabilities", 0LL, &Type, lpData, &cbData);
  v12 = v11;
  if ( v11 )
  {
    if ( v11 == 2 )
    {
      *a8 = 0LL;
      *a9 = 0;
      return 0LL;
    }
    if ( v11 == 234 )
    {
      v15 = a6;
      if ( cbData )
      {
        v16 = operator new(cbData);
        wmi::AutoVectorPtr<unsigned char>::operator=(v15, v16);
        if ( !*v15 )
          return 8LL;
      }
      v12 = RegQueryValueExW(a2, L"Capabilities", 0LL, &Type, (LPBYTE)*v15, &cbData);
      if ( !v12 && Type == 7 )
      {
        *a8 = *v15;
        *a9 = cbData >> 1;
      }
    }
  }
  else if ( Type == 7 )
  {
    v14 = cbData >> 1;
    *a8 = lpData;
    *a9 = v14;
    return 0LL;
  }
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
  {
    WPP_SF_SD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0xCu,
      (__int64)&WPP_9c6330531b9f37c0b720c7be8cd79119_Traceguids,
      L"Capabilities");
  }
  return v12;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (00000001800102A4) ----------------------------------------------------
__int64 __fastcall Triggers::Trigulator::ReadRegistrationData(
        Triggers::Trigulator *this,
        HKEY a2,
        unsigned __int16 *a3,
        __int64 a4)
{
  DWORD v4; // r14d
  signed int v8; // eax
  unsigned int v9; // ebx
  bool v10; // cc
  __int64 v11; // rcx
  __int64 v12; // rcx
  __int64 v13; // rcx
  __int64 v14; // rcx
  __int64 v15; // rcx
  __int64 v16; // rcx
  __int64 v17; // rcx
  __int64 v18; // rcx
  __int64 v19; // rcx
  DWORD v21; // [rsp+30h] [rbp-30h]
  DWORD v22; // [rsp+30h] [rbp-30h]
  DWORD v23; // [rsp+30h] [rbp-30h]
  DWORD v24; // [rsp+30h] [rbp-30h]
  DWORD v25; // [rsp+30h] [rbp-30h]
  DWORD v26; // [rsp+30h] [rbp-30h]
  DWORD v27; // [rsp+30h] [rbp-30h]
  DWORD v28; // [rsp+30h] [rbp-30h]
  DWORD v29; // [rsp+30h] [rbp-30h]
  unsigned int v30; // [rsp+40h] [rbp-20h] BYREF
  const OLECHAR *v31; // [rsp+48h] [rbp-18h] BYREF
  void *lpMem[2]; // [rsp+50h] [rbp-10h] BYREF

  lpMem[1] = (void *)-2LL;
  v4 = a4;
  lpMem[0] = 0LL;
  v8 = Triggers::Trigulator::ReadDWORD(this, a2, a3, a4, &v30);
  v9 = v8;
  v10 = v8 <= 0;
  if ( v8 )
    goto LABEL_13;
  v11 = *((_QWORD *)this + 6);
  *(_DWORD *)(v11 + 96) = v30;
  v8 = Triggers::Trigulator::ReadString(v11, a2, L"Version", (BYTE *)a3, v4, lpMem, v21, &v31);
  v9 = v8;
  v10 = v8 <= 0;
  if ( v8 )
    goto LABEL_13;
  _bstr_t::operator=((_bstr_t::Data_t **)(*((_QWORD *)this + 6) + 112LL), v31);
  v8 = Triggers::Trigulator::ReadString(v12, a2, L"Date", (BYTE *)a3, v4, lpMem, v22, &v31);
  v9 = v8;
  v10 = v8 <= 0;
  if ( v8 )
    goto LABEL_13;
  _bstr_t::operator=((_bstr_t::Data_t **)(*((_QWORD *)this + 6) + 104LL), v31);
  v8 = Triggers::Trigulator::ReadString(v13, a2, L"SecurityDescriptor", (BYTE *)a3, v4, lpMem, v23, &v31);
  v9 = v8;
  v10 = v8 <= 0;
  if ( v8 )
    goto LABEL_13;
  _bstr_t::operator=((_bstr_t::Data_t **)(*((_QWORD *)this + 6) + 120LL), v31);
  v8 = Triggers::Trigulator::ReadString(v14, a2, L"Source", (BYTE *)a3, v4, lpMem, v24, &v31);
  v9 = v8;
  v10 = v8 <= 0;
  if ( v8 )
    goto LABEL_13;
  _bstr_t::operator=((_bstr_t::Data_t **)(*((_QWORD *)this + 6) + 128LL), v31);
  v8 = Triggers::Trigulator::ReadString(v15, a2, L"Author", (BYTE *)a3, v4, lpMem, v25, &v31);
  v9 = v8;
  v10 = v8 <= 0;
  if ( v8 )
    goto LABEL_13;
  _bstr_t::operator=((_bstr_t::Data_t **)(*((_QWORD *)this + 6) + 136LL), v31);
  v8 = Triggers::Trigulator::ReadString(v16, a2, L"Description", (BYTE *)a3, v4, lpMem, v26, &v31);
  v9 = v8;
  v10 = v8 <= 0;
  if ( v8 )
    goto LABEL_13;
  _bstr_t::operator=((_bstr_t::Data_t **)(*((_QWORD *)this + 6) + 144LL), v31);
  v8 = Triggers::Trigulator::ReadString(v17, a2, L"Documentation", (BYTE *)a3, v4, lpMem, v27, &v31);
  v9 = v8;
  v10 = v8 <= 0;
  if ( v8 )
    goto LABEL_13;
  _bstr_t::operator=((_bstr_t::Data_t **)(*((_QWORD *)this + 6) + 152LL), v31);
  v8 = Triggers::Trigulator::ReadString(v18, a2, L"Data", (BYTE *)a3, v4, lpMem, v28, &v31);
  v9 = v8;
  v10 = v8 <= 0;
  if ( v8
    || (_bstr_t::operator=((_bstr_t::Data_t **)(*((_QWORD *)this + 6) + 168LL), v31),
        v8 = Triggers::Trigulator::ReadString(v19, a2, L"URI", (BYTE *)a3, v4, lpMem, v29, &v31),
        v9 = v8,
        v10 = v8 <= 0,
        v8) )
  {
LABEL_13:
    if ( !v10 )
      v9 = (unsigned __int16)v8 | 0x80070000;
  }
  else
  {
    _bstr_t::operator=((_bstr_t::Data_t **)(*((_QWORD *)this + 6) + 160LL), v31);
  }
  operator delete(lpMem[0]);
  return v9;
}
// 18001031D: variable 'v21' is possibly undefined
// 180010361: variable 'v12' is possibly undefined
// 180010361: variable 'v22' is possibly undefined
// 1800103A5: variable 'v13' is possibly undefined
// 1800103A5: variable 'v23' is possibly undefined
// 1800103E9: variable 'v14' is possibly undefined
// 1800103E9: variable 'v24' is possibly undefined
// 18001042D: variable 'v15' is possibly undefined
// 18001042D: variable 'v25' is possibly undefined
// 180010474: variable 'v16' is possibly undefined
// 180010474: variable 'v26' is possibly undefined
// 1800104BB: variable 'v17' is possibly undefined
// 1800104BB: variable 'v27' is possibly undefined
// 180010502: variable 'v18' is possibly undefined
// 180010502: variable 'v28' is possibly undefined
// 180010549: variable 'v19' is possibly undefined
// 180010549: variable 'v29' is possibly undefined

//----- (000000018001059C) ----------------------------------------------------
__int64 __fastcall Triggers::Trigulator::ReadString(
        __int64 a1,
        HKEY a2,
        const WCHAR *a3,
        BYTE *lpData,
        DWORD cbData,
        void **a6,
        DWORD Type,
        _QWORD *a8)
{
  LSTATUS v11; // eax
  unsigned int v12; // ebx
  void **v14; // rdi
  void *v15; // rax

  v11 = RegQueryValueExW(a2, a3, 0LL, &Type, lpData, &cbData);
  v12 = v11;
  if ( v11 )
  {
    if ( v11 == 2 )
    {
      *a8 = 0LL;
      return 0LL;
    }
    if ( v11 == 234 )
    {
      v14 = a6;
      if ( cbData )
      {
        v15 = operator new(cbData);
        wmi::AutoVectorPtr<unsigned char>::operator=(v14, v15);
        if ( !*v14 )
          return 8LL;
      }
      v12 = RegQueryValueExW(a2, a3, 0LL, &Type, (LPBYTE)*v14, &cbData);
      if ( !v12 && Type == 1 )
        *a8 = *v14;
    }
  }
  else if ( Type == 1 )
  {
    *a8 = lpData;
    return 0LL;
  }
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
  {
    WPP_SF_SD(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xBu, (__int64)&WPP_9c6330531b9f37c0b720c7be8cd79119_Traceguids, a3);
  }
  return v12;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180010634) ----------------------------------------------------
__int64 __fastcall Triggers::Trigulator::GetBucket(Triggers::Trigulator *this, struct JobMoniker *a2)
{
  struct JobBucket *v2; // r8
  JobMoniker *v4; // rax
  char v6[16]; // [rsp+20h] [rbp-38h] BYREF
  char v7[16]; // [rsp+30h] [rbp-28h] BYREF
  wmi::RefBase *v8; // [rsp+40h] [rbp-18h] BYREF

  v2 = (struct JobBucket *)*((_QWORD *)this + 6);
  if ( !v2 )
    return 2147549183LL;
  v4 = JobMoniker::JobMoniker((JobMoniker *)v6, a2, v2);
  JobMoniker::operator=((__int64)a2, (__int64)v4);
  wmi::AutoRef<JobBucket>::Release(&v8);
  _bstr_t::_Free((_bstr_t *)v7);
  return 0LL;
}
// 180010634: using guessed type char var_38[16];
// 180010634: using guessed type char var_28[16];

//----- (00000001800106A4) ----------------------------------------------------
__int64 __fastcall JobMoniker::operator=(__int64 a1, __int64 a2)
{
  _bstr_t::operator=((__int64 *)(a1 + 16), (__int64 *)(a2 + 16));
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  wmi::AutoRef<JobBucket>::operator=((wmi::RefBase **)(a1 + 32), *(volatile signed __int32 **)(a2 + 32));
  return a1;
}

//----- (00000001800106F4) ----------------------------------------------------
JobMoniker *__fastcall JobMoniker::JobMoniker(JobMoniker *this, const struct JobMoniker *a2, struct JobBucket *a3)
{
  JobMoniker *result; // rax

  *((_QWORD *)this + 2) = 0LL;
  *((_QWORD *)this + 4) = 0LL;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x40) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
  {
    WPP_SF_qqq(*((_QWORD *)WPP_GLOBAL_Control + 2), (__int64)a2, (__int64)a3, this, a2, a3);
  }
  wmi::AutoRef<JobBucket>::operator=((wmi::RefBase **)this + 4, (volatile signed __int32 *)a3);
  _bstr_t::operator=((__int64 *)this + 2, (__int64 *)a2 + 2);
  *((_QWORD *)this + 3) = *((_QWORD *)a2 + 3);
  result = this;
  *(_OWORD *)this = *(_OWORD *)a2;
  return result;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180010790) ----------------------------------------------------
__int64 __fastcall Triggers::WnfStateChangeTrigger::StreamIn(
        Triggers::WnfStateChangeTrigger *this,
        unsigned __int64 a2,
        unsigned __int8 **a3,
        unsigned __int8 *a4)
{
  __int64 result; // rax
  void *v8; // rcx
  void *v9; // rax

  result = Triggers::GenericTrigger::StreamIn(this, a2, a3, a4);
  if ( (int)result >= 0 )
  {
    v8 = (void *)*((_QWORD *)this + 13);
    if ( v8 )
    {
      operator delete(v8);
      *((_QWORD *)this + 13) = 0LL;
    }
    if ( a4 - *a3 < 16 )
      return 2147549183LL;
    *((_QWORD *)this + 11) = *(_QWORD *)*a3;
    *a3 += 8;
    *((_QWORD *)this + 12) = *(_QWORD *)*a3;
    *a3 += 8;
    if ( *((_DWORD *)this + 24) )
    {
      v9 = operator new(*((unsigned int *)this + 24));
      *((_QWORD *)this + 13) = v9;
      if ( !v9 )
        return 2147942414LL;
      memcpy_0(v9, *a3, *((unsigned int *)this + 24));
      *a3 += *((unsigned int *)this + 24);
    }
    else
    {
      *((_QWORD *)this + 13) = 0LL;
    }
    return 0LL;
  }
  return result;
}

//----- (0000000180010840) ----------------------------------------------------
CBstrWriter *__fastcall CBstrWriter::CBstrWriter(CBstrWriter *this)
{
  CBstrWriter::BufferBlock *v2; // rdi
  CBstrWriter::BufferBlock *v3; // rax

  v2 = 0LL;
  *((_DWORD *)this + 2) = 0;
  *(_QWORD *)this = &CBstrWriter::`vftable';
  *((_QWORD *)this + 2) = 0LL;
  *((_QWORD *)this + 4) = 0LL;
  v3 = (CBstrWriter::BufferBlock *)operator new(0x18uLL);
  if ( v3 )
    v2 = CBstrWriter::BufferBlock::BufferBlock(v3);
  *((_QWORD *)this + 3) = v2;
  *((_QWORD *)this + 4) = v2;
  return this;
}
// 180070900: using guessed type void *CBstrWriter::`vftable';

//----- (00000001800108B0) ----------------------------------------------------
CBstrWriter *__fastcall CBstrWriter::`scalar deleting destructor'(CBstrWriter *this, char a2)
{
  CBstrWriter::~CBstrWriter(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (00000001800108E8) ----------------------------------------------------
void __fastcall CBstrWriter::~CBstrWriter(CBstrWriter *this)
{
  void **v1; // rcx

  *(_QWORD *)this = &CBstrWriter::`vftable';
  v1 = (void **)*((_QWORD *)this + 3);
  if ( v1 )
    CBstrWriter::BufferBlock::`scalar deleting destructor'(v1);
}
// 180070900: using guessed type void *CBstrWriter::`vftable';

//----- (0000000180010910) ----------------------------------------------------
Triggers::TimeTrigger *__fastcall Triggers::TimeTrigger::`vector deleting destructor'(
        Triggers::TimeTrigger *this,
        char a2)
{
  Triggers::TimeTrigger::~TimeTrigger(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (0000000180010950) ----------------------------------------------------
__int64 __fastcall _ProcessElement__QITaskXmlHandler__ServerXMLUpdateHandler__UEAAJAEBUSchema__W4TaskXmlNodeId___Z(
        __int64 a1,
        int *a2,
        unsigned int a3)
{
  int v6; // eax
  const struct SchemaEntry * near *Entry; // rax
  __int64 v9; // r10

  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && *((char *)WPP_GLOBAL_Control + 28) < 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 5u )
  {
    Entry = Schema::GetEntry(a2, a3);
    WPP_SF_S(
      *(_QWORD *)(v9 + 16),
      0xAu,
      (__int64)&WPP_6a02f12a6b2c3ac58024ebcfa94f3c9a_Traceguids,
      (const wchar_t *)Entry[1]);
  }
  v6 = ServerXMLUpdateHandler::ProcessSubHandlers(a1, (__int64)a2, a3, 0LL, 0);
  if ( v6 < 0
    || v6 != 1
    && (v6 = _ProcessElement__QITaskXmlHandler__TriggersXmlHandler__MEAAJAEBUSchema__W4TaskXmlNodeId___Z(a1, a2, a3),
        v6 < 0) )
  {
    if ( *(int *)(a1 + 1072) >= 0 )
      *(_DWORD *)(a1 + 1072) = v6;
  }
  return *(unsigned int *)(a1 + 1072);
}
// 180043F65: variable 'v9' is possibly undefined
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (00000001800109E0) ----------------------------------------------------
__int64 __fastcall _ProcessElement__QITaskXmlHandler__TriggersXmlHandler__MEAAJAEBUSchema__W4TaskXmlNodeId___Z(
        __int64 a1,
        int *a2,
        int a3)
{
  __int64 result; // rax
  int v6; // ebx
  int v7; // ebx
  int v8; // ebx

  result = _ProcessElement__QITaskXmlHandler__ValidationXmlHandler__MEAAJAEBUSchema__W4TaskXmlNodeId___Z(
             (ValidationXmlHandler *)a1,
             a2,
             a3);
  if ( (int)result >= 0 )
  {
    v6 = a3 - 103;
    if ( !v6 || (v7 = v6 - 4) == 0 || (v8 = v7 - 6) == 0 || v8 == 15 )
      TriggersXmlHandler::CurrentAction::Reset((TriggersXmlHandler::CurrentAction *)(a1 + 544));
    return 0LL;
  }
  return result;
}

//----- (0000000180010A30) ----------------------------------------------------
__int64 __fastcall _ProcessElement__QITaskXmlHandler__ValidationXmlHandler__MEAAJAEBUSchema__W4TaskXmlNodeId___Z(
        ValidationXmlHandler *this,
        int *a2,
        int a3)
{
  bool v5; // cc
  BSTR *v7; // rax
  UINT v8; // eax
  const struct SchemaEntry * near *Entry; // rax
  __int64 v10; // r10

  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && *((char *)WPP_GLOBAL_Control + 28) < 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 5u )
  {
    Entry = Schema::GetEntry(a2, a3);
    WPP_SF_S(
      *(_QWORD *)(v10 + 16),
      0xAu,
      (__int64)&WPP_66bc7a8e9c2933fa102678c8dfb90698_Traceguids,
      (const wchar_t *)Entry[1]);
  }
  if ( a3 > 53 )
  {
    if ( a3 != 54 )
    {
      switch ( a3 )
      {
        case 98:
          v7 = (BSTR *)*((_QWORD *)this + 9);
          if ( v7 && *v7 )
            v8 = SysStringLen(*v7);
          else
            v8 = 0;
          if ( !v8 )
          {
            *(_DWORD *)(*((_QWORD *)this + 5) + 16LL) &= 0xFFF03FFF;
            *((_BYTE *)this + 489) = 0;
            return 0LL;
          }
          return 2147500033LL;
        case 102:
          *((_BYTE *)this + 489) = 0;
          *((_BYTE *)this + 105) = 1;
          return 0LL;
        case 103:
        case 107:
        case 113:
        case 128:
          ValidationXmlHandler::ResetActionFields(this);
          v5 = ++*((_DWORD *)this + 110) <= 0x20u;
          goto LABEL_15;
      }
      if ( a3 != 141 )
        return 0LL;
      goto LABEL_14;
    }
    if ( !*((_BYTE *)this + 140) )
    {
      *((_DWORD *)this + 67) = 4;
      goto LABEL_42;
    }
    return 2147750678LL;
  }
  if ( a3 == 53 )
  {
    *((_WORD *)this + 138) = 0;
    return 0LL;
  }
  if ( a3 <= 37 )
  {
    if ( a3 != 37 && a3 != 21 && (a3 <= 22 || a3 > 25 && a3 != 35 && a3 != 27) )
      return 0LL;
    goto LABEL_14;
  }
  if ( a3 != 39 )
  {
    switch ( a3 )
    {
      case '(':
        if ( !*((_BYTE *)this + 140) )
        {
          *((_BYTE *)this + 140) = 1;
          *((_DWORD *)this + 67) = 1;
          *((_WORD *)this + 136) = 1;
          return 0LL;
        }
        break;
      case '*':
        if ( !*((_BYTE *)this + 140) )
        {
          *((_DWORD *)this + 67) = 2;
          *((_BYTE *)this + 140) = 1;
          *((_DWORD *)this + 68) = 1;
          return 0LL;
        }
        break;
      case '4':
        if ( !*((_BYTE *)this + 140) )
        {
          *((_DWORD *)this + 67) = 3;
LABEL_42:
          *((_BYTE *)this + 140) = 1;
          *((_WORD *)this + 138) = 4095;
          return 0LL;
        }
        break;
      default:
        return 0LL;
    }
    return 2147750678LL;
  }
LABEL_14:
  ValidationXmlHandler::CurrentTrigger::Reset((__int64)this + 112, a3);
  v5 = ++*((_DWORD *)this + 109) <= 0x30u;
LABEL_15:
  if ( v5 )
    return 0LL;
  return 2147750685LL;
}
// 180043FB1: variable 'v10' is possibly undefined
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180010BAC) ----------------------------------------------------
__int64 __fastcall ServerXMLUpdateHandler::ProcessSubHandlers(
        __int64 a1,
        __int64 a2,
        unsigned int a3,
        __int64 a4,
        char a5)
{
  _QWORD *v5; // rbx
  _QWORD *v7; // rdi
  __int64 result; // rax
  int v11; // [rsp+20h] [rbp-28h]

  v5 = *(_QWORD **)(a1 + 784);
  v7 = *(_QWORD **)(a1 + 792);
  while ( 1 )
  {
    if ( v7 == v5 )
      return 0LL;
    LOBYTE(v11) = a5;
    result = (**(__int64 (__fastcall ***)(_QWORD, __int64, _QWORD, __int64, int))*v5)(*v5, a2, a3, a4, v11);
    if ( (int)result < 0 )
      return result;
    if ( (_DWORD)result == 1 )
      break;
    ++v5;
  }
  return 1LL;
}
// 180010BFC: variable 'v11' is possibly undefined

//----- (0000000180010C40) ----------------------------------------------------
__int64 __fastcall Triggers::GenericTrigger::StreamIn(
        Triggers::GenericTrigger *this,
        unsigned __int64 a2,
        unsigned __int8 **a3,
        unsigned __int8 *a4)
{
  unsigned __int8 *v5; // r8
  BSTR **v6; // rdi
  int v7; // ecx
  char v8; // al
  BSTR *v9; // rcx

  v5 = *a3;
  if ( a4 - v5 < 72 )
    return 2147549183LL;
  *(_OWORD *)((char *)this + 8) = *(_OWORD *)v5;
  *(_OWORD *)((char *)this + 24) = *((_OWORD *)v5 + 1);
  *(_OWORD *)((char *)this + 40) = *((_OWORD *)v5 + 2);
  *(_OWORD *)((char *)this + 56) = *((_OWORD *)v5 + 3);
  *((_QWORD *)this + 9) = *((_QWORD *)v5 + 8);
  *a3 += 72;
  if ( a2 < 0x16 )
    return 0LL;
  v6 = (BSTR **)((char *)this + 80);
  v7 = JobStore::StreamInBSTR((_bstr_t::Data_t **)this + 10, a3, a4);
  v8 = 0;
  if ( v7 >= 0 )
  {
    v9 = *v6;
    if ( *v6 && *v9 )
      v8 = SysStringLen(*v9);
    if ( ((2 * v8 - 4) & 7) != 0 )
      *a3 += 8 - ((2 * v8 - 4) & 7u);
    return 0LL;
  }
  return (unsigned int)v7;
}

//----- (0000000180010CFC) ----------------------------------------------------
void __fastcall UbpmParams::~UbpmParams(UbpmParams *this)
{
  void **v2; // rbx
  void **v3; // rbx
  void **v4; // r13
  void **v5; // r12
  void **v6; // rbx
  void **v7; // rbx
  void **v8; // rbp
  void **v9; // r15
  void **v10; // rbx
  void **v11; // rbx
  void **v12; // rbx
  void **v13; // rbx
  void **v14; // rbx
  void **v15; // rbx
  void **v16; // rbx
  void **v17; // rbx
  void **v18; // rbx
  void **v19; // rbx
  void **v20; // rsi
  void **v21; // rbx
  void **v22; // r14
  void **v23; // rbx
  void **v24; // rbx
  void *v25; // rcx
  void *v26; // rcx
  void *v27; // rcx
  void *v28; // rcx
  void *v29; // rcx
  void *v30; // rcx
  void *v31; // rcx
  void *v32; // rcx
  void *v33; // rcx
  void *v34; // rcx
  void *v35; // rcx
  void *v36; // rcx
  void *v37; // rcx
  void *v38; // rcx
  void *v39; // rcx
  void *v40; // rcx
  void *v41; // rcx
  void *v42; // rcx
  void *v43; // rcx
  void *v44; // rcx
  _QWORD *v45; // rbx
  void **v46; // rcx
  _QWORD *v47; // rbx
  void **v48; // rcx
  _QWORD *v49; // rbx
  void *v50; // rcx

  *(_QWORD *)this = &UbpmParams::`vftable';
  v2 = (void **)*((_QWORD *)this + 72);
  if ( v2 != *((void ***)this + 73) )
  {
    while ( v2 != *((void ***)this + 73) )
    {
      if ( *v2 )
      {
        operator delete(*v2);
        *v2 = 0LL;
      }
      ++v2;
    }
    *((_QWORD *)this + 73) = *((_QWORD *)this + 72);
  }
  v3 = (void **)*((_QWORD *)this + 75);
  if ( v3 != *((void ***)this + 76) )
  {
    while ( v3 != *((void ***)this + 76) )
    {
      if ( *v3 )
      {
        operator delete(*v3);
        *v3 = 0LL;
      }
      ++v3;
    }
    *((_QWORD *)this + 76) = *((_QWORD *)this + 75);
  }
  v4 = (void **)((char *)this + 216);
  if ( *((_QWORD *)this + 28) )
  {
    v45 = *v4;
    while ( 1 )
    {
      v45 = (_QWORD *)*v45;
      if ( v45 == *v4 )
        break;
      v46 = (void **)v45[2];
      if ( v46 )
      {
        wmi::AutoVectorPtr<_SID_AND_ATTRIBUTES>::`scalar deleting destructor'(v46);
        v45[2] = 0LL;
      }
    }
    std::list<std::vector<unsigned char> *,std::allocator<std::vector<unsigned char> *>>::clear((__int64)this + 216);
  }
  v5 = (void **)((char *)this + 248);
  if ( *((_QWORD *)this + 32) )
  {
    v47 = *v5;
    while ( 1 )
    {
      v47 = (_QWORD *)*v47;
      if ( v47 == *v5 )
        break;
      v48 = (void **)v47[2];
      if ( v48 )
      {
        wmi::AutoVectorPtr<_SID_AND_ATTRIBUTES>::`scalar deleting destructor'(v48);
        v47[2] = 0LL;
      }
    }
    std::list<std::vector<unsigned char> *,std::allocator<std::vector<unsigned char> *>>::clear((__int64)this + 248);
  }
  v6 = (void **)*((_QWORD *)this + 36);
  if ( v6 != *((void ***)this + 37) )
  {
    while ( v6 != *((void ***)this + 37) )
    {
      if ( *v6 )
      {
        operator delete(*v6);
        *v6 = 0LL;
      }
      ++v6;
    }
    *((_QWORD *)this + 37) = *((_QWORD *)this + 36);
  }
  v7 = (void **)*((_QWORD *)this + 39);
  if ( v7 != *((void ***)this + 40) )
  {
    while ( v7 != *((void ***)this + 40) )
    {
      if ( *v7 )
      {
        operator delete(*v7);
        *v7 = 0LL;
      }
      ++v7;
    }
    *((_QWORD *)this + 40) = *((_QWORD *)this + 39);
  }
  v8 = (void **)((char *)this + 344);
  tsched::ClearList<std::vector<unsigned short *>>((void ***)this + 43);
  v9 = (void **)((char *)this + 872);
  tsched::ClearList<std::vector<unsigned short *>>((void ***)this + 109);
  v10 = (void **)*((_QWORD *)this + 78);
  if ( v10 != *((void ***)this + 79) )
  {
    while ( v10 != *((void ***)this + 79) )
    {
      if ( *v10 )
      {
        operator delete(*v10);
        *v10 = 0LL;
      }
      ++v10;
    }
    *((_QWORD *)this + 79) = *((_QWORD *)this + 78);
  }
  v11 = (void **)*((_QWORD *)this + 81);
  if ( v11 != *((void ***)this + 82) )
  {
    while ( v11 != *((void ***)this + 82) )
    {
      if ( *v11 )
      {
        operator delete(*v11);
        *v11 = 0LL;
      }
      ++v11;
    }
    *((_QWORD *)this + 82) = *((_QWORD *)this + 81);
  }
  v12 = (void **)*((_QWORD *)this + 84);
  if ( v12 != *((void ***)this + 85) )
  {
    while ( v12 != *((void ***)this + 85) )
    {
      if ( *v12 )
      {
        operator delete(*v12);
        *v12 = 0LL;
      }
      ++v12;
    }
    *((_QWORD *)this + 85) = *((_QWORD *)this + 84);
  }
  v13 = (void **)*((_QWORD *)this + 87);
  if ( v13 != *((void ***)this + 88) )
  {
    while ( v13 != *((void ***)this + 88) )
    {
      if ( *v13 )
      {
        operator delete(*v13);
        *v13 = 0LL;
      }
      ++v13;
    }
    *((_QWORD *)this + 88) = *((_QWORD *)this + 87);
  }
  v14 = (void **)*((_QWORD *)this + 90);
  if ( v14 != *((void ***)this + 91) )
  {
    while ( v14 != *((void ***)this + 91) )
    {
      if ( *v14 )
      {
        operator delete(*v14);
        *v14 = 0LL;
      }
      ++v14;
    }
    *((_QWORD *)this + 91) = *((_QWORD *)this + 90);
  }
  v15 = (void **)*((_QWORD *)this + 93);
  if ( v15 != *((void ***)this + 94) )
  {
    while ( v15 != *((void ***)this + 94) )
    {
      if ( *v15 )
      {
        operator delete(*v15);
        *v15 = 0LL;
      }
      ++v15;
    }
    *((_QWORD *)this + 94) = *((_QWORD *)this + 93);
  }
  v16 = (void **)*((_QWORD *)this + 96);
  if ( v16 != *((void ***)this + 97) )
  {
    while ( v16 != *((void ***)this + 97) )
    {
      if ( *v16 )
      {
        operator delete(*v16);
        *v16 = 0LL;
      }
      ++v16;
    }
    *((_QWORD *)this + 97) = *((_QWORD *)this + 96);
  }
  v17 = (void **)*((_QWORD *)this + 99);
  if ( v17 != *((void ***)this + 100) )
  {
    while ( v17 != *((void ***)this + 100) )
    {
      if ( *v17 )
      {
        operator delete(*v17);
        *v17 = 0LL;
      }
      ++v17;
    }
    *((_QWORD *)this + 100) = *((_QWORD *)this + 99);
  }
  v18 = (void **)*((_QWORD *)this + 102);
  if ( v18 != *((void ***)this + 103) )
  {
    while ( v18 != *((void ***)this + 103) )
    {
      if ( *v18 )
      {
        operator delete(*v18);
        *v18 = 0LL;
      }
      ++v18;
    }
    *((_QWORD *)this + 103) = *((_QWORD *)this + 102);
  }
  v19 = (void **)*((_QWORD *)this + 105);
  if ( v19 != *((void ***)this + 106) )
  {
    while ( v19 != *((void ***)this + 106) )
    {
      if ( *v19 )
      {
        operator delete(*v19);
        *v19 = 0LL;
      }
      ++v19;
    }
    *((_QWORD *)this + 106) = *((_QWORD *)this + 105);
  }
  v20 = (void **)((char *)this + 120);
  tsched::ClearList<std::vector<unsigned short *>>((void ***)this + 15);
  v21 = (void **)*((_QWORD *)this + 18);
  if ( v21 != *((void ***)this + 19) )
  {
    while ( v21 != *((void ***)this + 19) )
    {
      if ( *v21 )
      {
        operator delete(*v21);
        *v21 = 0LL;
      }
      ++v21;
    }
    *((_QWORD *)this + 19) = *((_QWORD *)this + 18);
  }
  v22 = (void **)((char *)this + 232);
  if ( *((_QWORD *)this + 30) )
  {
    v49 = *v22;
    while ( 1 )
    {
      v49 = (_QWORD *)*v49;
      if ( v49 == *v22 )
        break;
      v50 = (void *)v49[2];
      if ( v50 )
      {
        std::vector<unsigned char>::`scalar deleting destructor'(v50);
        v49[2] = 0LL;
      }
    }
    std::list<std::vector<unsigned char> *,std::allocator<std::vector<unsigned char> *>>::clear((__int64)this + 232);
  }
  v23 = (void **)*((_QWORD *)this + 21);
  if ( v23 != *((void ***)this + 22) )
  {
    while ( v23 != *((void ***)this + 22) )
    {
      if ( *v23 )
      {
        operator delete(*v23);
        *v23 = 0LL;
      }
      ++v23;
    }
    *((_QWORD *)this + 22) = *((_QWORD *)this + 21);
  }
  v24 = (void **)*((_QWORD *)this + 24);
  if ( v24 != *((void ***)this + 25) )
  {
    while ( v24 != *((void ***)this + 25) )
    {
      if ( *v24 )
      {
        operator delete(*v24);
        *v24 = 0LL;
      }
      ++v24;
    }
    *((_QWORD *)this + 25) = *((_QWORD *)this + 24);
  }
  operator delete(*((void **)this + 115));
  v25 = (void *)*((_QWORD *)this + 112);
  if ( v25 )
  {
    operator delete(v25);
    *((_QWORD *)this + 112) = 0LL;
    *((_QWORD *)this + 113) = 0LL;
    *((_QWORD *)this + 114) = 0LL;
  }
  if ( *v9 )
  {
    operator delete(*v9);
    *v9 = 0LL;
    *((_QWORD *)this + 110) = 0LL;
    *((_QWORD *)this + 111) = 0LL;
  }
  v26 = (void *)*((_QWORD *)this + 105);
  if ( v26 )
  {
    operator delete(v26);
    *((_QWORD *)this + 105) = 0LL;
    *((_QWORD *)this + 106) = 0LL;
    *((_QWORD *)this + 107) = 0LL;
  }
  v27 = (void *)*((_QWORD *)this + 102);
  if ( v27 )
  {
    operator delete(v27);
    *((_QWORD *)this + 102) = 0LL;
    *((_QWORD *)this + 103) = 0LL;
    *((_QWORD *)this + 104) = 0LL;
  }
  v28 = (void *)*((_QWORD *)this + 99);
  if ( v28 )
  {
    operator delete(v28);
    *((_QWORD *)this + 99) = 0LL;
    *((_QWORD *)this + 100) = 0LL;
    *((_QWORD *)this + 101) = 0LL;
  }
  v29 = (void *)*((_QWORD *)this + 96);
  if ( v29 )
  {
    operator delete(v29);
    *((_QWORD *)this + 96) = 0LL;
    *((_QWORD *)this + 97) = 0LL;
    *((_QWORD *)this + 98) = 0LL;
  }
  v30 = (void *)*((_QWORD *)this + 93);
  if ( v30 )
  {
    operator delete(v30);
    *((_QWORD *)this + 93) = 0LL;
    *((_QWORD *)this + 94) = 0LL;
    *((_QWORD *)this + 95) = 0LL;
  }
  v31 = (void *)*((_QWORD *)this + 90);
  if ( v31 )
  {
    operator delete(v31);
    *((_QWORD *)this + 90) = 0LL;
    *((_QWORD *)this + 91) = 0LL;
    *((_QWORD *)this + 92) = 0LL;
  }
  v32 = (void *)*((_QWORD *)this + 87);
  if ( v32 )
  {
    operator delete(v32);
    *((_QWORD *)this + 87) = 0LL;
    *((_QWORD *)this + 88) = 0LL;
    *((_QWORD *)this + 89) = 0LL;
  }
  v33 = (void *)*((_QWORD *)this + 84);
  if ( v33 )
  {
    operator delete(v33);
    *((_QWORD *)this + 84) = 0LL;
    *((_QWORD *)this + 85) = 0LL;
    *((_QWORD *)this + 86) = 0LL;
  }
  v34 = (void *)*((_QWORD *)this + 81);
  if ( v34 )
  {
    operator delete(v34);
    *((_QWORD *)this + 81) = 0LL;
    *((_QWORD *)this + 82) = 0LL;
    *((_QWORD *)this + 83) = 0LL;
  }
  v35 = (void *)*((_QWORD *)this + 78);
  if ( v35 )
  {
    operator delete(v35);
    *((_QWORD *)this + 78) = 0LL;
    *((_QWORD *)this + 79) = 0LL;
    *((_QWORD *)this + 80) = 0LL;
  }
  v36 = (void *)*((_QWORD *)this + 75);
  if ( v36 )
  {
    operator delete(v36);
    *((_QWORD *)this + 75) = 0LL;
    *((_QWORD *)this + 76) = 0LL;
    *((_QWORD *)this + 77) = 0LL;
  }
  v37 = (void *)*((_QWORD *)this + 72);
  if ( v37 )
  {
    operator delete(v37);
    *((_QWORD *)this + 72) = 0LL;
    *((_QWORD *)this + 73) = 0LL;
    *((_QWORD *)this + 74) = 0LL;
  }
  v38 = (void *)*((_QWORD *)this + 70);
  if ( v38 )
  {
    CredFree(v38);
    *((_QWORD *)this + 70) = 0LL;
  }
  operator delete(*((void **)this + 47));
  if ( *v8 )
  {
    operator delete(*v8);
    *v8 = 0LL;
    *((_QWORD *)this + 44) = 0LL;
    *((_QWORD *)this + 45) = 0LL;
  }
  v39 = (void *)*((_QWORD *)this + 39);
  if ( v39 )
  {
    operator delete(v39);
    *((_QWORD *)this + 39) = 0LL;
    *((_QWORD *)this + 40) = 0LL;
    *((_QWORD *)this + 41) = 0LL;
  }
  v40 = (void *)*((_QWORD *)this + 36);
  if ( v40 )
  {
    operator delete(v40);
    *((_QWORD *)this + 36) = 0LL;
    *((_QWORD *)this + 37) = 0LL;
    *((_QWORD *)this + 38) = 0LL;
  }
  v41 = (void *)*((_QWORD *)this + 33);
  if ( v41 )
  {
    operator delete(v41);
    *((_QWORD *)this + 33) = 0LL;
    *((_QWORD *)this + 34) = 0LL;
    *((_QWORD *)this + 35) = 0LL;
  }
  std::list<std::vector<unsigned char> *,std::allocator<std::vector<unsigned char> *>>::clear((__int64)this + 248);
  operator delete(*v5);
  std::list<std::vector<unsigned char> *,std::allocator<std::vector<unsigned char> *>>::clear((__int64)this + 232);
  operator delete(*v22);
  std::list<std::vector<unsigned char> *,std::allocator<std::vector<unsigned char> *>>::clear((__int64)this + 216);
  operator delete(*v4);
  v42 = (void *)*((_QWORD *)this + 24);
  if ( v42 )
  {
    operator delete(v42);
    *((_QWORD *)this + 24) = 0LL;
    *((_QWORD *)this + 25) = 0LL;
    *((_QWORD *)this + 26) = 0LL;
  }
  v43 = (void *)*((_QWORD *)this + 21);
  if ( v43 )
  {
    operator delete(v43);
    *((_QWORD *)this + 21) = 0LL;
    *((_QWORD *)this + 22) = 0LL;
    *((_QWORD *)this + 23) = 0LL;
  }
  v44 = (void *)*((_QWORD *)this + 18);
  if ( v44 )
  {
    operator delete(v44);
    *((_QWORD *)this + 18) = 0LL;
    *((_QWORD *)this + 19) = 0LL;
    *((_QWORD *)this + 20) = 0LL;
  }
  if ( *v20 )
  {
    operator delete(*v20);
    *v20 = 0LL;
    *((_QWORD *)this + 16) = 0LL;
    *((_QWORD *)this + 17) = 0LL;
  }
}
// 1800707A8: using guessed type void *UbpmParams::`vftable';

//----- (00000001800114A0) ----------------------------------------------------
Triggers::WnfStateChangeTrigger *__fastcall Triggers::WnfStateChangeTrigger::`vector deleting destructor'(
        Triggers::WnfStateChangeTrigger *this,
        char a2)
{
  Triggers::WnfStateChangeTrigger::~WnfStateChangeTrigger(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (00000001800114D8) ----------------------------------------------------
__int64 __fastcall JobStore::RegGetTreeInfo(
        HKEY *this,
        const unsigned __int16 *a2,
        struct _GUID *a3,
        enum JobStore::TaskIndex *a4)
{
  int v7; // ebx
  LSTATUS v8; // eax
  _QWORD *v10; // rcx
  LSTATUS v11; // eax
  _QWORD *v12; // rcx
  unsigned __int16 v13; // dx
  const wchar_t *v14; // r9
  unsigned __int16 v15; // dx
  DWORD Type; // [rsp+30h] [rbp-59h] BYREF
  BYTE lpData[4]; // [rsp+34h] [rbp-55h] BYREF
  HKEY hKey; // [rsp+38h] [rbp-51h] BYREF
  DWORD cbData; // [rsp+40h] [rbp-49h] BYREF
  DWORD lpcbData; // [rsp+44h] [rbp-45h] BYREF
  __int64 v21; // [rsp+48h] [rbp-41h]
  OLECHAR Data[39]; // [rsp+50h] [rbp-39h] BYREF
  __int16 v23; // [rsp+9Eh] [rbp+15h]

  v21 = -2LL;
  hKey = 0LL;
  v7 = JobStore::RegTreeEntryOpen(this, a2, &hKey);
  if ( v7 < 0 )
  {
    v12 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
      || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) == 0
      || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
    {
      goto LABEL_8;
    }
    v13 = 82;
    v14 = a2;
LABEL_21:
    WPP_SF_SSD(v12[2], v13, (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids, v14, (__int64)a2);
    goto LABEL_8;
  }
  memset_0(Data, 0, 0x50uLL);
  cbData = 80;
  if ( a3 )
  {
    v8 = RegQueryValueExW(hKey, L"Id", 0LL, &Type, (LPBYTE)Data, &cbData);
    v7 = v8;
    if ( v8 )
    {
      if ( v8 > 0 )
        v7 = (unsigned __int16)v8 | 0x80070000;
      v10 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
        || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) == 0
        || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
      {
        goto LABEL_8;
      }
      v15 = 83;
LABEL_24:
      WPP_SF_SD(v10[2], v15, (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids, a2);
      goto LABEL_8;
    }
    if ( Type != 1 )
    {
      v7 = -2147352571;
      v10 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
        || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) == 0
        || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
      {
        goto LABEL_8;
      }
      v15 = 84;
      goto LABEL_24;
    }
    v23 = 0;
    v7 = IIDFromString(Data, a3);
    if ( v7 < 0 )
    {
      v12 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
        || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) == 0
        || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
      {
        goto LABEL_8;
      }
      v13 = 85;
      v14 = Data;
      goto LABEL_21;
    }
  }
  *(_DWORD *)lpData = 0;
  if ( !a4 )
  {
LABEL_7:
    v7 = 0;
    goto LABEL_8;
  }
  lpcbData = 4;
  v11 = RegQueryValueExW(hKey, L"Index", 0LL, &Type, lpData, &lpcbData);
  v7 = v11;
  if ( v11 )
  {
    if ( v11 > 0 )
      v7 = (unsigned __int16)v11 | 0x80070000;
    v10 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
      || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) == 0
      || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
    {
      goto LABEL_8;
    }
    v15 = 86;
    goto LABEL_24;
  }
  if ( Type == 4 )
  {
    *(_DWORD *)a4 = *(_DWORD *)lpData;
    goto LABEL_7;
  }
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
  {
    WPP_SF_SD(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x57u, (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids, a2);
  }
  v7 = -2147352571;
LABEL_8:
  wmi::AutoRegKey::Close(&hKey);
  return (unsigned int)v7;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 1800114D8: using guessed type OLECHAR Data[39];

//----- (0000000180011660) ----------------------------------------------------
__int64 __fastcall JobStore::RegJobSecurityQuery(HKEY *this, const unsigned __int16 *a2, void **a3)
{
  int v4; // ebx
  HKEY v6; // [rsp+58h] [rbp+20h] BYREF

  v6 = 0LL;
  v4 = JobStore::RegTreeEntryOpen(this, a2, &v6);
  if ( v4 >= 0 )
  {
    v4 = JobSecurity::StreamIn(a3, v6);
    if ( v4 >= 0 )
      v4 = 0;
  }
  wmi::AutoRegKey::Close(&v6);
  return (unsigned int)v4;
}

//----- (00000001800116D0) ----------------------------------------------------
void __fastcall _bstr_t::_Free(_bstr_t *this)
{
  __int64 v1; // rbx
  void *v3; // rcx

  v1 = *(_QWORD *)this;
  if ( *(_QWORD *)this )
  {
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v1 + 16), 0xFFFFFFFF) == 1 )
    {
      if ( *(_QWORD *)v1 )
      {
        SysFreeString(*(BSTR *)v1);
        *(_QWORD *)v1 = 0LL;
      }
      v3 = *(void **)(v1 + 8);
      if ( v3 )
      {
        operator delete(v3);
        *(_QWORD *)(v1 + 8) = 0LL;
      }
      HeapFree(g_PrivateHeap, 0, (LPVOID)v1);
    }
    *(_QWORD *)this = 0LL;
  }
}

//----- (0000000180011754) ----------------------------------------------------
void __fastcall ValidationXmlHandler::ResetActionFields(ValidationXmlHandler *this)
{
  __int64 v2; // [rsp+30h] [rbp+10h] BYREF

  v2 = 0LL;
  _bstr_t::operator=((__int64 *)this + 56, &v2);
  _bstr_t::_Free((_bstr_t *)&v2);
  v2 = 0LL;
  _bstr_t::operator=((__int64 *)this + 57, &v2);
  _bstr_t::_Free((_bstr_t *)&v2);
  v2 = 0LL;
  _bstr_t::operator=((__int64 *)this + 58, &v2);
  _bstr_t::_Free((_bstr_t *)&v2);
  v2 = 0LL;
  _bstr_t::operator=((__int64 *)this + 59, &v2);
  _bstr_t::_Free((_bstr_t *)&v2);
  v2 = 0LL;
  _bstr_t::operator=((__int64 *)this + 60, &v2);
  _bstr_t::_Free((_bstr_t *)&v2);
}

//----- (000000018001180C) ----------------------------------------------------
__int64 __fastcall _bstr_t::Data_t::Release(_bstr_t::Data_t *this)
{
  unsigned __int32 v2; // edi
  OLECHAR *v3; // rcx
  void *v4; // rcx

  v2 = _InterlockedDecrement((volatile signed __int32 *)this + 4);
  if ( !v2 && this )
  {
    v3 = *(OLECHAR **)this;
    if ( v3 )
    {
      SysFreeString(v3);
      *(_QWORD *)this = 0LL;
    }
    v4 = (void *)*((_QWORD *)this + 1);
    if ( v4 )
    {
      operator delete(v4);
      *((_QWORD *)this + 1) = 0LL;
    }
    operator delete(this);
  }
  return v2;
}

//----- (0000000180011870) ----------------------------------------------------
__int64 __fastcall Triggers::Trigulator::ParseTriggerBlobData(
        __int64 a1,
        unsigned __int64 *a2,
        unsigned int a3,
        __int128 *a4,
        __int128 *a5,
        char a6,
        unsigned __int64 *a7)
{
  unsigned int v9; // ebx
  unsigned __int8 **v10; // rdi
  unsigned __int64 v11; // r15
  unsigned __int8 *v12; // rdx
  unsigned __int8 *v13; // rdx
  __int64 result; // rax
  bool v15; // zf
  struct Triggers::Trigger *v16; // r9
  int v17; // eax
  void *v18; // rbx
  Triggers::GenericTrigger *v19; // rax
  Triggers::GenericTrigger *v20; // rax
  Triggers::SessionBasedTrigger *v21; // rax
  Triggers::EventTrigger *v22; // rax
  Triggers::SessionBasedTrigger *v23; // rax
  Triggers::GenericTrigger *v24; // rax
  Triggers::GenericTrigger *v25; // rax
  unsigned __int8 *v26; // [rsp+38h] [rbp-41h] BYREF
  struct Triggers::Trigger *v27[2]; // [rsp+40h] [rbp-39h] BYREF
  char v28; // [rsp+50h] [rbp-29h]
  __int64 v29; // [rsp+58h] [rbp-21h]
  Triggers::GenericTrigger *v30; // [rsp+60h] [rbp-19h]
  Triggers::GenericTrigger *v31; // [rsp+68h] [rbp-11h]
  void *v32; // [rsp+70h] [rbp-9h]
  Triggers::EventTrigger *v33; // [rsp+78h] [rbp-1h]
  Triggers::SessionBasedTrigger *v34; // [rsp+80h] [rbp+7h]
  Triggers::GenericTrigger *v35; // [rsp+88h] [rbp+Fh]
  Triggers::SessionBasedTrigger *v36; // [rsp+90h] [rbp+17h]
  Triggers::GenericTrigger *v37; // [rsp+98h] [rbp+1Fh]

  v29 = -2LL;
  v9 = 0;
  if ( a3 == 8 )
  {
    if ( *a2 == *(_QWORD *)NullData )
      return 1LL;
    return 2147549183LL;
  }
  v10 = (unsigned __int8 **)((char *)a2 + a3);
  if ( a2 + 5 >= (unsigned __int64 *)v10 )
    return 2147549183LL;
  v11 = *a2;
  v12 = (unsigned __int8 *)(a2 + 1);
  v26 = v12;
  if ( v11 - 21 > 2 )
    return 2147750675LL;
  if ( a7 )
    *a7 = v11;
  *(_OWORD *)a1 = *(_OWORD *)v12;
  *(_OWORD *)(a1 + 16) = *((_OWORD *)v12 + 1);
  v13 = v12 + 32;
  v26 = v13;
  if ( (a6 & 6) == 0 )
    return v9;
  if ( v13 >= (unsigned __int8 *)v10 )
    return 2147549183LL;
  result = JobBucket::StreamIn(*(JobBucket **)(a1 + 48), v11, &v26, v10);
  v9 = result;
  if ( (int)result >= 0 )
  {
    if ( (a6 & 4) == 0 )
      return v9;
    if ( !TSTime::operator<(a1 + 16, a4) && !TSTime::operator>(a1, a5) )
    {
      while ( 1 )
      {
        v15 = v26 == (unsigned __int8 *)v10;
        if ( v26 >= (unsigned __int8 *)v10 )
          goto LABEL_24;
        if ( (unsigned __int64)((char *)v10 - (char *)v26) < 8 )
          break;
        v16 = 0LL;
        v27[0] = 0LL;
        v27[1] = (struct Triggers::Trigger *)v27;
        v28 = 1;
        v17 = *(_DWORD *)v26;
        v26 += 8;
        switch ( v17 )
        {
          case 0x6666:
            v19 = (Triggers::GenericTrigger *)operator new(0x70uLL);
            v18 = v19;
            v37 = v19;
            if ( v19 )
            {
              Triggers::GenericTrigger::GenericTrigger(v19);
              *(_QWORD *)v18 = &Triggers::WnfStateChangeTrigger::`vftable';
              *((_QWORD *)v18 + 13) = 0LL;
              *((_DWORD *)v18 + 24) = 0;
              *((_DWORD *)v18 + 25) = 0;
            }
            else
            {
              v18 = 0LL;
            }
            break;
          case 0xDDDD:
            v18 = operator new(0x68uLL);
            v32 = v18;
            if ( v18 )
            {
              *(_QWORD *)v18 = &Triggers::TimeTrigger::`vftable';
              Scheduling::JobSchedule::JobSchedule((struct _FILETIME *)v18 + 1);
              *((_QWORD *)v18 + 12) = 0LL;
            }
            else
            {
              v18 = 0LL;
            }
            break;
          case 0xAAAA:
            v21 = (Triggers::SessionBasedTrigger *)operator new(0x60uLL);
            v18 = v21;
            v34 = v21;
            if ( v21 )
            {
              Triggers::SessionBasedTrigger::SessionBasedTrigger(v21);
              *(_QWORD *)v18 = &Triggers::LogonTrigger::`vftable';
            }
            else
            {
              v18 = 0LL;
            }
            break;
          case 0xCCCC:
            v22 = (Triggers::EventTrigger *)operator new(0x80uLL);
            v33 = v22;
            if ( v22 )
              v18 = Triggers::EventTrigger::EventTrigger(v22);
            else
              v18 = 0LL;
            break;
          case 0x7777:
            v23 = (Triggers::SessionBasedTrigger *)operator new(0x68uLL);
            v18 = v23;
            v36 = v23;
            if ( v23 )
            {
              Triggers::SessionBasedTrigger::SessionBasedTrigger(v23);
              *(_QWORD *)v18 = &Triggers::SessionChangeTrigger::`vftable';
            }
            else
            {
              v18 = 0LL;
            }
            break;
          case 0x8888:
            v24 = (Triggers::GenericTrigger *)operator new(0x58uLL);
            v18 = v24;
            v35 = v24;
            if ( v24 )
            {
              Triggers::GenericTrigger::GenericTrigger(v24);
              *(_QWORD *)v18 = &Triggers::RegistrationTrigger::`vftable';
            }
            else
            {
              v18 = 0LL;
            }
            break;
          case 0xEEEE:
            v25 = (Triggers::GenericTrigger *)operator new(0x60uLL);
            v18 = v25;
            v31 = v25;
            if ( v25 )
            {
              Triggers::GenericTrigger::GenericTrigger(v25);
              *(_QWORD *)v18 = &Triggers::IdleTrigger::`vftable';
            }
            else
            {
              v18 = 0LL;
            }
            break;
          case 0xFFFF:
            v20 = (Triggers::GenericTrigger *)operator new(0x58uLL);
            v18 = v20;
            v30 = v20;
            if ( v20 )
            {
              Triggers::GenericTrigger::GenericTrigger(v20);
              *(_QWORD *)v18 = &Triggers::BootTrigger::`vftable';
            }
            else
            {
              v18 = 0LL;
            }
            break;
          default:
            v9 = -2147418113;
            goto LABEL_57;
        }
        v27[0] = (struct Triggers::Trigger *)v18;
        v9 = (*(__int64 (__fastcall **)(void *, unsigned __int64, unsigned __int8 **, unsigned __int8 **))(*(_QWORD *)v18 + 104LL))(
               v18,
               v11,
               &v26,
               v10);
        if ( (v9 & 0x80000000) != 0 )
        {
          v16 = v27[0];
LABEL_57:
          if ( v16 )
            (**(void (__fastcall ***)(struct Triggers::Trigger *, __int64))v16)(v16, 1LL);
          return v9;
        }
        v28 = 0;
        Triggers::Trigulator::AddTrigger((Triggers::Trigulator *)a1, v27[0]);
      }
      v15 = v26 == (unsigned __int8 *)v10;
LABEL_24:
      if ( v15 )
        return v9;
      return 2147549183LL;
    }
    return 1LL;
  }
  return result;
}
// 180070000: using guessed type void *Triggers::BootTrigger::`vftable';
// 1800700C0: using guessed type void *Triggers::SessionChangeTrigger::`vftable';
// 180070138: using guessed type void *Triggers::LogonTrigger::`vftable';
// 1800709F8: using guessed type void *Triggers::WnfStateChangeTrigger::`vftable';
// 180070A70: using guessed type void *Triggers::TimeTrigger::`vftable';
// 180070BF0: using guessed type void *Triggers::IdleTrigger::`vftable';
// 180070C68: using guessed type void *Triggers::RegistrationTrigger::`vftable';
// 1800B0208: using guessed type BYTE NullData[16];

//----- (0000000180011BD0) ----------------------------------------------------
__int64 (__fastcall ****__fastcall tsched::DeleteMe<Triggers::Trigger>::~DeleteMe<Triggers::Trigger>(
        __int64 a1))(_QWORD, __int64)
{
  __int64 (__fastcall ****result)(_QWORD, __int64); // rax
  __int64 (__fastcall ***v2)(_QWORD, __int64); // rcx

  if ( *(_BYTE *)(a1 + 8) )
  {
    result = *(__int64 (__fastcall *****)(_QWORD, __int64))a1;
    v2 = **(__int64 (__fastcall *****)(_QWORD, __int64))a1;
    if ( v2 )
      return (__int64 (__fastcall ****)(_QWORD, __int64))(**v2)(v2, 1LL);
  }
  return result;
}

//----- (0000000180011BF0) ----------------------------------------------------
__int64 __fastcall _ProcessElementEnd__QITaskXmlHandler__ServerXMLUpdateHandler__UEAAJAEBUSchema__W4TaskXmlNodeId___Z(
        __int64 a1,
        int *a2,
        unsigned int a3)
{
  _QWORD *v6; // rbx
  _QWORD *v7; // r14
  int v8; // eax
  const struct SchemaEntry * near *Entry; // rax
  __int64 v11; // r10

  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && *((char *)WPP_GLOBAL_Control + 28) < 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 5u )
  {
    Entry = Schema::GetEntry(a2, a3);
    WPP_SF_S(
      *(_QWORD *)(v11 + 16),
      0xCu,
      (__int64)&WPP_6a02f12a6b2c3ac58024ebcfa94f3c9a_Traceguids,
      (const wchar_t *)Entry[1]);
  }
  v6 = *(_QWORD **)(a1 + 784);
  v7 = *(_QWORD **)(a1 + 792);
  while ( v7 != v6 )
  {
    v8 = (*(__int64 (__fastcall **)(_QWORD, int *, _QWORD))(*(_QWORD *)*v6 + 8LL))(*v6, a2, a3);
    if ( v8 < 0 )
      goto LABEL_10;
    if ( v8 == 1 )
      return *(unsigned int *)(a1 + 1072);
    ++v6;
  }
  v8 = _ProcessElementEnd__QITaskXmlHandler__TriggersXmlHandler__MEAAJAEBUSchema__W4TaskXmlNodeId___Z(a1, a2, a3);
  if ( v8 >= 0 )
    return *(unsigned int *)(a1 + 1072);
LABEL_10:
  if ( *(int *)(a1 + 1072) >= 0 )
    *(_DWORD *)(a1 + 1072) = v8;
  return *(unsigned int *)(a1 + 1072);
}
// 18004454F: variable 'v11' is possibly undefined
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180011CC0) ----------------------------------------------------
__int64 __fastcall _ProcessElementEnd__QITaskXmlHandler__TriggersXmlHandler__MEAAJAEBUSchema__W4TaskXmlNodeId___Z(
        __int64 a1,
        int *a2,
        int a3)
{
  const OLECHAR *v5; // r12
  char v6; // di
  __int64 result; // rax
  unsigned int v8; // esi
  int v9; // ebx
  int v10; // ebx
  int v11; // ebx
  int v12; // ebx
  int v13; // ebx
  int v14; // ebx
  int v15; // ebx
  int v16; // ebx
  int v17; // ebx
  int v18; // ebx
  int v19; // ebx
  int v20; // ebx
  int v21; // ebx
  char v22; // dl
  int v23; // ecx
  BSTR *v24; // rcx
  UINT v25; // eax
  LPVOID v26; // rcx
  const OLECHAR **v27; // rax
  const OLECHAR *v28; // rdx
  struct Triggers::Trigger *v29; // rax
  User::UserEntry **v30; // rcx
  LPVOID v31; // rcx
  const OLECHAR **v32; // rax
  const OLECHAR *v33; // rdx
  struct Triggers::Trigger *v34; // rax
  Triggers::TimeTrigger *v35; // rax
  const unsigned __int16 **v36; // rcx
  const unsigned __int16 *v37; // rdx
  const struct _bstr_t *v38; // rcx
  const WCHAR *v39; // rdx
  int v40; // eax
  const OLECHAR **v41; // rax
  Task *v42; // rax
  void **v43; // rcx
  Task *v44; // rbx
  __int64 v45; // rcx
  __int64 v46; // rax
  __int64 *v47; // r9
  _QWORD *v48; // rbx
  _QWORD *v49; // rdi
  _QWORD *v50; // rax
  __int64 v51; // rdx
  _QWORD *v52; // r10
  const OLECHAR **v53; // rcx
  const OLECHAR *v54; // rdx
  __int64 v55; // rcx
  __int64 v56; // r9
  ExeTask *v57; // r10
  ExeTask *v58; // rbx
  _QWORD *v59; // rbx
  _QWORD *v60; // rdi
  _QWORD *v61; // rdx
  __int64 v62; // rax
  char v63; // dl
  int v64; // ecx
  User::UserEntry *v65; // rbx
  BSTR *v66; // rcx
  UINT v67; // eax
  _QWORD *v68; // rdi
  const OLECHAR **v69; // rax
  const OLECHAR *v70; // rdx
  struct Triggers::Trigger *v71; // rax
  int v72; // ebx
  int v73; // ebx
  LPVOID v74; // rbx
  __int64 v75; // rax
  __int64 v76; // rax
  const OLECHAR **v77; // rax
  const OLECHAR *v78; // rdx
  _QWORD *v79; // rcx
  const OLECHAR **v80; // rax
  const OLECHAR *v81; // rdx
  const WCHAR **v82; // rax
  const WCHAR *v83; // rdx
  const WCHAR **v84; // rax
  const WCHAR *v85; // rdx
  LPVOID v86; // rcx
  const OLECHAR **v87; // rax
  const OLECHAR *v88; // rdx
  User::UserEntry **v89; // rax
  Task *v90; // rax
  __int64 v91; // rbx
  __int64 v92; // rax
  __int64 v93; // rax
  __int64 v94; // rbx
  __int128 v95; // [rsp+78h] [rbp-90h]
  User::UserEntry *v96; // [rsp+88h] [rbp-80h] BYREF
  User::UserEntry *v97; // [rsp+90h] [rbp-78h] BYREF
  __int128 v98; // [rsp+98h] [rbp-70h]
  User::UserEntry *v99; // [rsp+A8h] [rbp-60h] BYREF
  ExeTask *v100; // [rsp+B0h] [rbp-58h] BYREF
  __int64 v101; // [rsp+B8h] [rbp-50h] BYREF
  User::UserEntry *v102; // [rsp+C0h] [rbp-48h] BYREF
  __int64 v103; // [rsp+C8h] [rbp-40h] BYREF
  __int64 v104; // [rsp+D0h] [rbp-38h] BYREF
  __int64 v105; // [rsp+D8h] [rbp-30h] BYREF
  __int64 v106; // [rsp+E0h] [rbp-28h] BYREF
  __int64 v107; // [rsp+E8h] [rbp-20h] BYREF
  __int64 v108; // [rsp+F0h] [rbp-18h] BYREF
  __int64 v109; // [rsp+F8h] [rbp-10h] BYREF
  __int64 v110; // [rsp+100h] [rbp-8h] BYREF
  User::UserEntry *v111; // [rsp+108h] [rbp+0h] BYREF
  __int64 v112; // [rsp+110h] [rbp+8h] BYREF
  Task *v113; // [rsp+118h] [rbp+10h] BYREF
  void *v114[3]; // [rsp+120h] [rbp+18h] BYREF
  __int128 v115; // [rsp+138h] [rbp+30h] BYREF
  __int128 v116; // [rsp+148h] [rbp+40h] BYREF
  __int128 v117; // [rsp+158h] [rbp+50h] BYREF
  __int128 v118; // [rsp+168h] [rbp+60h] BYREF
  __int128 v119; // [rsp+178h] [rbp+70h] BYREF
  __int128 v120; // [rsp+188h] [rbp+80h] BYREF
  __int128 v121; // [rsp+198h] [rbp+90h] BYREF
  __int128 v122; // [rsp+1A8h] [rbp+A0h] BYREF
  __int128 v123; // [rsp+1B8h] [rbp+B0h] BYREF
  __int128 v124; // [rsp+1C8h] [rbp+C0h] BYREF
  __int128 v125; // [rsp+1D8h] [rbp+D0h] BYREF
  __int128 v126; // [rsp+1E8h] [rbp+E0h] BYREF
  __int128 v127; // [rsp+1F8h] [rbp+F0h] BYREF
  __int128 v128; // [rsp+208h] [rbp+100h] BYREF
  __int128 v129; // [rsp+218h] [rbp+110h] BYREF
  __int128 v130; // [rsp+228h] [rbp+120h] BYREF
  __int128 v131; // [rsp+238h] [rbp+130h] BYREF
  __int128 v132; // [rsp+248h] [rbp+140h] BYREF
  __int128 v133; // [rsp+258h] [rbp+150h] BYREF
  __int128 v134; // [rsp+268h] [rbp+160h] BYREF
  __int128 v135; // [rsp+278h] [rbp+170h] BYREF

  v114[2] = (void *)-2LL;
  v5 = 0LL;
  v6 = 0;
  result = _ProcessElementEnd__QITaskXmlHandler__ValidationXmlHandler__MEAAJAEBUSchema__W4TaskXmlNodeId___Z(a1, a2, a3);
  v8 = result;
  LODWORD(v96) = result;
  if ( (int)result >= 0 )
  {
    if ( a3 > 39 )
    {
      v9 = a3 - 102;
      if ( !v9 )
      {
        v41 = *(const OLECHAR ***)(a1 + 80);
        if ( v41 )
          v5 = *v41;
        _bstr_t::operator=((_bstr_t::Data_t **)(*(_QWORD *)(a1 + 536) + 16LL), v5);
        return v8;
      }
      v10 = v9 - 1;
      if ( v10 )
      {
        v11 = v10 - 4;
        if ( v11 )
        {
          v12 = v11 - 6;
          if ( v12 )
          {
            v13 = v12 - 12;
            if ( !v13 )
            {
              std::vector<_bstr_t>::push_back((__int64 *)(a1 + 720), (__int64 *)(a1 + 768));
              std::vector<_bstr_t>::push_back((__int64 *)(a1 + 744), (__int64 *)(a1 + 776));
              v106 = 0LL;
              _bstr_t::operator=((__int64 *)(a1 + 768), &v106);
              _bstr_t::_Free((_bstr_t *)&v106);
              v107 = 0LL;
              _bstr_t::operator=((__int64 *)(a1 + 776), &v107);
              _bstr_t::_Free((_bstr_t *)&v107);
              return v8;
            }
            v14 = v13 - 3;
            if ( v14 )
            {
              if ( v14 != 13 )
                return v8;
              *(_QWORD *)&v95 = *(_QWORD *)(a1 + 256);
              DWORD2(v95) = DWORD1(v95);
              BYTE12(v95) = *(_BYTE *)(a1 + 280);
              v31 = operator new(0x70uLL);
              if ( v31 )
              {
                v133 = v95;
                v134 = *(_OWORD *)(a1 + 312);
                v135 = *(_OWORD *)(a1 + 296);
                v32 = *(const OLECHAR ***)(a1 + 120);
                if ( v32 )
                  v33 = *v32;
                else
                  v33 = 0LL;
                v34 = (struct Triggers::Trigger *)Triggers::WnfStateChangeTrigger::WnfStateChangeTrigger(
                                                    (__int64)v31,
                                                    v33,
                                                    &v135,
                                                    &v134,
                                                    *(_DWORD *)(a1 + 132),
                                                    *(_DWORD *)(a1 + 136),
                                                    *(_BYTE *)(a1 + 128),
                                                    &v133,
                                                    *(_QWORD *)(a1 + 332),
                                                    *(_DWORD *)(a1 + 340),
                                                    *(void **)(a1 + 352),
                                                    *(_DWORD *)(a1 + 344));
              }
              else
              {
                v34 = 0LL;
              }
              goto LABEL_36;
            }
            v90 = (Task *)operator new(0x58uLL);
            v91 = (__int64)v90;
            if ( v90 )
            {
              v105 = 0LL;
              Task::Task(v90, (const struct _bstr_t *)(a1 + 544), (const struct _bstr_t *)&v105);
              v43 = &MessageBoxTask::`vftable';
              *(_QWORD *)v91 = &MessageBoxTask::`vftable';
              v92 = *(_QWORD *)(a1 + 672);
              *(_QWORD *)(v91 + 40) = v92;
              if ( v92 )
                _InterlockedIncrement((volatile signed __int32 *)(v92 + 16));
              v93 = *(_QWORD *)(a1 + 680);
              *(_QWORD *)(v91 + 48) = v93;
              if ( v93 )
                _InterlockedIncrement((volatile signed __int32 *)(v93 + 16));
              *(_BYTE *)(v91 + 56) = 0;
              *(_QWORD *)(v91 + 64) = 0LL;
              v6 = 8;
            }
            else
            {
              v91 = 0LL;
            }
            if ( (v6 & 8) != 0 )
              _bstr_t::_Free((_bstr_t *)&v105);
            if ( !v91 )
              return 2147942414LL;
            v101 = v91;
            v47 = &v101;
          }
          else
          {
            v101 = (__int64)operator new(0xC0uLL);
            if ( v101 )
            {
              v108 = 0LL;
              v94 = EmailTask::EmailTask(
                      v101,
                      (int)a1 + 544,
                      (unsigned int)&v108,
                      (int)a1 + 608,
                      a1 + 616,
                      a1 + 624,
                      a1 + 632,
                      a1 + 640,
                      a1 + 648,
                      a1 + 656,
                      a1 + 664,
                      a1 + 696,
                      a1 + 720,
                      a1 + 744);
              v8 = (unsigned int)v96;
              v6 = 4;
            }
            else
            {
              v94 = 0LL;
            }
            if ( (v6 & 4) != 0 )
              _bstr_t::_Free((_bstr_t *)&v108);
            if ( !v94 )
              return 2147942414LL;
            v112 = v94;
            v47 = &v112;
          }
        }
        else
        {
          v42 = (Task *)operator new(0x50uLL);
          v44 = v42;
          *(_QWORD *)&v98 = v42;
          if ( v42 )
          {
            v109 = 0LL;
            v6 = 2;
            Task::Task(v42, (const struct _bstr_t *)(a1 + 544), (const struct _bstr_t *)&v109);
            *(_QWORD *)v45 = &ComHandlerBase::`vftable';
            *(_OWORD *)(v45 + 40) = *(_OWORD *)(a1 + 552);
            *(_QWORD *)(v45 + 56) = 0LL;
            _bstr_t::_bstr_t((_bstr_t *)(v45 + 64), &ChannelPath);
            v46 = *(_QWORD *)(a1 + 568);
            *((_QWORD *)v44 + 9) = v46;
            if ( v46 )
            {
              _InterlockedIncrement((volatile signed __int32 *)(v46 + 16));
              v6 = 2;
            }
            *(_QWORD *)v44 = &ComHandlerTask::`vftable';
          }
          else
          {
            v44 = 0LL;
          }
          if ( (v6 & 2) != 0 )
            _bstr_t::_Free((_bstr_t *)&v109);
          if ( !v44 )
            return 2147942414LL;
          v113 = v44;
          v47 = (__int64 *)&v113;
        }
        v48 = *(_QWORD **)(a1 + 536);
        v49 = (_QWORD *)*v48;
        v50 = std::_List_buy<Task *>::_Buynode<Task * const &>(
                (__int64)v43,
                (_QWORD *)*v48,
                *(_QWORD **)(*v48 + 8LL),
                v47);
        v51 = v48[1];
        if ( v51 != 0xAAAAAAAAAAAAAA9LL )
        {
          v48[1] = v51 + 1;
          v49[1] = v50;
          *(_QWORD *)v50[1] = v50;
          return v8;
        }
      }
      else
      {
        v57 = (ExeTask *)operator new(0x60uLL);
        *(_QWORD *)&v98 = v57;
        if ( v57 )
        {
          v110 = 0LL;
          v6 = 1;
          LOBYTE(v56) = *(_BYTE *)(a1 + 576);
          v58 = ExeTask::ExeTask(
                  v57,
                  (const struct _bstr_t *)(a1 + 544),
                  (const struct _bstr_t *)&v110,
                  v56,
                  (struct _bstr_t *)(a1 + 584),
                  (struct _bstr_t *)(a1 + 592),
                  (struct _bstr_t *)(a1 + 600));
        }
        else
        {
          v58 = 0LL;
        }
        if ( (v6 & 1) != 0 )
          _bstr_t::_Free((_bstr_t *)&v110);
        if ( !v58 )
          return 2147942414LL;
        v100 = v58;
        v59 = *(_QWORD **)(a1 + 536);
        v60 = (_QWORD *)*v59;
        v61 = std::_List_buy<Task *>::_Buynode<Task * const &>(v55, (_QWORD *)*v59, *(_QWORD **)(*v59 + 8LL), &v100);
        v62 = v59[1];
        if ( v62 != 0xAAAAAAAAAAAAAA9LL )
        {
          v59[1] = v62 + 1;
          v60[1] = v61;
          *(_QWORD *)v61[1] = v61;
          return v8;
        }
      }
      std::_Xlength_error("list<T> too long");
    }
    if ( a3 != 39 )
    {
      v15 = a3 - 1;
      if ( !v15 )
      {
        if ( _bstr_t::operator!((_QWORD *)(a1 + 72)) )
        {
          *(_DWORD *)(a1 + 108) = 110;
          return 2147750681LL;
        }
        v96 = 0LL;
        if ( (*(_DWORD *)(*(_QWORD *)(a1 + 40) + 16LL) & 0x100000) != 0 )
        {
          v89 = User::CreateAlias(&v111, v38);
          wmi::AutoRef<User::UserEntry>::operator=(&v96, *v89);
          wmi::AutoRef<User::UserEntry>::Release(&v111);
        }
        else
        {
          if ( *(_QWORD *)v38 )
            v39 = **(const WCHAR ***)v38;
          else
            v39 = 0LL;
          v8 = User::FromUsername(&v96, v39);
        }
        v40 = *(_DWORD *)(a1 + 48) & 4;
        if ( (v8 & 0x80000000) != 0 )
        {
          if ( v40 )
            v8 = 0;
        }
        else if ( v40
               || (v72 = *(_DWORD *)(*(_QWORD *)(a1 + 40) + 16LL),
                   User::IsGroupAccount((User *)&v96) == ((v72 & 0x8000) != 0))
               && (v73 = *(_DWORD *)(*(_QWORD *)(a1 + 40) + 16LL),
                   User::IsService((User *)&v96) == ((v73 & 0x20000) != 0)) )
        {
          wmi::AutoRef<User::UserEntry>::operator=((User::UserEntry **)(*(_QWORD *)(a1 + 40) + 64LL), v96);
          _bstr_t::operator=((__int64 *)(*(_QWORD *)(a1 + 40) + 72LL), (__int64 *)(a1 + 80));
          _bstr_t::operator=((__int64 *)(*(_QWORD *)(a1 + 40) + 80LL), (__int64 *)(a1 + 88));
        }
        else
        {
          v8 = -2147216616;
        }
        v30 = &v96;
        goto LABEL_51;
      }
      v16 = v15 - 20;
      if ( !v16 )
      {
        *(_BYTE *)(a1 + 512) = 1;
        *(_QWORD *)&v95 = *(_QWORD *)(a1 + 256);
        DWORD2(v95) = DWORD1(v95);
        BYTE12(v95) = *(_BYTE *)(a1 + 280);
        v52 = operator new(0x58uLL);
        if ( v52 )
        {
          v130 = v95;
          v131 = *(_OWORD *)(a1 + 312);
          v132 = *(_OWORD *)(a1 + 296);
          v53 = *(const OLECHAR ***)(a1 + 120);
          if ( v53 )
            v54 = *v53;
          else
            v54 = 0LL;
          v34 = (struct Triggers::Trigger *)Triggers::BootTrigger::BootTrigger(
                                              v52,
                                              v54,
                                              &v132,
                                              &v131,
                                              *(_DWORD *)(a1 + 132),
                                              *(_DWORD *)(a1 + 136),
                                              *(_BYTE *)(a1 + 128),
                                              &v130);
        }
        else
        {
          v34 = 0LL;
        }
        goto LABEL_36;
      }
      v17 = v16 - 2;
      if ( !v17 )
      {
        *(_QWORD *)&v95 = *(_QWORD *)(a1 + 256);
        DWORD2(v95) = DWORD1(v95);
        BYTE12(v95) = *(_BYTE *)(a1 + 280);
        v79 = operator new(0x58uLL);
        if ( v79 )
        {
          v127 = v95;
          v128 = *(_OWORD *)(a1 + 312);
          v129 = *(_OWORD *)(a1 + 296);
          v80 = *(const OLECHAR ***)(a1 + 120);
          if ( v80 )
            v81 = *v80;
          else
            v81 = 0LL;
          v34 = (struct Triggers::Trigger *)Triggers::RegistrationTrigger::RegistrationTrigger(
                                              v79,
                                              v81,
                                              &v129,
                                              &v128,
                                              *(_DWORD *)(a1 + 132),
                                              *(_DWORD *)(a1 + 136),
                                              *(_BYTE *)(a1 + 128),
                                              &v127);
        }
        else
        {
          v34 = 0LL;
        }
        goto LABEL_36;
      }
      v18 = v17 - 1;
      if ( !v18 )
      {
        *(_QWORD *)&v95 = *(_QWORD *)(a1 + 256);
        DWORD2(v95) = DWORD1(v95);
        BYTE12(v95) = *(_BYTE *)(a1 + 280);
        v86 = operator new(0x60uLL);
        if ( v86 )
        {
          v124 = v95;
          v125 = *(_OWORD *)(a1 + 312);
          v126 = *(_OWORD *)(a1 + 296);
          v87 = *(const OLECHAR ***)(a1 + 120);
          if ( v87 )
            v88 = *v87;
          else
            v88 = 0LL;
          v34 = (struct Triggers::Trigger *)Triggers::IdleTrigger::IdleTrigger(
                                              (__int64)v86,
                                              v88,
                                              &v126,
                                              &v125,
                                              *(_DWORD *)(a1 + 132),
                                              *(_DWORD *)(a1 + 136),
                                              *(_BYTE *)(a1 + 128),
                                              &v124,
                                              0);
        }
        else
        {
          v34 = 0LL;
        }
        goto LABEL_36;
      }
      v19 = v18 - 1;
      if ( v19 )
      {
        v20 = v19 - 2;
        if ( v20 )
        {
          v21 = v20 - 8;
          if ( v21 )
          {
            if ( v21 != 2 )
              return v8;
            v22 = *(_BYTE *)(a1 + 280);
            v23 = *(_DWORD *)(a1 + 260);
            LODWORD(v98) = *(_DWORD *)(a1 + 256);
            DWORD1(v98) = v23;
            DWORD2(v98) = v23;
            BYTE12(v98) = v22;
            v97 = 0LL;
            v24 = *(BSTR **)(a1 + 200);
            if ( v24 && *v24 )
              v25 = SysStringLen(*v24);
            else
              v25 = 0;
            if ( !v25 )
              goto LABEL_24;
            v82 = *(const WCHAR ***)(a1 + 200);
            if ( v82 )
              v83 = *v82;
            else
              v83 = 0LL;
            v8 = User::FromUsername(&v97, v83);
            if ( (v8 & 0x80000000) != 0 )
            {
              if ( (*(_BYTE *)(a1 + 48) & 4) == 0 )
              {
LABEL_31:
                v30 = &v97;
LABEL_51:
                wmi::AutoRef<User::UserEntry>::Release(v30);
                return v8;
              }
              v8 = 0;
            }
            if ( !v97 || !User::operator==((User *)&v97, (User *)(a1 + 520)) )
LABEL_24:
              *(_BYTE *)(a1 + 512) = 1;
            v26 = operator new(0x68uLL);
            if ( v26 )
            {
              v115 = v98;
              v116 = *(_OWORD *)(a1 + 312);
              v117 = *(_OWORD *)(a1 + 296);
              v27 = *(const OLECHAR ***)(a1 + 120);
              if ( v27 )
                v28 = *v27;
              else
                v28 = 0LL;
              v29 = (struct Triggers::Trigger *)Triggers::SessionChangeTrigger::SessionChangeTrigger(
                                                  (__int64)v26,
                                                  v28,
                                                  &v97,
                                                  &v117,
                                                  &v116,
                                                  *(_DWORD *)(a1 + 132),
                                                  *(_DWORD *)(a1 + 136),
                                                  *(_BYTE *)(a1 + 128),
                                                  *(_DWORD *)(a1 + 328),
                                                  &v115);
            }
            else
            {
              v29 = 0LL;
            }
            if ( v29 )
              Triggers::Trigulator::AddTrigger(*(Triggers::Trigulator **)(a1 + 528), v29);
            else
              v8 = -2147024882;
            goto LABEL_31;
          }
          v63 = *(_BYTE *)(a1 + 280);
          v64 = *(_DWORD *)(a1 + 260);
          LODWORD(v98) = *(_DWORD *)(a1 + 256);
          DWORD1(v98) = v64;
          DWORD2(v98) = v64;
          BYTE12(v98) = v63;
          v65 = 0LL;
          v99 = 0LL;
          v66 = *(BSTR **)(a1 + 200);
          if ( v66 && *v66 )
            v67 = SysStringLen(*v66);
          else
            v67 = 0;
          if ( !v67 )
            goto LABEL_81;
          v84 = *(const WCHAR ***)(a1 + 200);
          if ( v84 )
            v85 = *v84;
          else
            v85 = 0LL;
          v8 = User::FromUsername(&v99, v85);
          if ( (v8 & 0x80000000) != 0 )
          {
            if ( (*(_BYTE *)(a1 + 48) & 4) == 0 )
            {
LABEL_90:
              v30 = &v99;
              goto LABEL_51;
            }
            v8 = 0;
          }
          v65 = v99;
          if ( !v99 || !User::operator==((User *)&v99, (User *)(a1 + 520)) )
LABEL_81:
            *(_BYTE *)(a1 + 512) = 1;
          v68 = operator new(0x60uLL);
          if ( v68 )
          {
            v118 = v98;
            v119 = *(_OWORD *)(a1 + 312);
            v120 = *(_OWORD *)(a1 + 296);
            v102 = v65;
            if ( v65 )
              User::UserEntry::AddRef(v65);
            v69 = *(const OLECHAR ***)(a1 + 120);
            if ( v69 )
              v70 = *v69;
            else
              v70 = 0LL;
            v71 = (struct Triggers::Trigger *)Triggers::LogonTrigger::LogonTrigger(
                                                v68,
                                                v70,
                                                &v102,
                                                &v120,
                                                &v119,
                                                *(_DWORD *)(a1 + 132),
                                                *(_DWORD *)(a1 + 136),
                                                *(_BYTE *)(a1 + 128),
                                                &v118);
          }
          else
          {
            v71 = 0LL;
          }
          if ( v71 )
            Triggers::Trigulator::AddTrigger(*(Triggers::Trigulator **)(a1 + 528), v71);
          else
            v8 = -2147024882;
          goto LABEL_90;
        }
        *(_QWORD *)&v95 = *(_QWORD *)(a1 + 256);
        DWORD2(v95) = DWORD1(v95);
        BYTE12(v95) = *(_BYTE *)(a1 + 280);
        v74 = operator new(0x80uLL);
        *(_QWORD *)&v98 = v74;
        if ( v74 )
        {
          std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>(
            v114,
            (_QWORD *)(a1 + 168));
          v75 = *(_QWORD *)(a1 + 160);
          v103 = v75;
          if ( v75 )
            _InterlockedIncrement((volatile signed __int32 *)(v75 + 16));
          v121 = v95;
          v122 = *(_OWORD *)(a1 + 312);
          v123 = *(_OWORD *)(a1 + 296);
          v76 = *(_QWORD *)(a1 + 144);
          v104 = v76;
          if ( v76 )
            _InterlockedIncrement((volatile signed __int32 *)(v76 + 16));
          v77 = *(const OLECHAR ***)(a1 + 120);
          if ( v77 )
            v78 = *v77;
          else
            v78 = 0LL;
          v34 = (struct Triggers::Trigger *)Triggers::EventTrigger::EventTrigger(
                                              (__int64)v74,
                                              v78,
                                              (_bstr_t *)&v104,
                                              &v123,
                                              &v122,
                                              *(_DWORD *)(a1 + 132),
                                              *(_DWORD *)(a1 + 136),
                                              *(_BYTE *)(a1 + 128),
                                              &v121,
                                              *(_DWORD *)(a1 + 152),
                                              *(_DWORD *)(a1 + 156),
                                              (_bstr_t *)&v103,
                                              v114);
        }
        else
        {
          v34 = 0LL;
        }
LABEL_36:
        if ( v34 )
        {
          Triggers::Trigulator::AddTrigger(*(Triggers::Trigulator **)(a1 + 528), v34);
          return v8;
        }
        return 2147942414LL;
      }
    }
    v35 = (Triggers::TimeTrigger *)operator new(0x68uLL);
    if ( v35 )
    {
      v36 = *(const unsigned __int16 ***)(a1 + 120);
      if ( v36 )
        v37 = *v36;
      else
        v37 = 0LL;
      v34 = Triggers::TimeTrigger::TimeTrigger(v35, v37, (const struct Scheduling::JobSchedule *)(a1 + 208));
    }
    else
    {
      v34 = 0LL;
    }
    goto LABEL_36;
  }
  return result;
}
// 180011F0E: variable 'v95' is possibly undefined
// 180012034: variable 'v38' is possibly undefined
// 18001210F: variable 'v45' is possibly undefined
// 180012182: variable 'v43' is possibly undefined
// 1800122F4: variable 'v56' is possibly undefined
// 18001232D: variable 'v55' is possibly undefined
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);
// 18004BA10: using guessed type __int64 __fastcall EmailTask::EmailTask(_DWORD, _DWORD, _DWORD, _DWORD, __int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64);
// 180070820: using guessed type void *ComHandlerTask::`vftable';
// 180070870: using guessed type void *ComHandlerBase::`vftable';
// 180073810: using guessed type void *MessageBoxTask::`vftable';

//----- (00000001800126F0) ----------------------------------------------------
__int64 __fastcall _ProcessElementEnd__QITaskXmlHandler__ValidationXmlHandler__MEAAJAEBUSchema__W4TaskXmlNodeId___Z(
        __int64 a1,
        int *a2,
        int a3)
{
  unsigned int v6; // r14d
  int v7; // ebx
  int v8; // ebx
  int v9; // ebx
  int v10; // ebx
  int v11; // ebx
  int v12; // ebx
  TSTimePeriod *Periodicity; // rax
  __int64 v15; // r9
  __int64 *v16; // rax
  __int64 v17; // rcx
  __int64 v18; // rdx
  __int64 *v19; // rcx
  __int64 v20; // rax
  __int64 v21; // rax
  __int64 *v22; // rax
  __int64 v23; // rcx
  OLECHAR **v24; // rcx
  OLECHAR *v25; // rcx
  UINT v26; // eax
  const WCHAR **v27; // rax
  const WCHAR *v28; // rdx
  BSTR *v29; // rax
  UINT v30; // eax
  TSTimePeriod *v31; // rax
  __int64 v32; // r9
  TSTimePeriod *Deadline; // rax
  __int64 v34; // r9
  __int64 v35; // rcx
  const struct SchemaEntry * near *Entry; // rax
  __int64 v37; // r10
  JobBucket *v38; // rbx
  int v39; // edi
  bool v40; // zf
  int v41; // edx
  __int16 v42; // ax
  BSTR *v43; // rax
  UINT v44; // eax
  BSTR *v45; // rax
  UINT v46; // eax
  BSTR *v47; // rax
  UINT v48; // eax
  BSTR *v49; // rax
  UINT v50; // eax
  int v51; // eax
  __int64 v52; // rcx
  int v53; // eax
  char v54[16]; // [rsp+28h] [rbp-28h] BYREF
  __int128 v55; // [rsp+38h] [rbp-18h] BYREF
  bool v56; // [rsp+90h] [rbp+40h] BYREF
  User::UserEntry *v57; // [rsp+98h] [rbp+48h] BYREF

  v6 = 0;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && *((char *)WPP_GLOBAL_Control + 28) < 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 5u )
  {
    Entry = Schema::GetEntry(a2, a3);
    WPP_SF_S(
      *(_QWORD *)(v37 + 16),
      0xCu,
      (__int64)&WPP_66bc7a8e9c2933fa102678c8dfb90698_Traceguids,
      (const wchar_t *)Entry[1]);
  }
  if ( a3 <= 39 )
  {
    if ( a3 != 39 )
    {
      if ( a3 != 1 )
      {
        if ( a3 == 21 )
          goto LABEL_24;
        if ( a3 <= 22 )
          return v6;
        if ( a3 <= 24 )
          goto LABEL_24;
        if ( a3 != 25 )
        {
          if ( a3 != 35 && a3 != 37 && a3 != 27 )
            return v6;
LABEL_24:
          LOBYTE(v55) = 0;
          *((_QWORD *)&v55 + 1) = 0LL;
          if ( TSTime::operator!=(a1 + 312, &v55) )
          {
            LOBYTE(v55) = 0;
            *((_QWORD *)&v55 + 1) = -1LL;
            if ( TSTime::operator!=(a1 + 312, &v55) && TSTime::operator<(a1 + 416, (__int128 *)(a1 + 312)) )
              *(_OWORD *)(a1 + 416) = *(_OWORD *)(a1 + 312);
          }
          goto LABEL_26;
        }
        LOBYTE(v55) = 0;
        *((_QWORD *)&v55 + 1) = 0LL;
        if ( !TSTime::operator==(a1 + 296, &v55) )
        {
          LOBYTE(v55) = 0;
          *((_QWORD *)&v55 + 1) = 0LL;
          if ( TSTime::operator!=(a1 + 312, &v55) )
          {
            LOBYTE(v55) = 0;
            *((_QWORD *)&v55 + 1) = -1LL;
            if ( TSTime::operator!=(a1 + 312, &v55) && TSTime::operator<(a1 + 416, (__int128 *)(a1 + 312)) )
              *(_OWORD *)(a1 + 416) = *(_OWORD *)(a1 + 312);
          }
          *(_DWORD *)(a1 + 264) = *(_DWORD *)(a1 + 136);
          *(_DWORD *)(a1 + 288) = *(_DWORD *)(a1 + 132);
          goto LABEL_26;
        }
        goto LABEL_131;
      }
      if ( *a2 == 0x10000 )
      {
        if ( !*(_BYTE *)(a1 + 104) )
        {
          _bstr_t::operator=((_bstr_t::Data_t **)(a1 + 72), L"AtServiceAccount");
          *(_DWORD *)(*(_QWORD *)(a1 + 40) + 16LL) |= 0x100000u;
          *(_DWORD *)(*(_QWORD *)(a1 + 40) + 16LL) &= 0xFFF03FFF;
          *(_DWORD *)(*(_QWORD *)(a1 + 40) + 16LL) |= 0x40000u;
        }
        if ( !*(_DWORD *)(a1 + 436) )
        {
          *(_DWORD *)(a1 + 108) = 12;
          return 2147750681LL;
        }
      }
      if ( (*(_BYTE *)(a1 + 48) & 2) == 0 && _bstr_t::operator!((_QWORD *)(a1 + 72)) )
        goto LABEL_87;
      if ( !*(_DWORD *)(a1 + 440) )
      {
        *(_DWORD *)(a1 + 108) = 102;
        return 2147750681LL;
      }
      if ( *(_DWORD *)(a1 + 432) != -1 )
      {
        LOBYTE(v55) = 0;
        *((_QWORD *)&v55 + 1) = 0LL;
        if ( TSTime::operator==((__int64)&v55, (__int128 *)(a1 + 416)) && *a2 >= 65538 )
        {
          *(_DWORD *)(a1 + 108) = 18;
          return 2147750681LL;
        }
        v38 = *(JobBucket **)(a1 + 40);
        v39 = *(_DWORD *)(a1 + 432);
        JobBucket::InitOptionalSettings(v38);
        *(_DWORD *)(*((_QWORD *)v38 + 26) + 12LL) = v39;
      }
      Periodicity = (TSTimePeriod *)JobBucket::GetPeriodicity(*(_QWORD *)(a1 + 40), (__int64)&v55);
      if ( TSTimePeriod::IsEmpty(Periodicity) )
        goto LABEL_113;
      if ( (*(_DWORD *)(v15 + 16) & 0x100) == 0 )
      {
        *(_DWORD *)(a1 + 108) = 72;
        return 2147750680LL;
      }
      if ( (*(_DWORD *)(v15 + 16) & 0x2000000) != 0 )
      {
LABEL_113:
        if ( (*(_DWORD *)(v15 + 16) & 0x20000000) == 0 || (*(_DWORD *)(v15 + 16) & 0x2000000) != 0 )
          return v6;
      }
      *(_DWORD *)(a1 + 108) = 131;
      return 2147750680LL;
    }
    if ( !*(_BYTE *)(a1 + 140) || (LOBYTE(v55) = 0, *((_QWORD *)&v55 + 1) = 0LL, TSTime::operator==(a1 + 296, &v55)) )
    {
LABEL_131:
      *(_DWORD *)(a1 + 108) = 17;
      return 2147750681LL;
    }
    LOBYTE(v55) = 0;
    *((_QWORD *)&v55 + 1) = 0LL;
    if ( TSTime::operator!=(a1 + 312, &v55) )
    {
      LOBYTE(v55) = 0;
      *((_QWORD *)&v55 + 1) = -1LL;
      if ( TSTime::operator!=(a1 + 312, &v55) && TSTime::operator<(a1 + 416, (__int128 *)(a1 + 312)) )
        *(_OWORD *)(a1 + 416) = *(_OWORD *)(a1 + 312);
    }
    *(_DWORD *)(a1 + 264) = *(_DWORD *)(a1 + 136);
    *(_DWORD *)(a1 + 288) = *(_DWORD *)(a1 + 132);
    switch ( *(_DWORD *)(a1 + 268) )
    {
      case 2:
        if ( *(_WORD *)(a1 + 274) )
          goto LABEL_26;
        break;
      case 3:
        v41 = *(_DWORD *)(a1 + 272);
        if ( !v41 )
        {
          *(_DWORD *)(a1 + 108) = 67;
          return 2147750681LL;
        }
        v42 = *(_WORD *)(a1 + 276);
        if ( !v42 )
        {
LABEL_128:
          *(_DWORD *)(a1 + 108) = 53;
          return 2147750681LL;
        }
        if ( (v41 & 0x9FFFFFFF) != 0 || (v42 & 0xFFD) != 0 && (v41 & 0x20000000) != 0 )
        {
LABEL_26:
          *(_DWORD *)(a1 + 112) = 0;
          return v6;
        }
        v40 = (v42 & 0xAD5) == 0 || (v41 & 0x40000000) == 0;
LABEL_127:
        if ( v40 )
          goto LABEL_128;
        goto LABEL_26;
      case 4:
        if ( *(_WORD *)(a1 + 272) )
        {
          if ( !*(_WORD *)(a1 + 274) )
          {
            *(_DWORD *)(a1 + 108) = 69;
            return 2147750681LL;
          }
          v40 = *(_WORD *)(a1 + 276) == 0;
          goto LABEL_127;
        }
        break;
      default:
        goto LABEL_26;
    }
    *(_DWORD *)(a1 + 108) = 44;
    return 2147750681LL;
  }
  v7 = a3 - 98;
  if ( !v7 )
  {
    if ( (*(_BYTE *)(a1 + 48) & 2) != 0 )
    {
LABEL_42:
      v18 = *(_QWORD *)(a1 + 40);
      v19 = *(__int64 **)(v18 + 176);
      if ( v19 )
        v20 = *v19;
      else
        v20 = 0LL;
      if ( !v20 && (unsigned int)((__int64)(*(_QWORD *)(v18 + 192) - *(_QWORD *)(v18 + 184)) >> 3) )
      {
        *(_DWORD *)(a1 + 108) = 145;
        return 2147750681LL;
      }
      if ( v19 )
        v21 = *v19;
      else
        v21 = 0LL;
      if ( v21 && (*(_DWORD *)(v18 + 16) & 0x1000000) != 0 )
      {
        *(_DWORD *)(a1 + 108) = 101;
        return 2147750680LL;
      }
      v22 = *(__int64 **)(a1 + 80);
      if ( v22 )
        v23 = *v22;
      else
        v23 = 0LL;
      if ( !v23 )
        _bstr_t::operator=((__int64 *)(a1 + 80), (__int64 *)(a1 + 96));
      if ( *(_BYTE *)(a1 + 489) || !(unsigned int)_bstr_t::_Compare((BSTR **)(a1 + 80), (BSTR **)(a1 + 96)) )
      {
        *(_BYTE *)(a1 + 489) = 0;
        *(_BYTE *)(a1 + 104) = 1;
        v24 = *(OLECHAR ***)(a1 + 72);
        if ( v24 && (v25 = *v24) != 0LL )
          v26 = SysStringLen(v25);
        else
          v26 = 0;
        if ( !v26 || (*(_DWORD *)(*(_QWORD *)(a1 + 40) + 16LL) & 0x100000) != 0 )
        {
          v52 = *(_QWORD *)(a1 + 40);
          v53 = *(_DWORD *)(v52 + 16);
          if ( (v53 & 0xFC000) == 0 )
            *(_DWORD *)(v52 + 16) = v53 & 0xFFF03FFF | 0x10000;
        }
        else
        {
          v57 = 0LL;
          v27 = *(const WCHAR ***)(a1 + 72);
          if ( v27 )
            v28 = *v27;
          else
            v28 = 0LL;
          v6 = User::FromUsername(&v57, v28);
          if ( (v6 & 0x80000000) != 0 )
          {
            if ( (*(_BYTE *)(a1 + 48) & 4) != 0 )
            {
              v6 = 0;
            }
            else
            {
              v51 = 111;
              if ( (*(_DWORD *)(*(_QWORD *)(a1 + 40) + 16LL) & 0xFC000) != 0x8000 )
                v51 = 36;
              *(_DWORD *)(a1 + 108) = v51;
            }
          }
          else if ( User::IsService((User *)&v57) )
          {
            *(_DWORD *)(*(_QWORD *)(a1 + 40) + 16LL) = *(_DWORD *)(*(_QWORD *)(a1 + 40) + 16LL) & 0xFFF03FFF | 0x20000;
          }
          wmi::AutoRef<User::UserEntry>::Release(&v57);
        }
        return v6;
      }
LABEL_170:
      *(_DWORD *)(a1 + 108) = 109;
      return 2147750681LL;
    }
    if ( !_bstr_t::operator!((_QWORD *)(a1 + 72)) )
    {
      if ( !*(_BYTE *)(a1 + 489) )
        goto LABEL_170;
      goto LABEL_42;
    }
LABEL_87:
    *(_DWORD *)(a1 + 108) = 36;
    return 2147750681LL;
  }
  v8 = v7 - 4;
  if ( !v8 )
  {
    if ( (*(_BYTE *)(a1 + 48) & 2) != 0 || *(_BYTE *)(a1 + 489) )
    {
      v16 = *(__int64 **)(a1 + 80);
      if ( v16 )
        v17 = *v16;
      else
        v17 = 0LL;
      if ( !v17 )
        _bstr_t::operator=((__int64 *)(a1 + 80), (__int64 *)(a1 + 96));
      if ( *(_BYTE *)(a1 + 489) || !(unsigned int)_bstr_t::_Compare((BSTR **)(a1 + 80), (BSTR **)(a1 + 96)) )
      {
        *(_BYTE *)(a1 + 489) = 0;
        *(_BYTE *)(a1 + 105) = 0;
        return v6;
      }
    }
    *(_DWORD *)(a1 + 108) = 110;
    return 2147750681LL;
  }
  v9 = v8 - 1;
  if ( v9 )
  {
    v10 = v9 - 10;
    if ( v10 )
    {
      v11 = v10 - 15;
      if ( v11 )
      {
        v12 = v11 - 8;
        if ( v12 )
        {
          if ( v12 != 5 )
            return v6;
          goto LABEL_24;
        }
        v31 = (TSTimePeriod *)JobBucket::GetPeriodicity(*(_QWORD *)(a1 + 40), (__int64)&v55);
        if ( !TSTimePeriod::IsEmpty(v31) )
        {
          Deadline = (TSTimePeriod *)JobBucket::GetDeadline(v32, (__int64)&v55);
          if ( TSTimePeriod::IsEmpty(Deadline) )
            return v6;
          JobBucket::GetPeriodicity(v34, (__int64)&v55);
          JobBucket::GetDeadline(v35, (__int64)v54);
          v56 = 0;
          if ( (int)TSTimePeriod::IsLessThen((TSTimePeriod *)&v55, (const struct TSTimePeriod *)v54, &v56) >= 0 && v56 )
            return v6;
          *(_DWORD *)(a1 + 108) = 138;
          return 2147750680LL;
        }
        *(_DWORD *)(a1 + 108) = 137;
        return 2147750681LL;
      }
      if ( (*(_BYTE *)(a1 + 48) & 4) != 0 )
        return v6;
    }
    else if ( (*(_BYTE *)(a1 + 48) & 4) != 0 )
    {
      v43 = *(BSTR **)(a1 + 448);
      if ( v43 && *v43 )
        v44 = SysStringLen(*v43);
      else
        v44 = 0;
      if ( v44
        || ((v45 = *(BSTR **)(a1 + 456)) == 0LL || !*v45 ? (v46 = 0) : (v46 = SysStringLen(*v45)),
            v46 || ((v47 = *(BSTR **)(a1 + 464)) == 0LL || !*v47 ? (v48 = 0) : (v48 = SysStringLen(*v47)), v48)) )
      {
        v49 = *(BSTR **)(a1 + 472);
        if ( v49 && *v49 )
          v50 = SysStringLen(*v49);
        else
          v50 = 0;
        if ( v50 )
          return v6;
        *(_DWORD *)(a1 + 108) = 120;
      }
      else
      {
        *(_DWORD *)(a1 + 108) = 116;
      }
      return 2147750681LL;
    }
    return 2147750704LL;
  }
  else
  {
    v29 = *(BSTR **)(a1 + 480);
    if ( v29 && *v29 )
      v30 = SysStringLen(*v29);
    else
      v30 = 0;
    if ( v30 )
      return v6;
    *(_DWORD *)(a1 + 108) = 104;
    return 2147750678LL;
  }
}
// 1800128DF: variable 'v15' is possibly undefined
// 180012ACB: variable 'v32' is possibly undefined
// 180012AE7: variable 'v34' is possibly undefined
// 180012AF0: variable 'v35' is possibly undefined
// 180044A33: variable 'v37' is possibly undefined
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);
// 1800824A0: using guessed type wchar_t aAtserviceaccou[17];
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180012C2C) ----------------------------------------------------
bool __fastcall TSTime::operator!=(__int64 a1, __int128 *a2)
{
  __int128 v4; // [rsp+20h] [rbp-18h] BYREF

  TSTime::EqualizeLocality((char *)a1, &v4, a2);
  return *(_QWORD *)(a1 + 8) != *((_QWORD *)&v4 + 1);
}

//----- (0000000180012C5C) ----------------------------------------------------
void __fastcall Triggers::Trigulator::AddTrigger(Triggers::Trigulator *this, struct Triggers::Trigger *a2)
{
  __int64 v4; // rax
  __int64 v5; // rax
  __int64 v6; // rcx
  __int64 v7; // rdi
  _QWORD *v8; // rdx
  __int64 v9; // rax
  char v10[32]; // [rsp+28h] [rbp-20h] BYREF
  struct Triggers::Trigger *v11; // [rsp+58h] [rbp+10h] BYREF

  v11 = a2;
  v4 = (*(__int64 (__fastcall **)(struct Triggers::Trigger *, char *))(*(_QWORD *)a2 + 8LL))(a2, v10);
  if ( TSTime::operator<(v4, (__int128 *)this) )
    *(_OWORD *)this = *(_OWORD *)(*(__int64 (__fastcall **)(struct Triggers::Trigger *, char *))(*(_QWORD *)a2 + 8LL))(
                                   a2,
                                   v10);
  v5 = (*(__int64 (__fastcall **)(struct Triggers::Trigger *, char *))(*(_QWORD *)a2 + 16LL))(a2, v10);
  if ( TSTime::operator>(v5, (__int128 *)this + 1) )
    *((_OWORD *)this + 1) = *(_OWORD *)(*(__int64 (__fastcall **)(struct Triggers::Trigger *, char *))(*(_QWORD *)a2 + 16LL))(
                                         a2,
                                         v10);
  v7 = *((_QWORD *)this + 4);
  v8 = std::_List_buy<Triggers::Trigger *>::_Buynode<Triggers::Trigger * const &>(
         v6,
         (_QWORD *)v7,
         *(_QWORD **)(v7 + 8),
         &v11);
  v9 = *((_QWORD *)this + 5);
  if ( v9 == 0xAAAAAAAAAAAAAA9LL )
    std::_Xlength_error("list<T> too long");
  *((_QWORD *)this + 5) = v9 + 1;
  *(_QWORD *)(v7 + 8) = v8;
  *(_QWORD *)v8[1] = v8;
}
// 180012CDA: variable 'v6' is possibly undefined

//----- (0000000180012D6C) ----------------------------------------------------
_QWORD *__fastcall std::_List_buy<Triggers::Trigger *>::_Buynode<Triggers::Trigger * const &>(
        __int64 a1,
        _QWORD *a2,
        _QWORD *a3,
        _QWORD *a4)
{
  _QWORD *result; // rax

  result = std::_List_alloc<0,std::_List_base_types<Triggers::Trigger *>>::_Buynode0(a1, a2, a3);
  result[2] = *a4;
  return result;
}

//----- (0000000180012DA0) ----------------------------------------------------
_QWORD *__fastcall std::_List_alloc<0,std::_List_base_types<Triggers::Trigger *>>::_Buynode0(
        __int64 a1,
        _QWORD *a2,
        _QWORD *a3)
{
  _QWORD *result; // rax

  result = operator new(0x18uLL);
  if ( !result )
    std::_Xbad_alloc();
  if ( !a2 )
  {
    a2 = result;
    a3 = result;
  }
  *result = a2;
  result[1] = a3;
  return result;
}

//----- (0000000180012E00) ----------------------------------------------------
bool __fastcall TSTime::operator>(__int64 a1, __int128 *a2)
{
  __int128 v4; // [rsp+20h] [rbp-18h] BYREF

  TSTime::EqualizeLocality((char *)a1, &v4, a2);
  return *(_QWORD *)(a1 + 8) > *((_QWORD *)&v4 + 1);
}

//----- (0000000180012E30) ----------------------------------------------------
bool __fastcall TSTime::operator<(__int64 a1, __int128 *a2)
{
  __int128 v4; // [rsp+20h] [rbp-18h] BYREF

  TSTime::EqualizeLocality((char *)a1, &v4, a2);
  return *(_QWORD *)(a1 + 8) < *((_QWORD *)&v4 + 1);
}

//----- (0000000180012E60) ----------------------------------------------------
__int128 *__fastcall TSTime::EqualizeLocality(char *a1, __int128 *a2, __int128 *a3)
{
  char v3; // al
  __int128 *v7; // rax
  __int128 v8; // xmm0
  char v9; // al
  __int128 v10; // [rsp+20h] [rbp-18h] BYREF

  v3 = *a1;
  *a2 = *a3;
  if ( v3 != *(_BYTE *)a3 )
  {
    if ( v3 )
      v7 = TSTime::ToLocal(a3, &v10);
    else
      v7 = TSTime::ToGMT(a3, &v10);
    v8 = *v7;
    v9 = *a1;
    *a2 = v8;
    *(_BYTE *)a2 = v9;
  }
  return a2;
}
// 180012E60: using guessed type __int128 var_18;

//----- (0000000180012EBC) ----------------------------------------------------
wmi::RefBase **__fastcall wmi::AutoRef<JobBucket>::operator=(wmi::RefBase **a1, volatile signed __int32 *a2)
{
  wmi::RefBase *v4; // rcx

  if ( a2 )
    _InterlockedIncrement(a2 + 2);
  v4 = *a1;
  if ( v4 )
    wmi::RefBase::Release(v4);
  *a1 = (wmi::RefBase *)a2;
  return a1;
}

//----- (0000000180012EFC) ----------------------------------------------------
void **__fastcall CBstrWriter::BufferBlock::`scalar deleting destructor'(void **this)
{
  CBstrWriter::BufferBlock *v2; // rcx

  operator delete(*this);
  v2 = (CBstrWriter::BufferBlock *)this[2];
  if ( v2 )
    CBstrWriter::BufferBlock::`scalar deleting destructor'(v2, 1u);
  operator delete(this);
  return this;
}

//----- (0000000180012F38) ----------------------------------------------------
void **__fastcall tsched::ClearList<std::vector<unsigned short *>>(void ***a1)
{
  void **v1; // rbx
  void **result; // rax

  v1 = *a1;
  if ( *a1 != a1[1] )
  {
    while ( v1 != a1[1] )
    {
      if ( *v1 )
      {
        operator delete(*v1);
        *v1 = 0LL;
      }
      ++v1;
    }
    result = *a1;
    a1[1] = *a1;
  }
  return result;
}

//----- (0000000180012F84) ----------------------------------------------------
JobMoniker *__fastcall JobMoniker::JobMoniker(JobMoniker *this, const unsigned __int16 *a2, LPCOLESTR lpsz)
{
  wmi::RefBase **v6; // rsi
  JobBucket *v7; // rax
  JobBucket *v8; // rdi
  HRESULT v10; // eax
  void **pExceptionObject; // [rsp+38h] [rbp-50h] BYREF
  char v12; // [rsp+40h] [rbp-48h]
  const unsigned __int16 *v13; // [rsp+48h] [rbp-40h]
  __int64 v14; // [rsp+50h] [rbp-38h]
  int v15; // [rsp+58h] [rbp-30h]
  int v16; // [rsp+5Ch] [rbp-2Ch]
  HRESULT v17; // [rsp+60h] [rbp-28h]
  int v18; // [rsp+64h] [rbp-24h]
  int v19; // [rsp+68h] [rbp-20h]

  *((_QWORD *)this + 2) = 0LL;
  v6 = (wmi::RefBase **)((char *)this + 32);
  *((_QWORD *)this + 4) = 0LL;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x40) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
  {
    WPP_SF_qSS(*((_QWORD *)WPP_GLOBAL_Control + 2), (__int64)a2, (__int64)lpsz, this, a2, lpsz, -2LL);
  }
  v7 = (JobBucket *)operator new(0xD8uLL);
  if ( v7 )
    v8 = JobBucket::JobBucket(v7);
  else
    v8 = 0LL;
  if ( v8 )
    _InterlockedIncrement((volatile signed __int32 *)v8 + 2);
  wmi::AutoRef<JobBucket>::Release(v6);
  *v6 = v8;
  JobMoniker::_SetPath((_bstr_t::Data_t **)this, a2);
  if ( lpsz )
  {
    v10 = IIDFromString(lpsz, (LPIID)this);
    if ( v10 < 0 )
    {
      v12 = 0;
      pExceptionObject = &wmi::GenericException::`vftable';
      v13 = &word_18007630E;
      v14 = 0LL;
      v15 = 0;
      v16 = 0;
      v17 = v10;
      v18 = -1;
      v19 = -1;
      CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
    }
  }
  else
  {
    *(GUID *)this = GUID_NULL;
  }
  *((_DWORD *)*v6 + 15) = 0;
  return this;
}
// 1800716D8: using guessed type void *wmi::GenericException::`vftable';
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018001306C) ----------------------------------------------------
__int64 __fastcall wmi::AutoRef<JobBucket>::Release(wmi::RefBase **a1)
{
  wmi::RefBase *v2; // rcx
  __int64 result; // rax

  v2 = *a1;
  if ( v2 )
    result = wmi::RefBase::Release(v2);
  *a1 = 0LL;
  return result;
}

//----- (0000000180013098) ----------------------------------------------------
__int64 __fastcall wmi::RefBase::Release(wmi::RefBase *this)
{
  unsigned __int32 v1; // ebx

  v1 = _InterlockedDecrement((volatile signed __int32 *)this + 2);
  if ( !v1 && this )
    (**(void (__fastcall ***)(wmi::RefBase *, __int64))this)(this, 1LL);
  return v1;
}

//----- (00000001800130D0) ----------------------------------------------------
void __fastcall JobBucket::SetHash(JobBucket *this, const unsigned __int8 *a2)
{
  int v2; // eax

  v2 = 0;
  if ( a2 )
  {
    v2 = 1;
    *(_OWORD *)((char *)this + 28) = *(_OWORD *)a2;
    *(_OWORD *)((char *)this + 44) = *((_OWORD *)a2 + 1);
  }
  *((_DWORD *)this + 15) = v2;
}

//----- (00000001800130F8) ----------------------------------------------------
void __fastcall JobMoniker::_SetPath(_bstr_t::Data_t **this, const unsigned __int16 *a2)
{
  bool v4; // al
  __int16 ***v5; // rbx
  const OLECHAR *v6; // rdx
  __int16 *v7; // rcx
  __int16 v8; // ax
  BSTR *v9; // [rsp+58h] [rbp+10h] BYREF

  if ( a2 )
  {
    v4 = 0;
    if ( *a2 != 92 )
      v4 = *a2 != 47;
    v5 = (__int16 ***)(this + 2);
    v6 = L"NT TASK\\";
    if ( !v4 )
      v6 = L"NT TASK";
    _bstr_t::operator=(this + 2, v6);
    _bstr_t::_bstr_t((_bstr_t *)&v9, a2);
    _bstr_t::operator+=((OLECHAR ***)this + 2, &v9);
    _bstr_t::_Free((_bstr_t *)&v9);
    if ( *v5 )
      v7 = **v5;
    else
      v7 = 0LL;
    while ( 1 )
    {
      v8 = *v7;
      if ( !*v7 )
        break;
      if ( v8 == 47 )
      {
        *v7 = 92;
        v8 = 92;
      }
      if ( v8 == 92 )
        this[3] = (_bstr_t::Data_t *)(v7 + 1);
      ++v7;
    }
  }
  else
  {
    v9 = 0LL;
    _bstr_t::operator=((__int64 *)this + 2, (__int64 *)&v9);
    _bstr_t::_Free((_bstr_t *)&v9);
    this[3] = 0LL;
  }
}
// 180076708: using guessed type wchar_t aNtTask_0[9];
// 180076720: using guessed type wchar_t aNtTask[8];

//----- (0000000180013210) ----------------------------------------------------
JobBucket *__fastcall JobBucket::`vector deleting destructor'(JobBucket *this, char a2)
{
  JobBucket::~JobBucket(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (0000000180013248) ----------------------------------------------------
void __fastcall JobBucket::~JobBucket(JobBucket *this)
{
  void *v2; // rcx

  *(_QWORD *)this = &JobBucket::`vftable';
  v2 = (void *)*((_QWORD *)this + 26);
  if ( v2 )
    operator delete(v2);
  std::vector<_bstr_t>::_Tidy((__int64)this + 184);
  _bstr_t::_Free((JobBucket *)((char *)this + 176));
  _bstr_t::_Free((JobBucket *)((char *)this + 168));
  _bstr_t::_Free((JobBucket *)((char *)this + 160));
  _bstr_t::_Free((JobBucket *)((char *)this + 152));
  _bstr_t::_Free((JobBucket *)((char *)this + 144));
  _bstr_t::_Free((JobBucket *)((char *)this + 136));
  _bstr_t::_Free((JobBucket *)((char *)this + 128));
  _bstr_t::_Free((JobBucket *)((char *)this + 120));
  _bstr_t::_Free((JobBucket *)((char *)this + 112));
  _bstr_t::_Free((JobBucket *)((char *)this + 104));
  _bstr_t::_Free((JobBucket *)((char *)this + 80));
  _bstr_t::_Free((JobBucket *)((char *)this + 72));
  wmi::AutoRef<User::UserEntry>::Release((char *)this + 64);
  *(_QWORD *)this = &wmi::RefBase::`vftable';
}
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);
// 180070978: using guessed type void *JobBucket::`vftable';
// 180070980: using guessed type void *wmi::RefBase::`vftable';

//----- (0000000180013324) ----------------------------------------------------
JobBucket *__fastcall JobBucket::JobBucket(JobBucket *this)
{
  JobBucket *result; // rax

  *((_QWORD *)this + 2) = 1111564600LL;
  *((_DWORD *)this + 6) = 0;
  *(_QWORD *)this = &wmi::RefBase::`vftable';
  *(_QWORD *)this = &JobBucket::`vftable';
  result = this;
  *((_DWORD *)this + 2) = 0;
  *((_QWORD *)this + 8) = 0LL;
  *((_QWORD *)this + 9) = 0LL;
  *((_QWORD *)this + 10) = 0LL;
  *((_QWORD *)this + 11) = 21LL;
  *((_DWORD *)this + 24) = 0;
  *((_QWORD *)this + 13) = 0LL;
  *((_QWORD *)this + 14) = 0LL;
  *((_QWORD *)this + 15) = 0LL;
  *((_QWORD *)this + 16) = 0LL;
  *((_QWORD *)this + 17) = 0LL;
  *((_QWORD *)this + 18) = 0LL;
  *((_QWORD *)this + 19) = 0LL;
  *((_QWORD *)this + 20) = 0LL;
  *((_QWORD *)this + 21) = 0LL;
  *((_QWORD *)this + 22) = 0LL;
  *((_QWORD *)this + 23) = 0LL;
  *((_QWORD *)this + 24) = 0LL;
  *((_QWORD *)this + 25) = 0LL;
  *((_QWORD *)this + 26) = 0LL;
  return result;
}
// 180070978: using guessed type void *JobBucket::`vftable';
// 180070980: using guessed type void *wmi::RefBase::`vftable';

//----- (00000001800133C4) ----------------------------------------------------
__int64 __fastcall JobStore::StreamInBSTR(_bstr_t::Data_t **a1, unsigned __int8 **a2, unsigned __int8 *a3)
{
  unsigned __int8 *v6; // rcx
  __int64 v7; // rdx
  __int64 v8; // rsi
  unsigned __int16 *v9; // rax
  __int64 v11; // [rsp+38h] [rbp+10h] BYREF

  _bstr_t::operator=(a1, 0LL);
  v6 = *a2 + 4;
  if ( v6 <= a3 )
  {
    v7 = *(unsigned int *)*a2;
    *a2 = v6;
    if ( !(_DWORD)v7 )
      return 0LL;
    v8 = (unsigned int)v7;
    if ( &v6[v7] <= a3 )
    {
      v9 = SysAllocStringLen((const OLECHAR *)v6, (unsigned int)v7 >> 1);
      _bstr_t::_bstr_t((_bstr_t *)&v11, v9);
      _bstr_t::operator=((__int64 *)a1, &v11);
      *a2 += v8;
      _bstr_t::_Free((_bstr_t *)&v11);
      return 0LL;
    }
  }
  return 2147549183LL;
}

//----- (0000000180013464) ----------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
_bstr_t::Data_t **__fastcall _bstr_t::operator=(_bstr_t::Data_t **a1, const OLECHAR *a2)
{
  _bstr_t::Data_t *v4; // rcx
  BSTR *v5; // rax
  BSTR *v6; // rbx
  BSTR v7; // rax
  void **pExceptionObject; // [rsp+28h] [rbp-38h] BYREF
  int v10; // [rsp+30h] [rbp-30h]
  __int128 v11; // [rsp+38h] [rbp-28h]
  int v12; // [rsp+48h] [rbp-18h]
  int v13; // [rsp+4Ch] [rbp-14h]
  int v14; // [rsp+50h] [rbp-10h]
  int v15; // [rsp+54h] [rbp-Ch]
  int v16; // [rsp+58h] [rbp-8h]

  v4 = *a1;
  if ( v4 )
  {
    _bstr_t::Data_t::Release(v4);
    *a1 = 0LL;
  }
  v5 = (BSTR *)HeapAlloc(g_PrivateHeap, 0, 0x18uLL);
  v6 = v5;
  if ( !v5 )
  {
    LOBYTE(v10) = 0;
    *(_QWORD *)&v11 = &word_18007630E;
    *((_QWORD *)&v11 + 1) = 0LL;
    v12 = 0;
    v13 = 0;
    v14 = 14;
    v15 = -1;
    v16 = -1;
    pExceptionObject = &wmi::OutOfMemoryException::`vftable';
    CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI4_AVOutOfMemoryException_wmi__);
  }
  v5[1] = 0LL;
  *((_DWORD *)v5 + 4) = 1;
  v7 = SysAllocString(a2);
  *v6 = v7;
  if ( !v7 && a2 )
  {
    pExceptionObject = &_com_error::`vftable';
    v10 = -2147024882;
    v11 = 0LL;
    CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI1_AV_com_error__);
  }
  *a1 = (_bstr_t::Data_t *)v6;
  return a1;
}
// 180044F19: bad sp value at call
// 180044F44: bad sp value at call
// 180071858: using guessed type void *_com_error::`vftable';
// 180073740: using guessed type void *wmi::OutOfMemoryException::`vftable';

//----- (0000000180013520) ----------------------------------------------------
__int64 __fastcall _ProcessValue__QITaskXmlHandler__ServerXMLUpdateHandler__UEAAJAEBUSchema__W4TaskXmlNodeId__AEBUData_1__N_Z(
        TriggersXmlHandler *this,
        int *a2,
        unsigned int a3,
        __int64 a4,
        char a5)
{
  _QWORD *v9; // rbx
  _QWORD *v10; // rdi
  int v11; // eax
  const struct SchemaEntry * near *Entry; // rax
  __int64 v14; // r10
  __int64 v15; // r11
  int v16; // [rsp+20h] [rbp-28h]

  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && *((char *)WPP_GLOBAL_Control + 28) < 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 5u )
  {
    Entry = Schema::GetEntry(a2, a3);
    WPP_SF_SS(
      *(_QWORD *)(v14 + 16),
      0xBu,
      (__int64)&WPP_6a02f12a6b2c3ac58024ebcfa94f3c9a_Traceguids,
      (const wchar_t *)Entry[1],
      v15);
  }
  v9 = (_QWORD *)*((_QWORD *)this + 98);
  v10 = (_QWORD *)*((_QWORD *)this + 99);
  while ( 1 )
  {
    LOBYTE(v16) = a5;
    if ( v10 == v9 )
      break;
    v11 = (**(__int64 (__fastcall ***)(_QWORD, int *, _QWORD, __int64, int))*v9)(*v9, a2, a3, a4, v16);
    if ( v11 < 0 )
    {
      if ( *((int *)this + 268) < 0 )
        return *((unsigned int *)this + 268);
      goto LABEL_15;
    }
    if ( v11 == 1 )
      return *((unsigned int *)this + 268);
    ++v9;
  }
  v11 = _ProcessValue__QITaskXmlHandler__TriggersXmlHandler__MEAAJAEBUSchema__W4TaskXmlNodeId__AEBUData_1__N_Z(
          this,
          a2,
          a3,
          a4);
  if ( v11 < 0 && *((int *)this + 268) >= 0 )
LABEL_15:
    *((_DWORD *)this + 268) = v11;
  return *((unsigned int *)this + 268);
}
// 18001359C: variable 'v16' is possibly undefined
// 180044F76: variable 'v14' is possibly undefined
// 180044F8F: variable 'v15' is possibly undefined
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180013600) ----------------------------------------------------
__int64 __fastcall _ProcessValue__QITaskXmlHandler__TriggersXmlHandler__MEAAJAEBUSchema__W4TaskXmlNodeId__AEBUData_1__N_Z(
        TriggersXmlHandler *this,
        int *a2,
        int a3,
        __int64 a4)
{
  __int64 result; // rax
  unsigned int v8; // r14d
  const unsigned __int16 *v9; // r15
  int v10; // ebx
  int v11; // ebx
  int v12; // ebx
  int v13; // ebx
  int v14; // ebx
  int v15; // ebx
  __int64 *Copy; // rax
  __int64 *v17; // rcx
  int v18; // ebx
  int v19; // ebx
  int v20; // ebx
  int v21; // ebx
  NTSTATUS v22; // eax
  int v23; // ebx
  int v24; // ebx
  __int64 v25; // rcx
  struct _GUID v26; // xmm1
  unsigned __int64 v27; // rcx
  const unsigned __int16 **v29; // rax
  int v30; // ebx
  int v31; // ebx
  int v32; // ebx
  int v33; // ebx
  __int64 *v34; // rax
  signed int v35; // eax
  struct _GUID v36; // [rsp+30h] [rbp-28h] BYREF
  __int64 v37; // [rsp+40h] [rbp-18h]

  v37 = -2LL;
  result = _ProcessValue__QITaskXmlHandler__ValidationXmlHandler__MEAAJAEBUSchema__W4TaskXmlNodeId__AEBUData_1__N_Z(
             this,
             a2,
             a3,
             a4);
  v8 = result;
  v9 = 0LL;
  if ( (int)result >= 0 )
  {
    if ( a3 > 117 )
    {
      if ( a3 <= 126 )
      {
        if ( a3 == 126 )
        {
          Copy = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)&v36);
          v17 = (__int64 *)((char *)this + 768);
        }
        else
        {
          v30 = a3 - 118;
          if ( v30 )
          {
            v31 = v30 - 1;
            if ( v31 )
            {
              v32 = v31 - 1;
              if ( v32 )
              {
                v33 = v32 - 1;
                if ( v33 )
                {
                  if ( v33 != 2 )
                    return v8;
                  v34 = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)&v36);
                  std::vector<_bstr_t>::push_back((__int64 *)this + 87, v34);
                  goto LABEL_17;
                }
                Copy = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)&v36);
                v17 = (__int64 *)((char *)this + 664);
              }
              else
              {
                Copy = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)&v36);
                v17 = (__int64 *)((char *)this + 656);
              }
            }
            else
            {
              Copy = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)&v36);
              v17 = (__int64 *)((char *)this + 648);
            }
          }
          else
          {
            Copy = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)&v36);
            v17 = (__int64 *)((char *)this + 640);
          }
        }
      }
      else
      {
        v18 = a3 - 127;
        if ( v18 )
        {
          v19 = v18 - 2;
          if ( v19 )
          {
            v20 = v19 - 1;
            if ( v20 )
            {
              v21 = v20 - 12;
              if ( v21 )
              {
                if ( v21 == 6 )
                  *((_BYTE *)this + 576) = *(_BYTE *)(a4 + 32);
              }
              else if ( (*((_BYTE *)this + 48) & 4) == 0 )
              {
                v36.Data1 = 0;
                v22 = NtQueryWnfStateNameInformation((char *)this + 332, 0LL, 0LL, &v36, 4);
                if ( v22 )
                {
                  v35 = RtlNtStatusToDosError(v22);
                  v8 = v35;
                  if ( v35 > 0 )
                    return (unsigned __int16)v35 | 0x80070000;
                }
                else if ( !v36.Data1 )
                {
                  return (unsigned int)-2147023728;
                }
              }
              return v8;
            }
            Copy = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)&v36);
            v17 = (__int64 *)((char *)this + 680);
          }
          else
          {
            Copy = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)&v36);
            v17 = (__int64 *)((char *)this + 672);
          }
        }
        else
        {
          Copy = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)&v36);
          v17 = (__int64 *)((char *)this + 776);
        }
      }
    }
    else if ( a3 == 117 )
    {
      Copy = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)&v36);
      v17 = (__int64 *)((char *)this + 632);
    }
    else if ( a3 > 106 )
    {
      v14 = a3 - 108;
      if ( !v14 )
      {
        *(_OWORD *)((char *)this + 552) = *(_OWORD *)(a4 + 32);
        return v8;
      }
      v15 = v14 - 1;
      if ( v15 )
      {
        v23 = v15 - 5;
        if ( v23 )
        {
          v24 = v23 - 1;
          if ( v24 )
          {
            if ( v24 != 1 )
              return v8;
            Copy = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)&v36);
            v17 = (__int64 *)((char *)this + 624);
          }
          else
          {
            Copy = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)&v36);
            v17 = (__int64 *)((char *)this + 616);
          }
        }
        else
        {
          Copy = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)&v36);
          v17 = (__int64 *)((char *)this + 608);
        }
      }
      else
      {
        Copy = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)&v36);
        v17 = (__int64 *)((char *)this + 544);
      }
    }
    else
    {
      if ( a3 != 106 )
      {
        v10 = a3 - 28;
        if ( v10 )
        {
          v11 = v10 - 64;
          if ( v11 )
          {
            v12 = v11 - 4;
            if ( v12 )
            {
              v13 = v12 - 8;
              if ( v13 )
              {
                if ( v13 != 1 )
                  return v8;
                Copy = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)&v36);
                v17 = (__int64 *)((char *)this + 592);
              }
              else
              {
                Copy = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)&v36);
                v17 = (__int64 *)((char *)this + 584);
              }
            }
            else
            {
              Copy = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)&v36);
              v17 = (__int64 *)((char *)this + 568);
            }
            goto LABEL_16;
          }
          if ( (*((_BYTE *)this + 48) & 4) != 0 )
            return v8;
          v25 = *(_QWORD *)(*((_QWORD *)this + 5) + 208LL);
          if ( v25 )
            v26 = *(struct _GUID *)(v25 + 28);
          else
            v26 = 0LL;
          v27 = *(_QWORD *)&GUID_NULL.Data1 - *(_QWORD *)&v26.Data1;
          if ( *(_QWORD *)&GUID_NULL.Data1 == *(_QWORD *)&v26.Data1 )
            v27 = *(_QWORD *)GUID_NULL.Data4 - _mm_srli_si128((__m128i)v26, 8).m128i_u64[0];
          if ( !v27 )
            return v8;
          v36 = v26;
          return (unsigned int)IsNetworkAvailable(&v36);
        }
        else
        {
          if ( (*((_BYTE *)this + 48) & 4) != 0 )
            return v8;
          v29 = (const unsigned __int16 **)*((_QWORD *)this + 18);
          if ( v29 )
            v9 = *v29;
          return (unsigned int)TriggersXmlHandler::CheckEventSubscription(this, v9);
        }
      }
      Copy = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)&v36);
      v17 = (__int64 *)((char *)this + 600);
    }
LABEL_16:
    _bstr_t::operator=(v17, Copy);
LABEL_17:
    _bstr_t::_Free((_bstr_t *)&v36);
    return v8;
  }
  return result;
}
// 180074748: using guessed type __int64 __fastcall NtQueryWnfStateNameInformation(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD);

//----- (00000001800137E0) ----------------------------------------------------
__int64 __fastcall _ProcessValue__QITaskXmlHandler__ValidationXmlHandler__MEAAJAEBUSchema__W4TaskXmlNodeId__AEBUData_1__N_Z(
        ValidationXmlHandler *this,
        int *a2,
        int a3,
        __int64 a4)
{
  const unsigned __int16 *v8; // rdi
  unsigned int v9; // r12d
  char v10; // al
  char *v11; // rcx
  int v13; // ebx
  int v14; // ebx
  int v15; // ebx
  __int64 *v16; // rbx
  unsigned __int16 *v17; // rax
  BSTR *v18; // rcx
  int v19; // ebx
  int v20; // ebx
  int v21; // ebx
  int v22; // ebx
  int v23; // ebx
  int v24; // ebx
  int v25; // ebx
  int v26; // ebx
  __int64 v27; // rax
  char v28; // cl
  int v29; // ebx
  int v30; // ebx
  int v31; // ebx
  int v32; // ebx
  int v33; // ebx
  int v34; // ebx
  __int64 v35; // rax
  BSTR *v36; // rax
  UINT v37; // eax
  BSTR **v38; // r13
  BSTR *v39; // rax
  UINT v40; // ecx
  const unsigned __int16 *v41; // rdx
  int v42; // ebx
  int v43; // ebx
  int v44; // ebx
  int v45; // ebx
  int v46; // ebx
  const OLECHAR **v47; // rcx
  __int64 *v48; // rax
  const WCHAR ***v49; // rbx
  __int64 v50; // rax
  __int64 v51; // rax
  __int64 v52; // rax
  const WCHAR *v53; // rdx
  __int64 *v54; // rbx
  __int64 v55; // rax
  __int64 v56; // rax
  __int64 v57; // rax
  __int64 *v58; // rax
  int v59; // ebx
  int v60; // ebx
  int v61; // ebx
  int v62; // ebx
  int v63; // ecx
  int v64; // ebx
  int v65; // ebx
  int v66; // ebx
  __int64 *v67; // rax
  __int64 *v68; // rcx
  __int64 *v69; // rbx
  JobBucket *v70; // rbx
  int v71; // edi
  __int64 v72; // rax
  __int64 v73; // rax
  int v74; // ebx
  void *v75; // rax
  int v76; // ebx
  int v77; // ebx
  int v78; // ebx
  int v79; // ebx
  unsigned __int16 *v80; // r8
  __int64 v81; // xmm6_8
  int v82; // edi
  unsigned __int16 v83; // si
  JobBucket *v84; // rbx
  __int64 v85; // rax
  int v86; // ebx
  __int64 v87; // rax
  JobBucket *v88; // rbx
  int v89; // edi
  JobBucket *v90; // rbx
  int v91; // edi
  __int64 v92; // rax
  const OLECHAR **v93; // rcx
  int v94; // eax
  __int64 *v95; // rax
  JobBucket *v96; // rbx
  int v97; // edi
  int v98; // edi
  JobBucket *v99; // rbx
  int v100; // edi
  JobBucket *v101; // rbx
  int v102; // ebx
  unsigned int v103; // eax
  unsigned int v104; // ecx
  unsigned int v105; // eax
  __int64 v106; // rax
  unsigned __int16 *v107; // r8
  __int64 v108; // xmm6_8
  int v109; // edi
  unsigned __int16 v110; // si
  JobBucket *v111; // rbx
  __int64 v112; // rax
  __int16 v113; // cx
  bool v114; // cc
  __int64 v115; // rax
  __int64 v116; // rax
  __int64 v117; // r8
  BSTR *v118; // rax
  UINT v119; // eax
  __int64 v120; // rax
  __int64 v121; // rax
  __int64 *v123; // rax
  int v124; // ebx
  __int64 *v125; // rax
  JobBucket *v126; // rbx
  int v127; // edi
  int v128; // ebx
  const struct SchemaEntry * near *Entry; // rax
  __int64 v130; // r10
  __int64 v131; // r11
  __int64 *v132; // rax
  __int64 *v133; // rax
  unsigned int v134; // eax
  unsigned int v135; // ecx
  __int64 *v136; // rax
  __int64 *v137; // rax
  int v138; // ebx
  int v139; // ebx
  __int64 *v140; // rax
  unsigned int v141; // eax
  __int64 *v142; // rax
  __int64 *v143; // rax
  __int64 *v144; // rax
  __int64 *v145; // rax
  BSTR *v146; // rcx
  UINT v147; // eax
  BSTR *v148; // rax
  UINT v149; // eax
  __int64 *v150; // rax
  unsigned int v151; // ebx
  __int64 *Copy; // rax
  const WCHAR *v153; // rdx
  __int64 *v154; // rax
  const WCHAR *v155; // rcx
  __int64 *v156; // rax
  int v157; // eax
  int v158; // ecx
  int v159; // eax
  int v160; // eax
  GUID v161; // xmm6
  JobBucket *v162; // rbx
  __int64 *v163; // rax
  __int64 *v164; // rax
  __int64 *v165; // rax
  __int64 *v166; // rax
  __int64 *v167; // rax
  BSTR *v168; // rax
  UINT v169; // eax
  const WCHAR **v170; // rax
  const WCHAR *v171; // rcx
  JobBucket *v172; // rbx
  __int64 v173; // rdi
  BSTR *v174; // rax
  UINT v175; // eax
  _QWORD *v176; // rax
  const WCHAR *v177; // rcx
  __int64 v178; // rax
  int v179; // ebx
  _bstr_t *v180; // rax
  __int64 *v181; // rax
  __int64 v182; // rax
  _bstr_t *v183; // rax
  char v184[8]; // [rsp+38h] [rbp-D0h] BYREF
  User::UserEntry *v185; // [rsp+40h] [rbp-C8h] BYREF
  __int64 *v186; // [rsp+48h] [rbp-C0h] BYREF
  __int64 v187; // [rsp+50h] [rbp-B8h] BYREF
  __int64 v188; // [rsp+58h] [rbp-B0h] BYREF
  volatile signed __int32 *v189; // [rsp+60h] [rbp-A8h] BYREF
  char v190[8]; // [rsp+68h] [rbp-A0h] BYREF
  char v191[8]; // [rsp+70h] [rbp-98h] BYREF
  char v192[8]; // [rsp+78h] [rbp-90h] BYREF
  char v193[8]; // [rsp+80h] [rbp-88h] BYREF
  char v194[8]; // [rsp+88h] [rbp-80h] BYREF
  char v195[8]; // [rsp+90h] [rbp-78h] BYREF
  char v196[8]; // [rsp+98h] [rbp-70h] BYREF
  char v197[8]; // [rsp+A0h] [rbp-68h] BYREF
  char v198[8]; // [rsp+A8h] [rbp-60h] BYREF
  char v199[8]; // [rsp+B0h] [rbp-58h] BYREF
  char v200[8]; // [rsp+B8h] [rbp-50h] BYREF
  char v201[8]; // [rsp+C0h] [rbp-48h] BYREF
  char v202[8]; // [rsp+C8h] [rbp-40h] BYREF
  char v203[8]; // [rsp+D0h] [rbp-38h] BYREF
  char v204[8]; // [rsp+D8h] [rbp-30h] BYREF
  char v205[8]; // [rsp+E0h] [rbp-28h] BYREF
  char v206[8]; // [rsp+E8h] [rbp-20h] BYREF
  char v207[8]; // [rsp+F0h] [rbp-18h] BYREF
  char v208[8]; // [rsp+F8h] [rbp-10h] BYREF
  char v209[8]; // [rsp+100h] [rbp-8h] BYREF
  char v210[8]; // [rsp+108h] [rbp+0h] BYREF
  char v211[8]; // [rsp+110h] [rbp+8h] BYREF
  char v212[8]; // [rsp+118h] [rbp+10h] BYREF
  char v213[8]; // [rsp+120h] [rbp+18h] BYREF
  char v214[8]; // [rsp+128h] [rbp+20h] BYREF
  char v215[8]; // [rsp+130h] [rbp+28h] BYREF
  char v216[8]; // [rsp+138h] [rbp+30h] BYREF
  char v217[8]; // [rsp+140h] [rbp+38h] BYREF
  char v218[8]; // [rsp+148h] [rbp+40h] BYREF
  char v219[8]; // [rsp+150h] [rbp+48h] BYREF
  char v220[8]; // [rsp+158h] [rbp+50h] BYREF
  char v221[8]; // [rsp+160h] [rbp+58h] BYREF
  __int64 v222; // [rsp+168h] [rbp+60h] BYREF
  char v223[8]; // [rsp+170h] [rbp+68h] BYREF
  __int64 v224; // [rsp+178h] [rbp+70h]
  char v225[24]; // [rsp+180h] [rbp+78h] BYREF
  GUID iid; // [rsp+198h] [rbp+90h] BYREF
  OLECHAR sz[40]; // [rsp+1A8h] [rbp+A0h] BYREF

  v224 = -2LL;
  v8 = 0LL;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x80) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 5u )
  {
    Entry = Schema::GetEntry(a2, a3);
    WPP_SF_SS(
      *(_QWORD *)(v130 + 16),
      0xBu,
      (__int64)&WPP_66bc7a8e9c2933fa102678c8dfb90698_Traceguids,
      (const wchar_t *)Entry[1],
      v131);
  }
  v9 = 0;
  if ( a3 <= 66 )
  {
    if ( a3 >= 55 )
    {
      v157 = *((unsigned __int16 *)this + 138);
      if ( (v157 & (1 << (a3 - 55))) == 0 )
      {
        *((_WORD *)this + 138) = v157 | (1 << (a3 - 55));
        return v9;
      }
      return 2147750678LL;
    }
    if ( a3 == 19 )
    {
      v28 = *(_BYTE *)(a4 + 32);
      if ( *((_DWORD *)this + 28) )
      {
        *((_BYTE *)this + 128) = v28;
        *((_BYTE *)this + 281) = *(_BYTE *)(a4 + 32);
      }
      else
      {
        v106 = *((_QWORD *)this + 5);
        if ( v28 )
          *(_DWORD *)(v106 + 16) |= 0x400000u;
        else
          *(_DWORD *)(v106 + 16) &= ~0x400000u;
      }
      return v9;
    }
    if ( a3 > 19 )
    {
      if ( a3 > 33 )
      {
        switch ( a3 )
        {
          case '$':
            v47 = *(const OLECHAR ***)(a4 + 48);
            if ( *((_DWORD *)this + 28) )
            {
              Copy = (__int64 *)XmlParserTempString::GetCopy(v47, (_bstr_t *)v207);
              _bstr_t::operator=((__int64 *)this + 25, Copy);
              _bstr_t::_Free((_bstr_t *)v207);
              v185 = 0LL;
              if ( *((_QWORD *)this + 25) )
                v153 = (const WCHAR *)**((_QWORD **)this + 25);
              else
                v153 = 0LL;
              v9 = User::FromUsername(&v185, v153);
              if ( (v9 & 0x80000000) == 0 )
              {
                if ( User::IsGroupAccount((User *)&v185) )
                {
                  wmi::AutoRef<User::UserEntry>::Release(&v185);
                  return 2147750680LL;
                }
              }
              else if ( (*((_BYTE *)this + 48) & 4) != 0 )
              {
                v9 = 0;
              }
              wmi::AutoRef<User::UserEntry>::Release(&v185);
              return v9;
            }
            v48 = (__int64 *)XmlParserTempString::GetCopy(v47, (_bstr_t *)v208);
            v49 = (const WCHAR ***)((char *)this + 72);
            _bstr_t::operator=((__int64 *)this + 9, v48);
            _bstr_t::_Free((_bstr_t *)v208);
            v50 = *((_QWORD *)this + 5);
            if ( (*(_DWORD *)(v50 + 16) & 0x18000000) == 0
              && ((v51 = *(_QWORD *)(v50 + 208)) != 0 ? (v52 = *(_QWORD *)(v51 + 48)) : (v52 = 0LL), !v52)
              || (!*v49 ? (v155 = 0LL) : (v155 = **v49), User::SupportsTaskHardening(v155)) )
            {
              if ( *v49 )
                v53 = **v49;
              else
                v53 = 0LL;
              if ( *v53 != 64 )
                return v9;
              *(_DWORD *)(*((_QWORD *)this + 5) + 16LL) |= 0x100000u;
              v189 = (volatile signed __int32 *)*v49;
              if ( v189 )
              {
                _InterlockedAdd(v189 + 4, 1u);
                v8 = *(const unsigned __int16 **)v189;
              }
              _bstr_t::operator=((_bstr_t::Data_t **)this + 9, v8 + 1);
              v11 = (char *)&v189;
              goto LABEL_16;
            }
            return 2147750678LL;
          case ')':
            v113 = *(_WORD *)(a4 + 32);
            v114 = (unsigned __int16)(v113 - 1) <= 0x16Cu;
            break;
          case '&':
            *((_DWORD *)this + 82) = *(_DWORD *)(a4 + 32);
            return v9;
          case '"':
            v156 = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)v209);
            _bstr_t::operator=((__int64 *)this + 23, v156);
            v11 = v209;
            goto LABEL_16;
          case '+':
            v113 = *(_WORD *)(a4 + 32);
            v114 = (unsigned __int16)(v113 - 1) <= 0x33u;
            break;
          default:
            v151 = a3 - 45;
            if ( v151 <= 6 )
            {
              if ( *((_DWORD *)this + 67) == 2 )
                *((_WORD *)this + 137) |= 1 << v151;
              else
                *((_WORD *)this + 136) |= 1 << v151;
            }
            return v9;
        }
        if ( v114 )
        {
          *((_WORD *)this + 136) = v113;
          return v9;
        }
        return 2147750680LL;
      }
      if ( a3 == 33 )
      {
        v145 = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)v206);
        _bstr_t::operator=((__int64 *)this + 24, v145);
        _bstr_t::_Free((_bstr_t *)v206);
        v146 = (BSTR *)*((_QWORD *)this + 24);
        if ( v146 && *v146 )
          v147 = SysStringLen(*v146);
        else
          v147 = 0;
        if ( !v147 )
          return 2147750680LL;
        v148 = (BSTR *)*((_QWORD *)this + 23);
        if ( v148 && *v148 )
          v149 = SysStringLen(*v148);
        else
          v149 = 0;
        if ( !v149 )
          return 2147750680LL;
        v150 = std::pair<_bstr_t,_bstr_t>::pair<_bstr_t,_bstr_t>(&v222, (__int64 *)this + 23, (__int64 *)this + 24);
        std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::insert<std::pair<_bstr_t,_bstr_t>>(
          (__int64 *)this + 21,
          (__int64)v225,
          v150);
        _bstr_t::_Free((_bstr_t *)v223);
        _bstr_t::_Free((_bstr_t *)&v222);
        v187 = 0LL;
        _bstr_t::operator=((__int64 *)this + 23, &v187);
        _bstr_t::_Free((_bstr_t *)&v187);
        v188 = 0LL;
        _bstr_t::operator=((__int64 *)this + 24, &v188);
        v11 = (char *)&v188;
      }
      else
      {
        v29 = a3 - 20;
        if ( !v29 )
        {
          if ( !*((_DWORD *)this + 28) )
          {
            v70 = (JobBucket *)*((_QWORD *)this + 5);
            v71 = *(_DWORD *)(a4 + 32);
            JobBucket::InitOptionalSettings(v70);
            *(_DWORD *)(*((_QWORD *)v70 + 26) + 8LL) = v71;
            return v9;
          }
          *((_DWORD *)this + 34) = *(_DWORD *)(a4 + 32);
          if ( (*((_BYTE *)this + 48) & 1) == 0 )
            return v9;
          v144 = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)v205);
          _bstr_t::operator=((__int64 *)this + 47, v144);
          v11 = v205;
          goto LABEL_16;
        }
        v30 = v29 - 2;
        if ( !v30 )
        {
          *((_DWORD *)this + 33) = *(_DWORD *)(a4 + 32);
          if ( (*((_BYTE *)this + 48) & 1) == 0 )
            return v9;
          v143 = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)v204);
          _bstr_t::operator=((__int64 *)this + 46, v143);
          v11 = v204;
          goto LABEL_16;
        }
        v102 = v30 - 4;
        if ( !v102 )
        {
          v103 = *(_DWORD *)(a4 + 32);
          if ( v103 <= 0x28DE80 )
          {
            *((_DWORD *)this + 33) = v103;
            if ( (*((_BYTE *)this + 48) & 1) == 0 )
              return v9;
            v142 = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)v203);
            _bstr_t::operator=((__int64 *)this + 46, v142);
            v11 = v203;
            goto LABEL_16;
          }
          return 2147750680LL;
        }
        v124 = v102 - 2;
        if ( v124 )
        {
          v138 = v124 - 1;
          if ( v138 )
          {
            v139 = v138 - 1;
            if ( v139 )
            {
              if ( v139 != 1 )
                return v9;
              v140 = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)v201);
              _bstr_t::operator=((__int64 *)this + 20, v140);
              v11 = v201;
              goto LABEL_16;
            }
            if ( (unsigned __int16)(*(_WORD *)(a4 + 32) - 1) <= 0x1Fu )
            {
              *((_DWORD *)this + 38) = *(unsigned __int16 *)(a4 + 32);
              return v9;
            }
          }
          else
          {
            v141 = *(_DWORD *)(a4 + 32);
            if ( v141 >= 0x3C )
            {
              *((_DWORD *)this + 39) = v141;
              return v9;
            }
          }
          return 2147750680LL;
        }
        v125 = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)v202);
        _bstr_t::operator=((__int64 *)this + 18, v125);
        v11 = v202;
      }
LABEL_16:
      _bstr_t::_Free((_bstr_t *)v11);
      return v9;
    }
    if ( a3 > 10 )
    {
      v42 = a3 - 11;
      if ( v42 )
      {
        v43 = v42 - 3;
        if ( v43 )
        {
          v44 = v43 - 1;
          if ( v44 )
          {
            v45 = v44 - 1;
            if ( !v45 )
            {
              *((_BYTE *)this + 280) = *(_BYTE *)(a4 + 32);
              return v9;
            }
            v46 = v45 - 1;
            if ( v46 )
            {
              if ( v46 != 1 )
                return v9;
              if ( !TSTime::operator<(a4, (__int128 *)((char *)this + 296)) )
              {
                *((_OWORD *)this + 14) = *(_OWORD *)a4;
                *(_OWORD *)((char *)this + 312) = *(_OWORD *)a4;
                if ( (*((_BYTE *)this + 48) & 1) == 0 )
                  return v9;
                v132 = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)v196);
                _bstr_t::operator=((__int64 *)this + 49, v132);
                v11 = v196;
                goto LABEL_16;
              }
            }
            else if ( !TSTime::operator<((__int64)this + 312, (__int128 *)a4) )
            {
              *((_OWORD *)this + 13) = *(_OWORD *)a4;
              *(_OWORD *)((char *)this + 296) = *(_OWORD *)a4;
              if ( (*((_BYTE *)this + 48) & 1) == 0 )
                return v9;
              v133 = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)v197);
              _bstr_t::operator=((__int64 *)this + 48, v133);
              v11 = v197;
              goto LABEL_16;
            }
          }
          else
          {
            v134 = *(_DWORD *)(a4 + 32);
            if ( v134 >= 0x3C )
            {
              v135 = *((_DWORD *)this + 64);
              if ( !v135 || v135 <= v134 )
              {
                *((_DWORD *)this + 65) = v134;
                if ( (*((_BYTE *)this + 48) & 1) == 0 )
                  return v9;
                v136 = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)v198);
                _bstr_t::operator=((__int64 *)this + 51, v136);
                v11 = v198;
                goto LABEL_16;
              }
            }
          }
        }
        else
        {
          v104 = *(_DWORD *)(a4 + 32);
          if ( v104 - 60 <= 0x28DE44 )
          {
            v105 = *((_DWORD *)this + 65);
            if ( !v105 || v105 >= v104 )
            {
              *((_DWORD *)this + 64) = v104;
              if ( (*((_BYTE *)this + 48) & 1) == 0 )
                return v9;
              v137 = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)v199);
              _bstr_t::operator=((__int64 *)this + 50, v137);
              v11 = v199;
              goto LABEL_16;
            }
          }
        }
        return 2147750680LL;
      }
      v67 = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)v200);
      v68 = (__int64 *)(*((_QWORD *)this + 5) + 152LL);
    }
    else if ( a3 == 10 )
    {
      v67 = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)v195);
      v68 = (__int64 *)(*((_QWORD *)this + 5) + 144LL);
    }
    else
    {
      v13 = a3 - 2;
      if ( !v13 )
      {
        *(_DWORD *)(*((_QWORD *)this + 5) + 96LL) = *(_DWORD *)(a4 + 32);
        if ( *(_DWORD *)(a4 + 32) == 0x10000 || *(_DWORD *)(a4 + 32) == 65537 )
          *(_DWORD *)(*((_QWORD *)this + 5) + 16LL) |= 0x200000u;
        return v9;
      }
      v14 = v13 - 2;
      if ( !v14 )
      {
        v54 = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)v194);
        _bstr_t::operator=((__int64 *)(*((_QWORD *)this + 5) + 160LL), v54);
        _bstr_t::_Free((_bstr_t *)v54);
        if ( !*((_QWORD *)this + 7) )
          return v9;
        v17 = XmlParserTempString::DetachBstr(*(const OLECHAR ***)(a4 + 48));
        v18 = (BSTR *)*((_QWORD *)this + 7);
        goto LABEL_105;
      }
      v15 = v14 - 1;
      if ( !v15 )
      {
        v16 = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)v193);
        _bstr_t::operator=((__int64 *)(*((_QWORD *)this + 5) + 120LL), v16);
        _bstr_t::_Free((_bstr_t *)v16);
        if ( !*((_QWORD *)this + 8) )
          return v9;
        v17 = XmlParserTempString::DetachBstr(*(const OLECHAR ***)(a4 + 48));
        v18 = (BSTR *)*((_QWORD *)this + 8);
LABEL_105:
        ATL::CComBSTR::Attach(v18, v17);
        return v9;
      }
      v64 = v15 - 1;
      if ( v64 )
      {
        v65 = v64 - 1;
        if ( v65 )
        {
          v66 = v65 - 1;
          if ( v66 )
          {
            if ( v66 != 1 )
              return v9;
            v67 = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)v216);
            v68 = (__int64 *)(*((_QWORD *)this + 5) + 112LL);
          }
          else
          {
            v67 = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)v190);
            v68 = (__int64 *)(*((_QWORD *)this + 5) + 136LL);
          }
        }
        else
        {
          v67 = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)v191);
          v68 = (__int64 *)(*((_QWORD *)this + 5) + 104LL);
        }
      }
      else
      {
        v67 = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)v192);
        v68 = (__int64 *)(*((_QWORD *)this + 5) + 128LL);
      }
    }
LABEL_132:
    v69 = v67;
    _bstr_t::operator=(v68, v67);
    v11 = (char *)v69;
    goto LABEL_16;
  }
  if ( a3 <= 100 )
  {
    if ( a3 == 100 )
    {
      v117 = *((_QWORD *)this + 5);
      if ( (*(_DWORD *)(v117 + 16) & 0xFC000) == 0
        || (*(_DWORD *)(v117 + 16) & 0xFC000) == (*(_DWORD *)(a4 + 32) & 0xFC000) )
      {
        *(_DWORD *)(v117 + 16) = *(_DWORD *)(a4 + 32) | *(_DWORD *)(v117 + 16) & 0xFFF03FFF;
        return v9;
      }
      return 2147750678LL;
    }
    if ( a3 <= 82 )
    {
      if ( a3 == 82 )
      {
        if ( *a2 < 65538 )
        {
          v160 = 0;
          if ( *(_DWORD *)(a4 + 32) )
            v160 = -2147216616;
          v9 = v160;
        }
        *((_DWORD *)this + 108) = *(_DWORD *)(a4 + 32);
        return v9;
      }
      if ( a3 > 75 )
      {
        v32 = a3 - 76;
        if ( !v32 )
        {
          v92 = *((_QWORD *)this + 5);
          if ( *(_BYTE *)(a4 + 32) )
            *(_DWORD *)(v92 + 16) |= 0x40000000u;
          else
            *(_DWORD *)(v92 + 16) &= ~0x40000000u;
          return v9;
        }
        v33 = v32 - 1;
        if ( v33 )
        {
          v34 = v33 - 1;
          if ( v34 )
          {
            v86 = v34 - 1;
            if ( v86 )
            {
              if ( v86 == 2 )
              {
                v87 = *((_QWORD *)this + 5);
                if ( *(_BYTE *)(a4 + 32) )
                  *(_DWORD *)(v87 + 16) |= 0x800000u;
                else
                  *(_DWORD *)(v87 + 16) &= ~0x800000u;
              }
            }
            else
            {
              v115 = *((_QWORD *)this + 5);
              if ( *(_BYTE *)(a4 + 32) )
                *(_DWORD *)(v115 + 16) |= 0x200u;
              else
                *(_DWORD *)(v115 + 16) &= ~0x200u;
            }
          }
          else
          {
            v35 = *((_QWORD *)this + 5);
            if ( *(_BYTE *)(a4 + 32) )
              *(_DWORD *)(v35 + 16) |= 0x80u;
            else
              *(_DWORD *)(v35 + 16) &= ~0x80u;
          }
          return v9;
        }
        v56 = *((_QWORD *)this + 5);
        if ( !*(_BYTE *)(a4 + 32) )
        {
          *(_DWORD *)(v56 + 16) &= ~0x40u;
          return v9;
        }
        v63 = 64;
      }
      else
      {
        if ( a3 != 75 )
        {
          v19 = a3 - 68;
          if ( !v19 )
          {
            if ( *a2 >= 65538 || *(_WORD *)(a4 + 32) != 32 )
            {
              v159 = *((_DWORD *)this + 68);
              _bittestandset(&v159, *(unsigned __int16 *)(a4 + 32) - 1);
              *((_DWORD *)this + 68) = v159;
              return v9;
            }
            return (unsigned int)-2147216616;
          }
          v20 = v19 - 2;
          if ( !v20 )
          {
            v158 = *((unsigned __int16 *)this + 137);
            _bittestandset(&v158, *(unsigned __int16 *)(a4 + 32) - 1);
            *((_WORD *)this + 137) = v158;
            return v9;
          }
          v21 = v20 - 2;
          if ( !v21 )
          {
            v116 = *((_QWORD *)this + 5);
            if ( *(_BYTE *)(a4 + 32) )
              *(_DWORD *)(v116 + 16) |= 0x100u;
            else
              *(_DWORD *)(v116 + 16) &= ~0x100u;
            return v9;
          }
          v22 = v21 - 1;
          if ( v22 )
          {
            if ( v22 == 1 )
            {
              v55 = *((_QWORD *)this + 5);
              if ( *(_BYTE *)(a4 + 32) )
                *(_DWORD *)(v55 + 16) |= 0x10u;
              else
                *(_DWORD *)(v55 + 16) &= ~0x10u;
            }
            return v9;
          }
          *(_DWORD *)(*((_QWORD *)this + 5) + 16LL) &= 0xFFFFC3FF;
          goto LABEL_38;
        }
        v56 = *((_QWORD *)this + 5);
        if ( !*(_BYTE *)(a4 + 32) )
        {
          *(_DWORD *)(v56 + 16) &= ~0x20u;
          return v9;
        }
        v63 = 32;
      }
      *(_DWORD *)(v56 + 16) |= v63;
      return v9;
    }
    if ( a3 <= 89 )
    {
      if ( a3 == 89 )
      {
        v57 = *((_QWORD *)this + 5);
        if ( *(_BYTE *)(a4 + 32) )
          *(_DWORD *)(v57 + 16) |= 4u;
        else
          *(_DWORD *)(v57 + 16) &= ~4u;
      }
      else
      {
        v23 = a3 - 83;
        if ( v23 )
        {
          v24 = v23 - 1;
          if ( v24 )
          {
            v25 = v24 - 2;
            if ( v25 )
            {
              v26 = v25 - 1;
              if ( v26 )
              {
                if ( v26 == 1 )
                {
                  v27 = *((_QWORD *)this + 5);
                  if ( *(_BYTE *)(a4 + 32) )
                    *(_DWORD *)(v27 + 16) |= 8u;
                  else
                    *(_DWORD *)(v27 + 16) &= ~8u;
                }
              }
              else
              {
                v88 = (JobBucket *)*((_QWORD *)this + 5);
                v89 = *(_DWORD *)(a4 + 32);
                JobBucket::InitOptionalSettings(v88);
                *(_DWORD *)(*((_QWORD *)v88 + 26) + 4LL) = v89;
              }
            }
            else
            {
              v90 = (JobBucket *)*((_QWORD *)this + 5);
              v91 = *(_DWORD *)(a4 + 32);
              JobBucket::InitOptionalSettings(v90);
              **((_DWORD **)v90 + 26) = v91;
            }
          }
          else
          {
            v72 = *((_QWORD *)this + 5);
            if ( *(_BYTE *)(a4 + 32) )
              *(_DWORD *)(v72 + 16) |= 2u;
            else
              *(_DWORD *)(v72 + 16) &= ~2u;
          }
        }
        else
        {
          v96 = (JobBucket *)*((_QWORD *)this + 5);
          v97 = *(unsigned __int16 *)(a4 + 32);
          JobBucket::InitOptionalSettings(v96);
          *(_DWORD *)(*((_QWORD *)v96 + 26) + 16LL) = v97;
        }
      }
      return v9;
    }
    switch ( a3 )
    {
      case '\\':
        v9 = IIDFromString(*(LPCOLESTR *)(*(_QWORD *)(a4 + 48) + 8LL), &iid);
        if ( (v9 & 0x80000000) != 0 )
        {
          if ( **(_WORD **)(*(_QWORD *)(a4 + 48) + 8LL) != 123 )
          {
            v9 = StringCchPrintfW(sz, 0x28uLL, (size_t *)L"{%s}");
            if ( (v9 & 0x80000000) != 0 )
              return v9;
            v9 = IIDFromString(sz, &iid);
          }
          if ( (v9 & 0x80000000) != 0 )
            return v9;
        }
        v161 = iid;
        v162 = (JobBucket *)*((_QWORD *)this + 5);
        JobBucket::InitOptionalSettings(v162);
        *(GUID *)(*((_QWORD *)v162 + 26) + 28LL) = v161;
        return v9;
      case '^':
        v100 = *(_DWORD *)(a4 + 32);
        if ( (unsigned int)(v100 - 60) <= 0x28DE44 )
        {
          v101 = (JobBucket *)*((_QWORD *)this + 5);
          JobBucket::InitOptionalSettings(v101);
          *(_DWORD *)(*((_QWORD *)v101 + 26) + 20LL) = v100;
          return v9;
        }
        return 2147750680LL;
      case '_':
        v98 = *(unsigned __int16 *)(a4 + 32);
        if ( (_WORD)v98 )
        {
          v99 = (JobBucket *)*((_QWORD *)this + 5);
          JobBucket::InitOptionalSettings(v99);
          *(_DWORD *)(*((_QWORD *)v99 + 26) + 24LL) = v98;
          return v9;
        }
        return 2147750680LL;
    }
    if ( a3 != 96 )
    {
      if ( a3 != 99 )
        return v9;
      goto LABEL_72;
    }
    if ( *((_BYTE *)this + 105) )
      return v9;
    v67 = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)v210);
    v68 = (__int64 *)(*((_QWORD *)this + 5) + 168LL);
    goto LABEL_132;
  }
  if ( a3 > 132 )
  {
    if ( a3 <= 140 )
    {
      if ( a3 == 140 )
      {
        v178 = *((_QWORD *)this + 5);
        if ( *(_BYTE *)(a4 + 32) )
          *(_DWORD *)(v178 + 16) |= 0x20000000u;
        else
          *(_DWORD *)(v178 + 16) &= ~0x20000000u;
        return v9;
      }
      v76 = a3 - 133;
      if ( v76 )
      {
        v77 = v76 - 2;
        if ( v77 )
        {
          v78 = v77 - 2;
          if ( v78 )
          {
            v79 = v78 - 1;
            if ( v79 )
            {
              if ( v79 == 1 )
              {
                v126 = (JobBucket *)*((_QWORD *)this + 5);
                v127 = *(unsigned __int8 *)(a4 + 32);
                JobBucket::InitOptionalSettings(v126);
                *(_DWORD *)(*((_QWORD *)v126 + 26) + 84LL) = v127;
              }
              return v9;
            }
            if ( !TSTimePeriod::IsEmpty((TSTimePeriod *)(a4 + 16))
              && (v80[1] + 12 * *v80
               || *(unsigned __int16 *)(a4 + 28)
                + 60
                * (*(unsigned __int16 *)(a4 + 26)
                 + 60
                 * (*(unsigned __int16 *)(a4 + 24)
                  + 24 * (*(unsigned __int16 *)(a4 + 22) + 7 * (unsigned int)*(unsigned __int16 *)(a4 + 20)))) >= 0x15180) )
            {
              v81 = *(_QWORD *)v80;
              v82 = *((_DWORD *)v80 + 2);
              v83 = v80[6];
              v84 = (JobBucket *)*((_QWORD *)this + 5);
              JobBucket::InitOptionalSettings(v84);
              v85 = *((_QWORD *)v84 + 26);
              *(_QWORD *)(v85 + 70) = v81;
              *(_DWORD *)(v85 + 78) = v82;
              *(_WORD *)(v85 + 82) = v83;
              return v9;
            }
          }
          else if ( !TSTimePeriod::IsEmpty((TSTimePeriod *)(a4 + 16))
                 && (v107[1] + 12 * *v107
                  || *(unsigned __int16 *)(a4 + 28)
                   + 60
                   * (*(unsigned __int16 *)(a4 + 26)
                    + 60
                    * (*(unsigned __int16 *)(a4 + 24)
                     + 24 * (*(unsigned __int16 *)(a4 + 22) + 7 * (unsigned int)*(unsigned __int16 *)(a4 + 20)))) >= 0x15180) )
          {
            v108 = *(_QWORD *)v107;
            v109 = *((_DWORD *)v107 + 2);
            v110 = v107[6];
            v111 = (JobBucket *)*((_QWORD *)this + 5);
            JobBucket::InitOptionalSettings(v111);
            v112 = *((_QWORD *)v111 + 26);
            *(_QWORD *)(v112 + 56) = v108;
            *(_DWORD *)(v112 + 64) = v109;
            *(_WORD *)(v112 + 68) = v110;
            return v9;
          }
          return (unsigned int)-2147216616;
        }
        v168 = (BSTR *)*((_QWORD *)this + 9);
        if ( v168 && *v168 )
          v169 = SysStringLen(*v168);
        else
          v169 = 0;
        if ( !v169
          || ((v170 = (const WCHAR **)*((_QWORD *)this + 9)) == 0LL ? (v171 = 0LL) : (v171 = *v170),
              User::SupportsTaskHardening(v171)) )
        {
          v172 = (JobBucket *)*((_QWORD *)this + 5);
          v173 = *(_QWORD *)(a4 + 32);
          JobBucket::InitOptionalSettings(v172);
          *(_QWORD *)(*((_QWORD *)v172 + 26) + 48LL) |= v173;
          return v9;
        }
      }
      else
      {
        v174 = (BSTR *)*((_QWORD *)this + 9);
        if ( v174 && *v174 )
          v175 = SysStringLen(*v174);
        else
          v175 = 0;
        if ( !v175 )
          goto LABEL_38;
        v176 = (_QWORD *)*((_QWORD *)this + 9);
        v177 = v176 ? (const WCHAR *)*v176 : 0LL;
        if ( User::SupportsTaskHardening(v177) )
          goto LABEL_38;
      }
    }
    else
    {
      v31 = a3 - 142;
      if ( !v31 )
      {
        if ( *(_DWORD *)(a4 + 64) == 8 )
        {
          *(_QWORD *)((char *)this + 332) = **(_QWORD **)(a4 + 56);
          return v9;
        }
        return (unsigned int)-2147216616;
      }
      v74 = v31 - 1;
      if ( !v74 )
      {
        v75 = operator new(*(unsigned int *)(a4 + 64));
        *((_QWORD *)this + 44) = v75;
        if ( v75 )
        {
          memcpy_0(v75, *(const void **)(a4 + 56), *(unsigned int *)(a4 + 64));
          *((_DWORD *)this + 86) = *(_DWORD *)(a4 + 64);
        }
        else
        {
          return (unsigned int)-2147024882;
        }
        return v9;
      }
      v128 = v74 - 1;
      if ( !v128 )
      {
        *((_DWORD *)this + 85) = *(_DWORD *)(a4 + 32);
        return v9;
      }
      v179 = v128 - 1;
      if ( v179 )
      {
        if ( v179 != 2 )
          return v9;
        v180 = XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)v220);
        if ( *(_QWORD *)v180 )
          v8 = **(const unsigned __int16 ***)v180;
        JobBucket::AddCapability(*((JobBucket **)this + 5), v8);
        v11 = v220;
        goto LABEL_16;
      }
      v181 = *(__int64 **)(*((_QWORD *)this + 5) + 176LL);
      if ( v181 )
        v182 = *v181;
      else
        v182 = 0LL;
      if ( !v182 )
      {
        v183 = XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)v184);
        if ( *(_QWORD *)v183 )
          v8 = **(const unsigned __int16 ***)v183;
        _bstr_t::operator=((_bstr_t::Data_t **)(*((_QWORD *)this + 5) + 176LL), v8);
        v11 = v184;
        goto LABEL_16;
      }
    }
  }
  else
  {
    if ( a3 == 132 )
    {
      v73 = *((_QWORD *)this + 5);
      if ( *(_BYTE *)(a4 + 32) )
        *(_DWORD *)(v73 + 16) |= 0x4000000u;
      else
        *(_DWORD *)(v73 + 16) &= ~0x4000000u;
      return v9;
    }
    if ( a3 > 111 )
    {
      v59 = a3 - 112;
      if ( v59 )
      {
        v60 = v59 - 4;
        if ( v60 )
        {
          v61 = v60 - 1;
          if ( v61 )
          {
            v62 = v61 - 1;
            if ( v62 )
            {
              if ( v62 != 2 )
                return v9;
              v163 = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)v215);
              _bstr_t::operator=((__int64 *)this + 59, v163);
              v11 = v215;
            }
            else
            {
              v164 = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)v221);
              _bstr_t::operator=((__int64 *)this + 58, v164);
              v11 = v221;
            }
          }
          else
          {
            v165 = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)v217);
            _bstr_t::operator=((__int64 *)this + 57, v165);
            v11 = v217;
          }
        }
        else
        {
          v166 = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)v218);
          _bstr_t::operator=((__int64 *)this + 56, v166);
          v11 = v218;
        }
      }
      else
      {
        v167 = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)v219);
        _bstr_t::operator=((__int64 *)this + 11, v167);
        v11 = v219;
      }
      goto LABEL_16;
    }
    if ( a3 != 111 )
    {
      if ( a3 != 101 )
      {
        if ( a3 == 104 )
        {
          v93 = *(const OLECHAR ***)(a4 + 48);
          v94 = 0;
          if ( (unsigned int)(*(_DWORD *)v93 - 1) > 0x103 )
            v94 = -2147216616;
          v9 = v94;
          v95 = (__int64 *)XmlParserTempString::GetCopy(v93, (_bstr_t *)v213);
          _bstr_t::operator=((__int64 *)this + 60, v95);
          v11 = v213;
          goto LABEL_16;
        }
        if ( a3 != 106 )
        {
          if ( a3 == 109 )
          {
            XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)&v186);
            if ( *((_DWORD *)this + 28) )
              _bstr_t::operator=((__int64 *)this + 15, (__int64 *)&v186);
            v10 = ValidationXmlHandler::CheckId((__int64 ***)this, &v186);
            v11 = (char *)&v186;
            if ( v10 )
              goto LABEL_16;
            goto LABEL_280;
          }
          if ( a3 != 110 )
            return v9;
LABEL_72:
          *((_BYTE *)this + 489) = 1;
          v36 = (BSTR *)*((_QWORD *)this + 10);
          if ( v36 && *v36 )
            v37 = SysStringLen(*v36);
          else
            v37 = 0;
          v38 = (BSTR **)((char *)this + 80);
          if ( v37 )
          {
            v39 = *v38;
            if ( *v38 && *v39 )
            {
              v40 = SysStringLen(*v39);
              v39 = (BSTR *)*((_QWORD *)this + 10);
            }
            else
            {
              v40 = 0;
            }
            if ( v39 )
              v41 = *v39;
            else
              v41 = 0LL;
            if ( !XmlParserTempString::IsEqualTo(*(const wchar_t ***)(a4 + 48), v41, v40) )
            {
              *((_BYTE *)this + 488) = 1;
              v154 = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)v211);
              _bstr_t::operator=((__int64 *)this + 10, v154);
              v11 = v211;
LABEL_280:
              _bstr_t::_Free((_bstr_t *)v11);
              return 2147750680LL;
            }
          }
          else
          {
            v58 = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)v212);
            _bstr_t::operator=((__int64 *)this + 10, v58);
            _bstr_t::_Free((_bstr_t *)v212);
          }
          if ( a3 != 99 || ValidationXmlHandler::CheckId((__int64 ***)this, (__int64 **)this + 10) )
            return v9;
          return 2147750680LL;
        }
        if ( (unsigned int)(**(_DWORD **)(a4 + 48) - 1) <= 0x103 )
          return v9;
        return (unsigned int)-2147216616;
      }
LABEL_38:
      *(_DWORD *)(*((_QWORD *)this + 5) + 16LL) |= *(_DWORD *)(a4 + 32);
      return v9;
    }
    if ( (*(_DWORD *)(*((_QWORD *)this + 5) + 16LL) & 0xF4000) == 0 )
    {
      v118 = (BSTR *)*((_QWORD *)this + 9);
      if ( v118 && *v118 )
        v119 = SysStringLen(*v118);
      else
        v119 = 0;
      if ( !v119 )
      {
        v120 = *((_QWORD *)this + 5);
        if ( (*(_DWORD *)(v120 + 16) & 0x18000000) == 0 )
        {
          v121 = *(_QWORD *)(v120 + 208);
          if ( !(v121 ? *(_QWORD *)(v121 + 48) : 0LL) )
          {
            v123 = (__int64 *)XmlParserTempString::GetCopy(*(const OLECHAR ***)(a4 + 48), (_bstr_t *)v214);
            _bstr_t::operator=((__int64 *)this + 9, v123);
            _bstr_t::_Free((_bstr_t *)v214);
            *(_DWORD *)(*((_QWORD *)this + 5) + 16LL) = *(_DWORD *)(*((_QWORD *)this + 5) + 16LL) & 0xFFF03FFF | 0x8000;
            return v9;
          }
        }
      }
    }
  }
  return 2147750678LL;
}
// 180013F5E: variable 'v80' is possibly undefined
// 1800141D9: variable 'v107' is possibly undefined
// 18004525C: variable 'v130' is possibly undefined
// 180045260: variable 'v131' is possibly undefined
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 1800137E0: using guessed type char var_1E0[8];
// 1800137E0: using guessed type char var_1E8[8];
// 1800137E0: using guessed type char var_1F0[8];
// 1800137E0: using guessed type char var_160[8];
// 1800137E0: using guessed type char var_1D0[8];
// 1800137E0: using guessed type char var_140[8];
// 1800137E0: using guessed type char var_120[8];
// 1800137E0: using guessed type char var_1C8[8];
// 1800137E0: using guessed type char var_138[8];
// 1800137E0: using guessed type char var_130[8];
// 1800137E0: using guessed type char var_190[8];
// 1800137E0: using guessed type char var_1D8[8];
// 1800137E0: using guessed type char var_1C0[8];
// 1800137E0: using guessed type char var_1B8[8];
// 1800137E0: using guessed type char var_1B0[8];
// 1800137E0: using guessed type char var_1A8[8];
// 1800137E0: using guessed type char var_1A0[8];
// 1800137E0: using guessed type char var_198[8];
// 1800137E0: using guessed type char var_188[8];
// 1800137E0: using guessed type char var_180[8];
// 1800137E0: using guessed type char var_178[8];
// 1800137E0: using guessed type char var_170[8];
// 1800137E0: using guessed type char var_D8[24];
// 1800137E0: using guessed type char var_E8[8];
// 1800137E0: using guessed type char var_168[8];
// 1800137E0: using guessed type char var_148[8];
// 1800137E0: using guessed type char var_158[8];
// 1800137E0: using guessed type char var_150[8];
// 1800137E0: using guessed type char var_128[8];
// 1800137E0: using guessed type char var_F8[8];
// 1800137E0: using guessed type char var_118[8];
// 1800137E0: using guessed type char var_110[8];
// 1800137E0: using guessed type char var_108[8];
// 1800137E0: using guessed type char var_100[8];
// 1800137E0: using guessed type char var_220[8];

//----- (00000001800144B4) ----------------------------------------------------
void __fastcall TriggersXmlHandler::CurrentAction::Reset(TriggersXmlHandler::CurrentAction *this)
{
  __int64 v2; // [rsp+30h] [rbp+10h] BYREF

  v2 = 0LL;
  _bstr_t::operator=((__int64 *)this, &v2);
  _bstr_t::_Free((_bstr_t *)&v2);
  *((_BYTE *)this + 32) = 0;
  v2 = 0LL;
  _bstr_t::operator=((__int64 *)this + 5, &v2);
  _bstr_t::_Free((_bstr_t *)&v2);
  v2 = 0LL;
  _bstr_t::operator=((__int64 *)this + 6, &v2);
  _bstr_t::_Free((_bstr_t *)&v2);
  v2 = 0LL;
  _bstr_t::operator=((__int64 *)this + 7, &v2);
  _bstr_t::_Free((_bstr_t *)&v2);
  v2 = 0LL;
  _bstr_t::operator=((__int64 *)this + 8, &v2);
  _bstr_t::_Free((_bstr_t *)&v2);
  v2 = 0LL;
  _bstr_t::operator=((__int64 *)this + 9, &v2);
  _bstr_t::_Free((_bstr_t *)&v2);
  v2 = 0LL;
  _bstr_t::operator=((__int64 *)this + 10, &v2);
  _bstr_t::_Free((_bstr_t *)&v2);
  v2 = 0LL;
  _bstr_t::operator=((__int64 *)this + 11, &v2);
  _bstr_t::_Free((_bstr_t *)&v2);
  v2 = 0LL;
  _bstr_t::operator=((__int64 *)this + 12, &v2);
  _bstr_t::_Free((_bstr_t *)&v2);
  v2 = 0LL;
  _bstr_t::operator=((__int64 *)this + 13, &v2);
  _bstr_t::_Free((_bstr_t *)&v2);
  v2 = 0LL;
  _bstr_t::operator=((__int64 *)this + 14, &v2);
  _bstr_t::_Free((_bstr_t *)&v2);
  v2 = 0LL;
  _bstr_t::operator=((__int64 *)this + 15, &v2);
  _bstr_t::_Free((_bstr_t *)&v2);
  std::vector<_bstr_t>::clear((_bstr_t **)this + 19);
  std::vector<_bstr_t>::clear((_bstr_t **)this + 22);
  std::vector<_bstr_t>::clear((_bstr_t **)this + 25);
  v2 = 0LL;
  _bstr_t::operator=((__int64 *)this + 28, &v2);
  _bstr_t::_Free((_bstr_t *)&v2);
  v2 = 0LL;
  _bstr_t::operator=((__int64 *)this + 29, &v2);
  _bstr_t::_Free((_bstr_t *)&v2);
  v2 = 0LL;
  _bstr_t::operator=((__int64 *)this + 18, &v2);
  _bstr_t::_Free((_bstr_t *)&v2);
}

//----- (0000000180014698) ----------------------------------------------------
void __fastcall ValidationXmlHandler::CurrentTrigger::Reset(__int64 a1, int a2)
{
  struct _FILETIME *v3; // rax
  __int128 v4; // xmm0
  void *v5; // rcx
  __int128 v6; // [rsp+20h] [rbp-19h]
  struct _FILETIME v7; // [rsp+30h] [rbp-9h] BYREF
  __int64 v8; // [rsp+A0h] [rbp+67h] BYREF

  *(_DWORD *)a1 = a2;
  v8 = 0LL;
  _bstr_t::operator=((__int64 *)(a1 + 8), &v8);
  _bstr_t::_Free((_bstr_t *)&v8);
  *(_DWORD *)(a1 + 24) = -1;
  *(_BYTE *)(a1 + 16) = 1;
  *(_DWORD *)(a1 + 20) = 0;
  v3 = Scheduling::JobSchedule::JobSchedule(&v7);
  v8 = 0LL;
  *(_OWORD *)(a1 + 96) = *(_OWORD *)&v3->dwLowDateTime;
  *(_OWORD *)(a1 + 112) = *(_OWORD *)&v3[2].dwLowDateTime;
  *(_OWORD *)(a1 + 128) = *(_OWORD *)&v3[4].dwLowDateTime;
  *(_OWORD *)(a1 + 144) = *(_OWORD *)&v3[6].dwLowDateTime;
  *(_OWORD *)(a1 + 160) = *(_OWORD *)&v3[8].dwLowDateTime;
  *(struct _FILETIME *)(a1 + 176) = v3[10];
  *(_BYTE *)(a1 + 28) = 0;
  _bstr_t::operator=((__int64 *)(a1 + 32), &v8);
  _bstr_t::_Free((_bstr_t *)&v8);
  *(_QWORD *)(a1 + 40) = 0LL;
  v8 = 0LL;
  _bstr_t::operator=((__int64 *)(a1 + 48), &v8);
  _bstr_t::_Free((_bstr_t *)&v8);
  std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::clear((_QWORD *)(a1 + 56));
  v8 = 0LL;
  _bstr_t::operator=((__int64 *)(a1 + 72), &v8);
  _bstr_t::_Free((_bstr_t *)&v8);
  v8 = 0LL;
  _bstr_t::operator=((__int64 *)(a1 + 80), &v8);
  _bstr_t::_Free((_bstr_t *)&v8);
  v8 = 0LL;
  _bstr_t::operator=((__int64 *)(a1 + 88), &v8);
  _bstr_t::_Free((_bstr_t *)&v8);
  LOBYTE(v6) = 0;
  v4 = (unsigned __int64)v6;
  *((_QWORD *)&v6 + 1) = -1LL;
  LOBYTE(v6) = 0;
  *(_OWORD *)(a1 + 184) = v4;
  *(_DWORD *)(a1 + 216) = 0;
  *(_OWORD *)(a1 + 200) = v6;
  ValidationXmlHandler::CurrentTrigger::_unnamed_type_strings_::Reset((ValidationXmlHandler::CurrentTrigger::_unnamed_type_strings_ *)(a1 + 248));
  *(_QWORD *)(a1 + 220) = 0LL;
  v5 = *(void **)(a1 + 240);
  *(_QWORD *)(a1 + 228) = 0LL;
  if ( v5 )
    operator delete(v5);
  *(_QWORD *)(a1 + 240) = 0LL;
}
// 1800147C3: variable 'v6' is possibly undefined

//----- (0000000180014838) ----------------------------------------------------
void __fastcall ValidationXmlHandler::CurrentTrigger::_unnamed_type_strings_::Reset(
        ValidationXmlHandler::CurrentTrigger::_unnamed_type_strings_ *this)
{
  __int64 v2; // [rsp+30h] [rbp+10h] BYREF

  v2 = 0LL;
  _bstr_t::operator=((__int64 *)this, &v2);
  _bstr_t::_Free((_bstr_t *)&v2);
  v2 = 0LL;
  _bstr_t::operator=((__int64 *)this + 1, &v2);
  _bstr_t::_Free((_bstr_t *)&v2);
  v2 = 0LL;
  _bstr_t::operator=((__int64 *)this + 2, &v2);
  _bstr_t::_Free((_bstr_t *)&v2);
  v2 = 0LL;
  _bstr_t::operator=((__int64 *)this + 3, &v2);
  _bstr_t::_Free((_bstr_t *)&v2);
  v2 = 0LL;
  _bstr_t::operator=((__int64 *)this + 4, &v2);
  _bstr_t::_Free((_bstr_t *)&v2);
  v2 = 0LL;
  _bstr_t::operator=((__int64 *)this + 5, &v2);
  _bstr_t::_Free((_bstr_t *)&v2);
  v2 = 0LL;
  _bstr_t::operator=((__int64 *)this + 6, &v2);
  _bstr_t::_Free((_bstr_t *)&v2);
}

//----- (0000000180014914) ----------------------------------------------------
__int64 *__fastcall _bstr_t::operator=(__int64 *a1, __int64 *a2)
{
  __int64 v4; // rbx
  void *v6; // rcx

  if ( *a2 )
    _InterlockedIncrement((volatile signed __int32 *)(*a2 + 16));
  v4 = *a1;
  if ( *a1 )
  {
    if ( _InterlockedExchangeAdd((volatile signed __int32 *)(v4 + 16), 0xFFFFFFFF) == 1 )
    {
      if ( *(_QWORD *)v4 )
      {
        SysFreeString(*(BSTR *)v4);
        *(_QWORD *)v4 = 0LL;
      }
      v6 = *(void **)(v4 + 8);
      if ( v6 )
      {
        operator delete(v6);
        *(_QWORD *)(v4 + 8) = 0LL;
      }
      HeapFree(g_PrivateHeap, 0, (LPVOID)v4);
    }
    *a1 = 0LL;
  }
  *a1 = *a2;
  return a1;
}

//----- (00000001800149B4) ----------------------------------------------------
_bstr_t *__fastcall XmlParserTempString::GetCopy(const OLECHAR **a1, _bstr_t *a2)
{
  unsigned __int16 *v3; // rbx
  BSTR v4; // rsi

  v3 = 0LL;
  v4 = XmlParserTempString::DetachBstr(a1);
  if ( v4 )
  {
    SysFreeString(0LL);
    v3 = v4;
  }
  _bstr_t::_bstr_t(a2, v3);
  SysFreeString(0LL);
  return a2;
}

//----- (0000000180014A30) ----------------------------------------------------
__int64 __fastcall JobStore::RegTreeEntryOpen(HKEY *this, const unsigned __int16 *a2, HKEY *a3)
{
  unsigned __int16 v6; // ax
  const unsigned __int16 *v7; // rdi
  const WCHAR *v8; // rdx
  LSTATUS v9; // eax
  unsigned int v10; // ebx
  HKEY v11; // rax
  BSTR *v13[2]; // [rsp+30h] [rbp-10h] BYREF
  const WCHAR **v14; // [rsp+70h] [rbp+30h] BYREF
  HKEY phkResult; // [rsp+78h] [rbp+38h] BYREF

  v13[1] = (BSTR *)-2LL;
  phkResult = 0LL;
  _bstr_t::_bstr_t((_bstr_t *)&v14, L"TaskCache\\Tree");
  if ( a2 )
  {
    v6 = *a2;
    if ( *a2 == 92 )
      v6 = a2[1];
    v7 = a2 + 1;
    if ( *a2 != 92 )
      v7 = a2;
    if ( v6 )
    {
      _bstr_t::_bstr_t((_bstr_t *)v13, L"\\");
      _bstr_t::operator+=((OLECHAR ***)&v14, v13);
      _bstr_t::_Free((_bstr_t *)v13);
      _bstr_t::_bstr_t((_bstr_t *)v13, v7);
      _bstr_t::operator+=((OLECHAR ***)&v14, v13);
      _bstr_t::_Free((_bstr_t *)v13);
    }
  }
  if ( v14 )
    v8 = *v14;
  else
    v8 = 0LL;
  v9 = RegOpenKeyExW(this[2], v8, 0, 0xF003Fu, &phkResult);
  v10 = v9;
  if ( v9 )
  {
    if ( v9 > 0 )
      v10 = (unsigned __int16)v9 | 0x80070000;
  }
  else
  {
    v11 = phkResult;
    phkResult = 0LL;
    *a3 = v11;
    v10 = 0;
  }
  _bstr_t::_Free((_bstr_t *)&v14);
  wmi::AutoRegKey::Close(&phkResult);
  return v10;
}

//----- (0000000180014B60) ----------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
_bstr_t *__fastcall _bstr_t::_bstr_t(_bstr_t *this, const unsigned __int16 *a2)
{
  BSTR *v4; // rax
  BSTR *v5; // rbx
  BSTR v6; // rax
  void **pExceptionObject; // [rsp+28h] [rbp-38h] BYREF
  int v9; // [rsp+30h] [rbp-30h]
  __int128 v10; // [rsp+38h] [rbp-28h]

  v4 = (BSTR *)HeapAlloc(g_PrivateHeap, 0, 0x18uLL);
  v5 = v4;
  if ( !v4 )
  {
    LOBYTE(v9) = 0;
    *(_QWORD *)&v10 = &word_18007630E;
    pExceptionObject = &wmi::OutOfMemoryException::`vftable';
    CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI4_AVOutOfMemoryException_wmi__);
  }
  v4[1] = 0LL;
  *((_DWORD *)v4 + 4) = 1;
  v6 = SysAllocString(a2);
  *v5 = v6;
  if ( !v6 && a2 )
  {
    pExceptionObject = &_com_error::`vftable';
    v9 = -2147024882;
    *(_QWORD *)&v10 = 0LL;
    CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI1_AV_com_error__);
  }
  *(_QWORD *)this = v5;
  return this;
}
// 180045B87: ignored the value written to the shadow area of the succeeding call
// 180045B83: ignored the value written to the shadow area of the succeeding call
// 180045B7C: ignored the value written to the shadow area of the succeeding call
// 180045B78: ignored the value written to the shadow area of the succeeding call
// 180045B74: ignored the value written to the shadow area of the succeeding call
// 180045B6F: ignored the value written to the shadow area of the succeeding call
// 180045BCC: bad sp value at call
// 180045BA1: bad sp value at call
// 180071858: using guessed type void *_com_error::`vftable';
// 180073740: using guessed type void *wmi::OutOfMemoryException::`vftable';

//----- (0000000180014C00) ----------------------------------------------------
OLECHAR ***__fastcall _bstr_t::operator+=(OLECHAR ***a1, BSTR **a2)
{
  _bstr_t::Data_t *v4; // rax
  _bstr_t::Data_t *v5; // rsi
  OLECHAR **v6; // rbx
  OLECHAR *v7; // rcx

  v4 = (_bstr_t::Data_t *)operator new(0x18uLL);
  if ( v4 )
    v5 = _bstr_t::Data_t::Data_t(v4, a1, a2);
  else
    v5 = 0LL;
  v6 = *a1;
  if ( *a1 && _InterlockedExchangeAdd((volatile signed __int32 *)v6 + 4, 0xFFFFFFFF) == 1 )
  {
    if ( *v6 )
    {
      SysFreeString(*v6);
      *v6 = 0LL;
    }
    v7 = v6[1];
    if ( v7 )
    {
      operator delete(v7);
      v6[1] = 0LL;
    }
    HeapFree(g_PrivateHeap, 0, v6);
  }
  *a1 = (OLECHAR **)v5;
  return a1;
}

//----- (0000000180014CB8) ----------------------------------------------------
_bstr_t::Data_t *__fastcall _bstr_t::Data_t::Data_t(_bstr_t::Data_t *this, OLECHAR ***a2, BSTR **a3)
{
  OLECHAR *v6; // rcx
  UINT v7; // ebx
  BSTR *v8; // rax
  UINT v9; // r14d
  UINT v10; // edi
  unsigned __int64 v11; // rax
  BSTR v12; // rax
  OLECHAR **v13; // rdx
  BSTR *v14; // rdx
  void **pExceptionObject; // [rsp+20h] [rbp-38h] BYREF
  int v17; // [rsp+28h] [rbp-30h]
  __int128 v18; // [rsp+30h] [rbp-28h]

  *((_QWORD *)this + 1) = 0LL;
  *((_DWORD *)this + 4) = 1;
  if ( *a2 && (v6 = **a2) != 0LL )
    v7 = SysStringLen(v6);
  else
    v7 = 0;
  v8 = *a3;
  if ( *a3 && *v8 )
    v9 = SysStringLen(*v8);
  else
    v9 = 0;
  v10 = v9 + v7;
  if ( v9 + v7 < v7 || (v11 = 2LL * v10, v11 > 0xFFFFFFFF) )
  {
    v17 = -2147024882;
    pExceptionObject = &_com_error::`vftable';
    v18 = 0LL;
    CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI1_AV_com_error__);
  }
  v12 = SysAllocStringByteLen(0LL, v11);
  *(_QWORD *)this = v12;
  if ( v12 )
  {
    v13 = *a2;
    if ( *a2 )
      v13 = (OLECHAR **)*v13;
    if ( v13 )
      memcpy_0(v12, v13, 2LL * (v7 + 1));
    v14 = *a3;
    if ( *a3 )
      v14 = (BSTR *)*v14;
    if ( v14 )
      memcpy_0((void *)(*(_QWORD *)this + 2LL * v7), v14, 2LL * (v9 + 1));
  }
  else if ( v10 )
  {
    v17 = -2147024882;
    pExceptionObject = &_com_error::`vftable';
    v18 = 0LL;
    CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI1_AV_com_error__);
  }
  return this;
}
// 180071858: using guessed type void *_com_error::`vftable';

//----- (0000000180014DDC) ----------------------------------------------------
_bstr_t *__fastcall _bstr_t::_bstr_t(_bstr_t *this, unsigned __int16 *a2)
{
  _QWORD *v4; // rax
  void **pExceptionObject; // [rsp+28h] [rbp-30h] BYREF
  int v7; // [rsp+30h] [rbp-28h]
  __int128 v8; // [rsp+38h] [rbp-20h]

  v4 = operator new(0x18uLL);
  if ( v4 )
  {
    v4[1] = 0LL;
    *((_DWORD *)v4 + 4) = 1;
    *v4 = a2;
  }
  *(_QWORD *)this = v4;
  if ( !v4 )
  {
    pExceptionObject = &_com_error::`vftable';
    v7 = -2147024882;
    v8 = 0LL;
    CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI1_AV_com_error__);
  }
  return this;
}
// 180071858: using guessed type void *_com_error::`vftable';

//----- (0000000180014E3C) ----------------------------------------------------
LPVOID __fastcall operator new(SIZE_T dwBytes)
{
  LPVOID result; // rax
  void **pExceptionObject; // [rsp+20h] [rbp-48h] BYREF
  char v3; // [rsp+28h] [rbp-40h]
  const unsigned __int16 *v4; // [rsp+30h] [rbp-38h]
  __int64 v5; // [rsp+38h] [rbp-30h]
  __int64 v6; // [rsp+40h] [rbp-28h]
  int v7; // [rsp+48h] [rbp-20h]
  int v8; // [rsp+4Ch] [rbp-1Ch]
  int v9; // [rsp+50h] [rbp-18h]

  result = HeapAlloc(g_PrivateHeap, 0, dwBytes);
  if ( !result )
  {
    v8 = -1;
    v9 = -1;
    v4 = &word_18007630E;
    v3 = 0;
    v5 = 0LL;
    v6 = 0LL;
    pExceptionObject = &wmi::OutOfMemoryException::`vftable';
    v7 = 14;
    CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI4_AVOutOfMemoryException_wmi__);
  }
  return result;
}
// 180073740: using guessed type void *wmi::OutOfMemoryException::`vftable';

//----- (0000000180014E70) ----------------------------------------------------
BSTR __fastcall XmlParserTempString::DetachBstr(const OLECHAR **this)
{
  BSTR result; // rax
  void **pExceptionObject; // [rsp+20h] [rbp-48h] BYREF
  char v4; // [rsp+28h] [rbp-40h]
  const unsigned __int16 *v5; // [rsp+30h] [rbp-38h]
  __int64 v6; // [rsp+38h] [rbp-30h]
  __int64 v7; // [rsp+40h] [rbp-28h]
  int v8; // [rsp+48h] [rbp-20h]
  int v9; // [rsp+4Ch] [rbp-1Ch]
  int v10; // [rsp+50h] [rbp-18h]

  result = XmlParserTempString::GetNullTerminated((XmlParserTempString *)this);
  if ( (*((_BYTE *)this + 1042) & 1) == 0 )
  {
    result = SysAllocStringLen(this[1], *(_DWORD *)this);
    if ( !result )
    {
      v9 = -1;
      v10 = -1;
      v5 = &word_18007630E;
      v4 = 0;
      v6 = 0LL;
      v7 = 0LL;
      pExceptionObject = &wmi::OutOfMemoryException::`vftable';
      v8 = 14;
      CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI4_AVOutOfMemoryException_wmi__);
    }
  }
  *((_BYTE *)this + 1042) &= ~1u;
  return result;
}
// 180073740: using guessed type void *wmi::OutOfMemoryException::`vftable';

//----- (0000000180014EB8) ----------------------------------------------------
BSTR __fastcall XmlParserTempString::GetNullTerminated(XmlParserTempString *this)
{
  char v1; // al
  BSTR result; // rax
  const OLECHAR *v4; // rcx
  void **pExceptionObject; // [rsp+20h] [rbp-48h] BYREF
  char v6; // [rsp+28h] [rbp-40h]
  const unsigned __int16 *v7; // [rsp+30h] [rbp-38h]
  __int64 v8; // [rsp+38h] [rbp-30h]
  int v9; // [rsp+40h] [rbp-28h]
  int v10; // [rsp+44h] [rbp-24h]
  int v11; // [rsp+48h] [rbp-20h]
  int v12; // [rsp+4Ch] [rbp-1Ch]
  int v13; // [rsp+50h] [rbp-18h]

  v1 = *((_BYTE *)this + 1042);
  if ( (v1 & 2) != 0 )
    return (BSTR)*((_QWORD *)this + 1);
  if ( (v1 & 1) != 0 )
    return (BSTR)*((_QWORD *)this + 1);
  v4 = (const OLECHAR *)*((_QWORD *)this + 1);
  if ( !v4 )
    return (BSTR)*((_QWORD *)this + 1);
  result = SysAllocStringLen(v4, *(_DWORD *)this);
  if ( !result )
  {
    v8 = 0LL;
    v9 = 0;
    v10 = 0;
    v12 = -1;
    v13 = -1;
    v7 = &word_18007630E;
    pExceptionObject = &wmi::OutOfMemoryException::`vftable';
    v6 = 0;
    v11 = 14;
    CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI4_AVOutOfMemoryException_wmi__);
  }
  *((_BYTE *)this + 1042) |= 1u;
  *((_QWORD *)this + 1) = result;
  return result;
}
// 180073740: using guessed type void *wmi::OutOfMemoryException::`vftable';

//----- (0000000180014F14) ----------------------------------------------------
void __fastcall Triggers::WnfStateChangeTrigger::~WnfStateChangeTrigger(Triggers::WnfStateChangeTrigger *this)
{
  void *v2; // rcx

  *(_QWORD *)this = &Triggers::WnfStateChangeTrigger::`vftable';
  v2 = (void *)*((_QWORD *)this + 13);
  if ( v2 )
    operator delete(v2);
  _bstr_t::_Free((Triggers::WnfStateChangeTrigger *)((char *)this + 80));
  *(_QWORD *)this = &Triggers::Trigger::`vftable';
}
// 180070988: using guessed type void *Triggers::Trigger::`vftable';
// 1800709F8: using guessed type void *Triggers::WnfStateChangeTrigger::`vftable';

//----- (0000000180014F58) ----------------------------------------------------
__int64 __fastcall JobSecurity::StreamIn(void **this, HKEY a2)
{
  LSTATUS v4; // eax
  unsigned int v5; // ebx
  bool v6; // cc
  HLOCAL v7; // rax
  LPBYTE v8; // rdi
  LPBYTE lpData[2]; // [rsp+30h] [rbp-10h] BYREF
  DWORD cbData; // [rsp+70h] [rbp+30h] BYREF
  DWORD Type; // [rsp+78h] [rbp+38h] BYREF

  lpData[0] = 0LL;
  cbData = 0;
  Type = 3;
  tsched::AutoLocalPtr<_SECURITY_DESCRIPTOR>::Attach((void **)lpData, 0LL);
  v4 = RegQueryValueExW(a2, L"SD", 0LL, &Type, lpData[0], &cbData);
  v5 = v4;
  v6 = v4 <= 0;
  if ( !v4 )
  {
    if ( Type != 3 )
      goto LABEL_9;
    v7 = LocalAlloc(0, cbData);
    tsched::AutoLocalPtr<_SECURITY_DESCRIPTOR>::Attach((void **)lpData, v7);
    v8 = lpData[0];
    if ( !lpData[0] )
    {
      v5 = 14;
      goto LABEL_8;
    }
    v4 = RegQueryValueExW(a2, L"SD", 0LL, &Type, lpData[0], &cbData);
    v5 = v4;
    v6 = v4 <= 0;
    if ( !v4 )
    {
      if ( Type == 3 && cbData )
      {
        lpData[0] = 0LL;
        tsched::AutoLocalPtr<_SECURITY_DESCRIPTOR>::Attach(this, v8);
        *((_DWORD *)this + 2) = cbData;
        goto LABEL_8;
      }
LABEL_9:
      v5 = -2147023537;
      goto LABEL_8;
    }
  }
  if ( !v6 )
    v5 = (unsigned __int16)v4 | 0x80070000;
LABEL_8:
  tsched::AutoLocalPtr<unsigned short>::~AutoLocalPtr<unsigned short>((void **)lpData);
  return v5;
}

//----- (0000000180015080) ----------------------------------------------------
HLOCAL __fastcall tsched::AutoLocalPtr<_SECURITY_DESCRIPTOR>::Attach(void **a1, void *a2)
{
  void *v4; // rcx
  HLOCAL result; // rax

  v4 = *a1;
  if ( v4 )
    result = LocalFree(v4);
  *a1 = a2;
  return result;
}

//----- (00000001800150BC) ----------------------------------------------------
char __fastcall ValidationXmlHandler::CheckId(__int64 ***this, __int64 **a2)
{
  __int64 *v4; // rax
  UINT v5; // eax
  __int64 v6; // r8
  __int64 *v7; // rax
  unsigned __int16 **v9[2]; // [rsp+38h] [rbp-30h] BYREF
  char v10[32]; // [rsp+48h] [rbp-20h] BYREF
  __int64 **v11; // [rsp+78h] [rbp+10h] BYREF

  v4 = *a2;
  if ( *a2 && *v4 )
    v5 = SysStringLen((BSTR)*v4);
  else
    v5 = 0;
  if ( !v5
    || *std::_Tree<std::_Tmap_traits<_bstr_t,void *,ValidationXmlHandler::stringless,std::allocator<std::pair<_bstr_t const,void *>>,0>>::find(
          (__int64)(this + 62),
          &v11,
          a2) != this[62] )
  {
    return 0;
  }
  v7 = *a2;
  v9[0] = (unsigned __int16 **)v7;
  if ( v7 )
    _InterlockedIncrement((volatile signed __int32 *)v7 + 4);
  v9[1] = 0LL;
  std::_Tree<std::_Tmap_traits<_bstr_t,void *,ValidationXmlHandler::stringless,std::allocator<std::pair<_bstr_t const,void *>>,0>>::_Insert_nohint<std::pair<_bstr_t const,void *>,std::_Nil>(
    this + 62,
    (__int64)v10,
    v6,
    v9);
  _bstr_t::_Free((_bstr_t *)v9);
  return 1;
}
// 180015150: variable 'v6' is possibly undefined
// 1800150BC: using guessed type char var_20[32];

//----- (000000018001517C) ----------------------------------------------------
__int64 ***__fastcall std::_Tree<std::_Tmap_traits<_bstr_t,void *,ValidationXmlHandler::stringless,std::allocator<std::pair<_bstr_t const,void *>>,0>>::find(
        __int64 a1,
        __int64 ***a2,
        __int64 **a3)
{
  __int64 **v3; // r11
  __int64 **v6; // r10
  __int64 *v7; // r9
  __int64 **v8; // r9
  __int64 **v9; // r10

  v3 = *(__int64 ***)a1;
  v6 = *(__int64 ***)a1;
  v7 = *(__int64 **)(*(_QWORD *)a1 + 8LL);
  while ( !*((_BYTE *)v7 + 25) )
  {
    if ( (unsigned __int8)ValidationXmlHandler::stringless::operator()(a1, (unsigned __int16 ***)v7 + 4, a3) )
    {
      v7 = v8[2];
    }
    else
    {
      v6 = v8;
      v7 = *v8;
    }
  }
  if ( v6 == v3 || (unsigned __int8)ValidationXmlHandler::stringless::operator()(a1, (unsigned __int16 ***)a3, v6 + 4) )
    v9 = v3;
  *a2 = v9;
  return a2;
}
// 180015198: variable 'v8' is possibly undefined
// 1800151AA: variable 'a1' is possibly undefined
// 1800151BE: variable 'v6' is possibly undefined
// 1800151BE: variable 'v3' is possibly undefined
// 1800151D3: variable 'v9' is possibly undefined

//----- (00000001800151EC) ----------------------------------------------------
__int64 __fastcall std::_Tree<std::_Tmap_traits<_bstr_t,void *,ValidationXmlHandler::stringless,std::allocator<std::pair<_bstr_t const,void *>>,0>>::_Insert_nohint<std::pair<_bstr_t const,void *>,std::_Nil>(
        __int64 ***a1,
        __int64 a2,
        __int64 a3,
        unsigned __int16 ***a4)
{
  __int64 **v7; // r11
  __int64 *v8; // r10
  __int64 *v9; // r9
  char v10; // di
  __int64 *v11; // r10
  __int64 *v12; // r10
  __int64 *v14; // rax
  __int64 *i; // rax
  _QWORD *v16; // r9
  __int64 v17; // r10
  __int64 v18; // [rsp+50h] [rbp+8h] BYREF

  v7 = *a1;
  v8 = (*a1)[1];
  v9 = (__int64 *)*a1;
  v10 = 1;
  while ( !*((_BYTE *)v8 + 25) )
  {
    v10 = ValidationXmlHandler::stringless::operator()((__int64)a1, a4, (__int64 **)v8 + 4);
    if ( v10 )
      v8 = (__int64 *)*v11;
    else
      v8 = (__int64 *)v11[2];
  }
  v12 = v9;
  if ( v10 )
  {
    if ( v9 == *v7 )
    {
      *(_QWORD *)a2 = *std::_Tree<std::_Tmap_traits<_bstr_t,void *,ValidationXmlHandler::stringless,std::allocator<std::pair<_bstr_t const,void *>>,0>>::_Insert_at<std::pair<_bstr_t const,void *>,std::_Nil>(
                         a1,
                         &v18,
                         1,
                         v9,
                         (__int64 *)a4);
      *(_BYTE *)(a2 + 8) = 1;
      return a2;
    }
    if ( *((_BYTE *)v9 + 25) )
    {
      v12 = (__int64 *)v9[2];
    }
    else
    {
      v14 = (__int64 *)*v9;
      if ( *(_BYTE *)(*v9 + 25) )
      {
        for ( i = (__int64 *)v9[1]; !*((_BYTE *)i + 25) && v12 == (__int64 *)*i; i = (__int64 *)i[1] )
          v12 = i;
        if ( !*((_BYTE *)v12 + 25) )
          v12 = i;
      }
      else
      {
        do
        {
          v12 = v14;
          v14 = (__int64 *)v14[2];
        }
        while ( !*((_BYTE *)v14 + 25) );
      }
    }
  }
  if ( (unsigned __int8)ValidationXmlHandler::stringless::operator()(
                          (__int64)a1,
                          (unsigned __int16 ***)v12 + 4,
                          (__int64 **)a4) )
  {
    *(_QWORD *)a2 = *std::_Tree<std::_Tmap_traits<_bstr_t,void *,ValidationXmlHandler::stringless,std::allocator<std::pair<_bstr_t const,void *>>,0>>::_Insert_at<std::pair<_bstr_t const,void *>,std::_Nil>(
                       a1,
                       &v18,
                       v10,
                       v16,
                       (__int64 *)a4);
    *(_BYTE *)(a2 + 8) = 1;
  }
  else
  {
    *(_QWORD *)a2 = v17;
    *(_BYTE *)(a2 + 8) = 0;
  }
  return a2;
}
// 180015221: variable 'v11' is possibly undefined
// 180015236: variable 'a1' is possibly undefined
// 180015247: variable 'v9' is possibly undefined
// 18001524F: variable 'v7' is possibly undefined
// 1800152E1: variable 'v16' is possibly undefined
// 180045DA7: variable 'v17' is possibly undefined

//----- (0000000180015308) ----------------------------------------------------
__int64 __fastcall ValidationXmlHandler::stringless::operator()(__int64 a1, unsigned __int16 ***a2, __int64 **a3)
{
  __int64 *v3; // r8
  unsigned int v4; // eax
  __int64 v5; // r8
  unsigned __int16 *v6; // rcx
  __int64 v7; // r8
  unsigned __int16 v8; // dx

  v3 = *a3;
  v4 = 0;
  if ( v3 )
    v5 = *v3;
  else
    v5 = 0LL;
  if ( *a2 )
    v6 = **a2;
  else
    v6 = 0LL;
  v7 = v5 - (_QWORD)v6;
  while ( 1 )
  {
    v8 = *v6;
    if ( *v6 != *(unsigned __int16 *)((char *)v6 + v7) )
      break;
    ++v6;
    if ( !v8 )
      return v4 >> 31;
  }
  v4 = v8 < *(unsigned __int16 *)((char *)v6 + v7) ? -1 : 1;
  return v4 >> 31;
}

//----- (0000000180015354) ----------------------------------------------------
_QWORD *__fastcall std::_Tree<std::_Tmap_traits<_bstr_t,void *,ValidationXmlHandler::stringless,std::allocator<std::pair<_bstr_t const,void *>>,0>>::_Insert_at<std::pair<_bstr_t const,void *>,std::_Nil>(
        _QWORD *a1,
        _QWORD *a2,
        char a3,
        _QWORD *a4,
        __int64 *a5)
{
  _QWORD *v9; // rax
  _QWORD *v10; // r10
  char v11; // r11
  __int64 v12; // rax
  _QWORD *v13; // r9
  __int64 v14; // rcx
  _QWORD *result; // rax
  __int64 v16; // rax
  __int64 *v17; // rdx
  __int64 v18; // rcx

  if ( a1[1] >= 0x555555555555554uLL )
    std::_Xlength_error("map/set<T> too long");
  v9 = std::_Tree_buy<std::pair<_bstr_t const,void *>>::_Buynode<std::pair<_bstr_t const,void *>>(a1, a5);
  ++a1[1];
  v10 = v9;
  v11 = 0;
  v9[1] = a4;
  if ( a4 == (_QWORD *)*a1 )
  {
    *(_QWORD *)(*a1 + 8LL) = v9;
    *(_QWORD *)*a1 = v9;
    *(_QWORD *)(*a1 + 16LL) = v9;
  }
  else if ( a3 )
  {
    *a4 = v9;
    if ( a4 == *(_QWORD **)*a1 )
      *(_QWORD *)*a1 = v9;
  }
  else
  {
    a4[2] = v9;
    if ( a4 == *(_QWORD **)(*a1 + 16LL) )
      *(_QWORD *)(*a1 + 16LL) = v9;
  }
  v12 = v9[1];
  v13 = v10;
  while ( *(_BYTE *)(v12 + 24) == v11 )
  {
    v16 = v13[1];
    v17 = *(__int64 **)(v16 + 8);
    v18 = *v17;
    if ( v16 == *v17 )
    {
      v18 = v17[2];
      if ( *(_BYTE *)(v18 + 24) == v11 )
        goto LABEL_11;
      if ( v13 == *(_QWORD **)(v16 + 16) )
        std::_Tree<std::_Tmap_traits<_bstr_t,void *,ValidationXmlHandler::stringless,std::allocator<std::pair<_bstr_t const,void *>>,0>>::_Lrotate(
          (__int64)a1,
          v13[1]);
      *(_BYTE *)(v13[1] + 24LL) = 1;
      *(_BYTE *)(*(_QWORD *)(v13[1] + 8LL) + 24LL) = v11;
      std::_Tree<std::_Tmap_traits<_bstr_t,void *,ValidationXmlHandler::stringless,std::allocator<std::pair<_bstr_t const,void *>>,0>>::_Rrotate(
        (__int64)a1,
        *(_QWORD **)(v13[1] + 8LL));
    }
    else
    {
      if ( *(_BYTE *)(v18 + 24) == v11 )
      {
LABEL_11:
        *(_BYTE *)(v16 + 24) = 1;
        *(_BYTE *)(v18 + 24) = 1;
        *(_BYTE *)(*(_QWORD *)(v13[1] + 8LL) + 24LL) = v11;
        v13 = *(_QWORD **)(v13[1] + 8LL);
        goto LABEL_12;
      }
      if ( v13 == *(_QWORD **)v16 )
        std::_Tree<std::_Tmap_traits<_bstr_t,void *,ValidationXmlHandler::stringless,std::allocator<std::pair<_bstr_t const,void *>>,0>>::_Rrotate(
          (__int64)a1,
          (_QWORD *)v13[1]);
      *(_BYTE *)(v13[1] + 24LL) = 1;
      *(_BYTE *)(*(_QWORD *)(v13[1] + 8LL) + 24LL) = v11;
      std::_Tree<std::_Tmap_traits<_bstr_t,void *,ValidationXmlHandler::stringless,std::allocator<std::pair<_bstr_t const,void *>>,0>>::_Lrotate(
        (__int64)a1,
        *(_QWORD *)(v13[1] + 8LL));
    }
LABEL_12:
    v12 = v13[1];
  }
  v14 = *(_QWORD *)(*a1 + 8LL);
  result = a2;
  *a2 = v10;
  *(_BYTE *)(v14 + 24) = 1;
  return result;
}
// 1800153CF: variable 'v11' is possibly undefined
// 1800153EA: variable 'v10' is possibly undefined
// 1800153F9: variable 'v13' is possibly undefined

//----- (00000001800154F4) ----------------------------------------------------
_QWORD *__fastcall std::_Tree_buy<std::pair<_bstr_t const,void *>>::_Buynode<std::pair<_bstr_t const,void *>>(
        _QWORD *a1,
        __int64 *a2)
{
  _QWORD *v3; // rcx
  __int64 v4; // rax

  v3 = std::_Tree_buy<std::pair<_bstr_t const,void *>>::_Buynode0(a1);
  *((_WORD *)v3 + 12) = 0;
  v4 = *a2;
  v3[4] = *a2;
  if ( v4 )
    _InterlockedIncrement((volatile signed __int32 *)(v4 + 16));
  v3[5] = a2[1];
  return v3;
}

//----- (0000000180015540) ----------------------------------------------------
_QWORD *__fastcall std::_Tree_buy<std::pair<_bstr_t const,void *>>::_Buynode0(_QWORD *a1)
{
  _QWORD *result; // rax

  result = operator new(0x30uLL);
  if ( !result )
    std::_Xbad_alloc();
  *result = *a1;
  result[1] = *a1;
  result[2] = *a1;
  return result;
}

//----- (0000000180015594) ----------------------------------------------------
CBstrWriter::BufferBlock *__fastcall CBstrWriter::BufferBlock::BufferBlock(CBstrWriter::BufferBlock *this)
{
  _WORD *v2; // rax
  void **pExceptionObject; // [rsp+20h] [rbp-48h] BYREF
  char v5; // [rsp+28h] [rbp-40h]
  const unsigned __int16 *v6; // [rsp+30h] [rbp-38h]
  __int64 v7; // [rsp+38h] [rbp-30h]
  __int64 v8; // [rsp+40h] [rbp-28h]
  int v9; // [rsp+48h] [rbp-20h]
  int v10; // [rsp+4Ch] [rbp-1Ch]
  int v11; // [rsp+50h] [rbp-18h]

  *(_QWORD *)this = 0LL;
  *((_QWORD *)this + 1) = 0LL;
  *((_QWORD *)this + 2) = 0LL;
  v2 = operator new(0x802uLL);
  *(_QWORD *)this = v2;
  if ( !v2 )
  {
    v10 = -1;
    v11 = -1;
    v6 = &word_18007630E;
    v5 = 0;
    pExceptionObject = &wmi::OutOfMemoryException::`vftable';
    v7 = 0LL;
    v8 = 0LL;
    v9 = 14;
    CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI4_AVOutOfMemoryException_wmi__);
  }
  *v2 = 0;
  return this;
}
// 180073740: using guessed type void *wmi::OutOfMemoryException::`vftable';

//----- (00000001800155DC) ----------------------------------------------------
unsigned __int16 *__fastcall CBstrWriter::GetCopy(CBstrWriter *this)
{
  UINT v1; // edx
  unsigned __int16 *v3; // rbx
  unsigned __int16 *v4; // rax
  __int64 v5; // rsi
  __int64 v6; // rdi
  unsigned __int16 *v7; // r14
  __int64 v8; // rax
  unsigned __int16 *v9; // rdi
  unsigned __int16 *v11; // [rsp+30h] [rbp+8h] BYREF

  v1 = *((_DWORD *)this + 4);
  v3 = 0LL;
  v11 = 0LL;
  v4 = SysAllocStringLen(0LL, v1);
  if ( v4 )
  {
    ATL::CComBSTR::Attach(&v11, v4);
    v3 = v11;
    v5 = *((_QWORD *)this + 2) + 1LL;
    v6 = *((_QWORD *)this + 3);
    v7 = v11;
    while ( v6 )
    {
      if ( (int)StringCchCopyNW((char *)v7, v5, *(char **)v6, *(_QWORD *)(v6 + 8)) < 0 )
        goto LABEL_8;
      v8 = *(_QWORD *)(v6 + 8);
      v6 = *(_QWORD *)(v6 + 16);
      v5 -= v8;
      v7 += v8;
    }
    v9 = v3;
    v3 = 0LL;
  }
  else
  {
LABEL_8:
    v9 = 0LL;
  }
  SysFreeString(v3);
  return v9;
}

//----- (00000001800156A0) ----------------------------------------------------
__int64 __fastcall _Write__QIStream__CBstrWriter__EEAAJPEBXKPEAK_Z(__int64 a1, char *a2, unsigned int a3, _DWORD *a4)
{
  unsigned int v5; // edi
  char *v6; // r14
  CBstrWriter::BufferBlock *v8; // r8
  CBstrWriter::BufferBlock *v9; // rdx
  __int64 v10; // rcx
  unsigned __int64 v11; // r15
  CBstrWriter::BufferBlock **v13; // r15
  CBstrWriter::BufferBlock *v14; // rax
  void **pExceptionObject; // [rsp+28h] [rbp-50h] BYREF
  char v16; // [rsp+30h] [rbp-48h]
  const unsigned __int16 *v17; // [rsp+38h] [rbp-40h]
  __int64 v18; // [rsp+40h] [rbp-38h]
  int v19; // [rsp+48h] [rbp-30h]
  int v20; // [rsp+4Ch] [rbp-2Ch]
  int v21; // [rsp+50h] [rbp-28h]
  int v22; // [rsp+54h] [rbp-24h]
  int v23; // [rsp+58h] [rbp-20h]

  v5 = a3;
  v6 = a2;
  if ( a4 )
    *a4 = 0;
  if ( a3 >= 2 && *(_WORD *)a2 == 0xFEFF )
  {
    v6 = a2 + 2;
    v5 = a3 - 2;
    if ( a4 )
      *a4 += 2;
  }
  for ( ; v5; *(_QWORD *)(a1 + 16) += v11 )
  {
    v8 = *(CBstrWriter::BufferBlock **)(a1 + 32);
    v9 = v8;
    if ( *((_QWORD *)v8 + 1) == 1024LL )
    {
      v13 = (CBstrWriter::BufferBlock **)((char *)v8 + 16);
      v8 = (CBstrWriter::BufferBlock *)*((_QWORD *)v8 + 2);
      if ( !v8 )
      {
        v14 = (CBstrWriter::BufferBlock *)operator new(0x18uLL);
        if ( v14 )
          v8 = CBstrWriter::BufferBlock::BufferBlock(v14);
        else
          v8 = 0LL;
        *v13 = v8;
      }
      v9 = v8;
      if ( !v8 )
      {
        v16 = 0;
        v17 = &word_18007630E;
        v18 = 0LL;
        v19 = 0;
        v20 = 0;
        v21 = 14;
        v22 = -1;
        v23 = -1;
        pExceptionObject = &wmi::OutOfMemoryException::`vftable';
        CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI4_AVOutOfMemoryException_wmi__);
      }
      *(_QWORD *)(a1 + 32) = v8;
    }
    v10 = *((_QWORD *)v8 + 1);
    v11 = (unsigned __int64)v5 >> 1;
    if ( v11 >= 1024 - v10 )
      v11 = 1024 - v10;
    else
      v8 = v9;
    StringCchCopyNW((char *)(*(_QWORD *)v8 + 2 * v10), v11 + 1, v6, v11);
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8LL) += v11;
    v6 += 2 * v11;
    v5 -= 2 * v11;
    if ( a4 )
      *a4 += 2 * v11;
  }
  return 0LL;
}
// 180073740: using guessed type void *wmi::OutOfMemoryException::`vftable';

//----- (00000001800157D0) ----------------------------------------------------
__int64 __fastcall StringCchCopyNW(char *a1, __int64 a2, char *a3, unsigned __int64 a4)
{
  unsigned int v4; // r10d
  __int64 v5; // r9
  signed __int64 v6; // r8
  unsigned __int16 v7; // ax
  unsigned __int16 *v8; // rax

  v4 = 0;
  if ( (unsigned __int64)(a2 - 1) > 0x7FFFFFFE )
    v4 = -2147024809;
  if ( (v4 & 0x80000000) != 0 )
  {
    if ( !a2 )
      return v4;
LABEL_16:
    *(_WORD *)a1 = 0;
    return v4;
  }
  if ( a4 > 0x7FFFFFFE )
  {
    v4 = -2147024809;
    goto LABEL_16;
  }
  if ( a2 )
  {
    v5 = a4 - a2;
    v6 = a3 - a1;
    do
    {
      if ( !(v5 + a2) )
        break;
      v7 = *(_WORD *)&a1[v6];
      if ( !v7 )
        break;
      *(_WORD *)a1 = v7;
      a1 += 2;
      --a2;
    }
    while ( a2 );
  }
  v8 = (unsigned __int16 *)(a1 - 2);
  if ( a2 )
    v8 = (unsigned __int16 *)a1;
  v4 = a2 == 0 ? 0x8007007A : 0;
  *v8 = 0;
  return v4;
}

//----- (0000000180015864) ----------------------------------------------------
__int64 __fastcall std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::clear(
        _QWORD *a1)
{
  __int64 result; // rax

  std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::_Erase(
    (__int64)a1,
    *(__int64 **)(*a1 + 8LL));
  *(_QWORD *)(*a1 + 8LL) = *a1;
  *(_QWORD *)*a1 = *a1;
  result = *a1;
  *(_QWORD *)(*a1 + 16LL) = *a1;
  a1[1] = 0LL;
  return result;
}

//----- (00000001800158A0) ----------------------------------------------------
void __fastcall std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::_Erase(
        __int64 a1,
        __int64 *a2)
{
  __int64 *v2; // rdi
  __int64 *i; // rsi

  v2 = a2;
  for ( i = a2; !*((_BYTE *)i + 25); v2 = i )
  {
    std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::_Erase(
      a1,
      i[2]);
    i = (__int64 *)*i;
    _bstr_t::_Free((_bstr_t *)(v2 + 5));
    _bstr_t::_Free((_bstr_t *)(v2 + 4));
    operator delete(v2);
  }
}

//----- (0000000180015914) ----------------------------------------------------
struct _FILETIME *__fastcall Scheduling::JobSchedule::JobSchedule(struct _FILETIME *this)
{
  struct _FILETIME *result; // rax

  LOBYTE(this->dwLowDateTime) = 0;
  GetSystemTimeAsFileTime(this + 1);
  LOBYTE(this[2].dwLowDateTime) = 0;
  GetSystemTimeAsFileTime(this + 3);
  LOBYTE(this[4].dwLowDateTime) = 0;
  GetSystemTimeAsFileTime(this + 5);
  *(_OWORD *)&this[1].dwLowDateTime = 0LL;
  *(_OWORD *)&this[3].dwLowDateTime = 0LL;
  this[5] = 0LL;
  this[8] = 0LL;
  this[7].dwHighDateTime = 0;
  this[6].dwLowDateTime = 0;
  this[6].dwHighDateTime = 0;
  this[7].dwLowDateTime = 0;
  this[10].dwLowDateTime = 0;
  result = this;
  LOWORD(this[9].dwLowDateTime) = 256;
  this[9].dwHighDateTime = 1;
  return result;
}

//----- (00000001800159A4) ----------------------------------------------------
__int64 __fastcall TaskAccessCheck(HANDLE ClientToken, const unsigned __int16 *a2, DWORD DesiredAccess)
{
  HKEY *v6; // rbx
  int v7; // ebx
  PSECURITY_DESCRIPTOR pSecurityDescriptor[4]; // [rsp+28h] [rbp-20h] BYREF

  v6 = (HKEY *)JobStore::m_pCommonStore;
  JobSecurity::JobSecurity((JobSecurity *)pSecurityDescriptor);
  v7 = JobStore::RegJobSecurityQuery(v6, a2, pSecurityDescriptor);
  if ( v7 >= 0 )
  {
    v7 = JobAccessCheck(ClientToken, pSecurityDescriptor[0], DesiredAccess);
    if ( v7 < 0 )
      v7 = -2147024891;
  }
  tsched::AutoLocalPtr<unsigned short>::~AutoLocalPtr<unsigned short>(pSecurityDescriptor);
  return (unsigned int)v7;
}

//----- (0000000180015A38) ----------------------------------------------------
JobSecurity *__fastcall JobSecurity::JobSecurity(JobSecurity *this)
{
  *(_QWORD *)this = 0LL;
  tsched::AutoLocalPtr<_SECURITY_DESCRIPTOR>::Attach((void **)this, 0LL);
  *((_DWORD *)this + 2) = 0;
  return this;
}

//----- (0000000180015A60) ----------------------------------------------------
void __fastcall JobBucket::InitOptionalSettings(JobBucket *this)
{
  char *v2; // rax

  if ( !*((_QWORD *)this + 26) )
  {
    v2 = (char *)operator new(0x58uLL);
    if ( v2 )
    {
      *(_DWORD *)v2 = 0;
      *((_DWORD *)v2 + 1) = -1;
      *((_DWORD *)v2 + 3) = -1;
      *((_DWORD *)v2 + 2) = 259200;
      *((_QWORD *)v2 + 2) = 7LL;
      *((_DWORD *)v2 + 6) = 0;
      *(_OWORD *)(v2 + 28) = 0LL;
      *((_QWORD *)v2 + 6) = 0LL;
      *((_QWORD *)v2 + 7) = 0LL;
      *((_QWORD *)v2 + 8) = 0LL;
      *((_QWORD *)v2 + 9) = 0LL;
      *((_QWORD *)v2 + 10) = 0LL;
    }
    else
    {
      v2 = 0LL;
    }
    *((_QWORD *)this + 26) = v2;
  }
}

//----- (0000000180015AE0) ----------------------------------------------------
__int64 __fastcall JobAccessCheck(HANDLE ClientToken, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD DesiredAccess)
{
  DWORD v3; // ebx
  WINBOOL pfResult; // [rsp+40h] [rbp-9h] BYREF
  DWORD GrantedAccess; // [rsp+44h] [rbp-5h] BYREF
  DWORD PrivilegeSetLength[2]; // [rsp+48h] [rbp-1h] BYREF
  __int64 v10; // [rsp+50h] [rbp+7h]
  struct _PRIVILEGE_SET RequiredPrivileges; // [rsp+58h] [rbp+Fh] BYREF
  struct _GENERIC_MAPPING GenericMapping; // [rsp+70h] [rbp+27h] BYREF

  pfResult = 0;
  v3 = DesiredAccess;
  RequiredPrivileges.Privilege[0].Luid = 0LL;
  if ( !ClientToken || !pSecurityDescriptor || !DesiredAccess )
    return 2147942405LL;
  RequiredPrivileges.Privilege[0].Attributes = 2;
  RequiredPrivileges.Control = 1;
  RequiredPrivileges.PrivilegeCount = 1;
  if ( (DesiredAccess & 1) != 0 )
  {
    *(_QWORD *)PrivilegeSetLength = 17LL;
    RequiredPrivileges.Privilege[0].Luid = (LUID)17LL;
    if ( !PrivilegeCheck(ClientToken, &RequiredPrivileges, &pfResult) )
      return 2147942405LL;
    if ( pfResult )
      v3 &= ~1u;
  }
  if ( (v3 & 0xD0006) != 0 )
  {
    v10 = 18LL;
    RequiredPrivileges.Privilege[0].Luid = (LUID)18LL;
    if ( !PrivilegeCheck(ClientToken, &RequiredPrivileges, &pfResult) )
      return 2147942405LL;
    if ( pfResult )
      v3 &= 0xFFF2FFF9;
  }
  if ( !v3 )
    return 0LL;
  GenericMapping.GenericRead = 1179785;
  GrantedAccess = 0;
  GenericMapping.GenericWrite = 1179926;
  GenericMapping.GenericExecute = 1179808;
  GenericMapping.GenericAll = 2032127;
  PrivilegeSetLength[0] = 20;
  memset(&RequiredPrivileges, 0, sizeof(RequiredPrivileges));
  if ( AccessCheck(
         pSecurityDescriptor,
         ClientToken,
         v3,
         &GenericMapping,
         &RequiredPrivileges,
         PrivilegeSetLength,
         &GrantedAccess,
         &pfResult) )
  {
    if ( pfResult && (GrantedAccess & v3) == v3 )
      return 0LL;
  }
  return 2147942405LL;
}

//----- (0000000180015C88) ----------------------------------------------------
void __fastcall std::vector<_bstr_t>::clear(_bstr_t **a1)
{
  _bstr_t *v1; // rsi
  _bstr_t *v3; // rbx

  v1 = a1[1];
  v3 = *a1;
  if ( *a1 != v1 )
  {
    do
    {
      _bstr_t::_Free(v3);
      v3 = (_bstr_t *)((char *)v3 + 8);
    }
    while ( v3 != v1 );
    v3 = *a1;
  }
  a1[1] = v3;
}

//----- (0000000180015CC8) ----------------------------------------------------
void __fastcall Triggers::TimeTrigger::~TimeTrigger(Triggers::TimeTrigger *this)
{
  *(_QWORD *)this = &Triggers::TimeTrigger::`vftable';
  _bstr_t::_Free((Triggers::TimeTrigger *)((char *)this + 96));
  *(_QWORD *)this = &Triggers::Trigger::`vftable';
}
// 180070988: using guessed type void *Triggers::Trigger::`vftable';
// 180070A70: using guessed type void *Triggers::TimeTrigger::`vftable';

//----- (0000000180015CFC) ----------------------------------------------------
Triggers::GenericTrigger *__fastcall Triggers::GenericTrigger::GenericTrigger(Triggers::GenericTrigger *this)
{
  __int128 v3; // [rsp+28h] [rbp-20h]

  *(_QWORD *)this = &Triggers::GenericTrigger::`vftable';
  Triggers::GenericTrigger::GenericData::GenericData((struct _FILETIME *)this + 1);
  *((_QWORD *)this + 10) = 0LL;
  LOBYTE(v3) = 0;
  *(_OWORD *)((char *)this + 8) = (unsigned __int64)v3;
  LOBYTE(v3) = 0;
  *((_QWORD *)&v3 + 1) = -1LL;
  *(_OWORD *)((char *)this + 24) = v3;
  *((_DWORD *)this + 10) = 0;
  *((_DWORD *)this + 11) = -1;
  *((_BYTE *)this + 64) = 1;
  return this;
}
// 180015D3E: variable 'v3' is possibly undefined
// 180070AF8: using guessed type void *Triggers::GenericTrigger::`vftable';

//----- (0000000180015D78) ----------------------------------------------------
struct _FILETIME *__fastcall Triggers::GenericTrigger::GenericData::GenericData(struct _FILETIME *this)
{
  struct _FILETIME *result; // rax

  LOBYTE(this->dwLowDateTime) = 0;
  GetSystemTimeAsFileTime(this + 1);
  LOBYTE(this[2].dwLowDateTime) = 0;
  GetSystemTimeAsFileTime(this + 3);
  this[5].dwLowDateTime = 0;
  result = this;
  this[5].dwHighDateTime = 0;
  this[6].dwLowDateTime = 0;
  LOBYTE(this[6].dwHighDateTime) = 0;
  return result;
}

//----- (0000000180015DC8) ----------------------------------------------------
__int64 __fastcall User::StreamIn(User::UserEntry **this, WCHAR **a2, unsigned __int8 **a3, unsigned __int8 **a4)
{
  int VarSize; // ebx
  unsigned __int64 v6; // r9
  unsigned __int64 *v7; // r10
  PSID v8; // rdi
  enum _SID_NAME_USE v9; // r15d
  unsigned __int64 v10; // rcx
  User::UserEntry **Alias; // rax
  _bstr_t *v12; // rcx
  User::UserEntry **v13; // rax
  const unsigned __int16 *v14; // rbx
  __int64 v15; // rcx
  __int64 v16; // r8
  __int64 v17; // r9
  User::UserEntry **v18; // rax
  unsigned __int8 **v20[3]; // [rsp+38h] [rbp-18h] BYREF
  WCHAR **v21; // [rsp+88h] [rbp+38h] BYREF
  const unsigned __int16 **v22; // [rsp+90h] [rbp+40h] BYREF
  PSID pSid; // [rsp+98h] [rbp+48h] BYREF

  v21 = a2;
  v20[0] = a3;
  v20[1] = a4;
  LOBYTE(v21) = 1;
  VarSize = DataAligner::ReadFixedSize<bool>((__int64)v20, &v21);
  if ( VarSize >= 0 )
  {
    if ( (_BYTE)v21 )
    {
      wmi::AutoRef<User::UserEntry>::operator=(this, 0LL);
      return 0;
    }
    LOBYTE(v21) = 0;
    VarSize = DataAligner::ReadFixedSize<bool>((__int64)v20, &v21);
    if ( VarSize < 0 )
      return (unsigned int)VarSize;
    v8 = 0LL;
    pSid = 0LL;
    v9 = SidTypeUnknown;
    if ( !(_BYTE)v21 )
    {
      v10 = *v7 + 8;
      if ( v10 > v6 )
        return (unsigned int)-2147418113;
      v9 = *(_DWORD *)*v7;
      *v7 = v10;
      VarSize = DataAligner::ReadVarSize(v20, (unsigned __int8 **)&pSid, (unsigned int *)&v22);
      if ( VarSize < 0 )
        return (unsigned int)VarSize;
      v8 = pSid;
      if ( !pSid || !IsValidSid(pSid) )
        return (unsigned int)-2147418113;
    }
    pSid = 0LL;
    VarSize = DataAligner::ReadVarSize(v20, (unsigned __int8 **)&pSid, (unsigned int *)&v22);
    if ( VarSize < 0 )
      return (unsigned int)VarSize;
    if ( (_BYTE)v21 )
    {
      _bstr_t::_bstr_t((_bstr_t *)&v21, (const unsigned __int16 *)pSid);
      Alias = User::CreateAlias((User::UserEntry **)&v22, (const struct _bstr_t *)&v21);
      wmi::AutoRef<User::UserEntry>::operator=(this, *Alias);
      wmi::AutoRef<User::UserEntry>::Release(&v22);
      v12 = (_bstr_t *)&v21;
    }
    else
    {
      v13 = User::LookupUser((User::UserEntry **)&v21, v8);
      wmi::AutoRef<User::UserEntry>::operator=(this, *v13);
      wmi::AutoRef<User::UserEntry>::Release(&v21);
      if ( *this )
        return 0;
      v22 = 0LL;
      v14 = (const unsigned __int16 *)pSid;
      if ( !pSid )
      {
        if ( (int)User::FromSidToDomainAccount((struct _bstr_t *)&v22, v8) >= 0 )
        {
          if ( v22 )
            v14 = *v22;
          else
            v14 = 0LL;
        }
        else if ( (unsigned int)dword_1800AFF68 > 4 && tlgKeywordOn((__int64)&dword_1800AFF68, 0LL) )
        {
          pSid = v8;
          LODWORD(v21) = v17;
          _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapperByVal<4>,_tlgWrapSid<_SID>>(
            v15,
            byte_18007EC69,
            v16,
            v17,
            (__int64)&v21,
            (__int64)&pSid);
        }
      }
      _bstr_t::_bstr_t((_bstr_t *)&v21, v14);
      v18 = (User::UserEntry **)User::CreateUser((User::UserEntry *)&pSid, &v21, v9, v8, 1);
      wmi::AutoRef<User::UserEntry>::operator=(this, *v18);
      wmi::AutoRef<User::UserEntry>::Release(&pSid);
      _bstr_t::~_bstr_t((_bstr_t *)&v21);
      VarSize = 0;
      v12 = (_bstr_t *)&v22;
    }
    _bstr_t::~_bstr_t(v12);
  }
  return (unsigned int)VarSize;
}
// 180015E4D: variable 'v7' is possibly undefined
// 180015E57: variable 'v6' is possibly undefined
// 180015F65: variable 'v17' is possibly undefined
// 180015F82: variable 'v15' is possibly undefined
// 180015F82: variable 'v16' is possibly undefined
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);
// 18007EC69: using guessed type unsigned __int8 byte_18007EC69[73];

//----- (0000000180015FFC) ----------------------------------------------------
__int64 __fastcall DataAligner::ReadFixedSize<bool>(__int64 a1, _BYTE *a2)
{
  _BYTE *v2; // r8

  v2 = **(_BYTE ***)a1;
  if ( (unsigned __int64)(v2 + 8) > *(_QWORD *)(a1 + 8) )
    return 2147549183LL;
  *a2 = *v2;
  **(_QWORD **)a1 += 8LL;
  return 0LL;
}

//----- (000000018001602C) ----------------------------------------------------
__int64 __fastcall JobBucket::StreamIn(
        JobBucket *this,
        unsigned __int64 a2,
        unsigned __int8 **a3,
        unsigned __int8 **a4)
{
  __int64 result; // rax
  unsigned int v9; // ebx
  WCHAR **v10; // rdx
  _bstr_t::Data_t **v11; // rcx
  int v12; // eax
  unsigned __int8 *v13; // rdi
  __int128 v14; // xmm0
  __int64 v15; // rcx
  __int64 v16; // rax
  unsigned __int8 **v17[3]; // [rsp+28h] [rbp-18h] BYREF
  __int64 v18; // [rsp+70h] [rbp+30h] BYREF
  unsigned __int8 *v19; // [rsp+80h] [rbp+40h] BYREF
  unsigned __int8 *v20; // [rsp+88h] [rbp+48h] BYREF

  v17[0] = a3;
  v17[1] = a4;
  result = DataAligner::ReadFixedSize((DataAligner *)v17, (_DWORD *)this + 4);
  v9 = 0;
  if ( (int)result >= 0 )
  {
    result = DataAligner::ReadFixedSize((DataAligner *)v17, (_DWORD *)this + 6);
    if ( (int)result >= 0 )
    {
      if ( a2 >= 0x16 )
      {
        LODWORD(v18) = 0;
        v19 = 0LL;
        result = DataAligner::ReadVarSize(v17, &v19, (unsigned int *)&v18);
        if ( (int)result < 0 )
          return result;
        v11 = (_bstr_t::Data_t **)((char *)this + 72);
        if ( (unsigned int)v18 >= 2 && v19 )
        {
          _bstr_t::operator=(v11, (const OLECHAR *)v19);
        }
        else
        {
          _bstr_t::operator=((__int64 *)v11, &v18);
          _bstr_t::_Free((_bstr_t *)&v18);
        }
      }
      if ( a2 >= 0x17 )
      {
        LODWORD(v18) = 0;
        v19 = 0LL;
        result = DataAligner::ReadVarSize(v17, &v19, (unsigned int *)&v18);
        if ( (int)result < 0 )
          return result;
        if ( (unsigned int)v18 >= 2 )
        {
          JobBucket::SetDisplayName(this, (const unsigned __int16 *)v19);
        }
        else
        {
          v18 = 0LL;
          _bstr_t::operator=((__int64 *)this + 10, &v18);
          _bstr_t::_Free((_bstr_t *)&v18);
        }
      }
      v19 = 0LL;
      v12 = User::StreamIn((User::UserEntry **)&v19, v10, a3, a4);
      if ( v12 < 0
        || (wmi::AutoRef<User::UserEntry>::operator=((User::UserEntry **)this + 8, (User::UserEntry *)v19),
            v20 = 0LL,
            LODWORD(v18) = 0,
            v12 = DataAligner::ReadVarSize(v17, &v20, (unsigned int *)&v18),
            v12 < 0) )
      {
        v9 = v12;
      }
      else
      {
        v13 = v20;
        if ( v20 )
        {
          JobBucket::InitOptionalSettings(this);
          v14 = *(_OWORD *)v13;
          if ( (_DWORD)v18 == 44 )
          {
            v15 = *((_QWORD *)this + 26);
            *(_OWORD *)v15 = v14;
            *(_OWORD *)(v15 + 16) = *((_OWORD *)v13 + 1);
            *(_QWORD *)(v15 + 32) = *((_QWORD *)v13 + 4);
            *(_DWORD *)(v15 + 40) = *((_DWORD *)v13 + 10);
          }
          else
          {
            v16 = *((_QWORD *)this + 26);
            *(_OWORD *)v16 = v14;
            *(_OWORD *)(v16 + 16) = *((_OWORD *)v13 + 1);
            *(_OWORD *)(v16 + 32) = *((_OWORD *)v13 + 2);
            if ( (_DWORD)v18 == 56 )
            {
              *(_QWORD *)(v16 + 48) = *((_QWORD *)v13 + 6);
            }
            else
            {
              *(_OWORD *)(v16 + 48) = *((_OWORD *)v13 + 3);
              *(_OWORD *)(v16 + 64) = *((_OWORD *)v13 + 4);
              *(_QWORD *)(v16 + 80) = *((_QWORD *)v13 + 10);
            }
          }
        }
      }
      wmi::AutoRef<User::UserEntry>::Release(&v19);
      return v9;
    }
  }
  return result;
}
// 180045EA6: ignored the value written to the shadow area of the succeeding call
// 180016126: variable 'v10' is possibly undefined
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);

//----- (0000000180016204) ----------------------------------------------------
__int64 __fastcall DataAligner::ReadVarSize(unsigned __int8 ***this, unsigned __int8 **a2, unsigned int *a3)
{
  unsigned __int8 **v4; // rax
  unsigned __int8 *v5; // rcx
  unsigned int v6; // r10d
  __int64 v7; // r11

  if ( !a2 )
    return 2147549183LL;
  if ( !a3 )
    return 2147549183LL;
  v4 = *this;
  v5 = **this;
  if ( v5 + 8 > (unsigned __int8 *)this[1] )
    return 2147549183LL;
  v6 = *(_DWORD *)v5;
  *v4 = v5 + 8;
  v7 = (v6 + 7) & 0xFFFFFFF8;
  if ( &(**this)[v7] > (unsigned __int8 *)this[1] )
    return 2147549183LL;
  if ( v6 )
  {
    *a3 = v6;
    *a2 = **this;
    **this += v7;
  }
  else
  {
    *a3 = 0;
    *a2 = 0LL;
  }
  return 0LL;
}

//----- (0000000180016274) ----------------------------------------------------
__int64 __fastcall DataAligner::ReadFixedSize(DataAligner *this, _DWORD *a2)
{
  _DWORD *v2; // r8

  if ( !a2 )
    return 2147549183LL;
  v2 = **(_DWORD ***)this;
  if ( (unsigned __int64)(v2 + 2) > *((_QWORD *)this + 1) )
    return 2147549183LL;
  *a2 = *v2;
  **(_QWORD **)this += 8LL;
  return 0LL;
}

//----- (00000001800162A8) ----------------------------------------------------
User::UserEntry **__fastcall User::LookupUser(User::UserEntry **a1, void *a2)
{
  struct _RTL_CRITICAL_SECTION *v4; // rdi
  User::UserEntry ***v5; // r14
  User::UserEntry **v6; // rbx
  void *v7; // rcx

  *a1 = 0LL;
  if ( a2 )
  {
    v4 = User::s_cs;
    EnterCriticalSection(User::s_cs);
    v5 = (User::UserEntry ***)User::s_userTable;
    v6 = *(User::UserEntry ***)User::s_userTable;
    if ( *(_QWORD *)User::s_userTable != *((_QWORD *)User::s_userTable + 1) )
    {
      while ( v6 != v5[1] )
      {
        v7 = (void *)*((_QWORD *)*v6 + 4);
        if ( v7 && EqualSid(v7, a2) )
        {
          wmi::AutoRef<User::UserEntry>::operator=(a1, *v6);
          break;
        }
        ++v6;
      }
    }
    LeaveCriticalSection(v4);
  }
  return a1;
}

//----- (0000000180016360) ----------------------------------------------------
__int64 __fastcall Actions::ActionCollection::ReadData(
        Actions::ActionCollection *this,
        unsigned __int8 *a2,
        int a3,
        unsigned __int16 *a4)
{
  int v5; // edi
  unsigned __int8 *v6; // r14
  int v7; // esi
  _WORD *v8; // r10
  unsigned __int16 v9; // r12
  __int64 result; // rax
  Task *v11; // rax
  Task *v12; // rsi
  __int64 v13; // rcx
  __int64 *v14; // rcx
  __int64 v15; // rcx
  __int64 v16; // r15
  _QWORD *v17; // rdx
  __int64 v18; // rax
  ExeTask *v19; // rax
  ExeTask *v20; // rax
  Task *v21; // rax
  Task *v22; // rsi
  _QWORD *v23; // rcx
  EmailTask *v24; // rax
  EmailTask *v25; // rax
  EmailTask *v26; // [rsp+48h] [rbp-140h]
  char v27[16]; // [rsp+50h] [rbp-138h] BYREF
  EmailTask *v28; // [rsp+60h] [rbp-128h]
  __int64 v29; // [rsp+68h] [rbp-120h] BYREF
  __int64 v30[3]; // [rsp+70h] [rbp-118h] BYREF
  int v31; // [rsp+E8h] [rbp-A0h]
  ExeTask *v32; // [rsp+100h] [rbp-88h] BYREF
  __int64 v33; // [rsp+108h] [rbp-80h] BYREF
  unsigned __int8 *v34; // [rsp+110h] [rbp-78h] BYREF
  Task *v35; // [rsp+118h] [rbp-70h] BYREF
  __int64 v36; // [rsp+130h] [rbp-58h] BYREF
  __int64 v37[3]; // [rsp+138h] [rbp-50h] BYREF
  char v38; // [rsp+150h] [rbp-38h]
  __int64 v39; // [rsp+158h] [rbp-30h]
  int v40; // [rsp+1A0h] [rbp+18h] BYREF

  v39 = -2LL;
  v5 = 0;
  v40 = 0;
  v34 = a2;
  v6 = &a2[a3];
  v37[1] = (__int64)v6;
  v7 = JobStore::StreamInUSHORT((unsigned __int16 *)&v40, (unsigned __int16 **)&v34, v6);
  if ( v7 < 0 )
    return (unsigned int)v7;
  v9 = v40;
  if ( (unsigned __int16)(v40 - 1) > 2u )
    return 2147750675LL;
  if ( v8 )
    *v8 = v40;
  if ( v9 < 2u
    || (result = JobStore::StreamInBSTR((_bstr_t::Data_t **)this + 2, &v34, v6), v7 = result, (int)result >= 0) )
  {
    while ( 1 )
    {
      if ( v7 < 0 || v34 >= v6 )
      {
        if ( v7 < 0 )
          return (unsigned int)v7;
        result = 2147549183LL;
        if ( v34 == v6 )
          return (unsigned int)v7;
        return result;
      }
      LOWORD(v40) = 0;
      v33 = 0LL;
      v32 = 0LL;
      v37[2] = (__int64)&v32;
      v38 = 1;
      v7 = JobStore::StreamInUSHORT((unsigned __int16 *)&v40, (unsigned __int16 **)&v34, v6);
      if ( v7 < 0 )
        goto LABEL_50;
      switch ( (unsigned __int16)v40 )
      {
        case 0x7777u:
          v11 = (Task *)operator new(0x50uLL);
          v12 = v11;
          v35 = v11;
          if ( v11 )
          {
            v36 = 0LL;
            v5 |= 2u;
            v40 = v5;
            Task::Task(v11, (const struct _bstr_t *)&v33, (const struct _bstr_t *)&v36);
            *(_QWORD *)v13 = &ComHandlerBase::`vftable';
            *(_OWORD *)(v13 + 40) = 0LL;
            *(_QWORD *)(v13 + 56) = 0LL;
            _bstr_t::_bstr_t((_bstr_t *)(v13 + 64), &ChannelPath);
            _bstr_t::_bstr_t((Task *)((char *)v12 + 72), 0LL);
            *(_QWORD *)v12 = &ComHandlerTask::`vftable';
          }
          else
          {
            v12 = 0LL;
          }
          v32 = v12;
          if ( (v5 & 2) != 0 )
          {
            v5 &= ~2u;
            v14 = &v36;
LABEL_15:
            _bstr_t::_Free((_bstr_t *)v14);
          }
          break;
        case 0x6666u:
          v19 = (ExeTask *)operator new(0x60uLL);
          v35 = v19;
          if ( v19 )
          {
            v37[0] = 0LL;
            v5 |= 1u;
            v40 = v5;
            v20 = ExeTask::ExeTask(v19, (const struct _bstr_t *)&v33, (const struct _bstr_t *)v37);
          }
          else
          {
            v20 = 0LL;
          }
          v32 = v20;
          if ( (v5 & 1) != 0 )
          {
            v5 &= ~1u;
            v14 = v37;
            goto LABEL_15;
          }
          break;
        case 0x8888u:
          v24 = (EmailTask *)operator new(0xC0uLL);
          v28 = v24;
          if ( v24 )
          {
            v30[0] = 0LL;
            v5 |= 4u;
            v31 = v5;
            v25 = EmailTask::EmailTask(v24, (const struct _bstr_t *)v27, (const struct _bstr_t *)v30);
          }
          else
          {
            v25 = 0LL;
          }
          v26 = v25;
          if ( (v5 & 4) != 0 )
          {
            v5 &= ~4u;
            v14 = v30;
            goto LABEL_15;
          }
          break;
        case 0x9999u:
          v21 = (Task *)operator new(0x58uLL);
          v22 = v21;
          v28 = v21;
          if ( v21 )
          {
            v29 = 0LL;
            v5 |= 8u;
            v31 = v5;
            Task::Task(v21, (const struct _bstr_t *)v27, (const struct _bstr_t *)&v29);
            *v23 = &MessageBoxTask::`vftable';
            _bstr_t::_bstr_t((_bstr_t *)(v23 + 5), 0LL);
            _bstr_t::_bstr_t((Task *)((char *)v22 + 48), 0LL);
            *((_BYTE *)v22 + 56) = 0;
            *((_QWORD *)v22 + 8) = 0LL;
          }
          else
          {
            v22 = 0LL;
          }
          v26 = v22;
          if ( (v5 & 8) != 0 )
          {
            v5 &= ~8u;
            v14 = &v29;
            goto LABEL_15;
          }
          break;
        default:
          _bstr_t::_Free((_bstr_t *)v27);
          return 2147549183LL;
      }
      if ( !v32 )
      {
        _bstr_t::_Free((_bstr_t *)v27);
        return 2147942414LL;
      }
      v7 = (*(__int64 (__fastcall **)(ExeTask *, _QWORD, unsigned __int8 **, unsigned __int8 *))(*(_QWORD *)v32 + 48LL))(
             v32,
             v9,
             &v34,
             v6);
      if ( v7 < 0 )
      {
        if ( v26 )
          (**(void (__fastcall ***)(EmailTask *, __int64))v26)(v26, 1LL);
LABEL_50:
        _bstr_t::_Free((_bstr_t *)v27);
        return (unsigned int)v7;
      }
      v38 = 0;
      v35 = v32;
      v16 = *(_QWORD *)this;
      v17 = std::_List_buy<Task *>::_Buynode<Task * const &>(
              v15,
              *(_QWORD **)this,
              *(_QWORD **)(*(_QWORD *)this + 8LL),
              &v35);
      v18 = *((_QWORD *)this + 1);
      if ( v18 == 0xAAAAAAAAAAAAAA9LL )
        std::_Xlength_error("list<T> too long");
      *((_QWORD *)this + 1) = v18 + 1;
      *(_QWORD *)(v16 + 8) = v17;
      *(_QWORD *)v17[1] = v17;
      _bstr_t::_Free((_bstr_t *)&v33);
    }
  }
  return result;
}
// 180016360: could not find valid save-restore pair for rbp
// 1800163E4: variable 'v8' is possibly undefined
// 1800164C6: variable 'v13' is possibly undefined
// 18001656E: variable 'v15' is possibly undefined
// 180045F65: variable 'v23' is possibly undefined
// 180046021: variable 'v26' is possibly undefined
// 180070820: using guessed type void *ComHandlerTask::`vftable';
// 180070870: using guessed type void *ComHandlerBase::`vftable';
// 180073810: using guessed type void *MessageBoxTask::`vftable';

//----- (0000000180016654) ----------------------------------------------------
__int64 __fastcall JobStore::StreamInUSHORT(unsigned __int16 *a1, unsigned __int16 **a2, unsigned __int8 *a3)
{
  *a1 = 0;
  if ( *a2 + 1 > (unsigned __int16 *)a3 )
    return 2147549183LL;
  *a1 = *(*a2)++;
  return 0LL;
}

//----- (0000000180016684) ----------------------------------------------------
_QWORD *__fastcall std::_List_buy<Task *>::_Buynode<Task * const &>(__int64 a1, _QWORD *a2, _QWORD *a3, _QWORD *a4)
{
  _QWORD *result; // rax

  result = std::_List_alloc<0,std::_List_base_types<std::vector<unsigned char> *,std::allocator<std::vector<unsigned char> *>>>::_Buynode0(
             a1,
             a2,
             a3);
  result[2] = *a4;
  return result;
}

//----- (00000001800166B8) ----------------------------------------------------
__int64 __fastcall Actions::ActionCollection::StreamIn(
        Actions::ActionCollection *this,
        HKEY hKey,
        unsigned __int16 *a3)
{
  LSTATUS v6; // eax
  int v7; // ebx
  void *v9; // rax
  unsigned __int8 *v10; // rbx
  int v11; // edi
  DWORD Type; // [rsp+38h] [rbp-D0h] BYREF
  DWORD cbData; // [rsp+3Ch] [rbp-CCh] BYREF
  LPBYTE lpData[2]; // [rsp+40h] [rbp-C8h] BYREF
  BYTE Data[512]; // [rsp+58h] [rbp-B0h] BYREF

  lpData[1] = (LPBYTE)-2LL;
  memset_0(Data, 0, sizeof(Data));
  cbData = 512;
  Type = 3;
  v6 = RegQueryValueExW(hKey, L"Actions", 0LL, &Type, Data, &cbData);
  v7 = v6;
  if ( !v6 )
  {
    if ( Type == 3 )
      return Actions::ActionCollection::ReadData(this, Data, cbData, a3);
    goto LABEL_18;
  }
  if ( v6 == 234 )
  {
    if ( Type != 3 )
      goto LABEL_11;
    v7 = 0;
  }
  if ( v7 )
  {
LABEL_11:
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_SD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0xAu,
        (__int64)&WPP_fa1b8c42477831648a2e44d3a9ea2fb6_Traceguids,
        L"Actions");
    }
    if ( v7 > 0 )
      return (unsigned __int16)v7 | 0x80070000;
    return (unsigned int)v7;
  }
  if ( Type != 3 )
  {
LABEL_18:
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_SD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0xBu,
        (__int64)&WPP_fa1b8c42477831648a2e44d3a9ea2fb6_Traceguids,
        L"Actions");
    }
    return 2147549183LL;
  }
  lpData[0] = 0LL;
  v9 = operator new(cbData);
  wmi::AutoVectorPtr<unsigned char>::operator=((void **)lpData, v9);
  v10 = lpData[0];
  if ( lpData[0] )
  {
    v11 = RegQueryValueExW(hKey, L"Actions", 0LL, &Type, lpData[0], &cbData);
    if ( v11 )
    {
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        WPP_SF_SD(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0xCu,
          (__int64)&WPP_fa1b8c42477831648a2e44d3a9ea2fb6_Traceguids,
          L"Actions");
      }
      if ( v11 > 0 )
        v11 = (unsigned __int16)v11 | 0x80070000;
    }
    else
    {
      v11 = Actions::ActionCollection::ReadData(this, v10, cbData, a3);
    }
  }
  else
  {
    v11 = -2147024882;
  }
  operator delete(v10);
  return (unsigned int)v11;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 1800166B8: using guessed type LPBYTE var_248[2];

//----- (00000001800167A4) ----------------------------------------------------
__int64 __fastcall Triggers::GenericTrigger::GenericTrigger(
        __int64 a1,
        const OLECHAR *a2,
        _OWORD *a3,
        _OWORD *a4,
        int a5,
        int a6,
        char a7,
        _OWORD *a8)
{
  *(_QWORD *)a1 = &Triggers::GenericTrigger::`vftable';
  Triggers::GenericTrigger::GenericData::GenericData((struct _FILETIME *)(a1 + 8));
  *(_QWORD *)(a1 + 80) = 0LL;
  *(_OWORD *)(a1 + 8) = *a3;
  *(_OWORD *)(a1 + 24) = *a4;
  *(_DWORD *)(a1 + 40) = a5;
  *(_DWORD *)(a1 + 44) = a6;
  *(_BYTE *)(a1 + 64) = a7;
  *(_OWORD *)(a1 + 48) = *a8;
  if ( a2 )
    _bstr_t::operator=((_bstr_t::Data_t **)(a1 + 80), a2);
  return a1;
}
// 180070AF8: using guessed type void *Triggers::GenericTrigger::`vftable';

//----- (00000001800168BC) ----------------------------------------------------
void __fastcall ATL::CComBSTR::Attach(BSTR *this, unsigned __int16 *a2)
{
  if ( *this != a2 )
  {
    SysFreeString(*this);
    *this = a2;
  }
}

//----- (00000001800168F8) ----------------------------------------------------
__int64 __fastcall TaskXmlReader::LoadValue(TaskXmlReader *this, struct _bstr_t *a2)
{
  const OLECHAR **v2; // rbx
  __int64 result; // rax
  __int64 *Copy; // rax
  char v6; // [rsp+30h] [rbp+8h] BYREF

  v2 = (const OLECHAR **)((char *)this + 64);
  result = TaskXmlReader::LoadRawValue(this, (TaskXmlReader *)((char *)this + 64));
  if ( (int)result >= 0 )
  {
    Copy = (__int64 *)XmlParserTempString::GetCopy(v2, (_bstr_t *)&v6);
    _bstr_t::operator=((__int64 *)a2, Copy);
    _bstr_t::_Free((_bstr_t *)&v6);
    return 0LL;
  }
  return result;
}

//----- (000000018001694C) ----------------------------------------------------
__int64 __fastcall JobBucket::WriteRegistrationXml(JobBucket *this, struct TaskXmlWriter *a2, struct Schema *a3)
{
  __int64 result; // rax
  __int64 v6; // rcx
  __int64 v7; // rcx
  __int64 v8; // rcx
  __int64 v9; // rcx
  __int64 v10; // rcx
  __int64 v11; // rcx
  __int64 v12; // rcx
  __int64 v13; // rcx
  _QWORD *v14; // rax
  __int64 v15; // r9
  _QWORD *v16; // rax
  __int64 v17; // r9
  _QWORD *v18; // rax
  __int64 v19; // r9
  _QWORD *v20; // rax
  __int64 v21; // r9
  _QWORD *v22; // rax
  __int64 v23; // r9
  _QWORD *v24; // rax
  __int64 v25; // r9
  _QWORD *v26; // rax
  __int64 v27; // r9
  __int64 *v28; // rax
  __int64 v29; // r9

  result = TaskXmlWriter::StartElement((int *)a2, 3);
  if ( (int)result >= 0 )
  {
    v14 = (_QWORD *)*((_QWORD *)this + 14);
    v15 = v14 ? *v14 : 0LL;
    result = JobBucket::WriteOptionalXmlElement(v6, (__int64)a2, 9, v15);
    if ( (int)result >= 0 )
    {
      v16 = (_QWORD *)*((_QWORD *)this + 13);
      v17 = v16 ? *v16 : 0LL;
      result = JobBucket::WriteOptionalXmlElement(v7, (__int64)a2, 7, v17);
      if ( (int)result >= 0 )
      {
        v18 = (_QWORD *)*((_QWORD *)this + 15);
        v19 = v18 ? *v18 : 0LL;
        result = JobBucket::WriteOptionalXmlElement(v8, (__int64)a2, 5, v19);
        if ( (int)result >= 0 )
        {
          v20 = (_QWORD *)*((_QWORD *)this + 16);
          v21 = v20 ? *v20 : 0LL;
          result = JobBucket::WriteOptionalXmlElement(v9, (__int64)a2, 6, v21);
          if ( (int)result >= 0 )
          {
            v22 = (_QWORD *)*((_QWORD *)this + 17);
            v23 = v22 ? *v22 : 0LL;
            result = JobBucket::WriteOptionalXmlElement(v10, (__int64)a2, 8, v23);
            if ( (int)result >= 0 )
            {
              v24 = (_QWORD *)*((_QWORD *)this + 18);
              v25 = v24 ? *v24 : 0LL;
              result = JobBucket::WriteOptionalXmlElement(v11, (__int64)a2, 10, v25);
              if ( (int)result >= 0 )
              {
                v26 = (_QWORD *)*((_QWORD *)this + 19);
                v27 = v26 ? *v26 : 0LL;
                result = JobBucket::WriteOptionalXmlElement(v12, (__int64)a2, 11, v27);
                if ( (int)result >= 0 )
                {
                  v28 = (__int64 *)*((_QWORD *)this + 20);
                  if ( v28 )
                    v29 = *v28;
                  else
                    v29 = 0LL;
                  result = JobBucket::WriteOptionalXmlElement(v13, (__int64)a2, 4, v29);
                  if ( (int)result >= 0 )
                    return TaskXmlWriter::EndElement((__int64)a2);
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 180016986: variable 'v6' is possibly undefined
// 18001699D: variable 'v7' is possibly undefined
// 1800169B4: variable 'v8' is possibly undefined
// 1800169CB: variable 'v9' is possibly undefined
// 1800169E2: variable 'v10' is possibly undefined
// 1800169F9: variable 'v11' is possibly undefined
// 180016A14: variable 'v12' is possibly undefined
// 180016A2F: variable 'v13' is possibly undefined

//----- (0000000180016A50) ----------------------------------------------------
__int64 __fastcall JobBucket::WriteOptionalXmlElement(__int64 a1, __int64 a2, int a3, __int64 a4)
{
  __int64 result; // rax

  result = 0LL;
  if ( a4 )
    return TaskXmlWriter::Element(a2, a3, a4);
  return result;
}

//----- (0000000180016A74) ----------------------------------------------------
__int64 __fastcall TaskXmlReader::LoadInstancePolicy(TaskXmlReader *this, enum JobFlags::JobFlag *a2)
{
  const wchar_t **v2; // rdi
  __int64 result; // rax

  *(_DWORD *)a2 = 0;
  v2 = (const wchar_t **)((char *)this + 64);
  result = TaskXmlReader::LoadRawValue(this, (TaskXmlReader *)((char *)this + 64));
  if ( (int)result >= 0 )
  {
    if ( XmlParserTempString::IsEqualTo(v2, L"Parallel", 8uLL) )
    {
      *(_DWORD *)a2 = 1024;
    }
    else if ( XmlParserTempString::IsEqualTo(v2, L"Queue", 5uLL) )
    {
      *(_DWORD *)a2 = 4096;
    }
    else if ( XmlParserTempString::IsEqualTo(v2, L"IgnoreNew", 9uLL) )
    {
      *(_DWORD *)a2 = 0x2000;
    }
    else
    {
      if ( !XmlParserTempString::IsEqualTo(v2, L"StopExisting", 0xCuLL) )
        return 2147750680LL;
      *(_DWORD *)a2 = 2048;
    }
    return 0LL;
  }
  return result;
}

//----- (0000000180016B10) ----------------------------------------------------
__int64 __fastcall TaskXmlReader::LoadTimespan(const unsigned __int16 **this, unsigned int *a2)
{
  __int64 result; // rax
  unsigned __int64 v5; // rdx
  const unsigned __int16 *v6; // rcx
  int v7; // edx
  int v8; // eax
  __int64 v9; // [rsp+20h] [rbp-10h] BYREF
  int v10; // [rsp+28h] [rbp-8h]
  unsigned __int16 v11; // [rsp+2Ch] [rbp-4h]

  result = TaskXmlReader::LoadRawValue((TaskXmlReader *)this, (struct XmlParserTempString *)(this + 8));
  if ( (int)result >= 0 )
  {
    v5 = *((unsigned int *)this + 16);
    v6 = this[9];
    v9 = 0LL;
    v10 = 0;
    v11 = 0;
    if ( (int)TSParser::ParseTimePeriod(v6, v5, (struct TSTimePeriod *)&v9) < 0 || WORD1(v9) + 12 * (unsigned __int16)v9 )
      return 2147750680LL;
    v7 = v11 + 60 * (HIWORD(v10) + 60 * ((unsigned __int16)v10 + 24 * (HIWORD(v9) + 7 * WORD2(v9))));
    v8 = -1;
    if ( (unsigned __int64)v7 <= 0xFFFFFFFF )
      v8 = v11 + 60 * (HIWORD(v10) + 60 * ((unsigned __int16)v10 + 24 * (HIWORD(v9) + 7 * WORD2(v9))));
    *a2 = v8;
    if ( (unsigned __int64)v7 > 0xFFFFFFFF )
      return 2147750680LL;
    else
      return 0LL;
  }
  return result;
}

//----- (0000000180016BE0) ----------------------------------------------------
__int64 __fastcall TSParser::ParseTimePeriod(const unsigned __int16 *a1, unsigned __int64 a2, struct TSTimePeriod *a3)
{
  __int16 v4; // dx
  int v7; // r9d
  unsigned __int64 v8; // r14
  unsigned __int16 v9; // r12
  unsigned __int16 v10; // r13
  __int64 v11; // rcx
  __int64 v12; // r10
  bool v13; // zf
  __int64 v14; // r11
  unsigned __int64 v15; // r14
  unsigned __int64 v16; // rcx
  unsigned __int64 v17; // r14
  int v18; // r10d
  __int16 v19; // r11
  __int64 v20; // r10
  __int64 v22; // r11
  int v23; // r10d
  __int64 v24; // r10
  __int64 v25; // r11
  unsigned __int64 v26; // r14
  unsigned __int64 v27; // rcx
  unsigned __int64 v28; // r14
  unsigned __int64 v29; // rcx
  unsigned __int64 v30; // r14
  int v31; // r10d
  __int16 v32; // r11
  int v33; // eax
  unsigned __int16 v34[2]; // [rsp+20h] [rbp-20h] BYREF
  unsigned __int16 v35; // [rsp+24h] [rbp-1Ch] BYREF
  __int16 v36; // [rsp+28h] [rbp-18h]
  __int16 v37; // [rsp+2Ah] [rbp-16h]
  __int16 v38; // [rsp+2Ch] [rbp-14h]
  unsigned int v39; // [rsp+30h] [rbp-10h] BYREF
  unsigned __int64 v40; // [rsp+38h] [rbp-8h] BYREF
  unsigned __int16 v41; // [rsp+80h] [rbp+40h] BYREF
  unsigned __int16 v42; // [rsp+98h] [rbp+58h] BYREF

  v40 = 0LL;
  v4 = 0;
  v41 = 0;
  v36 = 0;
  v37 = 0;
  v7 = 0;
  v38 = 0;
  v8 = 0LL;
  v42 = 0;
  v9 = 0;
  v34[0] = 0;
  v10 = 0;
  v35 = 0;
  if ( !a1 )
    return (unsigned int)-2147216616;
  if ( !a2 )
    return (unsigned int)-2147216616;
  if ( *a1 != 80 )
    return (unsigned int)-2147216616;
  LODWORD(v11) = 1;
  v39 = 1;
  if ( !a1[1] )
    return (unsigned int)-2147216616;
  if ( a1[1] != 84 )
  {
    v7 = TSParser::ParseWord(a1, a2, &v39, &v41);
    if ( v7 < 0 )
      return (unsigned int)v7;
    LODWORD(v11) = v39;
    v4 = v41;
  }
  if ( (unsigned int)v11 < a2 && a1[(unsigned int)v11] == 89 )
  {
    v11 = (unsigned int)(v11 + 1);
    v36 = v4;
    v39 = v11;
    if ( !a1[v11] )
      goto LABEL_43;
    if ( a1[v11] != 84 )
    {
      v7 = TSParser::ParseWord(a1, a2, &v39, &v41);
      if ( v7 < 0 )
        return (unsigned int)v7;
      LODWORD(v11) = v39;
      v4 = v41;
    }
  }
  if ( (unsigned int)v11 < a2 && a1[(unsigned int)v11] == 77 )
  {
    v11 = (unsigned int)(v11 + 1);
    v37 = v4;
    v39 = v11;
    if ( !a1[v11] )
      goto LABEL_43;
    if ( a1[v11] != 84 )
    {
      v7 = TSParser::ParseWord(a1, a2, &v39, &v41);
      if ( v7 < 0 )
        return (unsigned int)v7;
      LODWORD(v11) = v39;
      v4 = v41;
    }
  }
  if ( (unsigned int)v11 < a2 && a1[(unsigned int)v11] == 87 )
  {
    v11 = (unsigned int)(v11 + 1);
    v38 = v4;
    v39 = v11;
    if ( !a1[v11] )
      goto LABEL_43;
    if ( a1[v11] != 84 )
    {
      v7 = TSParser::ParseWord(a1, a2, &v39, &v41);
      if ( v7 < 0 )
        return (unsigned int)v7;
      LODWORD(v11) = v39;
      v4 = v41;
    }
  }
  if ( (unsigned int)v11 < a2 && a1[(unsigned int)v11] == 68 )
  {
    v11 = (unsigned int)(v11 + 1);
    v42 = v4;
    if ( !a1[v11] )
    {
LABEL_43:
      if ( v7 >= 0 )
      {
        *(_WORD *)a3 = v36;
        *((_WORD *)a3 + 1) = v37;
        *((_WORD *)a3 + 2) = v38;
        *((_WORD *)a3 + 3) = v42;
        *((_WORD *)a3 + 4) = v34[0];
        *((_WORD *)a3 + 5) = v9;
        *((_WORD *)a3 + 6) = v10;
      }
      return (unsigned int)v7;
    }
  }
  if ( a1[(unsigned int)v11] != 84 )
    v7 = -2147216616;
  if ( v7 >= 0 )
  {
    v12 = (unsigned int)(v11 + 1);
    v13 = a1[v12] == 0;
    v39 = v11 + 1;
    if ( v13 )
      v7 = -2147216616;
    if ( v7 >= 0 )
    {
      if ( (unsigned int)v12 < a2 )
      {
        v7 = TSParser::ParseULongLong(a1, a2, &v39, &v40);
        if ( v7 < 0 )
          return (unsigned int)v7;
        LODWORD(v12) = v39;
        v8 = v40;
      }
      if ( (unsigned int)v12 < a2 && a1[(unsigned int)v12] == 72 )
      {
        if ( (int)ULongLongToUShort(v8 / 0x18, &v41) < 0 )
          v7 = -2147216616;
        if ( v7 < 0 )
          return (unsigned int)v7;
        if ( (int)UShortAdd(v42, v41, &v42) < 0 )
          v7 = -2147216616;
        if ( v7 < 0 )
          return (unsigned int)v7;
        if ( (int)ULongLongToUShort(v8 - 24 * v22, &v41) < 0 )
          v7 = -2147216616;
        if ( v7 < 0 )
          return (unsigned int)v7;
        v24 = (unsigned int)(v23 + 1);
        v34[0] = v41;
        v39 = v24;
        if ( !a1[v24] )
          goto LABEL_43;
        v33 = TSParser::ParseULongLong(a1, a2, &v39, &v40);
        v7 = v33;
        if ( v33 < 0 )
          return (unsigned int)v7;
        LODWORD(v12) = v39;
        v8 = v40;
      }
      if ( (unsigned int)v12 < a2 && a1[(unsigned int)v12] == 77 )
      {
        if ( (int)ULongLongToUShort(v8 / 0x5A0, &v41) < 0 )
          v7 = -2147216616;
        if ( v7 < 0 )
          return (unsigned int)v7;
        if ( (int)UShortAdd(v42, v41, &v42) < 0 )
          v7 = -2147216616;
        if ( v7 < 0 )
          return (unsigned int)v7;
        v15 = v8 - 1440 * v14;
        v16 = v15 / 0x3C;
        v17 = v15 % 0x3C;
        if ( (int)ULongLongToUShort(v16, &v41) < 0 )
          v7 = -2147216616;
        if ( v7 < 0 )
          return (unsigned int)v7;
        if ( (int)UShortAdd(v34[0], v41, v34) < 0 )
          v7 = -2147216616;
        if ( v7 < 0 )
          return (unsigned int)v7;
        if ( (int)ULongLongToUShort(v17, &v41) < 0 )
          v7 = -2147216616;
        if ( v7 < 0 )
          return (unsigned int)v7;
        v9 = v41;
        v20 = (unsigned int)(v18 + 1);
        v35 = v41;
        v39 = v20;
        if ( a1[v20] == v19 )
          goto LABEL_43;
        v7 = TSParser::ParseULongLong(a1, a2, &v39, &v40);
        if ( v7 < 0 )
          return (unsigned int)v7;
        LODWORD(v12) = v39;
        v8 = v40;
      }
      if ( (unsigned int)v12 >= a2 || a1[(unsigned int)v12] != 83 )
      {
LABEL_85:
        v7 = -2147216616;
        goto LABEL_43;
      }
      if ( (int)ULongLongToUShort(v8 / 0x15180, &v41) < 0 )
        v7 = -2147216616;
      if ( v7 >= 0 )
      {
        if ( (int)UShortAdd(v42, v41, &v42) < 0 )
          v7 = -2147216616;
        if ( v7 >= 0 )
        {
          v26 = v8 - 86400 * v25;
          v27 = v26 / 0xE10;
          v28 = v26 % 0xE10;
          if ( (int)ULongLongToUShort(v27, &v41) < 0 )
            v7 = -2147216616;
          if ( v7 >= 0 )
          {
            if ( (int)UShortAdd(v34[0], v41, v34) < 0 )
              v7 = -2147216616;
            if ( v7 >= 0 )
            {
              v29 = v28 / 0x3C;
              v30 = v28 % 0x3C;
              if ( (int)ULongLongToUShort(v29, &v41) < 0 )
                v7 = -2147216616;
              if ( v7 >= 0 )
              {
                if ( (int)UShortAdd(v9, v41, &v35) < 0 )
                  v7 = -2147216616;
                if ( v7 >= 0 )
                {
                  if ( (int)ULongLongToUShort(v30, &v41) < 0 )
                    v7 = -2147216616;
                  if ( v7 >= 0 )
                  {
                    v10 = v41;
                    v9 = v35;
                    if ( a1[v31 + 1] == v32 )
                      goto LABEL_43;
                    goto LABEL_85;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return (unsigned int)v7;
}
// 180016D73: variable 'v7' is possibly undefined
// 180016D99: variable 'v14' is possibly undefined
// 180016E11: variable 'v18' is possibly undefined
// 180016E22: variable 'v19' is possibly undefined
// 180016ECA: variable 'v22' is possibly undefined
// 180016EF3: variable 'v23' is possibly undefined
// 180016FB7: variable 'v25' is possibly undefined
// 180017096: variable 'v31' is possibly undefined
// 1800170A4: variable 'v32' is possibly undefined

//----- (00000001800170B8) ----------------------------------------------------
__int64 __fastcall ULongLongToUShort(unsigned __int64 a1, unsigned __int16 *a2)
{
  unsigned __int16 v2; // r8

  if ( a1 > 0xFFFF )
    v2 = -1;
  else
    v2 = a1;
  *a2 = v2;
  return a1 > 0xFFFF ? 0x80070216 : 0;
}

//----- (00000001800170E4) ----------------------------------------------------
__int64 __fastcall UShortAdd(unsigned __int16 a1, __int16 a2, unsigned __int16 *a3)
{
  bool v3; // cf
  unsigned __int16 v4; // dx

  v3 = (unsigned __int16)(a2 + a1) < a1;
  if ( (unsigned __int16)(a2 + a1) < a1 )
    v4 = -1;
  else
    v4 = a2 + a1;
  *a3 = v4;
  return v3 ? 0x80070216 : 0;
}

//----- (000000018001710C) ----------------------------------------------------
__int64 __fastcall TaskXmlWriter::ElementHexString(__int64 a1, int a2, tsched *a3, unsigned int a4)
{
  _WORD *v8; // rax
  void *v9; // rbx
  unsigned int v10; // edi
  unsigned int v12; // [rsp+50h] [rbp+18h] BYREF

  if ( !a3 )
    return (unsigned int)TaskXmlWriter::Element(a1, a2, (__int64)&ChannelPath);
  if ( (int)tsched::HexBinaryToString(a3, (unsigned __int8 *)a4, 0LL, (unsigned __int16 *)&v12) >= 0 )
  {
    v8 = operator new(saturated_mul(v12, 2uLL));
    v9 = v8;
    if ( !v8 )
      return 2147942414LL;
    if ( (int)tsched::HexBinaryToString(a3, (unsigned __int8 *)a4, v8, (unsigned __int16 *)&v12) >= 0 )
    {
      v10 = TaskXmlWriter::Element(a1, a2, (__int64)v9);
      operator delete(v9);
      return v10;
    }
    operator delete(v9);
  }
  return 2147750680LL;
}

//----- (00000001800171CC) ----------------------------------------------------
__int64 __fastcall tsched::HexBinaryToString(tsched *this, unsigned __int8 *a2, _WORD *a3, unsigned __int16 *a4)
{
  tsched *v6; // rsi
  unsigned int v7; // r10d
  unsigned int v8; // r9d
  unsigned int v9; // r14d
  unsigned __int16 *v10; // r8
  unsigned int v11; // ebp
  unsigned int v12; // r15d
  tsched *v13; // rcx
  unsigned int v14; // r11d
  __int16 v16; // [rsp+50h] [rbp+8h] BYREF

  v6 = this;
  v7 = 0;
  if ( !this || !(_DWORD)a2 || !a4 )
    return (unsigned int)-2147024809;
  v8 = *(_DWORD *)a4;
  v9 = 2 * (_DWORD)a2 + 1;
  v10 = 0LL;
  v11 = 0;
  if ( !a3 )
    goto LABEL_14;
  if ( !v8 )
    return (unsigned int)-2147024809;
  *a3 = 0;
  if ( v8 < v9 )
    return (unsigned int)-2147024774;
  v12 = v8 - 1;
  while ( (unsigned int)v10 < v12 )
  {
    LOBYTE(this) = *(_BYTE *)v6 >> 4;
    if ( !(unsigned int)tsched::ByteToHexDigit(this, &v16, v10)
      || (v13 = (tsched *)(unsigned int)v10,
          a3[(unsigned int)v10] = v16,
          LOBYTE(v13) = *(_BYTE *)v6 & 0xF,
          !(unsigned int)tsched::ByteToHexDigit(v13, &v16, (unsigned __int16 *)(unsigned int)((_DWORD)v10 + 1))) )
    {
      v7 = -2147024809;
      break;
    }
    ++v11;
    a3[(_QWORD)v10] = v16;
    v6 = (tsched *)((char *)v6 + 1);
    v10 = (unsigned __int16 *)(unsigned int)((_DWORD)v10 + 1);
    if ( v11 >= v14 )
      break;
  }
  if ( (unsigned int)v10 < v8 )
    a3[(unsigned int)v10] = 0;
LABEL_14:
  *(_DWORD *)a4 = v9;
  return v7;
}
// 18001723C: conditional instruction was optimized away because edx.4!=0
// 180017251: variable 'this' is possibly undefined
// 180017264: variable 'v10' is possibly undefined
// 180017291: variable 'v14' is possibly undefined
// 180017296: variable 'v8' is possibly undefined
// 1800172A8: variable 'v7' is possibly undefined

//----- (00000001800172CC) ----------------------------------------------------
__int64 __fastcall tsched::ByteToHexDigit(tsched *this, _WORD *a2, unsigned __int16 *a3)
{
  __int16 v3; // ax

  if ( (unsigned __int8)this < 0xAu )
  {
    v3 = (unsigned __int8)this + 48;
LABEL_3:
    *a2 = v3;
    return 1LL;
  }
  if ( (unsigned __int8)this < 0x10u )
  {
    v3 = (unsigned __int8)this + 55;
    goto LABEL_3;
  }
  return 0LL;
}

//----- (00000001800172FC) ----------------------------------------------------
__int64 __fastcall TaskXmlReader::LoadHexString(tsched **this, void **a2, unsigned __int8 *a3)
{
  unsigned int *v6; // rdi
  __int64 result; // rax
  const unsigned __int16 *v8; // rdx
  void *v9; // rax

  wmi::AutoVectorPtr<unsigned char>::operator=(a2, 0LL);
  *(_DWORD *)a3 = 0;
  v6 = (unsigned int *)(this + 8);
  result = TaskXmlReader::LoadRawValue((TaskXmlReader *)this, (struct XmlParserTempString *)(this + 8));
  if ( (int)result >= 0 )
  {
    v8 = (const unsigned __int16 *)*v6;
    if ( (_DWORD)v8 )
    {
      if ( (int)tsched::HexStringToBinary(this[9], v8, 0LL, a3) < 0 )
        return 2147750680LL;
      v9 = operator new(*(unsigned int *)a3);
      wmi::AutoVectorPtr<unsigned char>::operator=(a2, v9);
      if ( !*a2 )
      {
        *(_DWORD *)a3 = 0;
        return 2147942414LL;
      }
      if ( (int)tsched::HexStringToBinary(this[9], (const unsigned __int16 *)*v6, (__int64)*a2, a3) < 0 )
        return 2147750680LL;
    }
    return 0LL;
  }
  return result;
}

//----- (00000001800173AC) ----------------------------------------------------
__int64 __fastcall tsched::HexStringToBinary(tsched *this, const unsigned __int16 *a2, __int64 a3, unsigned __int8 *a4)
{
  unsigned int v4; // r10d
  tsched *v7; // rbx
  unsigned int v8; // r8d
  unsigned int v9; // r9d
  __int16 v10; // cx
  char v11; // cl
  unsigned __int64 v12; // rax

  v4 = 0;
  v7 = this;
  if ( this && (_DWORD)a2 && a4 )
  {
    v8 = ((unsigned __int8)a2 & 1) + ((unsigned int)a2 >> 1);
    if ( a3 )
    {
      if ( *(_DWORD *)a4 < v8 )
        return (unsigned int)-2147024774;
      v9 = 0;
      do
      {
        v10 = *(_WORD *)v7;
        if ( (unsigned __int16)(*(_WORD *)v7 - 48) > 9u )
        {
          if ( (unsigned __int16)(v10 - 97) <= 5u )
          {
            v11 = v10 - 87;
          }
          else
          {
            if ( (unsigned __int16)(v10 - 65) > 5u )
              return (unsigned int)-2147024809;
            v11 = v10 - 55;
          }
        }
        else
        {
          v11 = v10 - 48;
        }
        v12 = (unsigned __int64)v9 >> 1;
        if ( (v9 & 1) != 0 )
          *(_BYTE *)(v12 + a3) |= v11;
        else
          *(_BYTE *)(v12 + a3) = 16 * v11;
        ++v9;
        v7 = (tsched *)((char *)v7 + 2);
      }
      while ( v9 < (unsigned int)a2 );
    }
    *(_DWORD *)a4 = v8;
  }
  else
  {
    return (unsigned int)-2147024809;
  }
  return v4;
}
// 1800173FD: conditional instruction was optimized away because edx.4!=0

//----- (0000000180017470) ----------------------------------------------------
__int64 __fastcall TaskXmlWriter::WriteAttribute(__int64 a1, int a2, __int64 a3)
{
  const struct SchemaEntry * near *Entry; // rax
  __int64 v7; // r11

  if ( !a3 || !*(_DWORD *)Schema::GetEntry((int *)a1, a2) )
    return 1LL;
  _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::operator->((__int64 *)(a1 + 16));
  Entry = Schema::GetEntry((int *)a1, a2);
  return (*(__int64 (__fastcall **)(__int64, const WCHAR *, const struct SchemaEntry *, _QWORD, __int64))(*(_QWORD *)v7 + 56LL))(
           v7,
           &ChannelPath,
           Entry[1],
           0LL,
           a3);
}
// 1800174AC: variable 'v7' is possibly undefined

//----- (00000001800174F0) ----------------------------------------------------
__int64 __fastcall TaskXmlWriter::EndDocument(TaskXmlWriter *this)
{
  __int64 *v1; // rbx
  __int64 v3; // rax
  __int64 result; // rax
  __int64 v5; // rax
  __int64 v6; // rax

  v1 = (__int64 *)((char *)this + 16);
  v3 = _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::operator->((__int64 *)this + 2);
  result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v3 + 248LL))(v3);
  if ( (int)result >= 0 )
  {
    result = TaskXmlWriter::EndElement((__int64)this);
    if ( (int)result >= 0 )
    {
      v5 = _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::operator->(v1);
      result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 112LL))(v5);
      if ( (int)result >= 0 )
      {
        v6 = _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::operator->(v1);
        return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v6 + 248LL))(v6);
      }
    }
  }
  return result;
}

//----- (000000018001757C) ----------------------------------------------------
__int64 __fastcall TaskXmlReader::ProcessXml(TaskXmlReader *this, struct ITaskXmlHandler *a2)
{
  __int64 result; // rax
  __int64 v5; // rax
  int v6; // eax
  __int64 v7; // rbx
  const struct SchemaEntry * near *Entry; // rax
  __int64 v9; // rax
  int v10; // eax
  __int64 v11; // rbx
  char v12; // [rsp+60h] [rbp+18h] BYREF
  int v13; // [rsp+68h] [rbp+20h] BYREF

  result = TaskXmlReader::CreateXmlReader(this);
  if ( (int)result >= 0 )
  {
    while ( 1 )
    {
      v5 = _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::operator->((__int64 *)this + 7);
      v6 = (*(__int64 (__fastcall **)(__int64, int *))(*(_QWORD *)v5 + 48LL))(v5, &v13);
      if ( v6 )
        break;
      if ( v13 == 1 )
      {
        v7 = _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::operator->((__int64 *)this + 7);
        XmlParserTempString::Clear((TaskXmlReader *)((char *)this + 64));
        v6 = (*(__int64 (__fastcall **)(__int64, char *, char *))(*(_QWORD *)v7 + 112LL))(
               v7,
               (char *)this + 72,
               (char *)this + 64);
        if ( v6 < 0 )
          return TaskXmlReader::SetErrorInfoXmlLite(this, v6);
        Entry = Schema::GetEntry((int *)this + 279, 1);
        if ( !XmlParserTempString::IsEqualTo(
                (const wchar_t **)this + 8,
                (const unsigned __int16 *)Entry[1],
                *((unsigned int *)Entry + 4)) )
          return TaskXmlReader::SetErrorInfo(this, -2147216618, *((char **)this + 9), *((_DWORD *)this + 16), 0LL, 0);
        v12 = 0;
        v9 = _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::operator->((__int64 *)this + 7);
        v10 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v9 + 160LL))(v9);
        result = TaskXmlReader::ProcessElement((__int64)this, (__int64)a2, 1u, v10 != 0, &v12);
        if ( (int)result < 0 )
          return result;
      }
      else if ( v13 == 3 )
      {
        v11 = _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::operator->((__int64 *)this + 7);
        XmlParserTempString::Clear((TaskXmlReader *)((char *)this + 64));
        v6 = (*(__int64 (__fastcall **)(__int64, char *, char *))(*(_QWORD *)v11 + 128LL))(
               v11,
               (char *)this + 72,
               (char *)this + 64);
        if ( v6 < 0 )
          return TaskXmlReader::SetErrorInfoXmlLite(this, v6);
        if ( (int)XmlParserTempString::Trim((TaskXmlReader *)((char *)this + 64)) < 0 || *((_DWORD *)this + 16) )
          return TaskXmlReader::SetErrorInfo((int *)this, -2147216616, 0, (__int64)this + 64);
      }
      else if ( v13 <= 6 || v13 != 13 && v13 != 17 && v13 > 8 )
      {
        XmlParserTempString::Clear((TaskXmlReader *)((char *)this + 64));
        return TaskXmlReader::SetErrorInfo(this, -2147216618, *((char **)this + 9), *((_DWORD *)this + 16), 0LL, 0);
      }
    }
    if ( v6 < 0 )
    {
      return TaskXmlReader::SetErrorInfoXmlLite(this, v6);
    }
    else
    {
      if ( !*((_BYTE *)this + 40) )
        return 0LL;
      result = TaskXmlWriter::EndDocument(*((TaskXmlWriter **)this + 2));
      if ( (int)result >= 0 )
        return 0LL;
    }
  }
  return result;
}

//----- (00000001800176DC) ----------------------------------------------------
__int64 __fastcall TaskXmlReader::ValidateNamespace(__int64 a1, int a2)
{
  XmlParserTempString *v4; // rdi
  __int64 v5; // rbx
  int v6; // eax

  v4 = (XmlParserTempString *)(a1 + 64);
  v5 = _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::operator->((__int64 *)(a1 + 56));
  XmlParserTempString::Clear(v4);
  v6 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v5 + 104LL))(v5, a1 + 72, a1 + 64);
  if ( v6 < 0 )
    return TaskXmlReader::SetErrorInfoXmlLite((TaskXmlReader *)a1, v6);
  if ( *((_DWORD *)Schema::GetEntry((int *)(a1 + 1116), a2) + 6) == 2 && !*(_DWORD *)v4
    || XmlParserTempString::IsEqualTo((const wchar_t **)(a1 + 64), Schema::namespaceUri, 0x35uLL) )
  {
    return 0LL;
  }
  return TaskXmlReader::SetErrorInfo((int *)a1, -2147216617, a2, a1 + 64);
}

//----- (0000000180017770) ----------------------------------------------------
__int64 __fastcall TaskXmlReader::ProcessComplexContent(__int64 a1, __int64 a2, int a3, char a4, _BYTE *a5)
{
  __int64 v5; // r12
  __int64 v6; // r13
  unsigned int v8; // r14d
  __int64 v9; // rsi
  __int64 *v10; // rbx
  __int64 v11; // rdi
  int v12; // eax
  __int64 v13; // rbx
  char v14; // al
  unsigned __int64 i; // rsi
  int v16; // eax
  int v17; // eax
  int v18; // eax
  const struct SchemaEntry **v19; // rcx
  __int64 v20; // rdi
  int v21; // eax
  const struct SchemaEntry **v22; // rbx
  size_t v23; // r8
  __int64 v24; // rcx
  __int64 v25; // r9
  __int64 result; // rax
  __int64 v27; // rax
  int *v28; // rcx
  unsigned int v29; // r8d
  int v30; // edx
  const struct SchemaEntry **v31; // rcx
  __int64 v32; // r9
  const struct SchemaEntry **v33; // rcx
  unsigned int v34; // ecx
  int *v35; // rax
  int *v36; // r10
  const struct SchemaEntry * near *Entry; // rax
  int v38; // edx
  __int64 v39; // r10
  int v40; // r11d
  __int64 v41; // rbx
  __int64 v42; // rdi
  int v43; // eax
  _DWORD *v44; // r9
  int RawValue; // eax
  int v46; // ebx
  unsigned __int64 v47; // rdx
  const unsigned __int64 near *v48; // r8
  unsigned __int64 v49; // rcx
  const unsigned __int64 near *v50; // rdx
  int v51; // r8d
  unsigned int v52; // ebx
  int v53; // r8d
  int v54; // edx
  unsigned __int64 v55; // r9
  const unsigned __int64 near *v56; // r10
  unsigned __int64 v57; // r10
  const unsigned __int64 near *v58; // r11
  unsigned __int16 *v59; // [rsp+20h] [rbp-E0h]
  char v60[4]; // [rsp+30h] [rbp-D0h] BYREF
  unsigned int v61; // [rsp+34h] [rbp-CCh]
  int v62; // [rsp+38h] [rbp-C8h] BYREF
  _BYTE *v63; // [rsp+40h] [rbp-C0h]
  __int64 v64; // [rsp+48h] [rbp-B8h]
  __int64 v65; // [rsp+50h] [rbp-B0h]
  void **pExceptionObject; // [rsp+58h] [rbp-A8h] BYREF
  int v67; // [rsp+60h] [rbp-A0h]
  __int128 v68; // [rsp+68h] [rbp-98h]
  void **v69; // [rsp+78h] [rbp-88h] BYREF
  int v70; // [rsp+80h] [rbp-80h]
  __int128 v71; // [rsp+88h] [rbp-78h]
  void **v72; // [rsp+98h] [rbp-68h] BYREF
  int v73; // [rsp+A0h] [rbp-60h]
  __int128 v74; // [rsp+A8h] [rbp-58h]
  char v75[48]; // [rsp+C0h] [rbp-40h] BYREF
  __int64 v76; // [rsp+F0h] [rbp-10h]
  void *lpMem; // [rsp+F8h] [rbp-8h]
  int v78[44]; // [rsp+110h] [rbp+10h] BYREF

  v65 = -2LL;
  v5 = a3;
  v6 = a2;
  v64 = a2;
  v63 = a5;
  v8 = 0;
  if ( a4 )
  {
    v36 = (int *)(Schema::GetEntry((int *)(a1 + 1116), a3) + 5);
    while ( 1 )
    {
      if ( !*v36 )
        return v8;
      Entry = Schema::GetEntry((int *)(a1 + 1116), *v36);
      if ( *((_DWORD *)Entry + 6) != 2 || *((_DWORD *)Entry + 8) )
      {
        if ( *((_DWORD *)Entry + 8) )
          break;
      }
      v36 = (int *)(v39 + 4);
      if ( (unsigned int)(v40 + 1) >= 0x16 )
        return v8;
    }
    return (unsigned int)TaskXmlReader::SetErrorInfo((int *)a1, -2147216615, v38);
  }
  LODWORD(v9) = 0;
  v61 = 0;
  v10 = (__int64 *)(a1 + 56);
LABEL_3:
  v11 = 40LL;
  do
  {
    do
    {
      if ( !*v10 )
      {
        v72 = &_com_error::`vftable';
        v73 = -2147467261;
        v74 = 0LL;
        CxxThrowException_0(&v72, (_ThrowInfo *)&TI1_AV_com_error__);
      }
      v12 = (*(__int64 (__fastcall **)(__int64, int *))(*(_QWORD *)*v10 + 48LL))(*v10, &v62);
      if ( v12 )
      {
        if ( v12 >= 0 )
          goto LABEL_54;
        return TaskXmlReader::SetErrorInfoXmlLite((TaskXmlReader *)a1, v12);
      }
    }
    while ( v62 == 13 );
    if ( v62 == 1 )
    {
      v13 = *v10;
      if ( !v13 )
      {
        v69 = &_com_error::`vftable';
        v70 = -2147467261;
        v71 = 0LL;
        CxxThrowException_0(&v69, (_ThrowInfo *)&TI1_AV_com_error__);
      }
      v14 = *(_BYTE *)(a1 + 1106);
      if ( (v14 & 1) != 0 )
      {
        SysFreeString(*(BSTR *)(a1 + 72));
        v14 = *(_BYTE *)(a1 + 1106);
      }
      *(_DWORD *)(a1 + 64) = 0;
      *(_QWORD *)(a1 + 72) = 0LL;
      *(_BYTE *)(a1 + 1106) = v14 & 0xFC;
      *(_WORD *)(a1 + 80) = 0;
      v12 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v13 + 112LL))(v13, a1 + 72, a1 + 64);
      if ( v12 >= 0 )
      {
        for ( i = 40LL; ; i += 4LL )
        {
          if ( !(_DWORD)v5 )
            return TaskXmlReader::SetErrorInfo(
                     (TaskXmlReader *)a1,
                     -2147216618,
                     *(char **)(a1 + 72),
                     *(_DWORD *)(a1 + 64),
                     0LL,
                     0);
          v16 = *(_DWORD *)(a1 + 1116);
          if ( v16 == 65542 )
          {
            v17 = 149;
          }
          else
          {
            if ( v16 < 0x10000 )
              goto LABEL_107;
            if ( v16 <= 65538 )
            {
              v17 = 131;
            }
            else
            {
              switch ( v16 )
              {
                case 65540:
                  v17 = 145;
                  break;
                case 65539:
                  v17 = 136;
                  break;
                case 65541:
                  v17 = 148;
                  break;
                default:
LABEL_107:
                  v17 = 0;
                  break;
              }
            }
          }
          if ( (int)v5 >= v17 || i >= 0x80 )
            return TaskXmlReader::SetErrorInfo(
                     (TaskXmlReader *)a1,
                     -2147216618,
                     *(char **)(a1 + 72),
                     *(_DWORD *)(a1 + 64),
                     0LL,
                     0);
          _mm_lfence();
          v18 = *(_DWORD *)(a1 + 1116);
          if ( v18 == 65542 )
          {
LABEL_19:
            v19 = &(&Schema::schemaEntries)[(unsigned __int16)v18][16 * v5];
            goto LABEL_20;
          }
          if ( v18 < 0x10000 )
            goto LABEL_112;
          if ( v18 > 65537 )
          {
            if ( v18 <= 65541 )
              goto LABEL_19;
LABEL_112:
            v19 = (const struct SchemaEntry **)&unk_180096000;
            goto LABEL_20;
          }
          v47 = 0LL;
          v48 = (&Schema::schemaEntriesCount)[(unsigned __int16)v18];
          if ( !v48 )
            goto LABEL_112;
          v19 = (&Schema::schemaEntries)[(unsigned __int16)v18];
          while ( *(_DWORD *)v19 != (_DWORD)v5 )
          {
            ++v47;
            v19 += 16;
            if ( v47 >= (unsigned __int64)v48 )
              goto LABEL_112;
          }
LABEL_20:
          v20 = *(int *)((char *)v19 + i);
          if ( !(_DWORD)v20 )
            return TaskXmlReader::SetErrorInfo(
                     (TaskXmlReader *)a1,
                     -2147216618,
                     *(char **)(a1 + 72),
                     *(_DWORD *)(a1 + 64),
                     0LL,
                     0);
          v21 = *(_DWORD *)(a1 + 1116);
          if ( v21 == 65542 )
            goto LABEL_22;
          if ( v21 < 0x10000 )
            goto LABEL_117;
          if ( v21 > 65537 )
          {
            if ( v21 > 65541 )
              goto LABEL_117;
LABEL_22:
            v22 = &(&Schema::schemaEntries)[(unsigned __int16)v21][16 * v20];
            goto LABEL_23;
          }
          v49 = 0LL;
          v50 = (&Schema::schemaEntriesCount)[(unsigned __int16)v21];
          if ( !v50 )
          {
LABEL_117:
            v22 = (const struct SchemaEntry **)&unk_180096000;
            goto LABEL_23;
          }
          v22 = (&Schema::schemaEntries)[(unsigned __int16)v21];
          while ( *(_DWORD *)v22 != (_DWORD)v20 )
          {
            ++v49;
            v22 += 16;
            if ( v49 >= (unsigned __int64)v50 )
              goto LABEL_117;
          }
LABEL_23:
          if ( *((_DWORD *)v22 + 6) == 1 )
          {
            v23 = *((unsigned int *)v22 + 4);
            if ( *(_DWORD *)(a1 + 64) == v23 && !wcsncmp(*(const wchar_t **)(a1 + 72), (const wchar_t *)v22[1], v23) )
            {
              v60[0] = 0;
              v24 = *(_QWORD *)(a1 + 56);
              if ( !v24 )
              {
                pExceptionObject = &_com_error::`vftable';
                v67 = -2147467261;
                v68 = 0LL;
                CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI1_AV_com_error__);
              }
              if ( (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v24 + 160LL))(v24) )
                LOBYTE(v25) = 1;
              else
                v25 = 0LL;
              v6 = v64;
              result = TaskXmlReader::ProcessElement(a1, v64, (unsigned int)v20, v25, v60);
              if ( (int)result < 0 )
                return result;
              v8 = 0;
              v27 = 0LL;
              v9 = v61;
              if ( v61 )
              {
                v28 = v78;
                do
                {
                  if ( *v28 == (_DWORD)v20 )
                    break;
                  v27 = (unsigned int)(v27 + 1);
                  v28 += 2;
                }
                while ( (unsigned int)v27 < v61 );
              }
              if ( (_DWORD)v27 == v61 )
              {
                v78[2 * v61] = v20;
                v78[2 * v9 + 1] = 1;
                LODWORD(v9) = v9 + 1;
                v61 = v9;
                v10 = (__int64 *)(a1 + 56);
                goto LABEL_3;
              }
              if ( (unsigned int)++v78[2 * v27 + 1] <= *((_DWORD *)v22 + 9) )
              {
                v10 = (__int64 *)(a1 + 56);
                goto LABEL_3;
              }
              v53 = v20;
              v54 = -2147216611;
              return TaskXmlReader::SetErrorInfo((int *)a1, v54, v53);
            }
          }
          if ( ++v8 >= 0x16 )
            return TaskXmlReader::SetErrorInfo(
                     (TaskXmlReader *)a1,
                     -2147216618,
                     *(char **)(a1 + 72),
                     *(_DWORD *)(a1 + 64),
                     0LL,
                     0);
        }
      }
      return TaskXmlReader::SetErrorInfoXmlLite((TaskXmlReader *)a1, v12);
    }
    if ( v62 == 3 )
    {
      v41 = _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::operator->(v10);
      v42 = a1 + 64;
      XmlParserTempString::Clear((XmlParserTempString *)(a1 + 64));
      v12 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v41 + 128LL))(v41, a1 + 72, a1 + 64);
      if ( v12 < 0 )
        return TaskXmlReader::SetErrorInfoXmlLite((TaskXmlReader *)a1, v12);
      v43 = XmlParserTempString::Trim((XmlParserTempString *)(a1 + 64));
      v44 = (_DWORD *)(a1 + 64);
      if ( v43 < 0 )
        return TaskXmlReader::SetErrorInfo((int *)a1, -2147216616, v5, (__int64)v44);
      v10 = (__int64 *)(a1 + 56);
      if ( *v44 )
      {
        if ( (_DWORD)v5 != 33 )
        {
          v44 = (_DWORD *)(a1 + 64);
          return TaskXmlReader::SetErrorInfo((int *)a1, -2147216616, v5, (__int64)v44);
        }
        XmlParserTempString::Clear((XmlParserTempString *)(a1 + 64));
        RawValue = TaskXmlReader::LoadRawValue((TaskXmlReader *)a1, (struct XmlParserTempString *)(a1 + 64));
        if ( RawValue >= 0 )
        {
          ITaskXmlHandler::Data::Data((ITaskXmlHandler::Data *)v75);
          v76 = a1 + 64;
          if ( v6 )
          {
            LOBYTE(v59) = *v63;
            v46 = (*(__int64 (__fastcall **)(__int64, __int64, __int64, char *, unsigned __int16 *))(*(_QWORD *)v6 + 8LL))(
                    v6,
                    a1 + 1116,
                    33LL,
                    v75,
                    v59);
            *v63 = 1;
            if ( v46 < 0 )
            {
              if ( (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v6 + 24LL))(v6) )
                v51 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v6 + 24LL))(v6);
              else
                v51 = 33;
              v52 = TaskXmlReader::SetErrorInfo((int *)a1, v46, v51, a1 + 64);
              operator delete(lpMem);
              return v52;
            }
            v42 = v76;
          }
          if ( *(_BYTE *)(a1 + 40) )
            TaskXmlWriter::WriteStringValue(*(TaskXmlWriter **)(a1 + 16), *(const unsigned __int16 **)(v42 + 8));
          operator delete(lpMem);
          v10 = (__int64 *)(a1 + 56);
        }
        else
        {
          TaskXmlReader::SetErrorInfo((int *)a1, RawValue, 33);
          v10 = (__int64 *)(a1 + 56);
        }
      }
      goto LABEL_3;
    }
    if ( v62 <= 6 )
      return TaskXmlReader::SetErrorInfo(
               (TaskXmlReader *)a1,
               -2147216618,
               *(char **)(a1 + 72),
               *(_DWORD *)(a1 + 64),
               0LL,
               0);
  }
  while ( v62 <= 8 );
  if ( v62 != 15 )
    return TaskXmlReader::SetErrorInfo(
             (TaskXmlReader *)a1,
             -2147216618,
             *(char **)(a1 + 72),
             *(_DWORD *)(a1 + 64),
             0LL,
             0);
LABEL_54:
  v29 = 0;
  v30 = *(_DWORD *)(a1 + 1116);
  while ( 2 )
  {
    if ( v30 == 65542 )
    {
LABEL_56:
      v31 = &(&Schema::schemaEntries)[(unsigned __int16)v30][16 * v5];
      goto LABEL_57;
    }
    if ( v30 < 0x10000 )
    {
LABEL_137:
      v31 = (const struct SchemaEntry **)&unk_180096000;
    }
    else
    {
      if ( v30 > 65537 )
      {
        if ( v30 <= 65541 )
          goto LABEL_56;
        goto LABEL_137;
      }
      v55 = 0LL;
      v56 = (&Schema::schemaEntriesCount)[(unsigned __int16)v30];
      if ( !v56 )
        goto LABEL_137;
      v31 = (&Schema::schemaEntries)[(unsigned __int16)v30];
      while ( *(_DWORD *)v31 != (_DWORD)v5 )
      {
        ++v55;
        v31 += 16;
        if ( v55 >= (unsigned __int64)v56 )
          goto LABEL_137;
      }
    }
LABEL_57:
    v32 = *(int *)((char *)v31 + v11);
    if ( !(_DWORD)v32 )
      return 0LL;
    if ( v30 == 65542 )
    {
LABEL_59:
      v33 = &(&Schema::schemaEntries)[(unsigned __int16)v30][16 * v32];
      goto LABEL_60;
    }
    if ( v30 < 0x10000 )
      goto LABEL_142;
    if ( v30 > 65537 )
    {
      if ( v30 <= 65541 )
        goto LABEL_59;
      goto LABEL_142;
    }
    v57 = 0LL;
    v58 = (&Schema::schemaEntriesCount)[(unsigned __int16)v30];
    if ( !v58 )
    {
LABEL_142:
      v33 = (const struct SchemaEntry **)&unk_180096000;
      goto LABEL_60;
    }
    v33 = (&Schema::schemaEntries)[(unsigned __int16)v30];
    while ( *(_DWORD *)v33 != (_DWORD)v32 )
    {
      ++v57;
      v33 += 16;
      if ( v57 >= (unsigned __int64)v58 )
        goto LABEL_142;
    }
LABEL_60:
    if ( *((_DWORD *)v33 + 6) == 2 || !*((_DWORD *)v33 + 8) )
    {
LABEL_62:
      ++v29;
      v11 += 4LL;
      if ( v29 >= 0x16 )
        return 0LL;
      continue;
    }
    break;
  }
  v34 = 0;
  if ( (_DWORD)v9 )
  {
    v35 = v78;
    while ( *v35 != (_DWORD)v32 )
    {
      ++v34;
      v35 += 2;
      if ( v34 >= (unsigned int)v9 )
        goto LABEL_143;
    }
    goto LABEL_62;
  }
LABEL_143:
  v53 = v32;
  v54 = -2147216615;
  return TaskXmlReader::SetErrorInfo((int *)a1, v54, v53);
}
// 180017989: variable 'v25' is possibly undefined
// 180017C0D: variable 'v39' is possibly undefined
// 180017C0A: variable 'v40' is possibly undefined
// 18004658F: variable 'v38' is possibly undefined
// 180046669: variable 'v59' is possibly undefined
// 180017C40: using guessed type __int64 __fastcall TaskXmlReader::ProcessElement(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 180071858: using guessed type void *_com_error::`vftable';
// 1800719A8: using guessed type const struct SchemaEntry * near *Schema::schemaEntries;
// 18007D588: using guessed type const unsigned __int64 near *const Schema::schemaEntriesCount;
// 180017770: using guessed type char var_1D0[4];

//----- (0000000180017C40) ----------------------------------------------------
__int64 __fastcall TaskXmlReader::ProcessElement(__int64 a1, __int64 a2, unsigned int a3, char a4, _BYTE *a5)
{
  __int64 v5; // r15
  char v10; // al
  int v11; // eax
  __int64 result; // rax
  unsigned int v13; // edi
  int v14; // eax
  int v15; // r15d
  int v16; // eax
  int v17; // eax
  void **pExceptionObject; // [rsp+30h] [rbp-38h] BYREF
  int v19; // [rsp+38h] [rbp-30h]
  __int128 v20; // [rsp+40h] [rbp-28h]

  v5 = *(_QWORD *)(a1 + 56);
  if ( !v5 )
  {
    v19 = -2147467261;
    pExceptionObject = &_com_error::`vftable';
    v20 = 0LL;
    CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI1_AV_com_error__);
  }
  v10 = *(_BYTE *)(a1 + 1106);
  if ( (v10 & 1) != 0 )
  {
    SysFreeString(*(BSTR *)(a1 + 72));
    v10 = *(_BYTE *)(a1 + 1106);
  }
  *(_DWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0LL;
  *(_BYTE *)(a1 + 1106) = v10 & 0xFC;
  *(_WORD *)(a1 + 80) = 0;
  v11 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v5 + 104LL))(v5, a1 + 72, a1 + 64);
  if ( v11 < 0 )
  {
    result = TaskXmlReader::SetErrorInfoXmlLite((TaskXmlReader *)a1, v11);
    goto LABEL_28;
  }
  if ( (*((_DWORD *)Schema::GetEntry((int *)(a1 + 1116), a3) + 6) != 2 || *(_DWORD *)(a1 + 64))
    && (*(_DWORD *)(a1 + 64) != 53 || wcsncmp(*(const wchar_t **)(a1 + 72), Schema::namespaceUri, 0x35uLL)) )
  {
    result = TaskXmlReader::SetErrorInfo((int *)a1, -2147216617, a3, a1 + 64);
LABEL_28:
    if ( (int)result < 0 )
      return result;
  }
  if ( *((_DWORD *)Schema::GetEntry((int *)(a1 + 1116), a3) + 7) )
  {
    result = TaskXmlReader::ProcessAttributes(a1, a2, a3, a5);
    if ( (int)result >= 0 )
    {
      result = TaskXmlReader::ProcessSimpleContent(a1, a2, a3, a4, a5);
      v13 = result;
      if ( (int)result >= 0 )
        return v13;
    }
  }
  else
  {
    *(_BYTE *)(a1 + 1112) = 0;
    if ( a2
      && (v14 = (**(__int64 (__fastcall ***)(__int64, __int64, _QWORD))a2)(a2, a1 + 1116, a3),
          *a5 = 1,
          v15 = v14,
          v14 < 0) )
    {
      if ( (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)a2 + 24LL))(a2) )
      {
        v16 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a2 + 24LL))(a2);
        return TaskXmlReader::SetErrorInfo((int *)a1, v15, v16);
      }
      else
      {
        return TaskXmlReader::SetErrorInfo((int *)a1, v15, a3);
      }
    }
    else
    {
      result = TaskXmlReader::ProcessAttributes(a1, a2, a3, a5);
      if ( (int)result >= 0 )
      {
        result = TaskXmlReader::ProcessComplexContent(a1, a2, a3, a4, a5);
        v13 = result;
        if ( (int)result >= 0 )
        {
          if ( a2
            && (v13 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(*(_QWORD *)a2 + 16LL))(a2, a1 + 1116, a3),
                (v13 & 0x80000000) != 0) )
          {
            if ( (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)a2 + 24LL))(a2) )
            {
              v17 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a2 + 24LL))(a2);
              return TaskXmlReader::SetErrorInfo((int *)a1, v13, v17);
            }
            else
            {
              return TaskXmlReader::SetErrorInfo((int *)a1, v13, a3);
            }
          }
          else
          {
            if ( !*(_BYTE *)(a1 + 40) )
              return v13;
            if ( a3 == 1 )
              return v13;
            result = TaskXmlWriter::EndElement(*(_QWORD *)(a1 + 16));
            v13 = result;
            if ( (int)result >= 0 )
              return v13;
          }
        }
      }
    }
  }
  return result;
}
// 180071858: using guessed type void *_com_error::`vftable';

//----- (0000000180017E38) ----------------------------------------------------
__int64 __fastcall TaskXmlReader::ProcessAttributes(__int64 a1, __int64 a2, int a3, _BYTE *a4)
{
  unsigned int v6; // esi
  __int64 *v7; // r14
  int v8; // eax
  const struct SchemaEntry * near *v9; // rbx
  int *v10; // r10
  __int64 result; // rax
  const struct SchemaEntry * near *v12; // rax
  int v13; // edx
  __int64 v14; // r10
  int v15; // r11d
  __int64 v16; // rbx
  __int64 v17; // rax
  int v18; // ebx
  int v19; // eax
  int v20; // r14d
  const struct SchemaEntry * near *Entry; // rax
  unsigned int v22; // ecx
  int Value; // ebx
  __int64 v24; // r9
  int *v25; // rax
  int v26; // ecx
  int *i; // rax
  __int64 *v28; // [rsp+30h] [rbp-A9h] BYREF
  wchar_t *String1; // [rsp+38h] [rbp-A1h] BYREF
  _BYTE *v30; // [rsp+40h] [rbp-99h]
  __int64 v31; // [rsp+48h] [rbp-91h]
  __int64 v32; // [rsp+50h] [rbp-89h]
  void **pExceptionObject; // [rsp+58h] [rbp-81h] BYREF
  int v34; // [rsp+60h] [rbp-79h]
  __int128 v35; // [rsp+68h] [rbp-71h]
  int v36[24]; // [rsp+80h] [rbp-59h] BYREF

  v32 = -2LL;
  v30 = a4;
  v31 = a2;
  v6 = 0;
  String1 = 0LL;
  v7 = (__int64 *)(a1 + 56);
  while ( 1 )
  {
    if ( !*v7 )
    {
      pExceptionObject = &_com_error::`vftable';
      v34 = -2147467261;
      v35 = 0LL;
      CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI1_AV_com_error__);
    }
    v8 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)*v7 + 72LL))(*v7);
    if ( v8 )
      break;
    v16 = _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::operator->(v7);
    XmlParserTempString::Clear((XmlParserTempString *)(a1 + 64));
    v8 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v16 + 112LL))(v16, a1 + 72, a1 + 64);
    if ( v8 < 0 )
      return TaskXmlReader::SetErrorInfoXmlLite((TaskXmlReader *)a1, v8);
    if ( *(_DWORD *)(a1 + 64) && !XmlParserTempString::IsEqualTo((const wchar_t **)(a1 + 64), L"xmlns", 5uLL) )
    {
      v17 = _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::operator->(v7);
      v8 = (*(__int64 (__fastcall **)(__int64, wchar_t **, _QWORD))(*(_QWORD *)v17 + 120LL))(v17, &String1, 0LL);
      if ( v8 < 0 )
        return TaskXmlReader::SetErrorInfoXmlLite((TaskXmlReader *)a1, v8);
      if ( !String1 || wcscmp_0(String1, L"xmlns") )
      {
        v18 = 0;
        while ( 1 )
        {
          v19 = Schema::ChildId((int *)(a1 + 1116), a3);
          v20 = v19;
          if ( !v19 )
            return TaskXmlReader::SetErrorInfo(
                     (TaskXmlReader *)a1,
                     -2147216618,
                     *(char **)(a1 + 72),
                     *(_DWORD *)(a1 + 64),
                     0LL,
                     0);
          Entry = Schema::GetEntry((int *)(a1 + 1116), v19);
          if ( *((_DWORD *)Entry + 6) != 2 )
            return TaskXmlReader::SetErrorInfo(
                     (TaskXmlReader *)a1,
                     -2147216618,
                     *(char **)(a1 + 72),
                     *(_DWORD *)(a1 + 64),
                     0LL,
                     0);
          if ( XmlParserTempString::IsEqualTo(
                 (const wchar_t **)(a1 + 64),
                 (const unsigned __int16 *)Entry[1],
                 *((unsigned int *)Entry + 4)) )
          {
            break;
          }
          if ( (unsigned int)++v18 >= 0x16 )
            return TaskXmlReader::SetErrorInfo(
                     (TaskXmlReader *)a1,
                     -2147216618,
                     *(char **)(a1 + 72),
                     *(_DWORD *)(a1 + 64),
                     0LL,
                     0);
        }
        result = TaskXmlReader::ValidateNamespace(a1, v20);
        if ( (int)result < 0 )
          return result;
        if ( *(_BYTE *)(a1 + 40) && a3 != 1 )
        {
          v28 = 0LL;
          Value = TaskXmlReader::LoadValue((TaskXmlReader *)a1, (struct _bstr_t *)&v28);
          if ( Value < 0
            || (!v28 ? (v24 = 0LL) : (v24 = *v28),
                Value = TaskXmlWriter::StartElementWithAttribute(*(_QWORD *)(a1 + 16), a3, v20, v24),
                Value < 0) )
          {
            _bstr_t::_Free((_bstr_t *)&v28);
            return (unsigned int)Value;
          }
          _bstr_t::_Free((_bstr_t *)&v28);
        }
        result = TaskXmlReader::ProcessSimpleContent(a1, v31, v20, 0, v30);
        if ( (int)result < 0 )
          return result;
        v22 = 0;
        if ( v6 )
        {
          v25 = v36;
          while ( *v25 != v20 )
          {
            ++v22;
            ++v25;
            if ( v22 >= v6 )
              goto LABEL_33;
          }
        }
        else
        {
LABEL_33:
          if ( v6 < 0x16 )
          {
            v36[v6++] = v20;
            v7 = (__int64 *)(a1 + 56);
            continue;
          }
        }
        return TaskXmlReader::SetErrorInfo(
                 (TaskXmlReader *)a1,
                 -2147216611,
                 *(char **)(a1 + 72),
                 *(_DWORD *)(a1 + 64),
                 0LL,
                 0);
      }
    }
  }
  if ( v8 < 0 )
    return TaskXmlReader::SetErrorInfoXmlLite((TaskXmlReader *)a1, v8);
  v9 = Schema::GetEntry((int *)(a1 + 1116), a3);
  v10 = (int *)(v9 + 5);
  do
  {
    if ( !*v10 )
      break;
    v12 = Schema::GetEntry((int *)(a1 + 1116), *v10);
    if ( *((_DWORD *)v12 + 6) != 2 )
      break;
    if ( *((_DWORD *)v12 + 8) )
    {
      v26 = 0;
      if ( !v6 )
        return TaskXmlReader::SetErrorInfo((int *)a1, -2147216615, v13);
      for ( i = v36; *i != v13; ++i )
      {
        if ( ++v26 >= v6 )
          return TaskXmlReader::SetErrorInfo((int *)a1, -2147216615, v13);
      }
    }
    v10 = (int *)(v14 + 4);
  }
  while ( (unsigned int)(v15 + 1) < 0x16 );
  if ( !*(_BYTE *)(a1 + 40) )
    return 0LL;
  if ( a3 == 1 )
    return 0LL;
  if ( v6 )
    return 0LL;
  if ( *((_DWORD *)v9 + 7) )
    return 0LL;
  result = TaskXmlWriter::StartElement(*(int **)(a1 + 16), a3);
  if ( (int)result >= 0 )
    return 0LL;
  return result;
}
// 180017F15: variable 'v14' is possibly undefined
// 180017F12: variable 'v15' is possibly undefined
// 180046AEA: variable 'v13' is possibly undefined
// 180071858: using guessed type void *_com_error::`vftable';
// 180017E38: using guessed type int var_B0[24];

//----- (0000000180018100) ----------------------------------------------------
__int64 __fastcall TaskXmlReader::ProcessSimpleContent(__int64 a1, __int64 a2, int a3, char a4, _BYTE *a5)
{
  WCHAR *v6; // r13
  int v9; // ebx
  int TranslatedString; // edi
  int v11; // esi
  int *v12; // r10
  int v13; // eax
  int Value; // eax
  __int64 v15; // rdx
  unsigned int *v17; // r15
  char v18; // al
  int RawValue; // eax
  const unsigned __int16 *v20; // r8
  int v21; // edx
  int Timespan; // eax
  __int64 v23; // rbx
  __int64 v24; // r8
  int v25; // edx
  int v26; // eax
  int InstancePolicy; // eax
  int v28; // eax
  int MaxNode; // eax
  unsigned int v30; // r8d
  int v31; // eax
  HRESULT v32; // eax
  int RunLevel; // eax
  __int64 v34; // rbx
  char *v35; // r13
  unsigned int v36; // esi
  OLECHAR *v37; // rbx
  int v38; // eax
  int v39; // eax
  int v40; // eax
  int v41; // eax
  int Logon; // eax
  int v43; // eax
  __int64 v44; // rax
  int v45; // eax
  int v46; // eax
  int v47; // edx
  int ProcessTokenSidType; // eax
  int Privilege; // eax
  int Week; // eax
  __int64 v51; // rcx
  int v52; // eax
  int DayOfMonth; // eax
  __int64 v54; // rcx
  __int64 v55; // r9
  int v56; // r8d
  int v57; // [rsp+28h] [rbp-A1h]
  LPOLESTR lpsz; // [rsp+48h] [rbp-81h] BYREF
  unsigned __int16 v59[2]; // [rsp+50h] [rbp-79h] BYREF
  unsigned __int16 v60; // [rsp+54h] [rbp-75h] BYREF
  unsigned __int16 v61[2]; // [rsp+58h] [rbp-71h] BYREF
  unsigned __int16 v62; // [rsp+5Ch] [rbp-6Dh] BYREF
  unsigned __int16 v63[2]; // [rsp+60h] [rbp-69h] BYREF
  unsigned __int16 v64; // [rsp+64h] [rbp-65h] BYREF
  unsigned __int16 v65[8]; // [rsp+68h] [rbp-61h] BYREF
  SYSTEMTIME v66; // [rsp+78h] [rbp-51h] BYREF
  __int64 v67; // [rsp+88h] [rbp-41h]
  int v68; // [rsp+90h] [rbp-39h]
  unsigned __int16 v69; // [rsp+94h] [rbp-35h]
  IID rclsid; // [rsp+98h] [rbp-31h] BYREF
  __int64 v71; // [rsp+A8h] [rbp-21h]
  LPVOID lpMem; // [rsp+B0h] [rbp-19h] BYREF
  unsigned int v73[4]; // [rsp+B8h] [rbp-11h] BYREF
  unsigned int v74; // [rsp+C8h] [rbp-1h] BYREF
  unsigned int v75; // [rsp+CCh] [rbp+3h] BYREF
  unsigned int v76; // [rsp+D0h] [rbp+7h] BYREF
  unsigned int v77; // [rsp+D4h] [rbp+Bh] BYREF
  unsigned int v78; // [rsp+D8h] [rbp+Fh] BYREF
  unsigned int v79; // [rsp+DCh] [rbp+13h] BYREF
  __int64 v80; // [rsp+E0h] [rbp+17h]

  v80 = -2LL;
  LODWORD(v6) = a3;
  v9 = 0;
  TranslatedString = 0;
  LOBYTE(v66.wYear) = 0;
  GetSystemTimeAsFileTime((LPFILETIME)&v66.wHour);
  v67 = 0LL;
  v68 = 0;
  v69 = 0;
  lpMem = 0LL;
  *(_BYTE *)(a1 + 1112) = 1;
  v11 = *((_DWORD *)Schema::GetEntry((int *)(a1 + 1116), (int)v6) + 7);
  if ( (v11 < 9 && v11 >= 2 || v11 < 0 || v11 > 1 && v11 != 26 && v11 != 11 && v11 != 9) && a4 )
  {
    v43 = TaskXmlReader::SetErrorInfo((int *)a1, -2147216616, (int)v6);
LABEL_192:
    TranslatedString = v43;
    goto LABEL_21;
  }
  if ( v11 == 8 )
  {
    Value = TaskXmlReader::LoadValue((TaskXmlReader *)a1, (bool *)&rclsid);
    TranslatedString = Value;
    if ( Value < 0 )
      TranslatedString = TaskXmlReader::SetErrorInfo((int *)a1, Value, (int)v6, a1 + 64);
    v71 = a1 + 64;
    if ( *(_BYTE *)(a1 + 40) )
    {
      v20 = L"true";
      if ( !LOBYTE(rclsid.Data1) )
        v20 = L"false";
      TranslatedString = TaskXmlWriter::Element(*(_QWORD *)(a1 + 16), (int)v6, (__int64)v20);
      if ( TranslatedString < 0 )
        goto LABEL_137;
    }
  }
  else
  {
    if ( v11 != 6 )
    {
      v6 = &_ImageBase;
      switch ( v11 )
      {
        case 0:
          goto LABEL_34;
        case 1:
        case 2:
        case 7:
          break;
        case 3:
          Timespan = TaskXmlReader::LoadTimespan((const unsigned __int16 **)a1, &rclsid.Data1);
          TranslatedString = Timespan;
          v23 = a1 + 64;
          LODWORD(v6) = a3;
          if ( Timespan >= 0 )
            goto LABEL_52;
          goto LABEL_132;
        case 4:
          Timespan = TaskXmlReader::LoadDateTime((const unsigned __int16 **)a1, &v66);
          TranslatedString = Timespan;
          v23 = a1 + 64;
          LODWORD(v6) = a3;
          if ( Timespan < 0 )
            goto LABEL_132;
          goto LABEL_52;
        case 5:
          LOWORD(rclsid.Data1) = 0;
          v38 = TaskXmlReader::LoadValue((TaskXmlReader *)a1, (unsigned __int16 *)&rclsid);
          TranslatedString = v38;
          LODWORD(v6) = a3;
          if ( v38 < 0 )
            TranslatedString = TaskXmlReader::SetErrorInfo((int *)a1, v38, a3, a1 + 64);
          v71 = a1 + 64;
          if ( !*(_BYTE *)(a1 + 40) )
            goto LABEL_17;
          goto LABEL_107;
        case 6:
        case 8:
          LODWORD(v6) = a3;
          goto LABEL_183;
        case 9:
          if ( a4 )
            goto LABEL_143;
          v44 = _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::operator->((__int64 *)(a1 + 56));
          v45 = (*(__int64 (__fastcall **)(__int64, LPOLESTR *))(*(_QWORD *)v44 + 48LL))(v44, &lpsz);
          TranslatedString = v45;
          if ( v45 < 0 )
          {
            TranslatedString = TaskXmlReader::SetErrorInfoXmlLite((TaskXmlReader *)a1, v45);
            goto LABEL_137;
          }
          if ( !v45 && (_DWORD)lpsz == 15 )
          {
LABEL_143:
            LODWORD(v6) = a3;
          }
          else
          {
            LODWORD(v6) = a3;
            TranslatedString = TaskXmlReader::SetErrorInfo((int *)a1, -2147216616, a3, a1 + 64);
          }
          v71 = 0LL;
          if ( !*(_BYTE *)(a1 + 40) )
            goto LABEL_17;
          v24 = 0LL;
LABEL_54:
          v25 = (int)v6;
LABEL_55:
          v26 = TaskXmlWriter::Element(*(_QWORD *)(a1 + 16), v25, v24);
          goto LABEL_56;
        case 10:
          v31 = TaskXmlReader::LoadValue((TaskXmlReader *)a1, &rclsid);
          TranslatedString = v31;
          LODWORD(v6) = a3;
          if ( v31 < 0 )
            TranslatedString = TaskXmlReader::SetErrorInfo((int *)a1, v31, a3, a1 + 64);
          v71 = a1 + 64;
          if ( !*(_BYTE *)(a1 + 40) )
            goto LABEL_17;
          v32 = StringFromCLSID(&rclsid, &lpsz);
          TranslatedString = v32;
          if ( v32 )
          {
            if ( v32 > 0 )
              TranslatedString = (unsigned __int16)v32 | 0x80070000;
            goto LABEL_137;
          }
          TranslatedString = TaskXmlWriter::Element(*(_QWORD *)(a1 + 16), a3, (__int64)lpsz);
          if ( TranslatedString < 0 )
            goto LABEL_137;
          CoTaskMemFree(lpsz);
          goto LABEL_17;
        case 11:
          v23 = a1 + 64;
          XmlParserTempString::Clear((XmlParserTempString *)(a1 + 64));
          if ( a4 )
          {
            LODWORD(v6) = a3;
          }
          else
          {
            Timespan = TaskXmlReader::LoadRawValue((TaskXmlReader *)a1, (struct XmlParserTempString *)(a1 + 64));
            TranslatedString = Timespan;
            LODWORD(v6) = a3;
            if ( Timespan < 0 )
LABEL_132:
              TranslatedString = TaskXmlReader::SetErrorInfo((int *)a1, Timespan, (int)v6, v23);
          }
LABEL_52:
          v71 = v23;
          if ( !*(_BYTE *)(a1 + 40) )
            goto LABEL_17;
          v24 = *(_QWORD *)(a1 + 72);
          goto LABEL_54;
        case 12:
          v39 = TaskXmlReader::LoadValue((TaskXmlReader *)a1, (unsigned __int16 *)&rclsid);
          TranslatedString = v39;
          LODWORD(v6) = a3;
          if ( v39 < 0 )
          {
            v47 = v39;
          }
          else
          {
            if ( LOWORD(rclsid.Data1) <= 0xAu )
              goto LABEL_113;
            v47 = -2147216616;
          }
          TranslatedString = TaskXmlReader::SetErrorInfo((int *)a1, v47, a3, a1 + 64);
LABEL_113:
          v71 = a1 + 64;
          if ( !*(_BYTE *)(a1 + 40) )
            goto LABEL_17;
LABEL_107:
          v26 = TaskXmlWriter::ElementInt(*(_QWORD *)(a1 + 16), (int)v6, LOWORD(rclsid.Data1));
          goto LABEL_56;
        case 13:
          Logon = TaskXmlReader::LoadLogon((TaskXmlReader *)a1, (enum JobFlags::JobFlag *)&rclsid);
          TranslatedString = Logon;
          LODWORD(v6) = a3;
          if ( Logon < 0 )
            TranslatedString = TaskXmlReader::SetErrorInfo((int *)a1, Logon, a3, a1 + 64);
          v71 = a1 + 64;
          if ( !*(_BYTE *)(a1 + 40) )
            goto LABEL_17;
          v26 = TaskXmlWriter::ElementLogonType(*(_QWORD *)(a1 + 16), a3, rclsid.Data1);
          goto LABEL_56;
        case 14:
          RunLevel = TaskXmlReader::LoadRunLevel((TaskXmlReader *)a1, (enum JobFlags::JobFlag *)&rclsid);
          TranslatedString = RunLevel;
          LODWORD(v6) = a3;
          if ( RunLevel < 0 )
            TranslatedString = TaskXmlReader::SetErrorInfo((int *)a1, RunLevel, a3, a1 + 64);
          v71 = a1 + 64;
          if ( !*(_BYTE *)(a1 + 40) || (rclsid.Data1 & 0x1000000) == 0 )
            goto LABEL_17;
          v26 = TaskXmlWriter::ElementRunLevel(*(_QWORD *)(a1 + 16), a3, 1);
          goto LABEL_56;
        case 15:
          LOWORD(rclsid.Data1) = 0;
          Week = TaskXmlReader::LoadWeek((TaskXmlReader *)a1, (unsigned __int16 *)&rclsid);
          TranslatedString = Week;
          LODWORD(v6) = a3;
          if ( Week < 0 )
            TranslatedString = TaskXmlReader::SetErrorInfo((int *)a1, Week, a3, a1 + 64);
          v71 = a1 + 64;
          if ( *(_BYTE *)(a1 + 40) )
          {
            v51 = *(_QWORD *)(a1 + 16);
            v46 = LOWORD(rclsid.Data1) == 5
                ? TaskXmlWriter::Element(v51, 70, (__int64)L"Last")
                : TaskXmlWriter::ElementInt(v51, 70, LOWORD(rclsid.Data1));
            TranslatedString = v46;
            if ( v46 < 0 )
              goto LABEL_138;
          }
          goto LABEL_17;
        case 16:
          InstancePolicy = TaskXmlReader::LoadInstancePolicy((TaskXmlReader *)a1, (enum JobFlags::JobFlag *)&rclsid);
          TranslatedString = InstancePolicy;
          LODWORD(v6) = a3;
          if ( InstancePolicy < 0 )
            TranslatedString = TaskXmlReader::SetErrorInfo((int *)a1, InstancePolicy, a3, a1 + 64);
          v71 = a1 + 64;
          if ( *(_BYTE *)(a1 + 40) )
          {
            TranslatedString = TaskXmlWriter::ElementMultipleInstancesPolicy(*(_QWORD *)(a1 + 16), rclsid.Data1);
            if ( TranslatedString < 0 )
              goto LABEL_139;
          }
          goto LABEL_17;
        case 17:
          v52 = TaskXmlReader::SkipElement((TaskXmlReader *)a1);
          TranslatedString = v52;
          LODWORD(v6) = a3;
          if ( v52 < 0 )
            TranslatedString = TaskXmlReader::SetErrorInfo((int *)a1, v52, a3, a1 + 64);
          v71 = a1 + 64;
          goto LABEL_17;
        case 18:
          LOWORD(rclsid.Data1) = 0;
          DayOfMonth = TaskXmlReader::LoadDayOfMonth((TaskXmlReader *)a1, (unsigned __int16 *)&rclsid);
          TranslatedString = DayOfMonth;
          LODWORD(v6) = a3;
          if ( DayOfMonth < 0 )
            TranslatedString = TaskXmlReader::SetErrorInfo((int *)a1, DayOfMonth, a3, a1 + 64);
          v71 = a1 + 64;
          if ( *(_BYTE *)(a1 + 40) )
          {
            v54 = *(_QWORD *)(a1 + 16);
            v43 = LOWORD(rclsid.Data1) == 32
                ? TaskXmlWriter::Element(v54, 68, (__int64)L"Last")
                : TaskXmlWriter::ElementInt(v54, 68, LOWORD(rclsid.Data1));
            TranslatedString = v43;
            if ( v43 < 0 )
              goto LABEL_192;
          }
          goto LABEL_17;
        case 19:
          rclsid.Data1 = 0;
          v40 = TaskXmlReader::LoadSessionStateChange((TaskXmlReader *)a1, &rclsid.Data1);
          TranslatedString = v40;
          LODWORD(v6) = a3;
          if ( v40 < 0 )
            TranslatedString = TaskXmlReader::SetErrorInfo((int *)a1, v40, a3, a1 + 64);
          v71 = a1 + 64;
          if ( !*(_BYTE *)(a1 + 40) )
            goto LABEL_17;
          TranslatedString = TaskXmlWriter::ElementSessionStateChange(
                               *(TaskXmlWriter **)(a1 + 16),
                               LOWORD(rclsid.Data1));
          if ( TranslatedString >= 0 )
            goto LABEL_17;
          goto LABEL_21;
        case 20:
          LODWORD(lpsz) = 65542;
          v28 = TaskXmlReader::LoadValue((TaskXmlReader *)a1, (enum Schema::Version *)&lpsz);
          TranslatedString = v28;
          LODWORD(v6) = a3;
          if ( v28 < 0 )
            TranslatedString = TaskXmlReader::SetErrorInfo((int *)a1, v28, a3, a1 + 64);
          MaxNode = Schema::GetMaxNode((int *)&lpsz);
          while ( v9 < MaxNode )
            ++v9;
          v15 = a1 + 1116;
          *(_DWORD *)(a1 + 1116) = v30;
          rclsid.Data1 = v30;
          v71 = a1 + 64;
          goto LABEL_18;
        case 21:
          ProcessTokenSidType = TaskXmlReader::LoadProcessTokenSidType(
                                  (TaskXmlReader *)a1,
                                  (enum JobFlags::JobFlag *)&rclsid);
          TranslatedString = ProcessTokenSidType;
          LODWORD(v6) = a3;
          if ( ProcessTokenSidType < 0 )
            TranslatedString = TaskXmlReader::SetErrorInfo((int *)a1, ProcessTokenSidType, a3, a1 + 64);
          v71 = a1 + 64;
          if ( !*(_BYTE *)(a1 + 40) )
            goto LABEL_17;
          if ( (rclsid.Data1 & 0x8000000) != 0 )
          {
            v26 = TaskXmlWriter::ElementProcessTokenSidType(*(_QWORD *)(a1 + 16), a3, 0);
          }
          else
          {
            if ( (rclsid.Data1 & 0x10000000) == 0 )
              goto LABEL_17;
            v26 = TaskXmlWriter::ElementProcessTokenSidType(*(_QWORD *)(a1 + 16), a3, 1);
          }
LABEL_56:
          TranslatedString = v26;
          if ( v26 >= 0 )
            goto LABEL_17;
          goto LABEL_137;
        case 22:
          Privilege = TaskXmlReader::LoadPrivilege((const WCHAR **)a1, (unsigned __int64 *)&rclsid.Data1);
          TranslatedString = Privilege;
          LODWORD(v6) = a3;
          if ( Privilege < 0 )
            TranslatedString = TaskXmlReader::SetErrorInfo((int *)a1, Privilege, a3, a1 + 64);
          v71 = a1 + 64;
          if ( !*(_BYTE *)(a1 + 40) )
            goto LABEL_17;
          v24 = *(_QWORD *)(a1 + 72);
          v25 = 135;
          goto LABEL_55;
        case 23:
          v74 = 0;
          v75 = 0;
          v77 = 0;
          v76 = 0;
          v78 = 0;
          v79 = 0;
          LODWORD(lpsz) = 0;
          TranslatedString = TaskXmlReader::LoadPeriod(
                               (const unsigned __int16 **)a1,
                               &v74,
                               &v75,
                               &v76,
                               &v77,
                               &v78,
                               &v79,
                               (unsigned int *)&lpsz);
          v59[0] = 0;
          v60 = 0;
          v62 = 0;
          v61[0] = 0;
          v63[0] = 0;
          v64 = 0;
          v65[0] = 0;
          if ( TranslatedString < 0
            || (TranslatedString = ULongToUShort(v74, v59), TranslatedString < 0)
            || (TranslatedString = ULongToUShort(v75, &v60), TranslatedString < 0)
            || (TranslatedString = ULongToUShort(v76, v61), TranslatedString < 0)
            || (TranslatedString = ULongToUShort(v77, &v62), TranslatedString < 0)
            || (TranslatedString = ULongToUShort(v78, v63), TranslatedString < 0)
            || (TranslatedString = ULongToUShort(v79, &v64), TranslatedString < 0)
            || (TranslatedString = ULongToUShort((unsigned int)lpsz, v65), TranslatedString < 0) )
          {
            v34 = a1 + 64;
            LODWORD(v6) = a3;
            TranslatedString = TaskXmlReader::SetErrorInfo((int *)a1, TranslatedString, a3, a1 + 64);
          }
          else
          {
            LOWORD(v67) = v59[0];
            WORD1(v67) = v60;
            WORD2(v67) = v61[0];
            HIWORD(v67) = v62;
            LOWORD(v68) = v63[0];
            HIWORD(v68) = v64;
            v69 = v65[0];
            v34 = a1 + 64;
            LODWORD(v6) = a3;
          }
          v71 = v34;
          if ( *(_BYTE *)(a1 + 40) )
          {
            TranslatedString = TaskXmlWriter::Element(*(_QWORD *)(a1 + 16), (int)v6, *(_QWORD *)(a1 + 72));
            if ( TranslatedString < 0 )
              goto LABEL_137;
          }
          goto LABEL_17;
        case 24:
        case 26:
          v13 = TaskXmlReader::LoadHexString((tsched **)a1, &lpMem, (unsigned __int8 *)v73);
          TranslatedString = v13;
          LODWORD(v6) = a3;
          if ( v13 < 0 )
            TranslatedString = TaskXmlReader::SetErrorInfo((int *)a1, v13, a3, a1 + 64);
          if ( v11 == 24 && *(_DWORD *)(a1 + 64) != 16 )
          {
            v55 = a1 + 64;
            goto LABEL_131;
          }
          v71 = a1 + 64;
          if ( *(_BYTE *)(a1 + 40) )
          {
            TranslatedString = TaskXmlWriter::ElementHexString(*(_QWORD *)(a1 + 16), a3, (tsched *)lpMem, v73[0]);
            if ( TranslatedString < 0 )
              goto LABEL_137;
          }
          goto LABEL_17;
        case 25:
          rclsid.Data1 = 0;
          v41 = TaskXmlReader::LoadValue((TaskXmlReader *)a1, &rclsid.Data1);
          TranslatedString = v41;
          LODWORD(v6) = a3;
          if ( v41 < 0 )
            TranslatedString = TaskXmlReader::SetErrorInfo((int *)a1, v41, a3, a1 + 64);
          v71 = a1 + 64;
          if ( !*(_BYTE *)(a1 + 40) )
            goto LABEL_17;
          v26 = TaskXmlWriter::ElementInt(*(_QWORD *)(a1 + 16), a3, rclsid.Data1);
          goto LABEL_56;
        default:
LABEL_183:
          TranslatedString = TaskXmlReader::SetErrorInfo((int *)a1, -2147216618, (int)v6);
          goto LABEL_17;
      }
    }
    v17 = (unsigned int *)(a1 + 64);
    v18 = *(_BYTE *)(a1 + 1106);
    if ( (v18 & 1) != 0 )
    {
      SysFreeString(*(BSTR *)(a1 + 72));
      v18 = *(_BYTE *)(a1 + 1106);
      v12 = (int *)(a1 + 1116);
    }
    *v17 = 0;
    *(_QWORD *)(a1 + 72) = 0LL;
    *(_BYTE *)(a1 + 1106) = v18 & 0xFC;
    *(_WORD *)(a1 + 80) = 0;
    if ( !a4 )
    {
      RawValue = TaskXmlReader::LoadRawValue((TaskXmlReader *)a1, (struct XmlParserTempString *)(a1 + 64));
      TranslatedString = RawValue;
      if ( RawValue < 0 )
      {
        LODWORD(v6) = a3;
        TranslatedString = TaskXmlReader::SetErrorInfo((int *)a1, RawValue, a3);
        goto LABEL_17;
      }
      v12 = (int *)(a1 + 1116);
    }
    if ( (v11 == 2 || v11 == 7) && !*v17 )
    {
      v55 = a1 + 64;
      LODWORD(v6) = a3;
LABEL_131:
      TranslatedString = TaskXmlReader::SetErrorInfo((int *)a1, -2147216616, (int)v6, v55);
      goto LABEL_17;
    }
    if ( v11 == 6 && !*v17 )
    {
      v55 = a1 + 64;
      LODWORD(v6) = a3;
      goto LABEL_131;
    }
    v71 = a1 + 64;
    if ( !*(_BYTE *)(a1 + 40) )
    {
LABEL_34:
      LODWORD(v6) = a3;
      goto LABEL_17;
    }
    if ( (a3 < 12 || a3 >= 112) && a3 >= 6 )
    {
      switch ( a3 )
      {
        case 6:
        case 8:
        case 10:
        case 11:
        case 112:
        case 115:
        case 121:
        case 129:
        case 130:
          v35 = *(char **)(a1 + 72);
          if ( v35 )
          {
            v36 = *v17;
            if ( *v17 )
            {
              v37 = (OLECHAR *)operator new(saturated_mul(v36 + 1, 2uLL));
              lpsz = v37;
              TranslatedString = StringCchCopyNW((char *)v37, v36 + 1, v35, v36);
              if ( TranslatedString >= 0 )
              {
                TranslatedString = TaskXmlReader::LoadTranslatedString((const wchar_t **)&lpsz);
                v37 = lpsz;
                if ( TranslatedString >= 0 )
                {
                  LODWORD(v6) = a3;
                  TranslatedString = TaskXmlWriter::Element(*(_QWORD *)(a1 + 16), a3, (__int64)lpsz);
                  if ( TranslatedString >= 0 )
                  {
                    operator delete(v37);
                    goto LABEL_17;
                  }
                }
              }
              operator delete(v37);
              goto LABEL_137;
            }
          }
          LODWORD(v6) = a3;
          TranslatedString = TaskXmlWriter::Element(*(_QWORD *)(a1 + 16), a3, (__int64)&ChannelPath);
          if ( TranslatedString >= 0 )
            goto LABEL_17;
          break;
        default:
          goto LABEL_47;
      }
      goto LABEL_21;
    }
LABEL_47:
    LODWORD(v6) = a3;
    if ( *((_DWORD *)Schema::GetEntry(v12, a3) + 6) != 2 )
      TranslatedString = TaskXmlWriter::Element(*(_QWORD *)(a1 + 16), v21, *(_QWORD *)(a1 + 72));
    if ( TranslatedString < 0 )
    {
LABEL_137:
      v46 = TranslatedString;
LABEL_138:
      TranslatedString = v46;
LABEL_139:
      v43 = TranslatedString;
      goto LABEL_192;
    }
  }
LABEL_17:
  v15 = a1 + 1116;
LABEL_18:
  *(_BYTE *)(a1 + 1112) = 0;
  if ( TranslatedString >= 0 )
  {
    if ( a2 )
    {
      LOBYTE(v57) = *a5;
      TranslatedString = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD, SYSTEMTIME *, int))(*(_QWORD *)a2 + 8LL))(
                           a2,
                           v15,
                           (unsigned int)v6,
                           &v66,
                           v57);
      *a5 = 1;
      if ( TranslatedString < 0 )
      {
        if ( (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)a2 + 24LL))(a2) )
          v56 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)a2 + 24LL))(a2);
        else
          v56 = (int)v6;
        v43 = TaskXmlReader::SetErrorInfo((int *)a1, TranslatedString, v56, a1 + 64);
        goto LABEL_192;
      }
    }
  }
LABEL_21:
  if ( lpMem )
    HeapFree(g_PrivateHeap, 0, lpMem);
  return (unsigned int)TranslatedString;
}
// 180018284: variable 'v57' is possibly undefined
// 1800183CA: variable 'v12' is possibly undefined
// 180018482: variable 'v21' is possibly undefined
// 18001851F: variable 'v30' is possibly undefined
// 180018100: using guessed type unsigned int var_60[4];
// 180018100: using guessed type unsigned __int16 var_C8[2];
// 180018100: using guessed type unsigned __int16 var_C0[2];
// 180018100: using guessed type unsigned __int16 var_B8[2];
// 180018100: using guessed type unsigned __int16 var_B0[8];

//----- (0000000180018AC0) ----------------------------------------------------
__int64 __fastcall _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::operator->(
        __int64 *a1)
{
  __int64 result; // rax
  void **pExceptionObject; // [rsp+20h] [rbp-28h] BYREF
  int v3; // [rsp+28h] [rbp-20h]
  __int128 v4; // [rsp+30h] [rbp-18h]

  result = *a1;
  if ( !*a1 )
  {
    v3 = -2147467261;
    pExceptionObject = &_com_error::`vftable';
    v4 = 0LL;
    CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI1_AV_com_error__);
  }
  return result;
}
// 180071858: using guessed type void *_com_error::`vftable';

//----- (0000000180018ADC) ----------------------------------------------------
__int64 __fastcall TaskXmlReader::LoadValue(TaskXmlReader *this, bool *a2)
{
  const wchar_t **v2; // rsi
  __int64 result; // rax
  bool v5; // bl

  v2 = (const wchar_t **)((char *)this + 64);
  result = TaskXmlReader::LoadRawValue(this, (TaskXmlReader *)((char *)this + 64));
  if ( (int)result >= 0 )
  {
    if ( !XmlParserTempString::IsEqualTo(v2, L"false", 5uLL) )
    {
      v5 = 1;
      if ( XmlParserTempString::IsEqualTo(v2, L"true", 4uLL) )
        goto LABEL_4;
      if ( !XmlParserTempString::IsEqualTo(v2, L"0", 1uLL) )
      {
        if ( !XmlParserTempString::IsEqualTo(v2, L"1", 1uLL) )
          return 2147750680LL;
        goto LABEL_4;
      }
    }
    v5 = 0;
LABEL_4:
    *a2 = v5;
    return 0LL;
  }
  return result;
}

//----- (0000000180018B58) ----------------------------------------------------
bool __fastcall XmlParserTempString::IsEqualTo(const wchar_t **this, const unsigned __int16 *a2, size_t a3)
{
  return *(_DWORD *)this == a3 && wcsncmp(this[1], a2, a3) == 0;
}

//----- (0000000180018B90) ----------------------------------------------------
__int64 __fastcall TaskXmlReader::LoadRawValue(TaskXmlReader *this, struct XmlParserTempString *a2)
{
  char v4; // al
  char v5; // si
  __int64 v6; // rcx
  int v7; // eax
  __int64 v8; // rcx
  __int64 v9; // rcx
  char v10; // r14
  __int64 v11; // rdi
  char v12; // al
  int v13; // eax
  int v14; // edi
  __int64 v15; // rcx
  char v16; // al
  int v17; // eax
  __int64 v18; // r9
  __int64 v19; // rdx
  _WORD *v20; // r8
  unsigned __int64 v21; // rax
  __int64 v23; // rax
  int v24; // [rsp+20h] [rbp-E0h] BYREF
  void **pExceptionObject; // [rsp+28h] [rbp-D8h] BYREF
  int v26; // [rsp+30h] [rbp-D0h]
  __int128 v27; // [rsp+38h] [rbp-C8h]
  __int64 v28; // [rsp+48h] [rbp-B8h]
  char *v29; // [rsp+50h] [rbp-B0h] BYREF
  BSTR bstrString; // [rsp+58h] [rbp-A8h] BYREF
  __int16 v31; // [rsp+60h] [rbp-A0h]
  char v32; // [rsp+462h] [rbp+362h]

  v28 = -2LL;
  v4 = *((_BYTE *)a2 + 1042);
  if ( (v4 & 1) != 0 )
  {
    SysFreeString(*((BSTR *)a2 + 1));
    v4 = *((_BYTE *)a2 + 1042);
  }
  *(_DWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0LL;
  *((_BYTE *)a2 + 1042) = v4 & 0xFC;
  *((_WORD *)a2 + 8) = 0;
  v5 = 0;
  v6 = *((_QWORD *)this + 7);
  if ( !v6 )
  {
    pExceptionObject = &_com_error::`vftable';
    v26 = -2147467261;
    v27 = 0LL;
    CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI1_AV_com_error__);
  }
  v7 = (*(__int64 (__fastcall **)(__int64, int *))(*(_QWORD *)v6 + 56LL))(v6, &v24);
  if ( v7 >= 0 )
  {
    if ( v24 )
    {
      if ( v24 == 1 )
      {
        v8 = *((_QWORD *)this + 7);
        if ( !v8 )
        {
          pExceptionObject = &_com_error::`vftable';
          v26 = -2147467261;
          v27 = 0LL;
          CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI1_AV_com_error__);
        }
        if ( (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v8 + 160LL))(v8) )
          return 0LL;
        v5 = 1;
      }
    }
    else
    {
      v5 = *((_BYTE *)this + 1112);
    }
    *((_BYTE *)this + 1112) = 0;
    if ( !v5 )
    {
LABEL_14:
      v10 = 1;
      while ( 1 )
      {
        v32 &= 0xFCu;
        LODWORD(v29) = 0;
        bstrString = 0LL;
        v31 = 0;
        v11 = *((_QWORD *)this + 7);
        if ( !v11 )
        {
          pExceptionObject = &_com_error::`vftable';
          v26 = -2147467261;
          v27 = 0LL;
          CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI1_AV_com_error__);
        }
        v12 = v32;
        if ( (v32 & 1) != 0 )
        {
          SysFreeString(bstrString);
          v12 = v32;
        }
        LODWORD(v29) = 0;
        bstrString = 0LL;
        v32 = v12 & 0xFC;
        v31 = 0;
        v13 = (*(__int64 (__fastcall **)(__int64, BSTR *, char **))(*(_QWORD *)v11 + 128LL))(v11, &bstrString, &v29);
        if ( v13 < 0 )
          break;
        if ( v10 )
        {
          v14 = XmlParserTempString::TrimLeft((XmlParserTempString *)&v29);
          if ( v14 < 0 )
            goto LABEL_55;
        }
        if ( (_DWORD)v29 )
        {
          v14 = XmlParserTempString::Append(a2, &v29);
          if ( v14 < 0 )
            goto LABEL_55;
          v10 = 0;
        }
        if ( v5 )
        {
          v15 = *((_QWORD *)this + 7);
          if ( !v15 )
          {
            pExceptionObject = &_com_error::`vftable';
            v26 = -2147467261;
            v27 = 0LL;
            CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI1_AV_com_error__);
          }
          v13 = (*(__int64 (__fastcall **)(__int64, int *))(*(_QWORD *)v15 + 48LL))(v15, &v24);
          if ( v13 < 0 )
            break;
          if ( v24 == 15 )
          {
            v5 = 0;
          }
          else if ( (unsigned int)(v24 - 3) > 1 && v24 != 13 )
          {
            v14 = -2147216618;
LABEL_55:
            XmlParserTempString::Clear((XmlParserTempString *)&v29);
            return (unsigned int)v14;
          }
        }
        v16 = v32;
        if ( (v32 & 1) != 0 )
        {
          SysFreeString(bstrString);
          v16 = v32;
        }
        LODWORD(v29) = 0;
        bstrString = 0LL;
        v32 = v16 & 0xFC;
        v31 = 0;
        if ( !v5 )
        {
          v17 = *(_DWORD *)a2;
          if ( *(_DWORD *)a2 && *((_QWORD *)a2 + 1) && v17 )
          {
            v18 = 0x100002600LL;
            do
            {
              v19 = (unsigned int)(v17 - 1);
              v20 = (_WORD *)(*((_QWORD *)a2 + 1) + 2 * v19);
              v21 = (unsigned __int16)*v20;
              if ( (unsigned int)v21 > 0x20 )
                break;
              if ( !_bittest64(&v18, v21) )
                break;
              *(_DWORD *)a2 = v19;
              *v20 = 0;
              v17 = *(_DWORD *)a2;
            }
            while ( *(_DWORD *)a2 );
          }
          return 0LL;
        }
      }
      v14 = TaskXmlReader::SetErrorInfoXmlLite(this, v13);
      goto LABEL_55;
    }
    while ( 1 )
    {
      v9 = *((_QWORD *)this + 7);
      if ( !v9 )
      {
        pExceptionObject = &_com_error::`vftable';
        v26 = -2147467261;
        v27 = 0LL;
        CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI1_AV_com_error__);
      }
      v7 = (*(__int64 (__fastcall **)(__int64, int *))(*(_QWORD *)v9 + 48LL))(v9, &v24);
      if ( v7 < 0 )
        break;
      if ( (unsigned int)(v24 - 3) <= 1 )
        goto LABEL_14;
      if ( v24 == 15 )
        return 0LL;
      if ( v24 == 1 )
      {
        v23 = _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::operator->((__int64 *)this + 7);
        if ( !(*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v23 + 160LL))(v23) )
          return 2147750678LL;
      }
    }
  }
  return TaskXmlReader::SetErrorInfoXmlLite(this, v7);
}
// 180071858: using guessed type void *_com_error::`vftable';

//----- (0000000180018E50) ----------------------------------------------------
__int64 __fastcall XmlParserTempString::Append(XmlParserTempString *this, char **a2)
{
  unsigned __int64 v4; // rcx
  char v5; // r8
  char *v6; // r10
  _WORD *v7; // rax
  __int64 v8; // r8
  char *v9; // rax
  int v10; // edi
  signed __int64 v11; // r9
  __int16 v12; // dx
  int v13; // eax
  __int64 result; // rax
  char *v15; // rax
  OLECHAR *v16; // rdi
  int v17; // esi
  char v18; // cl
  char v19; // cl
  void **pExceptionObject; // [rsp+20h] [rbp-48h] BYREF
  char v21; // [rsp+28h] [rbp-40h]
  const unsigned __int16 *v22; // [rsp+30h] [rbp-38h]
  __int64 v23; // [rsp+38h] [rbp-30h]
  __int64 v24; // [rsp+40h] [rbp-28h]
  int v25; // [rsp+48h] [rbp-20h]
  __int64 v26; // [rsp+4Ch] [rbp-1Ch]

  v4 = *(unsigned int *)a2;
  if ( !(_DWORD)v4 )
    return 0LL;
  v5 = *((_BYTE *)this + 1042);
  if ( (v5 & 1) != 0 || (unsigned int)(*(_DWORD *)this + v4) >= 0x200 )
  {
    v15 = (char *)SysAllocStringLen(0LL, (int)v4 + *(_DWORD *)this);
    v16 = (OLECHAR *)v15;
    if ( !v15 )
    {
      v21 = 0;
      v25 = 14;
      v23 = 0LL;
      v22 = &word_18007630E;
      v24 = 0LL;
      pExceptionObject = &wmi::OutOfMemoryException::`vftable';
      v26 = -1LL;
      CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI4_AVOutOfMemoryException_wmi__);
    }
    if ( *(_DWORD *)this
      && (v17 = StringCchCopyNW(
                  v15,
                  (unsigned int)(*(_DWORD *)this + 1 + *(_DWORD *)a2),
                  *((char **)this + 1),
                  *(unsigned int *)this),
          v17 < 0)
      || (v17 = StringCchCopyNW(
                  (char *)&v16[*(unsigned int *)this],
                  (unsigned int)(*(_DWORD *)a2 + 1),
                  a2[1],
                  *(unsigned int *)a2),
          v17 < 0) )
    {
      SysFreeString(v16);
      return (unsigned int)v17;
    }
    else
    {
      v18 = *((_BYTE *)this + 1042);
      if ( (v18 & 1) != 0 )
      {
        SysFreeString(*((BSTR *)this + 1));
        v18 = *((_BYTE *)this + 1042);
      }
      v19 = v18 & 0xFD;
      *((_QWORD *)this + 1) = v16;
      *((_BYTE *)this + 1042) = v19;
      *((_WORD *)this + 8) = 0;
      v13 = *(_DWORD *)a2;
      *((_BYTE *)this + 1042) = v19 | 1;
LABEL_15:
      *(_DWORD *)this += v13;
      return 0LL;
    }
  }
  else
  {
    if ( *(_DWORD *)this && (v5 & 2) == 0 )
    {
      result = StringCchCopyNW((char *)this + 16, 512LL, *((char **)this + 1), *(unsigned int *)this);
      if ( (int)result < 0 )
        return result;
      *((_QWORD *)this + 1) = (char *)this + 16;
      v4 = *(unsigned int *)a2;
    }
    v6 = (char *)this + 16;
    v7 = (_WORD *)((char *)this + 16);
    v8 = 512LL;
    while ( *v7 )
    {
      ++v7;
      if ( !--v8 )
        return (unsigned int)-2147024809;
    }
    if ( v4 > 0x7FFFFFFE )
      return (unsigned int)-2147024809;
    v9 = &v6[2 * (512 - v8)];
    v10 = 0;
    v11 = a2[1] - v9;
    while ( v4 )
    {
      v12 = *(_WORD *)&v9[v11];
      if ( !v12 )
        break;
      *(_WORD *)v9 = v12;
      --v4;
      v9 += 2;
      if ( !--v8 )
      {
        v9 -= 2;
        v10 = -2147024774;
        break;
      }
    }
    *(_WORD *)v9 = 0;
    if ( v10 >= 0 )
    {
      *((_QWORD *)this + 1) = v6;
      v13 = *(_DWORD *)a2;
      *((_BYTE *)this + 1042) |= 2u;
      goto LABEL_15;
    }
    return (unsigned int)v10;
  }
}
// 180018EBC: conditional instruction was optimized away because r8.8!=0
// 180018F0D: conditional instruction was optimized away because r8.8!=0
// 180073740: using guessed type void *wmi::OutOfMemoryException::`vftable';

//----- (0000000180018F54) ----------------------------------------------------
__int64 __fastcall XmlParserTempString::TrimLeft(XmlParserTempString *this)
{
  unsigned int v1; // r8d
  __int64 v3; // r9
  __int64 i; // rcx
  __int64 v5; // r10
  int v6; // r8d

  v1 = *(_DWORD *)this;
  if ( !*(_DWORD *)this )
    return 0LL;
  v3 = *((_QWORD *)this + 1);
  if ( !v3 )
    return 0LL;
  if ( (*((_BYTE *)this + 1042) & 3) == 0 )
  {
    for ( i = 0LL; (unsigned int)i < v1; i = (unsigned int)(i + 1) )
    {
      if ( *(_WORD *)(v3 + 2 * i) > 0x20u )
        break;
      v5 = 0x100002600LL;
      if ( !_bittest64(&v5, *(unsigned __int16 *)(v3 + 2 * i)) )
        break;
    }
    v6 = v1 - i;
    *(_DWORD *)this = v6;
    if ( v6 )
      *((_QWORD *)this + 1) = v3 + 2 * i;
    else
      *((_QWORD *)this + 1) = 0LL;
    return 0LL;
  }
  return 2147549183LL;
}

//----- (0000000180018FC8) ----------------------------------------------------
void __fastcall XmlParserTempString::Clear(XmlParserTempString *this)
{
  char v1; // al

  v1 = *((_BYTE *)this + 1042);
  if ( (v1 & 1) != 0 )
  {
    SysFreeString(*((BSTR *)this + 1));
    v1 = *((_BYTE *)this + 1042);
  }
  *(_DWORD *)this = 0;
  *((_BYTE *)this + 1042) = v1 & 0xFC;
  *((_QWORD *)this + 1) = 0LL;
  *((_WORD *)this + 8) = 0;
}

//----- (0000000180019000) ----------------------------------------------------
__int64 __fastcall Schema::ChildId(int *a1, int a2)
{
  int MaxNode; // eax
  int v3; // edx
  int *v4; // rcx
  unsigned __int64 v5; // r8
  const struct SchemaEntry * near *Entry; // rax
  __int64 v7; // r10

  if ( !a2 )
    return 0LL;
  MaxNode = Schema::GetMaxNode(a1);
  if ( v3 >= MaxNode || v5 >= 0x16 )
    return 0LL;
  Entry = Schema::GetEntry(v4, v3);
  return *((unsigned int *)Entry + v7 + 10);
}
// 180019012: variable 'v3' is possibly undefined
// 180019018: variable 'v5' is possibly undefined
// 18001901A: variable 'v4' is possibly undefined
// 18001901F: variable 'v7' is possibly undefined

//----- (0000000180019040) ----------------------------------------------------
const struct SchemaEntry * near *__fastcall Schema::GetEntry(int *a1, int a2)
{
  int v2; // eax
  const struct SchemaEntry * near *result; // rax
  __int64 v4; // r9
  __int64 v5; // rax
  const unsigned __int64 near *v6; // rcx

  v2 = *a1;
  if ( *a1 == 65542 )
    return &(&Schema::schemaEntries)[(unsigned __int16)v2][16 * (__int64)a2];
  if ( v2 < 0x10000 )
    return (const struct SchemaEntry * near *)&unk_180096000;
  if ( v2 > 65537 )
  {
    if ( v2 <= 65541 )
      return &(&Schema::schemaEntries)[(unsigned __int16)v2][16 * (__int64)a2];
    return (const struct SchemaEntry * near *)&unk_180096000;
  }
  v4 = 0LL;
  v5 = (unsigned __int16)v2;
  v6 = (&Schema::schemaEntriesCount)[v5];
  if ( !v6 )
    return (const struct SchemaEntry * near *)&unk_180096000;
  for ( result = (&Schema::schemaEntries)[v5]; *(_DWORD *)result != a2; result += 16 )
  {
    if ( ++v4 >= (unsigned __int64)v6 )
      return (const struct SchemaEntry * near *)&unk_180096000;
  }
  return result;
}
// 1800719A8: using guessed type const struct SchemaEntry * near *Schema::schemaEntries;
// 18007D588: using guessed type const unsigned __int64 near *const Schema::schemaEntriesCount;

//----- (0000000180019090) ----------------------------------------------------
__int64 __fastcall Schema::GetMaxNode(int *a1)
{
  int v1; // eax

  v1 = *a1;
  if ( *a1 == 65542 )
    return 149LL;
  if ( v1 < 0x10000 )
    return 0LL;
  if ( v1 <= 65538 )
    return 131LL;
  switch ( v1 )
  {
    case 65540:
      return 145LL;
    case 65539:
      return 136LL;
    case 65541:
      return 148LL;
    default:
      return 0LL;
  }
}

//----- (00000001800190E0) ----------------------------------------------------
int __fastcall JobBucket::WriteSettingsXml(JobBucket *this, struct TaskXmlWriter *a2, struct Schema *a3)
{
  int result; // eax
  const unsigned __int16 *v7; // rsi
  JobBucket *v8; // rcx
  unsigned int v9; // r14d
  const unsigned __int16 *v10; // r8
  const unsigned __int16 *v11; // r8
  JobBucket *v12; // rcx
  unsigned int ExecutionTimeLimit; // eax
  int v14; // eax
  __int16 v15; // dx
  JobBucket *v16; // rcx
  __int64 v17; // rax
  __int64 v19; // rax
  __m128i v20; // xmm6
  unsigned __int64 v21; // rax
  unsigned int *v22; // rax
  unsigned int v23; // ecx
  __int64 v24; // rax
  int v25; // ecx
  const unsigned __int16 *v26; // r8
  const unsigned __int16 *v27; // r8
  const unsigned __int16 *v28; // r8
  TSTimePeriod *Periodicity; // rax
  unsigned int v30; // r8d
  const unsigned __int16 *v31; // r8
  __int64 v32; // rax
  int v33; // ecx
  unsigned int v34; // r8d
  __int64 v35; // rax
  int v36; // ecx
  unsigned int v37; // r8d
  TSTimePeriod *v38; // rax
  __int64 v39; // rax
  int v40; // ecx
  __int64 v41; // xmm1_8
  TSTimePeriod *Deadline; // rax
  __int64 v43; // rax
  int v44; // ecx
  __int64 v45; // xmm1_8
  __int64 v46; // rax
  unsigned int Priority; // eax
  const unsigned __int16 *v49; // r8
  int v50; // ecx
  const unsigned __int16 *v51; // r8
  unsigned int Expiration; // eax
  __int64 v53; // [rsp+20h] [rbp-40h] BYREF
  int v54; // [rsp+28h] [rbp-38h]
  __int16 v55; // [rsp+2Ch] [rbp-34h]
  __m128i v56; // [rsp+30h] [rbp-30h] BYREF

  result = TaskXmlWriter::StartElement((int *)a2, 71);
  if ( result >= 0 )
  {
    v7 = L"true";
    if ( (~*((_DWORD *)this + 4) & 0x40000000) == 0 )
      goto LABEL_142;
    v31 = L"true";
    if ( (*((_DWORD *)this + 4) & 0x40000000) == 0 )
      v31 = L"false";
    result = TaskXmlWriter::Element((__int64)a2, 76, (__int64)v31);
    if ( result >= 0 )
    {
LABEL_142:
      if ( (~*((_DWORD *)this + 4) & 0x100) == 0 )
        goto LABEL_4;
      v51 = L"true";
      if ( (*((_DWORD *)this + 4) & 0x100) == 0 )
        v51 = L"false";
      result = TaskXmlWriter::Element((__int64)a2, 72, (__int64)v51);
      if ( result >= 0 )
      {
LABEL_4:
        v9 = -1;
        if ( (unsigned int)JobBucket::GetExpiration(this) == -1
          || (Expiration = JobBucket::GetExpiration(v8),
              result = TaskXmlWriter::ElementDuration((__int64)a2, 82, Expiration),
              result >= 0) )
        {
          v10 = L"true";
          if ( (*((_BYTE *)this + 16) & 0x10) == 0 )
            v10 = L"false";
          result = TaskXmlWriter::Element((__int64)a2, 74, (__int64)v10);
          if ( result >= 0 )
          {
            v11 = L"true";
            if ( (*((_BYTE *)this + 16) & 0x20) == 0 )
              v11 = L"false";
            result = TaskXmlWriter::Element((__int64)a2, 75, (__int64)v11);
            if ( result >= 0 )
            {
              if ( (~*((_DWORD *)this + 4) & 0x400000) == 0 )
                goto LABEL_143;
              v49 = L"true";
              if ( (*((_DWORD *)this + 4) & 0x400000) == 0 )
                v49 = L"false";
              result = TaskXmlWriter::Element((__int64)a2, 19, (__int64)v49);
              if ( result >= 0 )
              {
LABEL_143:
                if ( (unsigned int)JobBucket::GetExecutionTimeLimit(this) == 259200
                  || (ExecutionTimeLimit = JobBucket::GetExecutionTimeLimit(v12),
                      result = TaskXmlWriter::ElementDuration((__int64)a2, 20, ExecutionTimeLimit),
                      result >= 0) )
                {
                  if ( (*((_DWORD *)this + 4) & 0x800000) == 0
                    || (result = TaskXmlWriter::Element((__int64)a2, 81, (__int64)L"true"), result >= 0) )
                  {
                    if ( (v14 = *((_DWORD *)this + 4), v15 = 1024, (v14 & 0x400) == 0)
                      && (v15 = 4096, (v14 & 0x1000) == 0)
                      && (v15 = 0x2000, (v14 & 0x2000) == 0)
                      && (v15 = 2048, (v14 & 0x800) == 0)
                      || (result = TaskXmlWriter::ElementMultipleInstancesPolicy((__int64)a2, v15), result >= 0) )
                    {
                      if ( (unsigned int)JobBucket::GetPriority(this) == 7
                        || (Priority = JobBucket::GetPriority(v16),
                            result = TaskXmlWriter::ElementInt((__int64)a2, 83, Priority),
                            result >= 0) )
                      {
                        v17 = *((_QWORD *)this + 26);
                        if ( !(v17 ? *(_DWORD *)(v17 + 24) : 0) )
                          goto LABEL_148;
                        result = TaskXmlWriter::StartElement((int *)a2, 93);
                        if ( result >= 0 )
                        {
                          v32 = *((_QWORD *)this + 26);
                          v33 = v32 ? *(_DWORD *)(v32 + 24) : 0;
                          if ( !v33
                            || (!v32 ? (v34 = 0) : (v34 = *(_DWORD *)(v32 + 24)),
                                result = TaskXmlWriter::ElementInt((__int64)a2, 95, v34),
                                result >= 0) )
                          {
                            v35 = *((_QWORD *)this + 26);
                            v36 = v35 ? *(_DWORD *)(v35 + 20) : 0;
                            if ( !v36
                              || (!v35 ? (v37 = 0) : (v37 = *(_DWORD *)(v35 + 20)),
                                  result = TaskXmlWriter::ElementDuration((__int64)a2, 94, v37),
                                  result >= 0) )
                            {
                              result = TaskXmlWriter::EndElement((__int64)a2);
                              if ( result >= 0 )
                              {
LABEL_148:
                                if ( (*((_BYTE *)this + 16) & 0x40) == 0
                                  || (result = TaskXmlWriter::Element((__int64)a2, 77, (__int64)L"true"), result >= 0) )
                                {
                                  if ( (*((_DWORD *)this + 4) & 0x200) == 0
                                    || (result = TaskXmlWriter::Element((__int64)a2, 79, (__int64)L"true"), result >= 0) )
                                  {
                                    if ( *((char *)this + 16) >= 0
                                      || (result = TaskXmlWriter::Element((__int64)a2, 78, (__int64)L"true"), result >= 0) )
                                    {
                                      if ( *((char *)this + 16) >= 0 )
                                        goto LABEL_144;
                                      v19 = *((_QWORD *)this + 26);
                                      v56 = 0LL;
                                      if ( v19 )
                                        v20 = *(__m128i *)(v19 + 28);
                                      else
                                        v20 = 0LL;
                                      v21 = v20.m128i_i64[0] - v56.m128i_i64[0];
                                      if ( v20.m128i_i64[0] == v56.m128i_i64[0] )
                                        v21 = _mm_srli_si128(v20, 8).m128i_u64[0] - v56.m128i_i64[1];
                                      if ( !v21
                                        || (result = TaskXmlWriter::StartElement((int *)a2, 90), result >= 0)
                                        && (v56 = v20,
                                            result = TaskXmlWriter::ElementGUID((__int64)a2, 92, (GUID *)&v56),
                                            result >= 0)
                                        && (result = TaskXmlWriter::EndElement((__int64)a2), result >= 0) )
                                      {
LABEL_144:
                                        if ( (*((_BYTE *)this + 16) & 2) == 0
                                          || (result = TaskXmlWriter::Element((__int64)a2, 84, (__int64)L"true"),
                                              result >= 0) )
                                        {
                                          result = TaskXmlWriter::StartElement((int *)a2, 85);
                                          if ( result >= 0 )
                                          {
                                            v22 = (unsigned int *)*((_QWORD *)this + 26);
                                            v23 = v22 ? *v22 : 0;
                                            if ( !v23
                                              || (!v22 ? (v30 = 0) : (v30 = *v22),
                                                  result = TaskXmlWriter::ElementDuration((__int64)a2, 86, v30),
                                                  result >= 0) )
                                            {
                                              v24 = *((_QWORD *)this + 26);
                                              v25 = v24 ? *(_DWORD *)(v24 + 4) : -1;
                                              if ( v25 == -1 )
                                                goto LABEL_42;
                                              if ( v24 )
                                                v9 = *(_DWORD *)(v24 + 4);
                                              result = TaskXmlWriter::ElementDuration((__int64)a2, 87, v9);
                                              if ( result >= 0 )
                                              {
LABEL_42:
                                                v26 = L"true";
                                                if ( (*((_BYTE *)this + 16) & 8) == 0 )
                                                  v26 = L"false";
                                                result = TaskXmlWriter::Element((__int64)a2, 88, (__int64)v26);
                                                if ( result >= 0 )
                                                {
                                                  v27 = L"true";
                                                  if ( (*((_BYTE *)this + 16) & 4) == 0 )
                                                    v27 = L"false";
                                                  result = TaskXmlWriter::Element((__int64)a2, 89, (__int64)v27);
                                                  if ( result >= 0 )
                                                  {
                                                    result = TaskXmlWriter::EndElement((__int64)a2);
                                                    if ( result >= 0 )
                                                    {
                                                      if ( *(int *)a3 <= 65538 )
                                                        goto LABEL_145;
                                                      if ( (*((_DWORD *)this + 4) & 0x4000000) == 0
                                                        || (result = TaskXmlWriter::Element(
                                                                       (__int64)a2,
                                                                       132,
                                                                       (__int64)L"true"),
                                                            result >= 0) )
                                                      {
                                                        v28 = L"true";
                                                        if ( (*((_DWORD *)this + 4) & 0x2000000) == 0 )
                                                          v28 = L"false";
                                                        result = TaskXmlWriter::Element((__int64)a2, 131, (__int64)v28);
                                                        if ( result >= 0 )
                                                        {
LABEL_145:
                                                          if ( *(int *)a3 <= 65539 )
                                                            return TaskXmlWriter::EndElement((__int64)a2);
                                                          if ( (*((_DWORD *)this + 4) & 0x20000000) == 0
                                                            || (result = TaskXmlWriter::Element(
                                                                           (__int64)a2,
                                                                           140,
                                                                           (__int64)L"true"),
                                                                result >= 0) )
                                                          {
                                                            Periodicity = (TSTimePeriod *)JobBucket::GetPeriodicity(
                                                                                            (__int64)this,
                                                                                            (__int64)&v53);
                                                            if ( TSTimePeriod::IsEmpty(Periodicity) )
                                                              return TaskXmlWriter::EndElement((__int64)a2);
                                                            result = TaskXmlWriter::StartElement((int *)a2, 136);
                                                            if ( result >= 0 )
                                                            {
                                                              v38 = (TSTimePeriod *)JobBucket::GetPeriodicity(
                                                                                      (__int64)this,
                                                                                      (__int64)&v53);
                                                              if ( TSTimePeriod::IsEmpty(v38) )
                                                                goto LABEL_146;
                                                              v39 = JobBucket::GetPeriodicity(
                                                                      (__int64)this,
                                                                      (__int64)&v56);
                                                              v40 = *(_DWORD *)(v39 + 8);
                                                              v41 = *(_QWORD *)v39;
                                                              LOWORD(v39) = *(_WORD *)(v39 + 12);
                                                              v54 = v40;
                                                              v55 = v39;
                                                              v53 = v41;
                                                              result = TaskXmlWriter::ElementTSDuration(
                                                                         (__int64)a2,
                                                                         137,
                                                                         (unsigned __int16 *)&v53);
                                                              if ( result >= 0 )
                                                              {
LABEL_146:
                                                                Deadline = (TSTimePeriod *)JobBucket::GetDeadline(
                                                                                             (__int64)this,
                                                                                             (__int64)&v56);
                                                                if ( TSTimePeriod::IsEmpty(Deadline) )
                                                                  goto LABEL_147;
                                                                v43 = JobBucket::GetDeadline(
                                                                        (__int64)this,
                                                                        (__int64)&v56);
                                                                v44 = *(_DWORD *)(v43 + 8);
                                                                v45 = *(_QWORD *)v43;
                                                                LOWORD(v43) = *(_WORD *)(v43 + 12);
                                                                v54 = v44;
                                                                v55 = v43;
                                                                v53 = v45;
                                                                result = TaskXmlWriter::ElementTSDuration(
                                                                           (__int64)a2,
                                                                           138,
                                                                           (unsigned __int16 *)&v53);
                                                                if ( result >= 0 )
                                                                {
LABEL_147:
                                                                  v46 = *((_QWORD *)this + 26);
                                                                  if ( !(v46 ? *(_DWORD *)(v46 + 84) : 0) )
                                                                    goto LABEL_99;
                                                                  v50 = v46 ? *(_DWORD *)(v46 + 84) : 0;
                                                                  if ( v50 != 1 )
                                                                    v7 = L"false";
                                                                  result = TaskXmlWriter::Element(
                                                                             (__int64)a2,
                                                                             139,
                                                                             (__int64)v7);
                                                                  if ( result >= 0 )
                                                                  {
LABEL_99:
                                                                    result = TaskXmlWriter::EndElement((__int64)a2);
                                                                    if ( result >= 0 )
                                                                      return TaskXmlWriter::EndElement((__int64)a2);
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 1800191DA: variable 'v12' is possibly undefined
// 180019689: variable 'v16' is possibly undefined
// 18004747C: variable 'v8' is possibly undefined

//----- (0000000180019740) ----------------------------------------------------
__int64 __fastcall ServerXMLUpdateHandler::WriterHandler::EndElement(__int64 a1, __int64 a2, int a3)
{
  TaskXmlWriter *v3; // rcx

  v3 = *(TaskXmlWriter **)(*(_QWORD *)(a1 + 8) + 1048LL);
  if ( a3 == 1 )
    return TaskXmlWriter::EndDocument(v3);
  else
    return TaskXmlWriter::EndElement((__int64)v3);
}

//----- (0000000180019760) ----------------------------------------------------
__int64 __fastcall TaskXmlWriter::StartElementWithAttribute(__int64 a1, int a2, int a3, __int64 a4)
{
  int v4; // eax
  const struct SchemaEntry * near *Entry; // rdi
  __int64 v9; // rax
  __int64 result; // rax
  unsigned int v11; // r10d
  const struct SchemaEntry * near *v12; // rax
  __int64 v13; // r11

  v4 = *(_DWORD *)(a1 + 152);
  if ( v4 )
  {
    *(_DWORD *)(a1 + 152) = v4 + 1;
    return 1LL;
  }
  else
  {
    Entry = Schema::GetEntry((int *)a1, a2);
    if ( *(_DWORD *)Entry )
    {
      v9 = _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::operator->((__int64 *)(a1 + 16));
      result = (*(__int64 (__fastcall **)(__int64, const WCHAR *, const struct SchemaEntry *, wchar_t *const))(*(_QWORD *)v9 + 216LL))(
                 v9,
                 &ChannelPath,
                 Entry[1],
                 Schema::namespaceUri);
      if ( (int)result >= 0 )
      {
        if ( *(_DWORD *)Schema::GetEntry((int *)a1, a3) )
        {
          _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::operator->((__int64 *)(a1 + 16));
          v12 = Schema::GetEntry((int *)a1, a3);
          return (*(unsigned int (__fastcall **)(__int64, const WCHAR *, const struct SchemaEntry *, _QWORD, __int64))(*(_QWORD *)v13 + 56LL))(
                   v13,
                   &ChannelPath,
                   v12[1],
                   0LL,
                   a4);
        }
        return v11;
      }
    }
    else
    {
      result = 1LL;
      *(_DWORD *)(a1 + 152) = 1;
    }
  }
  return result;
}
// 1800197FE: variable 'v13' is possibly undefined
// 180019827: variable 'v11' is possibly undefined

//----- (000000018001984C) ----------------------------------------------------
__int64 __fastcall TaskXmlWriter::Element(__int64 a1, int a2, __int64 a3)
{
  int v3; // eax
  unsigned int v6; // edi
  const struct SchemaEntry * near *Entry; // rax
  __int64 v8; // rcx
  __int64 result; // rax
  __int64 v10; // rcx
  int v11; // eax
  __int64 v12; // rcx
  void **pExceptionObject; // [rsp+30h] [rbp-20h] BYREF
  int v14; // [rsp+38h] [rbp-18h]
  __int128 v15; // [rsp+40h] [rbp-10h]

  v3 = *(_DWORD *)(a1 + 152);
  v6 = 1;
  if ( v3 )
  {
    *(_DWORD *)(a1 + 152) = v3 + 1;
LABEL_9:
    v11 = *(_DWORD *)(a1 + 152);
    if ( v11 )
    {
      *(_DWORD *)(a1 + 152) = v11 - 1;
    }
    else
    {
      v12 = *(_QWORD *)(a1 + 16);
      if ( !v12 )
      {
        v14 = -2147467261;
        pExceptionObject = &_com_error::`vftable';
        v15 = 0LL;
        CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI1_AV_com_error__);
      }
      return (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v12 + 120LL))(v12);
    }
    return v6;
  }
  Entry = Schema::GetEntry((int *)a1, a2);
  if ( !*(_DWORD *)Entry )
  {
    *(_DWORD *)(a1 + 152) = 1;
    goto LABEL_9;
  }
  v8 = *(_QWORD *)(a1 + 16);
  if ( !v8 )
  {
    v14 = -2147467261;
    pExceptionObject = &_com_error::`vftable';
    v15 = 0LL;
    CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI1_AV_com_error__);
  }
  result = (*(__int64 (__fastcall **)(__int64, const WCHAR *, const struct SchemaEntry *, wchar_t *const))(*(_QWORD *)v8 + 216LL))(
             v8,
             &ChannelPath,
             Entry[1],
             Schema::namespaceUri);
  if ( (int)result >= 0 )
  {
    if ( (_DWORD)result || !a3 )
      goto LABEL_9;
    v10 = *(_QWORD *)(a1 + 16);
    if ( !v10 )
    {
      v14 = -2147467261;
      pExceptionObject = &_com_error::`vftable';
      v15 = 0LL;
      CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI1_AV_com_error__);
    }
    result = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v10 + 224LL))(v10, a3);
    if ( (int)result >= 0 )
      goto LABEL_9;
  }
  return result;
}
// 180071858: using guessed type void *_com_error::`vftable';

//----- (0000000180019940) ----------------------------------------------------
__int64 __fastcall ServerXMLUpdateHandler::WriterHandler::Process(
        __int64 a1,
        const struct Schema *a2,
        int a3,
        __int64 a4,
        char a5)
{
  __int64 v6; // rbx
  ServerXMLUpdateHandler *v7; // rcx
  bool v11; // zf
  int v12; // edx
  __int64 v13; // rax
  __int64 v14; // rsi
  __int64 v15; // rbp
  __int64 result; // rax
  __int64 v17; // rcx
  void **pExceptionObject; // [rsp+20h] [rbp-28h] BYREF
  int v19; // [rsp+28h] [rbp-20h]
  __int128 v20; // [rsp+30h] [rbp-18h]

  v6 = 0LL;
  v7 = *(ServerXMLUpdateHandler **)(a1 + 8);
  if ( !*((_QWORD *)v7 + 131) )
  {
    if ( a3 == 1 )
      return 0LL;
    result = ServerXMLUpdateHandler::CreateWriter(v7, a2);
    if ( (int)result < 0 )
      return result;
  }
  if ( a3 == 2 )
    return 0LL;
  if ( !a4 )
    return TaskXmlWriter::StartElement(*(int **)(*(_QWORD *)(a1 + 8) + 1048LL), a3);
  v11 = *((_DWORD *)Schema::GetEntry((int *)a2, a3) + 6) == 2;
  v13 = *(_QWORD *)(a4 + 48);
  if ( v11 )
  {
    if ( v13 )
      v6 = *(_QWORD *)(v13 + 8);
    return TaskXmlWriter::WriteAttribute(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 1048LL), v12, v6);
  }
  else if ( a5 )
  {
    return TaskXmlWriter::WriteStringValue(
             *(TaskXmlWriter **)(*(_QWORD *)(a1 + 8) + 1048LL),
             *(const unsigned __int16 **)(v13 + 8));
  }
  else if ( a3 == 96 )
  {
    if ( v13 )
      v6 = *(_QWORD *)(v13 + 8);
    return TaskXmlWriter::ElementCData(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 1048LL), 96, v6);
  }
  else
  {
    if ( v13 )
      v14 = *(_QWORD *)(v13 + 8);
    else
      v14 = 0LL;
    v15 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 1048LL);
    result = TaskXmlWriter::StartElement((int *)v15, a3);
    if ( (int)result >= 0 )
    {
      if ( (_DWORD)result || !v14 )
        return TaskXmlWriter::EndElement(v15);
      v17 = *(_QWORD *)(v15 + 16);
      if ( !v17 )
      {
        v19 = -2147467261;
        pExceptionObject = &_com_error::`vftable';
        v20 = 0LL;
        CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI1_AV_com_error__);
      }
      result = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v17 + 224LL))(v17, v14);
      if ( (int)result >= 0 )
        return TaskXmlWriter::EndElement(v15);
    }
  }
  return result;
}
// 180019A57: variable 'v12' is possibly undefined
// 180071858: using guessed type void *_com_error::`vftable';

//----- (0000000180019AA0) ----------------------------------------------------
__int64 __fastcall TaskXmlWriter::StartElement(int *a1, int a2)
{
  int v2; // eax
  const struct SchemaEntry * near *Entry; // rax
  __int64 v4; // r10
  __int64 v5; // rcx
  __int64 result; // rax
  void **pExceptionObject; // [rsp+30h] [rbp-28h] BYREF
  int v8; // [rsp+38h] [rbp-20h]
  __int128 v9; // [rsp+40h] [rbp-18h]

  v2 = a1[38];
  if ( v2 )
  {
    a1[38] = v2 + 1;
    return 1LL;
  }
  else
  {
    Entry = Schema::GetEntry(a1, a2);
    if ( *(_DWORD *)Entry )
    {
      v5 = *(_QWORD *)(v4 + 16);
      if ( !v5 )
      {
        v8 = -2147467261;
        pExceptionObject = &_com_error::`vftable';
        v9 = 0LL;
        CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI1_AV_com_error__);
      }
      return (*(__int64 (__fastcall **)(__int64, const WCHAR *, const struct SchemaEntry *, wchar_t *const))(*(_QWORD *)v5 + 216LL))(
               v5,
               &ChannelPath,
               Entry[1],
               Schema::namespaceUri);
    }
    else
    {
      result = 1LL;
      *(_DWORD *)(v4 + 152) = 1;
    }
  }
  return result;
}
// 180019AC6: variable 'v4' is possibly undefined
// 180071858: using guessed type void *_com_error::`vftable';

//----- (0000000180019B04) ----------------------------------------------------
__int64 __fastcall TaskXmlWriter::EndElement(__int64 a1)
{
  int v1; // eax
  __int64 v2; // rcx
  void **pExceptionObject; // [rsp+20h] [rbp-28h] BYREF
  int v5; // [rsp+28h] [rbp-20h]
  __int128 v6; // [rsp+30h] [rbp-18h]

  v1 = *(_DWORD *)(a1 + 152);
  if ( v1 )
  {
    *(_DWORD *)(a1 + 152) = v1 - 1;
    return 1LL;
  }
  else
  {
    v2 = *(_QWORD *)(a1 + 16);
    if ( !v2 )
    {
      v5 = -2147467261;
      pExceptionObject = &_com_error::`vftable';
      v6 = 0LL;
      CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI1_AV_com_error__);
    }
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v2 + 120LL))(v2);
  }
}
// 180071858: using guessed type void *_com_error::`vftable';

//----- (0000000180019B3C) ----------------------------------------------------
int __fastcall TaskXmlWriter::StartDocument(__int64 a1, int a2)
{
  int result; // eax
  void *v5; // rcx
  void *v6; // rdi
  IUnknown *v7; // rcx
  __int64 v8; // rax
  int v9; // edi
  __int64 v10; // rax
  __int64 v11; // rax
  const struct SchemaEntry * near *Entry; // rax
  __int64 v13; // r11
  const struct SchemaEntry * near *v14; // rax
  __int64 v15; // r11
  __int64 v16; // rax
  int v17; // [rsp+20h] [rbp-68h]
  void *v18; // [rsp+30h] [rbp-58h] BYREF
  IXmlWriterOutput *ppOutput; // [rsp+38h] [rbp-50h] BYREF
  unsigned __int16 v20[24]; // [rsp+40h] [rbp-48h] BYREF

  v18 = 0LL;
  result = CreateXmlWriter(&GUID_7279fc88_709d_4095_b63d_69fe4b0d9030, &v18, 0LL);
  if ( result >= 0 )
  {
    v5 = v18;
    v6 = *(void **)(a1 + 16);
    if ( v6 != v18 )
    {
      *(_QWORD *)(a1 + 16) = v18;
      if ( v5 )
      {
        (*(void (__fastcall **)(void *))(*(_QWORD *)v5 + 8LL))(v5);
        v5 = v18;
      }
      if ( v6 )
      {
        (*(void (__fastcall **)(void *))(*(_QWORD *)v6 + 16LL))(v6);
        v5 = v18;
      }
    }
    (*(void (__fastcall **)(void *))(*(_QWORD *)v5 + 16LL))(v5);
    v7 = *(IUnknown **)(a1 + 8);
    ppOutput = 0LL;
    result = CreateXmlWriterOutputWithEncodingName(v7, 0LL, L"UTF-16", &ppOutput);
    if ( result >= 0 )
    {
      v8 = _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::operator->((__int64 *)(a1 + 16));
      v9 = (*(__int64 (__fastcall **)(__int64, IXmlWriterOutput *))(*(_QWORD *)v8 + 24LL))(v8, ppOutput);
      ((void (__fastcall *)(IXmlWriterOutput *))ppOutput->lpVtbl->Release)(ppOutput);
      if ( v9 < 0 )
      {
        return v9;
      }
      else
      {
        v10 = _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::operator->((__int64 *)(a1 + 16));
        result = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(*(_QWORD *)v10 + 40LL))(v10, 1LL, 1LL);
        if ( result >= 0 )
        {
          v11 = _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::operator->((__int64 *)(a1 + 16));
          result = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v11 + 208LL))(v11, 0LL);
          if ( result >= 0 )
          {
            _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::operator->((__int64 *)(a1 + 16));
            Entry = Schema::GetEntry((int *)a1, 1);
            result = (*(__int64 (__fastcall **)(__int64, const WCHAR *, const struct SchemaEntry *, wchar_t *const))(*(_QWORD *)v13 + 216LL))(
                       v13,
                       &ChannelPath,
                       Entry[1],
                       Schema::namespaceUri);
            if ( result >= 0 )
            {
              if ( a2 )
              {
                v17 = (unsigned __int16)*(_DWORD *)a1;
                result = StringCchPrintfW(v20, 0x16uLL, (size_t *)L"%d.%d", HIWORD(*(_DWORD *)a1), v17);
                if ( result >= 0 )
                {
                  _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::operator->((__int64 *)(a1 + 16));
                  v14 = Schema::GetEntry((int *)a1, 2);
                  result = (*(__int64 (__fastcall **)(__int64, const WCHAR *, const struct SchemaEntry *, _QWORD, unsigned __int16 *))(*(_QWORD *)v15 + 56LL))(
                             v15,
                             &ChannelPath,
                             v14[1],
                             0LL,
                             v20);
                  if ( result >= 0 )
                  {
                    v16 = _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::operator->((__int64 *)(a1 + 16));
                    return (*(__int64 (__fastcall **)(__int64, const WCHAR *, const wchar_t *, _QWORD, wchar_t *const))(*(_QWORD *)v16 + 56LL))(
                             v16,
                             &ChannelPath,
                             L"xmlns",
                             0LL,
                             Schema::namespaceUri);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 180019CA4: variable 'v13' is possibly undefined
// 180019D20: variable 'v15' is possibly undefined

//----- (0000000180019DB0) ----------------------------------------------------
__int64 __fastcall TSParser::ParseDateTime(const unsigned __int16 *a1, unsigned __int64 a2, SYSTEMTIME *a3)
{
  __int64 result; // rax
  unsigned int v7; // esi
  unsigned __int16 v8; // cx
  int v9; // r14d
  unsigned __int64 v10; // rdx
  unsigned int v11; // [rsp+20h] [rbp-40h] BYREF
  unsigned __int16 v12; // [rsp+24h] [rbp-3Ch] BYREF
  unsigned __int16 v13; // [rsp+28h] [rbp-38h] BYREF
  struct _FILETIME FileTime; // [rsp+30h] [rbp-30h] BYREF
  unsigned __int64 v15; // [rsp+38h] [rbp-28h] BYREF
  SYSTEMTIME SystemTime; // [rsp+40h] [rbp-20h] BYREF

  v11 = 0;
  v15 = 0LL;
  FileTime = 0LL;
  SystemTime = 0LL;
  if ( a2 )
    v11 = *a1 == 43;
  result = TSParser::ParseWord(a1, a2, &v11, &SystemTime.wYear);
  if ( (int)result >= 0 )
  {
    if ( v11 >= a2 || a1[v11] != 45 )
      return 2147750680LL;
    ++v11;
    result = TSParser::ParseWord(a1, a2, &v11, &SystemTime.wMonth);
    if ( (int)result < 0 )
      return result;
    if ( v11 >= a2 || a1[v11] != 45 )
      return 2147750680LL;
    ++v11;
    result = TSParser::ParseWord(a1, a2, &v11, &SystemTime.wDay);
    if ( (int)result < 0 )
      return result;
    if ( a1[v11] != 84 )
      return 2147750680LL;
    ++v11;
    result = TSParser::ParseWord(a1, a2, &v11, &SystemTime.wHour);
    if ( (int)result < 0 )
      return result;
    if ( v11 >= a2 || a1[v11] != 58 )
      return 2147750680LL;
    ++v11;
    result = TSParser::ParseWord(a1, a2, &v11, &SystemTime.wMinute);
    if ( (int)result < 0 )
      return result;
    v7 = v11;
    if ( v11 < a2 && a1[v11] == 58 )
    {
      ++v11;
      result = TSParser::ParseWord(a1, a2, &v11, &SystemTime.wSecond);
      if ( (int)result < 0 )
        return result;
      v7 = v11;
    }
    if ( v7 >= a2 || a1[v7] != 46 )
    {
LABEL_21:
      if ( SystemTimeToFileTime(&SystemTime, &FileTime) )
      {
        if ( v7 == a2 || (v8 = a1[v7]) == 0 )
        {
          LOBYTE(SystemTime.wYear) = 1;
LABEL_40:
          *(struct _FILETIME *)&SystemTime.wHour = FileTime;
          *a3 = SystemTime;
          return 0LL;
        }
        if ( v8 == 90 && v7 < a2 )
        {
          LOBYTE(SystemTime.wYear) = 0;
          goto LABEL_40;
        }
        v12 = 0;
        v13 = 0;
        if ( v7 < a2 )
        {
          if ( v8 == 43 )
          {
            v9 = 3600;
          }
          else
          {
            if ( v7 >= a2 || v8 != 45 )
              return 2147750680LL;
            v9 = -3600;
          }
          v11 = v7 + 1;
          result = TSParser::ParseWord(a1, a2, &v11, &v12);
          if ( (int)result < 0 )
            return result;
          if ( v12 <= 0xEu && a1[v11] == 58 )
          {
            ++v11;
            result = TSParser::ParseWord(a1, a2, &v11, &v13);
            if ( (int)result < 0 )
              return result;
            if ( v13 <= 0x3Bu && (v11 == a2 || !a1[v11]) )
            {
              *(struct _FILETIME *)&SystemTime.wHour = FileTime;
              LOBYTE(SystemTime.wYear) = 0;
              v10 = 10000000LL * (-60 * v13 - v9 * v12);
              *a3 = SystemTime;
              v15 = v10;
              TSTime::operator+=((__int64)a3, (__int64 *)&v15);
              return 0LL;
            }
          }
        }
      }
      return 2147750680LL;
    }
    v11 = v7 + 1;
    result = TSParser::ParseULongLong(a1, a2, &v11, &v15);
    if ( (int)result >= 0 )
    {
      v7 = v11;
      goto LABEL_21;
    }
  }
  return result;
}

//----- (000000018001A0B4) ----------------------------------------------------
__int64 __fastcall TSParser::ParseWord(
        const unsigned __int16 *a1,
        unsigned __int64 a2,
        unsigned int *a3,
        unsigned __int16 *a4)
{
  unsigned __int16 v5; // ax
  int v6; // ecx
  unsigned __int64 v8[3]; // [rsp+20h] [rbp-18h] BYREF

  if ( (int)TSParser::ParseULongLong(a1, a2, a3, v8) < 0 )
    return 2147750680LL;
  v5 = v8[0];
  if ( v8[0] > 0xFFFF )
  {
    v6 = -2147024362;
    v5 = -1;
  }
  else
  {
    v6 = 0;
  }
  *a4 = v5;
  if ( v6 < 0 )
    return 2147750680LL;
  else
    return 0LL;
}
// 18001A0B4: using guessed type unsigned __int64 var_18[3];

//----- (000000018001A100) ----------------------------------------------------
__int64 __fastcall TSParser::ParseULongLong(
        const unsigned __int16 *a1,
        unsigned __int64 a2,
        unsigned int *a3,
        unsigned __int64 *a4)
{
  unsigned __int64 v6; // rax
  const unsigned __int16 *v7; // rbx
  unsigned __int64 v8; // r9
  unsigned int v9; // r8d
  unsigned __int64 v10; // rdx
  unsigned int v11; // ecx
  unsigned int v12; // eax
  wchar_t *v14; // [rsp+30h] [rbp+8h] BYREF

  if ( !a1 )
    return 2147750680LL;
  v6 = *a3;
  if ( v6 >= a2 )
    return 2147750680LL;
  v7 = &a1[v6];
  if ( (unsigned __int16)(*v7 - 48) > 9u )
    return 2147750680LL;
  v14 = 0LL;
  v8 = _wcstoui64(v7, &v14, 10);
  if ( v14 <= v7 )
    return 2147750680LL;
  v9 = -1;
  v10 = v14 - v7;
  if ( v10 > 0xFFFFFFFF )
    return 2147750680LL;
  v11 = *a3;
  v12 = *a3 + v10;
  if ( v12 >= *a3 )
    v9 = *a3 + v10;
  *a3 = v9;
  if ( v12 < v11 )
    return 2147750680LL;
  *a4 = v8;
  return 0LL;
}

//----- (000000018001A1A4) ----------------------------------------------------
__int64 __fastcall ULongToUShort(unsigned int a1, unsigned __int16 *a2)
{
  unsigned __int16 v2; // r8

  if ( a1 > 0xFFFF )
    v2 = -1;
  else
    v2 = a1;
  *a2 = v2;
  return a1 > 0xFFFF ? 0x80070216 : 0;
}

//----- (000000018001A1CC) ----------------------------------------------------
__int64 StringCchPrintfW(unsigned __int16 *a1, size_t a2, size_t *a3, ...)
{
  int v3; // r9d
  va_list va; // [rsp+58h] [rbp+20h] BYREF

  va_start(va, a3);
  v3 = 0;
  if ( a2 - 1 > 0x7FFFFFFE )
    v3 = -2147024809;
  if ( v3 < 0 )
  {
    if ( a2 )
      *a1 = 0;
  }
  else
  {
    return (unsigned int)StringVPrintfWorkerW(a1, a2, a3, (STRSAFE_LPCWSTR)a3, va);
  }
  return (unsigned int)v3;
}

//----- (000000018001A224) ----------------------------------------------------
HRESULT __stdcall StringVPrintfWorkerW(
        STRSAFE_LPWSTR pszDest,
        size_t cchDest,
        size_t *pcchNewDestLength,
        STRSAFE_LPCWSTR pszFormat,
        va_list argList)
{
  size_t v5; // rdi
  HRESULT v7; // ebx
  int v8; // eax

  v5 = cchDest - 1;
  v7 = 0;
  v8 = _vsnwprintf(pszDest, cchDest - 1, pszFormat, argList);
  if ( v8 < 0 || v8 > v5 )
  {
    pszDest[v5] = 0;
    return -2147024774;
  }
  else if ( v8 == v5 )
  {
    pszDest[v5] = 0;
  }
  return v7;
}

//----- (000000018001A28C) ----------------------------------------------------
__int64 __fastcall tsched::TaskPathCanonicalize(tsched *this, char *a2, const unsigned __int16 *a3)
{
  unsigned __int16 *v4; // rbx
  __int16 v5; // r8
  int v6; // r9d
  char *v7; // r10
  __int64 result; // rax
  bool v9; // zf
  __int64 v10; // r9
  unsigned __int16 *v11; // r8
  unsigned __int16 v12; // ax
  unsigned __int16 *v13; // rax
  __int64 v14; // rdx
  char *v15; // rcx
  unsigned __int16 v16; // ax
  unsigned __int16 *v17; // rax

  v4 = (unsigned __int16 *)this;
  memset_0(this, 0, 0x20AuLL);
  if ( !a2 || !*(_WORD *)a2 )
  {
    v14 = 261LL;
    v15 = (char *)((char *)L"\\" - (char *)v4);
    do
    {
      if ( v14 == -2147483385 )
        break;
      v16 = *(unsigned __int16 *)((char *)v4 + (_QWORD)v15);
      if ( !v16 )
        break;
      *v4++ = v16;
      --v14;
    }
    while ( v14 );
    v17 = v4 - 1;
    if ( v14 )
      v17 = v4;
    *v17 = 0;
    return v14 == 0 ? 0x8007007A : 0;
  }
  if ( *(_WORD *)a2 != 92 )
  {
    v10 = 261LL;
    v11 = v4;
    do
    {
      if ( v10 == -2147483385 )
        break;
      v12 = *(unsigned __int16 *)((char *)v11 + (char *)L"\\" - (char *)v4);
      if ( !v12 )
        break;
      *v11++ = v12;
      --v10;
    }
    while ( v10 );
    v13 = v11 - 1;
    if ( v10 )
      v13 = v11;
    *v13 = 0;
    result = v10 == 0 ? 0x8007007A : 0;
    if ( !v10 )
      return result;
  }
  v5 = 0;
  v6 = 0;
  v7 = a2;
  while ( *(_WORD *)v7 )
  {
    switch ( *(_WORD *)v7 )
    {
      case ' ':
        if ( v5 == 92 )
          return 2147942523LL;
        v9 = v5 == 0;
        goto LABEL_18;
      case '.':
        if ( v5 == 46 )
          return 2147942523LL;
        if ( v5 == 92 )
        {
          v9 = *((_WORD *)v7 + 1) == 92;
LABEL_18:
          if ( v9 )
            return 2147942523LL;
        }
        break;
      case '/':
      case ':':
        return 2147942523LL;
      case '\\':
        v9 = v5 == 92;
        goto LABEL_18;
    }
    v5 = *(_WORD *)v7;
    ++v6;
    v7 += 2;
    if ( v6 >= 261 )
      break;
  }
  if ( v6 >= 261 || v5 == 92 && v6 > 1 )
    return 2147942523LL;
  result = StringCchCatW(v4, 261LL, a2);
  if ( (int)result >= 0 )
    return 0LL;
  return result;
}

//----- (000000018001A3E4) ----------------------------------------------------
__int64 __fastcall TaskXmlWriter::ElementDuration(__int64 a1, int a2, unsigned int a3)
{
  unsigned __int16 *v3; // rbx
  unsigned int v6; // ebp
  unsigned int v7; // esi
  _WORD *v8; // rcx
  unsigned int v9; // r14d
  __int64 v10; // rdx
  unsigned int v11; // r9d
  unsigned int v12; // ebp
  __int16 v13; // ax
  _WORD *v14; // rax
  __int64 result; // rax
  __int64 v16; // rcx
  unsigned __int16 *v17; // rax
  __int64 v18; // r8
  char *v19; // rdx
  __int64 v20; // rcx
  __int64 v21; // rax
  signed __int64 v22; // r8
  __int16 v23; // r9
  char *v24; // rax
  unsigned __int16 v25[12]; // [rsp+20h] [rbp-58h] BYREF

  v3 = (unsigned __int16 *)(a1 + 24);
  if ( !a3 )
  {
    result = StringCchPrintfW((unsigned __int16 *)(a1 + 24), 0x40uLL, (size_t *)L"PT%dS", 0LL);
    goto LABEL_42;
  }
  v6 = a3 / 0x3C / 0x3C;
  v7 = a3 % 0x3C;
  v8 = (_WORD *)(a1 + 24);
  v9 = a3 / 0x3C % 0x3C;
  v10 = 64LL;
  v11 = v6 / 0x18;
  v12 = v6 % 0x18;
  do
  {
    if ( v10 == -2147483582 )
      break;
    v13 = *(_WORD *)((char *)v8 + (char *)L"P" - (char *)v3);
    if ( !v13 )
      break;
    *v8++ = v13;
    --v10;
  }
  while ( v10 );
  v14 = v8 - 1;
  if ( v10 )
    v14 = v8;
  *v14 = 0;
  result = v10 == 0 ? 0x8007007A : 0;
  if ( v10 )
  {
    if ( !v11
      || (result = StringCchPrintfW(v25, 0xCuLL, (size_t *)L"%dD"), (int)result >= 0)
      && (result = StringCchCatW(v3, 64LL, (char *)v25), (int)result >= 0) )
    {
      if ( !v12 && !v9 && !v7 )
        return TaskXmlWriter::Element(a1, a2, (__int64)v3);
      v16 = 64LL;
      v17 = v3;
      do
      {
        if ( !*v17 )
          break;
        ++v17;
        --v16;
      }
      while ( v16 );
      result = v16 == 0 ? 0x80070057 : 0;
      if ( v16 )
        v18 = 64 - v16;
      else
        v18 = 0LL;
      if ( !v16 )
        return result;
      v19 = (char *)&v3[v18];
      v20 = 64 - v18;
      if ( v18 != 64 )
      {
        v21 = 2147483646LL;
        v22 = (char *)L"T" - v19;
        do
        {
          if ( !v21 )
            break;
          v23 = *(_WORD *)&v19[v22];
          if ( !v23 )
            break;
          *(_WORD *)v19 = v23;
          --v21;
          v19 += 2;
          --v20;
        }
        while ( v20 );
      }
      v24 = v19 - 2;
      if ( v20 )
        v24 = v19;
      *(_WORD *)v24 = 0;
      result = v20 == 0 ? 0x8007007A : 0;
      if ( !v20 )
        return result;
      if ( v12 )
      {
        result = StringCchPrintfW(v25, 0xCuLL, (size_t *)L"%dH", v12);
        if ( (int)result < 0 )
          return result;
        result = StringCchCatW(v3, 64LL, (char *)v25);
        if ( (int)result < 0 )
          return result;
      }
      if ( v9 )
      {
        result = StringCchPrintfW(v25, 0xCuLL, (size_t *)L"%dM", v9);
        if ( (int)result < 0 )
          return result;
        result = StringCchCatW(v3, 64LL, (char *)v25);
        if ( (int)result < 0 )
          return result;
      }
      if ( !v7 )
        return TaskXmlWriter::Element(a1, a2, (__int64)v3);
      result = StringCchPrintfW(v25, 0xCuLL, (size_t *)L"%dS", v7);
      if ( (int)result < 0 )
        return result;
      result = StringCchCatW(v3, 64LL, (char *)v25);
LABEL_42:
      if ( (int)result < 0 )
        return result;
      return TaskXmlWriter::Element(a1, a2, (__int64)v3);
    }
  }
  return result;
}
// 1800767A4: using guessed type wchar_t aP[2];
// 1800767A8: using guessed type wchar_t aT[2];

//----- (000000018001A68C) ----------------------------------------------------
__int64 __fastcall StringCchCatW(unsigned __int16 *a1, __int64 a2, char *a3)
{
  signed int v5; // r9d
  __int64 v7; // rcx
  unsigned __int16 *i; // rax
  __int64 v9; // r8
  unsigned __int16 *v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // r9
  char *v13; // r11
  unsigned __int16 v14; // ax
  unsigned __int16 *v15; // rax

  v5 = 0;
  if ( (unsigned __int64)(a2 - 1) > 0x7FFFFFFE )
    v5 = -2147024809;
  if ( v5 < 0 )
    goto LABEL_19;
  v7 = a2;
  for ( i = a1; v7; --v7 )
  {
    if ( !*i )
      break;
    ++i;
  }
  v5 = v7 == 0 ? 0x80070057 : 0;
  if ( v7 )
    v9 = a2 - v7;
  else
LABEL_19:
    v9 = 0LL;
  if ( v5 >= 0 )
  {
    v10 = &a1[v9];
    v11 = a2 - v9;
    if ( a2 != v9 )
    {
      v12 = 2147483646LL;
      v13 = (char *)(a3 - (char *)v10);
      do
      {
        if ( !v12 )
          break;
        v14 = *(unsigned __int16 *)((char *)v10 + (_QWORD)v13);
        if ( !v14 )
          break;
        *v10 = v14;
        --v12;
        ++v10;
        --v11;
      }
      while ( v11 );
    }
    v15 = v10 - 1;
    if ( v11 )
      v15 = v10;
    v5 = v11 == 0 ? 0x8007007A : 0;
    *v15 = 0;
  }
  return (unsigned int)v5;
}

//----- (000000018001A768) ----------------------------------------------------
__int64 __fastcall Triggers::WnfStateChangeTrigger::WriteInnerXml(
        Triggers::WnfStateChangeTrigger *this,
        struct TaskXmlWriter *a2)
{
  __int64 result; // rax
  tsched *v5; // r8
  unsigned int v6; // r8d

  result = Triggers::GenericTrigger::WriteInnerXml(this, a2);
  if ( (int)result >= 0 )
  {
    result = TaskXmlWriter::ElementHexString(
               (__int64)a2,
               142,
               (Triggers::WnfStateChangeTrigger *)((char *)this + 88),
               8u);
    if ( (int)result >= 0 )
    {
      v5 = (tsched *)*((_QWORD *)this + 13);
      if ( v5 )
      {
        result = TaskXmlWriter::ElementHexString((__int64)a2, 143, v5, *((_DWORD *)this + 24));
        if ( (int)result >= 0 )
        {
          v6 = *((_DWORD *)this + 25);
          if ( v6 )
            return TaskXmlWriter::ElementInt((__int64)a2, 144, v6);
        }
      }
    }
  }
  return result;
}

//----- (000000018001A7DC) ----------------------------------------------------
char *__fastcall UbpmParams::NewHostedString(
        unsigned __int64 a1,
        __int64 *a2,
        unsigned __int16 *a3,
        unsigned __int64 a4)
{
  int v6; // eax
  __int64 v7; // rbx
  char v8; // r14
  int v9; // eax
  char **v10; // rcx
  char *v11; // rax
  __int64 v13; // rax
  __int64 v14; // rbx
  char *v15[3]; // [rsp+20h] [rbp-60h] BYREF
  char v16; // [rsp+38h] [rbp-48h]
  void **pExceptionObject; // [rsp+40h] [rbp-40h] BYREF
  char v18; // [rsp+48h] [rbp-38h]
  const unsigned __int16 *v19; // [rsp+50h] [rbp-30h]
  __int64 v20; // [rsp+58h] [rbp-28h]
  int v21; // [rsp+60h] [rbp-20h]
  int v22; // [rsp+64h] [rbp-1Ch]
  int v23; // [rsp+68h] [rbp-18h]
  int v24; // [rsp+6Ch] [rbp-14h]
  int v25; // [rsp+70h] [rbp-10h]
  unsigned __int64 v26; // [rsp+A0h] [rbp+20h] BYREF

  v26 = a1;
  v15[1] = (char *)-2LL;
  v6 = StringCchLengthW(a3, a4, &v26);
  if ( v6 < 0 )
  {
    v18 = 0;
    pExceptionObject = &wmi::GenericException::`vftable';
    v19 = &word_18007630E;
    v20 = 0LL;
    v21 = 0;
    v22 = 0;
    v23 = v6;
    v24 = -1;
    v25 = -1;
    CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
  }
  v7 = v26 + 1;
  v15[0] = (char *)operator new(saturated_mul(v26 + 1, 2uLL));
  v15[2] = (char *)v15;
  v8 = 1;
  v16 = 1;
  v9 = StringCchCopyW(v15[0], v7, (char *)a3);
  if ( v9 < 0 )
  {
    v18 = 0;
    pExceptionObject = &wmi::GenericException::`vftable';
    v19 = &word_18007630E;
    v20 = 0LL;
    v21 = 0;
    v22 = 0;
    v23 = v9;
    v24 = -1;
    v25 = -1;
    CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
  }
  v10 = (char **)a2[1];
  if ( v15 >= v10 || *a2 > (unsigned __int64)v15 )
    v8 = 0;
  if ( v8 )
  {
    v13 = *a2;
    v14 = ((__int64)v15 - *a2) >> 3;
    if ( v10 == (char **)a2[2] )
    {
      std::vector<unsigned short *>::_Reserve(a2);
      v13 = *a2;
      v10 = (char **)a2[1];
    }
    v11 = *(char **)(v13 + 8 * v14);
  }
  else
  {
    if ( v10 == (char **)a2[2] )
    {
      std::vector<unsigned short *>::_Reserve(a2);
      v10 = (char **)a2[1];
    }
    v11 = v15[0];
  }
  *v10 = v11;
  a2[1] += 8LL;
  return v15[0];
}
// 1800716D8: using guessed type void *wmi::GenericException::`vftable';

//----- (000000018001A8D8) ----------------------------------------------------
__int64 __fastcall StringCchCopyW(char *a1, __int64 a2, char *a3)
{
  signed int v3; // r9d
  __int64 v4; // r10
  signed __int64 v5; // r8
  unsigned __int16 v6; // ax
  unsigned __int16 *v7; // rax

  v3 = 0;
  if ( (unsigned __int64)(a2 - 1) > 0x7FFFFFFE )
    v3 = -2147024809;
  if ( v3 < 0 )
  {
    if ( a2 )
      *(_WORD *)a1 = 0;
  }
  else
  {
    if ( a2 )
    {
      v4 = 2147483646 - a2;
      v5 = a3 - a1;
      do
      {
        if ( !(v4 + a2) )
          break;
        v6 = *(_WORD *)&a1[v5];
        if ( !v6 )
          break;
        *(_WORD *)a1 = v6;
        a1 += 2;
        --a2;
      }
      while ( a2 );
    }
    v7 = (unsigned __int16 *)(a1 - 2);
    if ( a2 )
      v7 = (unsigned __int16 *)a1;
    v3 = a2 == 0 ? 0x8007007A : 0;
    *v7 = 0;
  }
  return (unsigned int)v3;
}

//----- (000000018001A95C) ----------------------------------------------------
__int64 __fastcall StringCchLengthW(const unsigned __int16 *a1, unsigned __int64 a2, unsigned __int64 *a3)
{
  unsigned __int64 i; // r9
  __int64 result; // rax

  if ( a1 && a2 <= 0x7FFFFFFF )
  {
    for ( i = a2; i; --i )
    {
      if ( !*a1 )
        break;
      ++a1;
    }
    result = i == 0 ? 0x80070057 : 0;
    if ( a3 )
    {
      if ( i )
        *a3 = a2 - i;
      else
        *a3 = 0LL;
    }
  }
  else
  {
    result = 2147942487LL;
  }
  if ( (int)result < 0 )
  {
    if ( a3 )
      *a3 = 0LL;
  }
  return result;
}

//----- (000000018001A9C0) ----------------------------------------------------
__int64 __fastcall std::vector<unsigned short *>::_Reserve(_QWORD *a1)
{
  __int64 v2; // rdx
  __int64 result; // rax
  __int64 v4; // rdx
  unsigned __int64 v5; // rdx
  unsigned __int64 v6; // r9
  unsigned __int64 v7; // rcx

  v2 = a1[1];
  result = (a1[2] - v2) >> 3;
  if ( !result )
  {
    v4 = (v2 - *a1) >> 3;
    if ( v4 == 0x1FFFFFFFFFFFFFFFLL )
      std::_Xlength_error("vector<T> too long");
    v5 = v4 + 1;
    v6 = (__int64)(a1[2] - *a1) >> 3;
    v7 = 0LL;
    if ( 0x1FFFFFFFFFFFFFFFLL - (v6 >> 1) >= v6 )
      v7 = v6 + (v6 >> 1);
    if ( v7 >= v5 )
      v5 = v7;
    return (__int64)std::vector<unsigned short *>::_Reallocate((__int64)a1, v5);
  }
  return result;
}

//----- (000000018001AA3C) ----------------------------------------------------
char *__fastcall std::vector<unsigned short *>::_Reallocate(__int64 a1, unsigned __int64 a2)
{
  char *v4; // rbx
  __int64 v5; // r14
  char *result; // rax

  v4 = 0LL;
  if ( a2 )
  {
    if ( a2 > 0x1FFFFFFFFFFFFFFFLL || (v4 = (char *)operator new(8 * a2)) == 0LL )
      std::_Xbad_alloc();
  }
  memmove_0(v4, *(const void **)a1, (*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) & 0xFFFFFFFFFFFFFFF8uLL);
  v5 = (__int64)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3;
  if ( *(_QWORD *)a1 )
    operator delete(*(void **)a1);
  *(_QWORD *)(a1 + 16) = &v4[8 * a2];
  result = &v4[8 * v5];
  *(_QWORD *)(a1 + 8) = result;
  *(_QWORD *)a1 = v4;
  return result;
}

//----- (000000018001AAF8) ----------------------------------------------------
__int64 __fastcall TaskXmlReader::LoadRunLevel(TaskXmlReader *this, enum JobFlags::JobFlag *a2)
{
  const wchar_t **v2; // rdi
  int v4; // ebx
  __int64 result; // rax

  v2 = (const wchar_t **)((char *)this + 64);
  v4 = 0;
  *(_DWORD *)a2 = 0;
  result = TaskXmlReader::LoadRawValue(this, (TaskXmlReader *)((char *)this + 64));
  if ( (int)result >= 0 )
  {
    if ( *(_DWORD *)v2 )
    {
      if ( XmlParserTempString::IsEqualTo(v2, L"LeastPrivilege", 0xEuLL) )
      {
LABEL_6:
        *(_DWORD *)a2 = v4;
        return 0LL;
      }
      if ( XmlParserTempString::IsEqualTo(v2, L"HighestAvailable", 0x10uLL) )
      {
        v4 = 0x1000000;
        goto LABEL_6;
      }
    }
    return 2147750680LL;
  }
  return result;
}

//----- (000000018001AB78) ----------------------------------------------------
__int64 __fastcall ServerXMLUpdateHandler::WriteContext(__int64 a1, int *a2, int a3, __int64 a4, __int64 a5)
{
  int v8; // eax
  __int64 result; // rax

  v8 = _ProcessValue__QITaskXmlHandler__TriggersXmlHandler__MEAAJAEBUSchema__W4TaskXmlNodeId__AEBUData_1__N_Z(
         (TriggersXmlHandler *)a1,
         a2,
         a3,
         a5);
  if ( v8 < 0 && *(int *)(a1 + 1072) >= 0 )
    *(_DWORD *)(a1 + 1072) = v8;
  result = TaskXmlWriter::WriteAttribute(*(_QWORD *)(a1 + 1048), a3, a4);
  if ( (int)result < 0 && *(int *)(a1 + 1072) >= 0 )
    *(_DWORD *)(a1 + 1072) = result;
  return result;
}

//----- (000000018001ABE0) ----------------------------------------------------
__int64 __fastcall ServerXMLUpdateHandler::ContextHandler::Process(__int64 a1, int *a2, int a3, __int64 a4)
{
  __int64 v7; // rcx
  BSTR *v8; // rax
  UINT v9; // eax
  _QWORD *v10; // r9
  __int64 v11; // rax
  __int64 v12; // rcx
  BSTR *v13; // rax
  UINT v14; // eax
  _QWORD *v15; // r9
  __int64 v16; // rax

  switch ( a3 )
  {
    case 'b':
      *(_BYTE *)(a1 + 18) = 1;
      return 0LL;
    case 'f':
      *(_BYTE *)(a1 + 17) = 1;
      return 0LL;
    case 'n':
    case 'c':
      if ( a4 && *(_QWORD *)(a4 + 48) )
      {
        *(_WORD *)(a1 + 17) = 0;
        ServerXMLUpdateHandler::WriteContext(*(_QWORD *)(a1 + 8), a2, a3, *(_QWORD *)(*(_QWORD *)(a4 + 48) + 8LL), a4);
        return 1LL;
      }
      else
      {
        return 2147549183LL;
      }
    default:
      if ( *(_BYTE *)(a1 + 18) )
      {
        *(_BYTE *)(a1 + 18) = 0;
        v7 = *(_QWORD *)(a1 + 8);
        v8 = *(BSTR **)(v7 + 80);
        if ( v8 && *v8 )
        {
          v9 = SysStringLen(*v8);
          v7 = *(_QWORD *)(a1 + 8);
        }
        else
        {
          v9 = 0;
        }
        v10 = *(_QWORD **)((-(__int64)(v9 != 0) & 0xFFFFFFFFFFFFFFF0uLL) + v7 + 96);
        if ( v10 )
          v10 = (_QWORD *)*v10;
        ServerXMLUpdateHandler::WriteContext(v7, a2, 99, (__int64)v10);
        v11 = *(_QWORD *)(a1 + 8);
        if ( *(int *)(v11 + 1072) < 0 )
          *(_DWORD *)(v11 + 108) = 99;
      }
      else if ( *(_BYTE *)(a1 + 17) )
      {
        *(_BYTE *)(a1 + 17) = 0;
        v12 = *(_QWORD *)(a1 + 8);
        v13 = *(BSTR **)(v12 + 80);
        if ( v13 && *v13 )
        {
          v14 = SysStringLen(*v13);
          v12 = *(_QWORD *)(a1 + 8);
        }
        else
        {
          v14 = 0;
        }
        v15 = *(_QWORD **)((-(__int64)(v14 != 0) & 0xFFFFFFFFFFFFFFF0uLL) + v12 + 96);
        if ( v15 )
          v15 = (_QWORD *)*v15;
        ServerXMLUpdateHandler::WriteContext(v12, a2, 110, (__int64)v15);
        v16 = *(_QWORD *)(a1 + 8);
        if ( *(int *)(v16 + 1072) < 0 )
          *(_DWORD *)(v16 + 108) = 110;
      }
      return *(unsigned int *)(*(_QWORD *)(a1 + 8) + 1072LL);
  }
}

//----- (000000018001AC80) ----------------------------------------------------
__int64 __fastcall tsched::SafePathAppend(tsched *this, unsigned __int16 *a2, tsched *a3, tsched *a4)
{
  char *v4; // rbx
  unsigned __int64 v7; // [rsp+30h] [rbp+8h] BYREF

  v4 = (char *)a4;
  if ( this
    && a3
    && this != a4
    && (!*(_WORD *)a3 || this == a3 || (int)StringCchCopyW((char *)this, 261LL, (char *)a3) >= 0) )
  {
    if ( !v4 || !*(_WORD *)v4 )
      return 0LL;
    v7 = 0LL;
    if ( (int)StringCchLengthW((const unsigned __int16 *)this, 0x105uLL, &v7) >= 0 )
    {
      if ( *((_WORD *)this + v7 - 1) == 92 )
      {
        if ( *(_WORD *)v4 == 92 )
          v4 += 2;
      }
      else if ( *(_WORD *)v4 != 92 && (int)StringCchCatW((unsigned __int16 *)this, 261LL, (char *)L"\\") < 0 )
      {
        return 2147942487LL;
      }
      if ( (int)StringCchCatW((unsigned __int16 *)this, 261LL, v4) >= 0 )
        return 0LL;
    }
  }
  return 2147942487LL;
}

//----- (000000018001AD68) ----------------------------------------------------
__int64 __fastcall JobBucket::WritePrincipalXml(JobBucket *this, struct TaskXmlWriter *a2, struct Schema *a3)
{
  __int64 result; // rax
  BSTR *v6; // rax
  UINT v7; // eax
  _QWORD *v8; // rax
  __int64 v9; // r9
  BSTR *v10; // rax
  UINT v11; // eax
  int SidString; // ebx
  __int64 v13; // r8
  int v14; // edx
  int v15; // eax
  __int64 v16; // rax
  __int64 v17; // rcx
  _QWORD *v18; // rax
  __int64 v19; // r9
  __int64 *v20; // rax
  __int64 v21; // r8
  __int64 v22; // r8
  __int64 v23; // rdx
  int v24; // eax
  int v25; // r8d
  ULONGLONG v26; // r14
  __int64 v27; // rax
  __int64 v28; // r15
  unsigned int v29; // r12d
  __int64 v30; // r14
  __int64 v31; // r15
  _QWORD *v32; // rcx
  __int64 v33; // r9
  unsigned __int16 *v34[2]; // [rsp+20h] [rbp-10h] BYREF
  __int64 *v35; // [rsp+70h] [rbp+40h] BYREF
  struct _LUID LeastSignificantBit; // [rsp+78h] [rbp+48h]

  v35 = (__int64 *)a3;
  v34[1] = (unsigned __int16 *)-2LL;
  result = TaskXmlWriter::StartElement((int *)a2, 97);
  if ( (int)result >= 0 )
  {
    v6 = (BSTR *)*((_QWORD *)this + 9);
    if ( v6 && *v6 )
      v7 = SysStringLen(*v6);
    else
      v7 = 0;
    if ( v7 )
    {
      v8 = (_QWORD *)*((_QWORD *)this + 9);
      v9 = v8 ? *v8 : 0LL;
      result = TaskXmlWriter::StartElementWithAttribute((__int64)a2, 98, 99, v9);
    }
    else
    {
      result = TaskXmlWriter::StartElement((int *)a2, 98);
    }
    if ( (int)result >= 0 )
    {
      v10 = (BSTR *)*((_QWORD *)this + 10);
      if ( v10 && *v10 )
        v11 = SysStringLen(*v10);
      else
        v11 = 0;
      if ( !v11
        || ((v20 = (__int64 *)*((_QWORD *)this + 10)) == 0LL ? (v21 = 0LL) : (v21 = *v20),
            result = TaskXmlWriter::Element((__int64)a2, 112, v21),
            (int)result >= 0) )
      {
        v35 = 0LL;
        SidString = User::GetSidString((JobBucket *)((char *)this + 64), (struct _bstr_t *)&v35);
        if ( SidString < 0 )
          goto LABEL_34;
        if ( User::IsGroupAccount((JobBucket *)((char *)this + 64)) )
        {
          if ( v35 )
            v13 = *v35;
          else
            v13 = 0LL;
          v14 = 111;
        }
        else
        {
          if ( (*((_DWORD *)this + 4) & 0x20000) == 0 )
          {
            if ( v35 )
              v22 = *v35;
            else
              v22 = 0LL;
            SidString = TaskXmlWriter::Element((__int64)a2, 36, v22);
            if ( SidString < 0 )
              goto LABEL_34;
            v24 = *((_DWORD *)this + 4);
            if ( (v24 & 0x40000) != 0 )
            {
              v25 = 1;
            }
            else if ( (v24 & 0x4000) != 0 )
            {
              v25 = 2;
            }
            else
            {
              v25 = 3;
              if ( (v24 & 0x10000) == 0 && (v24 & 0x80000) != 0 )
                v25 = 6;
            }
            v15 = TaskXmlWriter::ElementLogonType((__int64)a2, v23, v25);
            goto LABEL_20;
          }
          if ( v35 )
            v13 = *v35;
          else
            v13 = 0LL;
          v14 = 36;
        }
        v15 = TaskXmlWriter::Element((__int64)a2, v14, v13);
LABEL_20:
        SidString = v15;
        if ( v15 >= 0 )
        {
          if ( (*((_DWORD *)this + 4) & 0x1000000) == 0
            || (SidString = TaskXmlWriter::ElementRunLevel((__int64)a2, 101, 1), SidString >= 0) )
          {
            if ( (*((_DWORD *)this + 4) & 0x8000000) == 0
              || (SidString = TaskXmlWriter::ElementProcessTokenSidType((__int64)a2, 133, 0), SidString >= 0) )
            {
              if ( (*((_DWORD *)this + 4) & 0x10000000) == 0
                || (SidString = TaskXmlWriter::ElementProcessTokenSidType((__int64)a2, 133, 1), SidString >= 0) )
              {
                v16 = *((_QWORD *)this + 26);
                if ( v16 )
                  v17 = *(_QWORD *)(v16 + 48);
                else
                  v17 = 0LL;
                if ( v17 )
                {
                  SidString = TaskXmlWriter::StartElement((int *)a2, 134);
                  if ( SidString >= 0 )
                  {
                    v26 = 1LL;
                    v27 = *((_QWORD *)this + 26);
                    if ( v27 )
                      v28 = *(_QWORD *)(v27 + 48);
                    else
                      v28 = 0LL;
                    while ( 1 )
                    {
                      if ( (v28 & v26) != 0 )
                      {
                        v34[0] = 0LL;
                        LeastSignificantBit = (struct _LUID)(unsigned int)RtlFindLeastSignificantBit(v26);
                        if ( (unsigned int)User::GetPrivilegeName(LeastSignificantBit, (const unsigned __int16 **)v34) )
                        {
                          SidString = TaskXmlWriter::Element((__int64)a2, 135, (__int64)v34[0]);
                          if ( SidString < 0 )
                            break;
                        }
                      }
                      v26 *= 2LL;
                      if ( !v26 )
                      {
                        SidString = TaskXmlWriter::EndElement((__int64)a2);
                        if ( SidString < 0 )
                          goto LABEL_34;
                        goto LABEL_28;
                      }
                    }
                  }
                  goto LABEL_34;
                }
LABEL_28:
                v18 = (_QWORD *)*((_QWORD *)this + 22);
                v19 = v18 ? *v18 : 0LL;
                SidString = JobBucket::WriteOptionalXmlElement(v17, (__int64)a2, 145, v19);
                if ( SidString >= 0 )
                {
                  if ( !(unsigned int)((__int64)(*((_QWORD *)this + 24) - *((_QWORD *)this + 23)) >> 3) )
                    goto LABEL_32;
                  SidString = TaskXmlWriter::StartElement((int *)a2, 146);
                  if ( SidString >= 0 )
                  {
                    v29 = 0;
                    v30 = (__int64)(*((_QWORD *)this + 24) - *((_QWORD *)this + 23)) >> 3;
                    if ( (_DWORD)v30 )
                    {
                      v31 = 0LL;
                      do
                      {
                        v32 = *(_QWORD **)(v31 + *((_QWORD *)this + 23));
                        v33 = v32 ? *v32 : 0LL;
                        SidString = JobBucket::WriteOptionalXmlElement((__int64)v32, (__int64)a2, 147, v33);
                        if ( SidString < 0 )
                          goto LABEL_34;
                        ++v29;
                        v31 += 8LL;
                      }
                      while ( v29 < (unsigned int)v30 );
                    }
                    SidString = TaskXmlWriter::EndElement((__int64)a2);
                    if ( SidString >= 0 )
                    {
LABEL_32:
                      SidString = TaskXmlWriter::EndElement((__int64)a2);
                      if ( SidString >= 0 )
                        SidString = TaskXmlWriter::EndElement((__int64)a2);
                    }
                  }
                }
              }
            }
          }
        }
LABEL_34:
        _bstr_t::_Free((_bstr_t *)&v35);
        return (unsigned int)SidString;
      }
    }
  }
  return result;
}
// 18001AEF9: variable 'v17' is possibly undefined
// 180047B00: variable 'v23' is possibly undefined

//----- (000000018001AF78) ----------------------------------------------------
__int64 __fastcall TaskXmlReader::LoadDateTime(const unsigned __int16 **this, SYSTEMTIME *a2)
{
  __int64 result; // rax
  unsigned int v5; // ebx

  result = TaskXmlReader::LoadRawValue((TaskXmlReader *)this, (struct XmlParserTempString *)(this + 8));
  v5 = 0;
  if ( (int)result >= 0 )
  {
    if ( (int)TSParser::ParseDateTime(this[9], *((unsigned int *)this + 16), a2) < 0 )
      return (unsigned int)-2147216616;
    return v5;
  }
  return result;
}

//----- (000000018001AFE0) ----------------------------------------------------
__int64 __fastcall UbpmParams::AddExeAction(
        UbpmParams *this,
        unsigned __int16 *a2,
        unsigned __int16 *a3,
        unsigned int a4,
        unsigned __int16 *a5,
        unsigned __int16 *a6)
{
  __int64 *v6; // rsi
  unsigned __int64 v11; // rcx
  unsigned __int64 v12; // rcx
  char *v13; // rax
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // r8
  __int64 v18; // [rsp+28h] [rbp-59h]
  __int64 v19; // [rsp+30h] [rbp-51h]
  __int64 v20; // [rsp+38h] [rbp-49h]
  __int64 v21; // [rsp+40h] [rbp-41h]
  char *NewActionId; // [rsp+48h] [rbp-39h] BYREF
  int v23; // [rsp+58h] [rbp-29h]
  int v24; // [rsp+5Ch] [rbp-25h]
  __int64 v25; // [rsp+60h] [rbp-21h]
  __int64 v26; // [rsp+68h] [rbp-19h]
  _DWORD v27[2]; // [rsp+70h] [rbp-11h] BYREF
  char *v28; // [rsp+78h] [rbp-9h]
  __int128 v29; // [rsp+80h] [rbp-1h]
  __int128 v30; // [rsp+90h] [rbp+Fh]
  __int64 v31; // [rsp+A0h] [rbp+1Fh]

  v24 = 0;
  v6 = (__int64 *)((char *)this + 120);
  v27[1] = 0;
  v27[0] = 1;
  v29 = 0LL;
  v30 = 0LL;
  v28 = UbpmParams::NewHostedString((unsigned __int64)this, (__int64 *)this + 15, a3, 0x7FFFFFFFuLL);
  v31 = a4;
  if ( a5 )
    *(_QWORD *)&v29 = UbpmParams::NewHostedString(v11, v6, a5, 0x7FFFFFFFuLL);
  if ( a6 )
    *((_QWORD *)&v29 + 1) = UbpmParams::NewHostedString(v11, v6, a6, 0x7FFFFFFFuLL);
  if ( *((_QWORD *)this + 57) )
    *(_QWORD *)&v30 = (char *)this + 448;
  NewActionId = UbpmParams::GetNewActionId(this);
  v13 = UbpmParams::NewHostedString(v12, v6, a2, 0x7FFFFFFFuLL);
  v23 = 1;
  v25 = UbpmParams::NewHostedObject<std::vector<_CSebiSystemEventCreationParameter *>,_CSebiSystemEventCreationParameter>(
          (__int64 *)this + 36,
          (__int64)v27,
          v14,
          v15,
          v18,
          v19,
          v20,
          v21,
          (__int64)NewActionId,
          (__int64)v13);
  v26 = (__int64)this + 384;
  std::vector<_UBPM_ACTION_PARAMS>::push_back((__int64 *)this + 33, (unsigned __int64)&NewActionId);
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
  {
    WPP_SF_SSSD(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xBu, v16, a3, (__int64)a5, (__int64)a6);
  }
  return 0LL;
}
// 18001B05D: variable 'v11' is possibly undefined
// 18001B096: variable 'v12' is possibly undefined
// 18001B0B1: variable 'v14' is possibly undefined
// 18001B0B1: variable 'v15' is possibly undefined
// 18001B0B1: variable 'v18' is possibly undefined
// 18001B0B1: variable 'v19' is possibly undefined
// 18001B0B1: variable 'v20' is possibly undefined
// 18001B0B1: variable 'v21' is possibly undefined
// 180047C96: variable 'v16' is possibly undefined
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018001B148) ----------------------------------------------------
__int64 __fastcall Triggers::TimeTrigger::WriteInnerXml(Triggers::TimeTrigger *this, struct TaskXmlWriter *a2)
{
  unsigned int v4; // ebx
  __int64 v5; // rax
  __int64 result; // rax
  __int64 v7; // rax
  char v8; // al
  const unsigned __int16 *v9; // r8
  unsigned int v10; // r8d
  int v11; // ecx
  unsigned int v12; // r8d
  int v13; // ecx
  __int64 v14; // rax
  unsigned int v15; // eax
  int v16; // ecx
  int v17; // ecx
  unsigned __int16 v18; // dx
  int v19; // edx
  __int128 v20; // [rsp+20h] [rbp-28h] BYREF
  char v21[24]; // [rsp+30h] [rbp-18h] BYREF

  v4 = 0;
  if ( *(_QWORD *)((*(__int64 (__fastcall **)(Triggers::TimeTrigger *, __int128 *))(*(_QWORD *)this + 120LL))(
                     this,
                     &v20)
                 + 8) )
  {
    v5 = (*(__int64 (__fastcall **)(Triggers::TimeTrigger *, __int128 *))(*(_QWORD *)this + 120LL))(this, &v20);
    if ( *(_DWORD *)(v5 + 12) != -1 || *(_DWORD *)(v5 + 8) != -1 )
    {
      v20 = *(_OWORD *)(*(__int64 (__fastcall **)(Triggers::TimeTrigger *, char *))(*(_QWORD *)this + 120LL))(this, v21);
      result = TaskXmlWriter::ElementTSDateTime((__int64)a2, 17, (TSTime *)&v20);
      v4 = result;
      if ( (int)result < 0 )
        return result;
    }
  }
  v7 = (*(__int64 (__fastcall **)(Triggers::TimeTrigger *, char *))(*(_QWORD *)this + 128LL))(this, v21);
  if ( *(_DWORD *)(v7 + 12) || *(_DWORD *)(v7 + 8) )
  {
    v14 = (*(__int64 (__fastcall **)(Triggers::TimeTrigger *, char *))(*(_QWORD *)this + 128LL))(this, v21);
    if ( *(_DWORD *)(v14 + 12) != -1 || *(_DWORD *)(v14 + 8) != -1 )
    {
      v20 = *(_OWORD *)(*(__int64 (__fastcall **)(Triggers::TimeTrigger *, char *))(*(_QWORD *)this + 128LL))(this, v21);
      result = TaskXmlWriter::ElementTSDateTime((__int64)a2, 18, (TSTime *)&v20);
      v4 = result;
      if ( (int)result < 0 )
        return result;
    }
  }
  if ( !(*(unsigned __int8 (__fastcall **)(Triggers::TimeTrigger *))(*(_QWORD *)this + 24LL))(this) )
  {
    v8 = (*(__int64 (__fastcall **)(Triggers::TimeTrigger *))(*(_QWORD *)this + 24LL))(this);
    v9 = L"true";
    if ( !v8 )
      v9 = L"false";
    result = TaskXmlWriter::Element((__int64)a2, 19, (__int64)v9);
    v4 = result;
    if ( (int)result < 0 )
      return result;
  }
  if ( (*(unsigned int (__fastcall **)(Triggers::TimeTrigger *))(*(_QWORD *)this + 48LL))(this) != -1 )
  {
    v15 = (*(__int64 (__fastcall **)(Triggers::TimeTrigger *))(*(_QWORD *)this + 48LL))(this);
    result = TaskXmlWriter::ElementDuration((__int64)a2, 20, v15);
    v4 = result;
    if ( (int)result < 0 )
      return result;
  }
  if ( *((_DWORD *)this + 14) )
  {
    result = TaskXmlWriter::StartElement((int *)a2, 13);
    if ( (int)result < 0 )
      return result;
    result = TaskXmlWriter::ElementDuration((__int64)a2, 14, *((_DWORD *)this + 14));
    if ( (int)result < 0 )
      return result;
    v12 = *((_DWORD *)this + 15);
    if ( v12 )
    {
      result = TaskXmlWriter::ElementDuration((__int64)a2, 15, v12);
      if ( (int)result < 0 )
        return result;
    }
    if ( *((_BYTE *)this + 80) )
    {
      result = TaskXmlWriter::Element((__int64)a2, 16, (__int64)L"true");
      if ( (int)result < 0 )
        return result;
    }
    result = TaskXmlWriter::EndElement((__int64)a2);
    v4 = result;
    if ( (int)result < 0 )
      return result;
  }
  v10 = *((_DWORD *)this + 22);
  if ( v10 )
  {
    result = TaskXmlWriter::ElementDuration((__int64)a2, 26, v10);
    v4 = result;
    if ( (int)result < 0 )
      return result;
  }
  v11 = *((_DWORD *)this + 17);
  if ( !v11 )
    return v4;
  v13 = v11 - 1;
  if ( !v13 )
  {
    result = TaskXmlWriter::StartElement((int *)a2, 40);
    if ( (int)result < 0 )
      return result;
    result = TaskXmlWriter::ElementInt((__int64)a2, 41, *((unsigned __int16 *)this + 36));
LABEL_28:
    if ( (int)result < 0 )
      return result;
LABEL_29:
    result = TaskXmlWriter::EndElement((__int64)a2);
    v4 = result;
    if ( (int)result < 0 )
      return result;
    return v4;
  }
  v16 = v13 - 1;
  if ( !v16 )
  {
    result = TaskXmlWriter::StartElement((int *)a2, 42);
    if ( (int)result < 0 )
      return result;
    result = TaskXmlWriter::ElementInt((__int64)a2, 43, *((unsigned __int16 *)this + 36));
    if ( (int)result < 0 )
      return result;
    if ( !*((_WORD *)this + 37) )
      goto LABEL_29;
    v18 = *((_WORD *)this + 37);
LABEL_61:
    result = TaskXmlWriter::SectionDaysOfWeek(a2, v18);
    goto LABEL_28;
  }
  v17 = v16 - 1;
  if ( !v17 )
  {
    result = TaskXmlWriter::StartElement((int *)a2, 52);
    if ( (int)result < 0 )
      return result;
    if ( *((_WORD *)this + 38) )
    {
      result = TaskXmlWriter::SectionMonths(a2, *((_WORD *)this + 38));
      if ( (int)result < 0 )
        return result;
    }
    v19 = *((_DWORD *)this + 18);
    if ( !v19 )
      goto LABEL_29;
    result = TaskXmlWriter::SectionDaysOfMonth(a2, v19);
    goto LABEL_28;
  }
  if ( v17 != 1 )
    return 2147549183LL;
  result = TaskXmlWriter::StartElement((int *)a2, 54);
  if ( (int)result >= 0 )
  {
    if ( !*((_WORD *)this + 38) || (result = TaskXmlWriter::SectionMonths(a2, *((_WORD *)this + 38)), (int)result >= 0) )
    {
      if ( !*((_WORD *)this + 37)
        || (result = TaskXmlWriter::SectionWeeks(a2, *((unsigned __int16 *)this + 37)), (int)result >= 0) )
      {
        if ( !*((_WORD *)this + 36) )
          goto LABEL_29;
        v18 = *((_WORD *)this + 36);
        goto LABEL_61;
      }
    }
  }
  return result;
}

//----- (000000018001B368) ----------------------------------------------------
__int64 __fastcall Triggers::GenericTrigger::WriteInnerXml(Triggers::GenericTrigger *this, struct TaskXmlWriter *a2)
{
  unsigned int v4; // ebx
  __int64 v5; // rax
  __int64 v6; // rax
  char v7; // al
  const unsigned __int16 *v8; // r8
  __int64 result; // rax
  unsigned int v10; // r8d
  __int64 v11; // rax
  unsigned int v12; // eax
  unsigned int v13; // r8d
  __int128 v14; // [rsp+20h] [rbp-28h] BYREF
  char v15[24]; // [rsp+30h] [rbp-18h] BYREF

  v4 = 0;
  if ( !*(_QWORD *)((*(__int64 (__fastcall **)(Triggers::GenericTrigger *, __int128 *))(*(_QWORD *)this + 8LL))(
                      this,
                      &v14)
                  + 8)
    || (v11 = (*(__int64 (__fastcall **)(Triggers::GenericTrigger *, __int128 *))(*(_QWORD *)this + 8LL))(this, &v14),
        *(_DWORD *)(v11 + 12) == -1)
    && *(_DWORD *)(v11 + 8) == -1
    || (v14 = *(_OWORD *)(*(__int64 (__fastcall **)(Triggers::GenericTrigger *, char *))(*(_QWORD *)this + 8LL))(
                           this,
                           v15),
        result = TaskXmlWriter::ElementTSDateTime((__int64)a2, 17, (TSTime *)&v14),
        v4 = result,
        (int)result >= 0) )
  {
    if ( (v5 = (*(__int64 (__fastcall **)(Triggers::GenericTrigger *, char *))(*(_QWORD *)this + 16LL))(this, v15),
          !*(_DWORD *)(v5 + 12))
      && !*(_DWORD *)(v5 + 8)
      || (v6 = (*(__int64 (__fastcall **)(Triggers::GenericTrigger *, char *))(*(_QWORD *)this + 16LL))(this, v15),
          *(_DWORD *)(v6 + 12) == -1)
      && *(_DWORD *)(v6 + 8) == -1
      || (v14 = *(_OWORD *)(*(__int64 (__fastcall **)(Triggers::GenericTrigger *, char *))(*(_QWORD *)this + 16LL))(
                             this,
                             v15),
          result = TaskXmlWriter::ElementTSDateTime((__int64)a2, 18, (TSTime *)&v14),
          v4 = result,
          (int)result >= 0) )
    {
      if ( (*(unsigned int (__fastcall **)(Triggers::GenericTrigger *))(*(_QWORD *)this + 48LL))(this) == -1
        || (v12 = (*(__int64 (__fastcall **)(Triggers::GenericTrigger *))(*(_QWORD *)this + 48LL))(this),
            result = TaskXmlWriter::ElementDuration((__int64)a2, 20, v12),
            v4 = result,
            (int)result >= 0) )
      {
        if ( (*(unsigned __int8 (__fastcall **)(Triggers::GenericTrigger *))(*(_QWORD *)this + 24LL))(this) )
          goto LABEL_11;
        v7 = (*(__int64 (__fastcall **)(Triggers::GenericTrigger *))(*(_QWORD *)this + 24LL))(this);
        v8 = L"true";
        if ( !v7 )
          v8 = L"false";
        result = TaskXmlWriter::Element((__int64)a2, 19, (__int64)v8);
        v4 = result;
        if ( (int)result >= 0 )
        {
LABEL_11:
          v10 = *((_DWORD *)this + 10);
          if ( !v10 || (result = TaskXmlWriter::ElementDuration((__int64)a2, 22, v10), v4 = result, (int)result >= 0) )
          {
            if ( !*((_DWORD *)this + 12) )
              return v4;
            result = TaskXmlWriter::StartElement((int *)a2, 13);
            if ( (int)result >= 0 )
            {
              result = TaskXmlWriter::ElementDuration((__int64)a2, 14, *((_DWORD *)this + 12));
              if ( (int)result >= 0 )
              {
                v13 = *((_DWORD *)this + 13);
                if ( !v13 || (result = TaskXmlWriter::ElementDuration((__int64)a2, 15, v13), (int)result >= 0) )
                {
                  if ( !*((_BYTE *)this + 60)
                    || (result = TaskXmlWriter::Element((__int64)a2, 16, (__int64)L"true"), (int)result >= 0) )
                  {
                    result = TaskXmlWriter::EndElement((__int64)a2);
                    v4 = result;
                    if ( (int)result >= 0 )
                      return v4;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (000000018001B4B0) ----------------------------------------------------
__int64 __fastcall Triggers::WnfStateChangeTrigger::WriteXml(
        Triggers::WnfStateChangeTrigger *this,
        struct TaskXmlWriter *a2)
{
  BSTR *v2; // rax
  UINT v5; // eax
  __int64 *v6; // rax
  __int64 v7; // r9
  __int64 result; // rax

  v2 = (BSTR *)*((_QWORD *)this + 10);
  if ( v2 && *v2 )
    v5 = SysStringLen(*v2);
  else
    v5 = 0;
  if ( v5 )
  {
    v6 = (__int64 *)*((_QWORD *)this + 10);
    if ( v6 )
      v7 = *v6;
    else
      v7 = 0LL;
    result = TaskXmlWriter::StartElementWithAttribute((__int64)a2, 141, 109, v7);
  }
  else
  {
    result = TaskXmlWriter::StartElement((int *)a2, 141);
  }
  if ( (int)result >= 0 )
  {
    result = Triggers::WnfStateChangeTrigger::WriteInnerXml(this, a2);
    if ( (int)result >= 0 )
      return TaskXmlWriter::EndElement((__int64)a2);
  }
  return result;
}

//----- (000000018001B544) ----------------------------------------------------
__int64 __fastcall JobBucket::GetExecutionTimeLimit(JobBucket *this)
{
  __int64 v1; // rax

  v1 = *((_QWORD *)this + 26);
  if ( v1 )
    return *(unsigned int *)(v1 + 8);
  else
    return 259200LL;
}

//----- (000000018001B564) ----------------------------------------------------
__int64 __fastcall TSTime::operator+=(__int64 a1, __int64 *a2)
{
  __int64 v2; // r8
  unsigned __int64 v3; // rdx

  v2 = *a2;
  v3 = *(_QWORD *)(a1 + 8);
  if ( v2 < 0 )
  {
    if ( v2 < -(__int64)v3 )
    {
      *(_QWORD *)(a1 + 8) = 0LL;
      return a1;
    }
  }
  else if ( v3 > -1 - v2 )
  {
    *(_QWORD *)(a1 + 8) = -1LL;
    return a1;
  }
  *(_QWORD *)(a1 + 8) = v3 + v2;
  return a1;
}

//----- (000000018001B5AC) ----------------------------------------------------
char *__fastcall UbpmParams::GetNewTriggerId(UbpmParams *this)
{
  unsigned __int64 v2; // rcx
  wchar_t Buffer[32]; // [rsp+20h] [rbp-58h] BYREF

  _ltow_s(*((_DWORD *)this + 216), Buffer, 0x20uLL, 10);
  ++*((_DWORD *)this + 216);
  return UbpmParams::NewHostedString(v2, (__int64 *)this + 109, Buffer, 0x20uLL);
}
// 18001B5FD: variable 'v2' is possibly undefined

//----- (000000018001B61C) ----------------------------------------------------
XmlParserTempString *__fastcall XmlParserTempString::operator=(XmlParserTempString *a1, __int64 a2)
{
  __int64 v4; // rax
  XmlParserTempString *result; // rax

  XmlParserTempString::Clear(a1);
  v4 = -1LL;
  do
    ++v4;
  while ( *(_WORD *)(a2 + 2 * v4) );
  *(_DWORD *)a1 = v4;
  result = a1;
  *((_QWORD *)a1 + 1) = a2;
  return result;
}

//----- (000000018001B660) ----------------------------------------------------
__int64 __fastcall UbpmParams::SetActionConstraints(UbpmParams *this, const struct JobMoniker *a2)
{
  __int64 v3; // rdx
  int v5; // ecx
  int v6; // ecx
  __int64 v7; // rdx
  unsigned int *v8; // rax
  unsigned int v9; // ecx
  __int64 v10; // rcx
  unsigned int v11; // edx
  unsigned int Priority; // eax
  __int64 v13; // rcx
  unsigned int v14; // eax
  __int64 v15; // rdx
  unsigned int v16; // r8d
  __int64 v17; // rcx
  unsigned int v18; // eax
  __int64 v19; // rdx
  unsigned int v20; // r8d
  __int64 v21; // rcx
  unsigned int v22; // eax
  __int64 v23; // rdx
  unsigned int v24; // r8d
  unsigned int v25; // r9d
  __int64 v26; // rcx
  __int64 v27; // rcx
  __int64 v28; // rcx
  int v29; // eax
  struct _GUID v31; // [rsp+20h] [rbp-18h] BYREF

  *((_DWORD *)this + 110) = 1;
  v3 = *((_QWORD *)a2 + 4);
  if ( (*(_DWORD *)(v3 + 16) & 0x100) != 0 )
  {
    *((_DWORD *)this + 96) |= 1u;
    v3 = *((_QWORD *)a2 + 4);
  }
  if ( (*(_DWORD *)(v3 + 16) & 0x40000000) != 0 )
  {
    *((_DWORD *)this + 96) |= 8u;
    v3 = *((_QWORD *)a2 + 4);
  }
  if ( (*(_BYTE *)(v3 + 16) & 0x10) != 0 )
  {
    *((_DWORD *)this + 96) |= 2u;
    v3 = *((_QWORD *)a2 + 4);
  }
  v5 = *((_DWORD *)this + 96);
  if ( (*(_DWORD *)(v3 + 16) & 0x4000000) != 0 )
    v5 |= 0x400u;
  v6 = v5 | 0x20000;
  *((_DWORD *)this + 96) = v6;
  v7 = *((_QWORD *)a2 + 4);
  if ( (*(_BYTE *)(v7 + 16) & 0x20) != 0 )
  {
    v6 |= 4u;
    *((_DWORD *)this + 96) = v6;
    v7 = *((_QWORD *)a2 + 4);
  }
  if ( (*(_DWORD *)(v7 + 16) & 0x200) != 0 )
  {
    v6 |= 0x10u;
    *((_DWORD *)this + 96) = v6;
    v7 = *((_QWORD *)a2 + 4);
  }
  if ( (*(_BYTE *)(v7 + 16) & 2) != 0 )
  {
    v6 |= 0x40u;
    *((_DWORD *)this + 96) = v6;
    v7 = *((_QWORD *)a2 + 4);
    if ( (*(_BYTE *)(v7 + 16) & 8) != 0 )
    {
      v6 |= 0x80u;
      *((_DWORD *)this + 96) = v6;
      v7 = *((_QWORD *)a2 + 4);
      if ( (*(_BYTE *)(v7 + 16) & 4) != 0 )
      {
        v6 |= 0x100u;
        *((_DWORD *)this + 96) = v6;
        v7 = *((_QWORD *)a2 + 4);
      }
    }
  }
  if ( (*(_BYTE *)(v7 + 16) & 0x80) != 0 )
  {
    *((_DWORD *)this + 96) = v6 | 0x200;
    *(struct _GUID *)((char *)this + 424) = *JobBucket::GetNetworkId(*((JobBucket **)a2 + 4), &v31);
    v7 = *((_QWORD *)a2 + 4);
  }
  v8 = *(unsigned int **)(v7 + 208);
  if ( v8 )
    v9 = *v8;
  else
    v9 = 0;
  *((_DWORD *)this + 97) = v9 / 0x3C;
  v10 = *(_QWORD *)(*((_QWORD *)a2 + 4) + 208LL);
  if ( v10 )
    v11 = *(_DWORD *)(v10 + 4);
  else
    v11 = -1;
  *((_DWORD *)this + 98) = v11 / 0x3C;
  *((_DWORD *)this + 99) = JobBucket::GetExecutionTimeLimit(*((JobBucket **)a2 + 4));
  Priority = JobBucket::GetPriority(*((JobBucket **)a2 + 4));
  v13 = 0LL;
  if ( Priority )
    v13 = Priority;
  if ( (unsigned int)v13 >= 0xA )
    v13 = 10LL;
  *((_DWORD *)this + 100) = *((_DWORD *)&PriorityToPriorityClass + v13);
  v14 = JobBucket::GetPriority(*((JobBucket **)a2 + 4));
  v17 = 0LL;
  if ( v14 )
    v17 = v14;
  if ( (unsigned int)v17 >= v16 )
    v17 = v16;
  *((_DWORD *)this + 101) = *(_DWORD *)(v15 + 4 * v17 + 513160);
  v18 = JobBucket::GetPriority(*((JobBucket **)a2 + 4));
  v21 = 0LL;
  if ( v18 )
    v21 = v18;
  if ( (unsigned int)v21 >= v20 )
    v21 = v20;
  *((_DWORD *)this + 102) = *(_DWORD *)(v19 + 4 * v21 + 513112);
  v22 = JobBucket::GetPriority(*((JobBucket **)a2 + 4));
  v26 = 0LL;
  if ( v22 )
    v26 = v22;
  if ( (unsigned int)v26 >= v24 )
    v26 = v24;
  *((_DWORD *)this + 103) = *(_DWORD *)(v23 + 4 * v26 + 513208);
  v27 = *(_QWORD *)(*((_QWORD *)a2 + 4) + 208LL);
  if ( v27 )
    LODWORD(v27) = *(_DWORD *)(v27 + 20);
  *((_DWORD *)this + 104) = (unsigned int)(((unsigned int)v27 * (unsigned __int64)v25) >> 32) >> 5;
  v28 = *(_QWORD *)(*((_QWORD *)a2 + 4) + 208LL);
  if ( v28 )
    v29 = *(_DWORD *)(v28 + 24);
  else
    v29 = 0;
  *((_DWORD *)this + 105) = v29;
  if ( (unsigned int)RtlGetCurrentServiceSessionId() )
    *((_DWORD *)this + 96) &= 0xFFFDFDFF;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
  {
    WPP_SF_S(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0xEu,
      (__int64)&WPP_f0f7296807f33a7e423f6d049324e537_Traceguids,
      *((const wchar_t **)a2 + 3));
  }
  return 0LL;
}
// 18001B827: variable 'v16' is possibly undefined
// 18001B82B: variable 'v15' is possibly undefined
// 18001B84B: variable 'v20' is possibly undefined
// 18001B84F: variable 'v19' is possibly undefined
// 18001B86F: variable 'v24' is possibly undefined
// 18001B873: variable 'v23' is possibly undefined
// 18001B896: variable 'v25' is possibly undefined
// 180074628: using guessed type __int64 RtlGetCurrentServiceSessionId(void);
// 18007D4E8: using guessed type unsigned int near *PriorityToPriorityClass;
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018001B928) ----------------------------------------------------
__int64 __fastcall JobBucket::GetPriority(JobBucket *this)
{
  __int64 v1; // rax

  v1 = *((_QWORD *)this + 26);
  if ( v1 )
    return *(unsigned int *)(v1 + 16);
  else
    return 7LL;
}

//----- (000000018001B948) ----------------------------------------------------
char *__fastcall UbpmParams::GetNewActionId(UbpmParams *this)
{
  unsigned __int64 v2; // rcx
  wchar_t Buffer[32]; // [rsp+20h] [rbp-58h] BYREF

  _ltow_s(*((_DWORD *)this + 84), Buffer, 0x20uLL, 10);
  ++*((_DWORD *)this + 84);
  return UbpmParams::NewHostedString(v2, (__int64 *)this + 43, Buffer, 0x20uLL);
}
// 18001B999: variable 'v2' is possibly undefined

//----- (000000018001B9B8) ----------------------------------------------------
__int64 __fastcall TaskXmlReader::CreateXmlReader(TaskXmlReader *this)
{
  char v2; // r15
  int v3; // eax
  void *v4; // rbx
  __int64 v5; // rax
  int v6; // eax
  __int64 *v7; // rcx
  void *v8; // rsi
  int started; // edi
  CBstrWriter *v11; // rax
  TaskXmlWriter *v12; // rcx
  __int64 v13; // rax
  __int64 v14; // r14
  int MaxNode; // eax
  int v16; // edx
  __int64 v17[4]; // [rsp+20h] [rbp-20h] BYREF
  CBstrWriter *v18; // [rsp+78h] [rbp+38h] BYREF
  void *ppvObject; // [rsp+80h] [rbp+40h] BYREF
  void *v20; // [rsp+88h] [rbp+48h] BYREF

  v17[1] = -2LL;
  v2 = 0;
  LODWORD(v18) = 0;
  ppvObject = 0LL;
  v3 = CreateXmlReader(&GUID_7279fc81_709d_4095_b63d_69fe4b0d9030, &ppvObject, 0LL);
  if ( v3 < 0 )
    return TaskXmlReader::SetErrorInfoXmlLite(this, v3);
  v4 = ppvObject;
  v20 = ppvObject;
  _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::_AddRef((__int64 *)&v20);
  (*(void (__fastcall **)(void *))(*(_QWORD *)ppvObject + 16LL))(ppvObject);
  v5 = _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::operator->((__int64 *)&v20);
  v6 = (*(__int64 (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v5 + 24LL))(v5, *((_QWORD *)this + 4));
  if ( v6 < 0 )
  {
    started = TaskXmlReader::SetErrorInfoXmlLite(this, v6);
  }
  else
  {
    v7 = (__int64 *)((char *)this + 56);
    v8 = (void *)*((_QWORD *)this + 7);
    if ( v8 != v4 )
    {
      *v7 = (__int64)v4;
      _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::_AddRef(v7);
      if ( v8 )
        (*(void (__fastcall **)(void *))(*(_QWORD *)v8 + 16LL))(v8);
    }
    if ( *((_BYTE *)this + 40) )
    {
      v11 = (CBstrWriter *)operator new(0x28uLL);
      v18 = v11;
      if ( v11 )
        v11 = CBstrWriter::CBstrWriter(v11);
      ATL::CComPtr<IStream>::operator=((__int64 *)this + 3, (__int64)v11);
      if ( !*((_QWORD *)this + 3) )
        goto LABEL_28;
      v12 = (TaskXmlWriter *)*((_QWORD *)this + 2);
      if ( v12 )
        TaskXmlWriter::`scalar deleting destructor'(v12);
      v13 = (__int64)operator new(0xA0uLL);
      v14 = v13;
      v17[2] = v13;
      if ( v13 )
      {
        LODWORD(v18) = 65542;
        MaxNode = Schema::GetMaxNode((int *)&v18);
        while ( v16 < MaxNode )
          ++v16;
        _com_ptr_t<_com_IIID<IStream,&__s_GUID const _GUID_0000000c_0000_0000_c000_000000000046>>::_com_ptr_t<_com_IIID<IStream,&__s_GUID const _GUID_0000000c_0000_0000_c000_000000000046>>(
          v17,
          (_QWORD *)this + 3);
        v2 = 1;
        v13 = TaskXmlWriter::TaskXmlWriter(v14, v17, &v18);
      }
      *((_QWORD *)this + 2) = v13;
      if ( (v2 & 1) != 0 )
      {
        _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::~_com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>(v17);
        v13 = *((_QWORD *)this + 2);
      }
      if ( !v13 )
      {
LABEL_28:
        started = -2147024882;
        goto LABEL_8;
      }
      started = TaskXmlWriter::StartDocument(v13, 65542);
      if ( started < 0 )
        goto LABEL_8;
    }
    started = 0;
  }
LABEL_8:
  if ( v4 )
    (*(void (__fastcall **)(void *))(*(_QWORD *)v4 + 16LL))(v4);
  return (unsigned int)started;
}
// 18001BB09: variable 'v16' is possibly undefined

//----- (000000018001BB74) ----------------------------------------------------
__int64 __fastcall TaskXmlWriter::ElementMultipleInstancesPolicy(__int64 a1, __int16 a2)
{
  int v2; // edx
  const unsigned __int16 *v3; // r8

  v2 = a2 & 0x3C00;
  switch ( v2 )
  {
    case 4096:
      v3 = L"Queue";
      break;
    case 1024:
      v3 = L"Parallel";
      break;
    case 2048:
      v3 = L"StopExisting";
      break;
    default:
      v3 = L"IgnoreNew";
      break;
  }
  return TaskXmlWriter::Element(a1, 73, (__int64)v3);
}

//----- (000000018001BBC4) ----------------------------------------------------
int __fastcall TaskXmlReader::LoadValue(TaskXmlReader *this, enum Schema::Version *a2)
{
  char v4; // r14
  unsigned int *v5; // rsi
  int result; // eax
  _QWORD *v7; // rsi
  __int64 v8; // rcx
  CBstrWriter *v9; // rax
  TaskXmlWriter *v10; // rcx
  __int64 v11; // rax
  __int64 v12; // rbp
  int MaxNode; // eax
  int v14; // edx
  CBstrWriter *v15; // [rsp+60h] [rbp+8h] BYREF
  __int64 v16; // [rsp+70h] [rbp+18h] BYREF
  __int64 v17; // [rsp+78h] [rbp+20h]

  v4 = 0;
  LODWORD(v15) = 0;
  v5 = (unsigned int *)((char *)this + 64);
  result = TaskXmlReader::LoadRawValue(this, (TaskXmlReader *)((char *)this + 64));
  if ( result >= 0 )
  {
    if ( !wcsncmp(*((const wchar_t **)this + 9), L"1.0", *v5) )
    {
      *(_DWORD *)a2 = 0x10000;
    }
    else if ( !wcsncmp(*((const wchar_t **)this + 9), L"1.1", *v5) )
    {
      *(_DWORD *)a2 = 65537;
    }
    else if ( !wcsncmp(*((const wchar_t **)this + 9), L"1.2", *v5) )
    {
      *(_DWORD *)a2 = 65538;
    }
    else if ( !wcsncmp(*((const wchar_t **)this + 9), L"1.3", *v5) )
    {
      *(_DWORD *)a2 = 65539;
    }
    else if ( !wcsncmp(*((const wchar_t **)this + 9), L"1.4", *v5) )
    {
      *(_DWORD *)a2 = 65540;
    }
    else if ( !wcsncmp(*((const wchar_t **)this + 9), L"1.5", *v5) )
    {
      *(_DWORD *)a2 = 65541;
    }
    else
    {
      if ( wcsncmp(*((const wchar_t **)this + 9), L"1.6", *v5) )
        return -2147216616;
      *(_DWORD *)a2 = 65542;
    }
    if ( !*((_BYTE *)this + 40) )
      return 0;
    v7 = (_QWORD *)((char *)this + 24);
    v8 = *((_QWORD *)this + 3);
    if ( v8 )
    {
      *v7 = 0LL;
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v8 + 16LL))(v8);
    }
    v9 = (CBstrWriter *)operator new(0x28uLL);
    v15 = v9;
    if ( v9 )
      v9 = CBstrWriter::CBstrWriter(v9);
    ATL::CComPtr<IStream>::operator=((__int64 *)this + 3, (__int64)v9);
    if ( !*v7 )
      return -2147024882;
    v10 = (TaskXmlWriter *)*((_QWORD *)this + 2);
    if ( v10 )
    {
      TaskXmlWriter::`scalar deleting destructor'(v10);
      *((_QWORD *)this + 2) = 0LL;
    }
    v11 = (__int64)operator new(0xA0uLL);
    v12 = v11;
    v17 = v11;
    if ( v11 )
    {
      LODWORD(v15) = *(_DWORD *)a2;
      MaxNode = Schema::GetMaxNode((int *)&v15);
      while ( v14 < MaxNode )
        ++v14;
      _com_ptr_t<_com_IIID<IStream,&__s_GUID const _GUID_0000000c_0000_0000_c000_000000000046>>::_com_ptr_t<_com_IIID<IStream,&__s_GUID const _GUID_0000000c_0000_0000_c000_000000000046>>(
        &v16,
        (_QWORD *)this + 3);
      v4 = 1;
      v11 = TaskXmlWriter::TaskXmlWriter(v12, &v16, &v15);
    }
    *((_QWORD *)this + 2) = v11;
    if ( (v4 & 1) != 0 )
    {
      _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::~_com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>(&v16);
      v11 = *((_QWORD *)this + 2);
    }
    if ( !v11 )
      return -2147024882;
    result = TaskXmlWriter::StartDocument(v11, *(_DWORD *)a2);
    if ( result >= 0 )
      return 0;
  }
  return result;
}
// 18001BD8E: variable 'v14' is possibly undefined

//----- (000000018001BE1C) ----------------------------------------------------
__int64 __fastcall RpcServer::RetrieveTask(
        RpcServer *this,
        char *a2,
        const unsigned __int16 *a3,
        unsigned int *a4,
        unsigned __int16 **a5)
{
  const unsigned __int16 *v9; // r8
  __int64 result; // rax
  const unsigned __int16 *v11; // rdx
  int CallerToken; // esi
  RTL_SRWLOCK *v13; // rdi
  HKEY *v14; // rbx
  char *v15; // rbx
  volatile signed __int32 *v16; // rax
  volatile signed __int32 *v17; // rsi
  unsigned __int16 *Copy; // rax
  UINT v19; // eax
  __int64 v20; // r14
  unsigned __int16 *v21; // rax
  int v22; // [rsp+88h] [rbp-80h] BYREF
  BSTR pbstr; // [rsp+90h] [rbp-78h] BYREF
  __int64 v24; // [rsp+98h] [rbp-70h] BYREF
  void *lpMem; // [rsp+A0h] [rbp-68h] BYREF
  HANDLE ClientToken; // [rsp+A8h] [rbp-60h] BYREF
  User::UserEntry *v27; // [rsp+B0h] [rbp-58h] BYREF
  volatile signed __int32 *v28; // [rsp+B8h] [rbp-50h] BYREF
  RTL_SRWLOCK *v29; // [rsp+C0h] [rbp-48h]
  __int64 v30; // [rsp+C8h] [rbp-40h]
  char v31[24]; // [rsp+D0h] [rbp-38h] BYREF
  struct _FILETIME v32[7]; // [rsp+E8h] [rbp-20h] BYREF
  char v33[16]; // [rsp+120h] [rbp+18h] BYREF
  char v34[16]; // [rsp+130h] [rbp+28h] BYREF
  wmi::RefBase *v35; // [rsp+140h] [rbp+38h] BYREF
  char v36[16]; // [rsp+148h] [rbp+40h] BYREF
  char v37[16]; // [rsp+158h] [rbp+50h] BYREF
  wmi::RefBase *v38; // [rsp+168h] [rbp+60h] BYREF
  char v39[1056]; // [rsp+178h] [rbp+70h] BYREF
  CBstrWriter *v40; // [rsp+598h] [rbp+490h]
  unsigned __int16 v41[264]; // [rsp+5B8h] [rbp+4B0h] BYREF

  v30 = -2LL;
  if ( a5 )
    *a5 = 0LL;
  memset_0(v41, 0, 0x20AuLL);
  result = tsched::TaskPathCanonicalize((tsched *)v41, a2, v9);
  if ( (int)result >= 0 )
  {
    if ( tsched::IsRoot((tsched *)v41, v11) )
    {
      return 2147942487LL;
    }
    else
    {
      ClientToken = 0LL;
      CallerToken = GetCallerToken(L"RetrieveTask", &ClientToken);
      if ( CallerToken >= 0 )
      {
        v13 = (RTL_SRWLOCK *)((char *)this + 16);
        v29 = v13;
        AcquireSRWLockShared(v13);
        v14 = (HKEY *)JobStore::m_pCommonStore;
        CallerToken = TaskAccessCheck(ClientToken, v41, 1u);
        if ( CallerToken >= 0 )
        {
          JobMoniker::JobMoniker((JobMoniker *)v36, v41, 0LL);
          lpMem = 0LL;
          CallerToken = JobStore::GenerateTaskXmlFromRegistry(
                          v14,
                          (struct JobMoniker *)v36,
                          (__int64)a3,
                          a4,
                          (char **)&lpMem);
          if ( CallerToken >= 0 )
          {
            v15 = 0LL;
            pbstr = 0LL;
            v24 = 0LL;
            CallerToken = StringReader::CreateStream((__int64)lpMem, &v24);
            if ( CallerToken >= 0 )
            {
              v16 = (volatile signed __int32 *)operator new(0x460uLL);
              v28 = v16;
              if ( v16 )
                v17 = (volatile signed __int32 *)TaskXmlReader::TaskXmlReader((__int64)v16, &v24, 0LL, 0);
              else
                v17 = 0LL;
              v28 = v17;
              if ( v17 )
              {
                _InterlockedIncrement(v17 + 2);
                v13 = v29;
                v15 = (char *)pbstr;
              }
              JobMoniker::JobMoniker((JobMoniker *)v33, v41, 0LL);
              Triggers::Trigulator::Trigulator(v32);
              Actions::ActionCollection::ActionCollection((Actions::ActionCollection *)v31);
              v27 = 0LL;
              ServerXMLUpdateHandler::ServerXMLUpdateHandler(
                (ServerXMLUpdateHandler *)v39,
                0,
                1,
                v41,
                0LL,
                0LL,
                0,
                (const struct JobMoniker *)v33,
                &v27,
                (struct Triggers::Trigulator *)v32,
                (struct Actions::ActionCollection *)v31,
                0,
                0LL,
                0LL,
                6u);
              wmi::AutoRef<User::UserEntry>::Release(&v27);
              RpcAutoImpersonate::RpcAutoImpersonate((RpcAutoImpersonate *)&v22, L"RpcServer::RetrieveTask", 1);
              CallerToken = TaskXmlReader::ProcessXml((TaskXmlReader *)v17, (struct ITaskXmlHandler *)v39);
              if ( CallerToken < 0 )
              {
                if ( v22 )
                  RpcRevertToSelf();
              }
              else
              {
                if ( v22 )
                  RpcRevertToSelf();
                Copy = CBstrWriter::GetCopy(v40);
                ATL::CComBSTR::Attach(&pbstr, Copy);
                v15 = (char *)pbstr;
                v19 = SysStringLen(pbstr);
                if ( v19 )
                {
                  v20 = v19 + 1LL;
                  v21 = (unsigned __int16 *)operator new(saturated_mul(v20, 2uLL));
                  *a5 = v21;
                  if ( v21 )
                  {
                    *v21 = 0;
                    StringCchCopyW((char *)*a5, v20, v15);
                  }
                }
              }
              ServerXMLUpdateHandler::~ServerXMLUpdateHandler((ServerXMLUpdateHandler *)v39);
              Actions::ActionCollection::~ActionCollection((Actions::ActionCollection *)v31);
              Triggers::Trigulator::~Trigulator((Triggers::Trigulator *)v32);
              wmi::AutoRef<JobBucket>::Release(&v35);
              _bstr_t::_Free((_bstr_t *)v34);
              wmi::AutoRef<FolderEnumerator>::~AutoRef<FolderEnumerator>(&v28);
            }
            _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::~_com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>(&v24);
            SysFreeString((BSTR)v15);
          }
          operator delete(lpMem);
          wmi::AutoRef<JobBucket>::Release(&v38);
          _bstr_t::_Free((_bstr_t *)v37);
        }
        ReleaseSRWLockShared(v13);
      }
      wmi::AutoHandle::Close(&ClientToken);
      return (unsigned int)CallerToken;
    }
  }
  return result;
}
// 18001BE91: variable 'v9' is possibly undefined
// 18001BEA5: variable 'v11' is possibly undefined
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);
// 1800090EC: using guessed type __int64 __fastcall wmi::AutoRef<FolderEnumerator>::~AutoRef<FolderEnumerator>(_QWORD);
// 18001BE1C: using guessed type char var_6D8[16];
// 18001BE1C: using guessed type char var_6B0[16];

//----- (000000018001C1B0) ----------------------------------------------------
__int64 __fastcall GetCallerToken(const unsigned __int16 *a1, PHANDLE TokenHandle)
{
  HANDLE CurrentThread; // rax
  unsigned int v4; // ebx
  signed int LastError; // eax
  int v7; // [rsp+40h] [rbp+18h] BYREF

  RpcAutoImpersonate::RpcAutoImpersonate((RpcAutoImpersonate *)&v7, a1, 1);
  CurrentThread = GetCurrentThread();
  if ( OpenThreadToken(CurrentThread, 8u, 1, TokenHandle) )
  {
    v4 = 0;
  }
  else
  {
    LastError = GetLastError();
    v4 = LastError;
    if ( LastError > 0 )
      v4 = (unsigned __int16)LastError | 0x80070000;
  }
  if ( v7 )
    RpcRevertToSelf();
  return v4;
}

//----- (000000018001C220) ----------------------------------------------------
RpcAutoImpersonate *__fastcall RpcAutoImpersonate::RpcAutoImpersonate(
        RpcAutoImpersonate *this,
        const unsigned __int16 *a2,
        int a3)
{
  unsigned int v5; // eax
  EventManager *v6; // rcx
  int v7; // edi
  void *v9; // [rsp+20h] [rbp-58h]
  const struct _GUID *v10; // [rsp+28h] [rbp-50h]
  void **pExceptionObject; // [rsp+30h] [rbp-48h] BYREF
  char v12; // [rsp+38h] [rbp-40h]
  const unsigned __int16 *v13; // [rsp+40h] [rbp-38h]
  __int64 v14; // [rsp+48h] [rbp-30h]
  int v15; // [rsp+50h] [rbp-28h]
  int v16; // [rsp+54h] [rbp-24h]
  int v17; // [rsp+58h] [rbp-20h]
  int v18; // [rsp+5Ch] [rbp-1Ch]
  int v19; // [rsp+60h] [rbp-18h]

  *(_DWORD *)this = a3;
  if ( a3 )
  {
    v5 = RpcImpersonateClient(0LL);
    v7 = v5;
    if ( v5 )
    {
      EventManager::EvtReport(v6, &IMPERSONATION_FAILURE, a2, v5, v9, v10);
      v14 = 0LL;
      v15 = 0;
      v16 = 0;
      v18 = -1;
      v19 = -1;
      pExceptionObject = &wmi::GenericException::`vftable';
      v13 = &word_18007630E;
      v12 = 0;
      v17 = v7;
      CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
    }
  }
  return this;
}
// 1800480BF: variable 'v6' is possibly undefined
// 1800480BF: variable 'v9' is possibly undefined
// 1800480BF: variable 'v10' is possibly undefined
// 1800716D8: using guessed type void *wmi::GenericException::`vftable';

//----- (000000018001C274) ----------------------------------------------------
bool __fastcall tsched::IsRoot(tsched *this, const unsigned __int16 *a2)
{
  if ( !*(_WORD *)this )
    return 1;
  if ( *(_WORD *)this == 92 )
    return *((_WORD *)this + 1) == 0;
  return 0;
}

//----- (000000018001C2A0) ----------------------------------------------------
__int64 __fastcall SchRpcRetrieveTask(
        __int64 a1,
        char *a2,
        const unsigned __int16 *a3,
        unsigned int *a4,
        unsigned __int16 **a5)
{
  return RpcServer::RetrieveTask((RpcServer *)&RpcServer::s_singleton, a2, a3, a4, a5);
}
// 18001C2A0: could not find valid save-restore pair for rbp
// 1800B0D48: using guessed type __int64 RpcServer::s_singleton;

//----- (000000018001C2E0) ----------------------------------------------------
__int64 __fastcall UbpmParams::AddComAction(
        UbpmParams *this,
        unsigned __int16 *a2,
        struct _GUID *a3,
        unsigned __int16 *a4,
        unsigned __int16 *a5)
{
  unsigned __int64 v9; // rcx
  unsigned __int64 v10; // rcx
  char *v11; // rax
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // r8
  __int64 v16; // [rsp+28h] [rbp-51h]
  __int64 v17; // [rsp+28h] [rbp-51h]
  __int64 v18; // [rsp+30h] [rbp-49h]
  __int64 v19; // [rsp+30h] [rbp-49h]
  __int64 v20; // [rsp+38h] [rbp-41h]
  __int64 v21; // [rsp+38h] [rbp-41h]
  __int64 v22; // [rsp+40h] [rbp-39h]
  __int64 v23; // [rsp+40h] [rbp-39h]
  __int64 v24[2]; // [rsp+48h] [rbp-31h] BYREF
  int v25; // [rsp+58h] [rbp-21h]
  int v26; // [rsp+5Ch] [rbp-1Dh]
  __int64 v27; // [rsp+60h] [rbp-19h]
  __int64 v28; // [rsp+68h] [rbp-11h]
  _DWORD v29[2]; // [rsp+70h] [rbp-9h] BYREF
  __int64 v30; // [rsp+78h] [rbp-1h]
  __int128 v31; // [rsp+80h] [rbp+7h]
  __int128 v32; // [rsp+90h] [rbp+17h]
  __int64 v33; // [rsp+A0h] [rbp+27h]

  v26 = 0;
  v29[1] = 0;
  v29[0] = 2;
  v33 = 0LL;
  v31 = 0LL;
  v32 = 0LL;
  v30 = UbpmParams::NewHostedObject<std::vector<_DAB_SID_INFO *>,_DAB_SID_INFO>(
          (__int64 *)this + 18,
          a3,
          (__int64)a3,
          (__int64)a4,
          v16,
          v18,
          v20,
          v22,
          v24[0],
          v24[1]);
  if ( a4 )
    *(_QWORD *)&v31 = UbpmParams::NewHostedString(v9, (__int64 *)this + 15, a4, 0x7FFFFFFFuLL);
  if ( a5 )
    *((_QWORD *)&v31 + 1) = UbpmParams::NewHostedString(v9, (__int64 *)this + 15, a5, 0x7FFFFFFFuLL);
  if ( *((_QWORD *)this + 57) )
    *(_QWORD *)&v32 = (char *)this + 448;
  v24[0] = (__int64)UbpmParams::GetNewActionId(this);
  v11 = UbpmParams::NewHostedString(v10, (__int64 *)this + 15, a2, 0x7FFFFFFFuLL);
  v25 = 1;
  v27 = UbpmParams::NewHostedObject<std::vector<_CSebiSystemEventCreationParameter *>,_CSebiSystemEventCreationParameter>(
          (__int64 *)this + 36,
          (__int64)v29,
          v12,
          v13,
          v17,
          v19,
          v21,
          v23,
          v24[0],
          (__int64)v11);
  v28 = (__int64)this + 384;
  std::vector<_UBPM_ACTION_PARAMS>::push_back((__int64 *)this + 33, (unsigned __int64)v24);
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
  {
    WPP_SF__guid_SSD(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xDu, v14, (__int64)a3, (__int64)a4, (__int64)a5);
  }
  return 0LL;
}
// 18001C339: variable 'v16' is possibly undefined
// 18001C339: variable 'v18' is possibly undefined
// 18001C339: variable 'v20' is possibly undefined
// 18001C339: variable 'v22' is possibly undefined
// 18001C35A: variable 'v9' is possibly undefined
// 18001C39A: variable 'v10' is possibly undefined
// 18001C3B5: variable 'v12' is possibly undefined
// 18001C3B5: variable 'v13' is possibly undefined
// 18001C3B5: variable 'v17' is possibly undefined
// 18001C3B5: variable 'v19' is possibly undefined
// 18001C3B5: variable 'v21' is possibly undefined
// 18001C3B5: variable 'v23' is possibly undefined
// 180048149: variable 'v14' is possibly undefined
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018001C424) ----------------------------------------------------
void __fastcall TSTime::ToString(TSTime *this, unsigned __int16 *a2, int a3)
{
  size_t v4; // r14
  LONG Bias; // ebx
  int v7; // ebx
  int v8; // edi
  int v9; // ebx
  int v10; // [rsp+20h] [rbp-E0h]
  int wMonth; // [rsp+20h] [rbp-E0h]
  int v12; // [rsp+28h] [rbp-D8h]
  int wDay; // [rsp+28h] [rbp-D8h]
  int v14; // [rsp+30h] [rbp-D0h]
  int wHour; // [rsp+30h] [rbp-D0h]
  int v16; // [rsp+38h] [rbp-C8h]
  int wMinute; // [rsp+38h] [rbp-C8h]
  int v18; // [rsp+40h] [rbp-C0h]
  int wSecond; // [rsp+40h] [rbp-C0h]
  int v20; // [rsp+48h] [rbp-B8h]
  int v21; // [rsp+50h] [rbp-B0h]
  char v22[8]; // [rsp+60h] [rbp-A0h] BYREF
  __int64 v23; // [rsp+68h] [rbp-98h]
  struct _SYSTEMTIME v24; // [rsp+70h] [rbp-90h] BYREF
  struct _SYSTEMTIME v25; // [rsp+80h] [rbp-80h] BYREF
  struct _TIME_DYNAMIC_ZONE_INFORMATION pTimeZoneInformation; // [rsp+90h] [rbp-70h] BYREF

  v4 = a3;
  if ( *(_BYTE *)this )
  {
    TSTime::ToSYSTEMTIME(this, &v24);
    wSecond = v24.wSecond;
    wMinute = v24.wMinute;
    wHour = v24.wHour;
    wDay = v24.wDay;
    wMonth = v24.wMonth;
    StringCchPrintfW(
      a2,
      v4,
      (size_t *)L"%04ld-%02ld-%02ldT%02ld:%02ld:%02ld%",
      v24.wYear,
      wMonth,
      wDay,
      wHour,
      wMinute,
      wSecond);
  }
  else
  {
    if ( GetDynamicTimeZoneInformation(&pTimeZoneInformation) == 2 )
      Bias = pTimeZoneInformation.Bias + pTimeZoneInformation.DaylightBias;
    else
      Bias = pTimeZoneInformation.Bias;
    v23 = *((_QWORD *)this + 1);
    v7 = -Bias;
    v22[0] = 0;
    *(_QWORD *)&v24.wYear = 600000000LL * v7;
    TSTime::operator+=((__int64)v22, (__int64 *)&v24);
    v8 = v7 / 60;
    if ( v7 >= 0 )
      v9 = v7 % 60;
    else
      v9 = -v7 % 60;
    TSTime::ToSYSTEMTIME((TSTime *)v22, &v25);
    v21 = v9;
    v20 = v8;
    v18 = v25.wSecond;
    v16 = v25.wMinute;
    v14 = v25.wHour;
    v12 = v25.wDay;
    v10 = v25.wMonth;
    StringCchPrintfW(
      a2,
      v4,
      (size_t *)L"%04ld-%02ld-%02ldT%02ld:%02ld:%02ld%+03ld:%02ld",
      v25.wYear,
      v10,
      v12,
      v14,
      v16,
      v18,
      v20,
      v21);
  }
}
// 18001C424: using guessed type char var_210[8];

//----- (000000018001C5C0) ----------------------------------------------------
__int64 __fastcall Triggers::WnfStateChangeTrigger::ToUbpmFormat(
        Triggers::WnfStateChangeTrigger *this,
        const struct Triggers::TriggerExportOptions *a2,
        struct IUbpmRegistrationParams *a3)
{
  __int64 v3; // rsi
  char *v4; // rdi
  TSTime *v7; // rax
  struct _SYSTEMTIME *v8; // rbx
  TSTime *v9; // rax
  struct _SYSTEMTIME *v10; // rax
  __int128 v12; // [rsp+50h] [rbp-68h] BYREF
  __int128 v13; // [rsp+60h] [rbp-58h] BYREF
  struct _SYSTEMTIME v14; // [rsp+70h] [rbp-48h] BYREF
  struct _SYSTEMTIME v15; // [rsp+80h] [rbp-38h] BYREF

  v3 = *(_QWORD *)a3;
  v4 = (char *)this + 96;
  v7 = (TSTime *)TSTime::ToGMT((__int128 *)((char *)this + 24), &v12);
  v8 = TSTime::ToSYSTEMTIME(v7, &v14);
  v9 = (TSTime *)TSTime::ToGMT((__int128 *)((char *)this + 8), &v13);
  v10 = TSTime::ToSYSTEMTIME(v9, &v15);
  return (*(__int64 (__fastcall **)(struct IUbpmRegistrationParams *, _QWORD, _QWORD, _QWORD, char *, struct _SYSTEMTIME *, struct _SYSTEMTIME *, _QWORD, char *))(v3 + 72))(
           a3,
           *((unsigned __int8 *)this + 64),
           *((unsigned int *)this + 10),
           *((unsigned int *)this + 11),
           (char *)this + 48,
           v10,
           v8,
           *((_QWORD *)this + 11),
           v4);
}

//----- (000000018001C6A0) ----------------------------------------------------
__int64 __fastcall Triggers::TimeTrigger::GetEndBoundary(__int64 a1, __int64 a2)
{
  Scheduling::JobSchedule::GetStop(a1 + 8, a2);
  return a2;
}

//----- (000000018001C6C4) ----------------------------------------------------
__int64 __fastcall Scheduling::JobSchedule::GetStop(__int64 a1, __int64 a2)
{
  _QWORD *v2; // rsi
  int v5; // ecx
  unsigned int v6; // r8d
  __int128 v7; // xmm0
  char v9[24]; // [rsp+20h] [rbp-18h] BYREF

  v2 = (_QWORD *)(a2 + 8);
  *(_BYTE *)a2 = 0;
  GetSystemTimeAsFileTime((LPFILETIME)(a2 + 8));
  if ( *(_DWORD *)(a1 + 28) || *(_DWORD *)(a1 + 24) )
  {
    v7 = *(_OWORD *)(a1 + 16);
    goto LABEL_8;
  }
  if ( *(_DWORD *)(a1 + 60) )
    goto LABEL_11;
  v5 = *(_DWORD *)(a1 + 52);
  if ( v5 )
  {
    v6 = v5 + *(_DWORD *)(a1 + 80);
    goto LABEL_7;
  }
  if ( *(_DWORD *)(a1 + 48) )
  {
LABEL_11:
    *v2 = -1LL;
    return a2;
  }
  v6 = *(_DWORD *)(a1 + 80);
LABEL_7:
  v7 = *(_OWORD *)TSTime::operator+(a1, (__int64)v9, v6);
LABEL_8:
  *(_OWORD *)a2 = v7;
  return a2;
}
// 18001C6C4: using guessed type char var_18[24];

//----- (000000018001C75C) ----------------------------------------------------
struct _SYSTEMTIME *__fastcall TSTime::ToSYSTEMTIME(TSTime *this, struct _SYSTEMTIME *__return_ptr retstr)
{
  const FILETIME *v4; // rcx
  void **pExceptionObject; // [rsp+20h] [rbp-40h] BYREF
  char v6; // [rsp+28h] [rbp-38h]
  const unsigned __int16 *v7; // [rsp+30h] [rbp-30h]
  __int64 v8; // [rsp+38h] [rbp-28h]
  int v9; // [rsp+40h] [rbp-20h]
  int v10; // [rsp+44h] [rbp-1Ch]
  DWORD LastError; // [rsp+48h] [rbp-18h]
  int v12; // [rsp+4Ch] [rbp-14h]
  int v13; // [rsp+50h] [rbp-10h]

  *retstr = 0LL;
  if ( *((_QWORD *)this + 1) )
  {
    v4 = (const FILETIME *)((char *)this + 8);
    if ( *(_QWORD *)v4 >= 0x7FFF35F4F06C58F0uLL )
    {
      *(_DWORD *)&retstr->wYear = 817259;
      *(_DWORD *)&retstr->wDayOfWeek = 2031621;
      *(_DWORD *)&retstr->wHour = 3866647;
      *(_DWORD *)&retstr->wSecond = 65470523;
    }
    else if ( !FileTimeToSystemTime(v4, retstr) )
    {
      v8 = 0LL;
      v9 = 0;
      v10 = 0;
      v12 = -1;
      v13 = -1;
      pExceptionObject = &wmi::GenericException::`vftable';
      v7 = &word_18007630E;
      v6 = 0;
      LastError = GetLastError();
      CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
    }
  }
  return retstr;
}
// 1800716D8: using guessed type void *wmi::GenericException::`vftable';

//----- (000000018001C7E0) ----------------------------------------------------
__int64 __fastcall TSTime::operator+(__int64 a1, __int64 a2, unsigned int a3)
{
  unsigned __int64 v3; // r9
  __int64 v4; // r8

  v3 = *(_QWORD *)(a1 + 8);
  v4 = 10000000LL * a3;
  if ( v3 > ~v4 )
  {
    *(_QWORD *)(a2 + 8) = -1LL;
    *(_BYTE *)a2 = 0;
  }
  else
  {
    *(_BYTE *)a2 = *(_BYTE *)a1;
    *(_QWORD *)(a2 + 8) = v3 + v4;
  }
  return a2;
}

//----- (000000018001C814) ----------------------------------------------------
_OWORD *__fastcall TSTime::ToGMT(__int128 *a1, _OWORD *a2)
{
  __int128 v3; // xmm0
  _OWORD *result; // rax
  const FILETIME *v5; // rdi
  DWORD LastError; // eax
  struct _FILETIME FileTime[2]; // [rsp+20h] [rbp-19h] BYREF
  void **pExceptionObject; // [rsp+30h] [rbp-9h] BYREF
  char v9; // [rsp+38h] [rbp-1h]
  const unsigned __int16 *v10; // [rsp+40h] [rbp+7h]
  __int64 v11; // [rsp+48h] [rbp+Fh]
  int v12; // [rsp+50h] [rbp+17h]
  int v13; // [rsp+54h] [rbp+1Bh]
  DWORD v14; // [rsp+58h] [rbp+1Fh]
  int v15; // [rsp+5Ch] [rbp+23h]
  int v16; // [rsp+60h] [rbp+27h]
  struct _SYSTEMTIME SystemTime; // [rsp+68h] [rbp+2Fh] BYREF
  struct _SYSTEMTIME UniversalTime; // [rsp+78h] [rbp+3Fh] BYREF

  if ( *(_BYTE *)a1
    && (v5 = (const FILETIME *)a1 + 1,
        (unsigned __int64)(*((_QWORD *)a1 + 1) - 94608000000000000LL) <= 0x119C8C1114A0000LL) )
  {
    TSTime::TSTime((TSTime *)FileTime);
    if ( (!FileTimeToSystemTime(v5, &SystemTime)
       || !TzSpecificLocalTimeToSystemTime(0LL, &SystemTime, &UniversalTime)
       || !SystemTimeToFileTime(&UniversalTime, &FileTime[1]))
      && !LocalFileTimeToFileTime(v5, &FileTime[1]) )
    {
      LastError = GetLastError();
      v11 = 0LL;
      v12 = 0;
      v13 = 0;
      v15 = -1;
      v16 = -1;
      pExceptionObject = &wmi::GenericException::`vftable';
      v10 = &word_18007630E;
      v9 = 0;
      v14 = LastError;
      CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
    }
    LOBYTE(FileTime[0].dwLowDateTime) = 0;
    v3 = *(_OWORD *)&FileTime[0].dwLowDateTime;
  }
  else
  {
    v3 = *a1;
  }
  result = a2;
  *a2 = v3;
  return result;
}
// 1800716D8: using guessed type void *wmi::GenericException::`vftable';

//----- (000000018001C904) ----------------------------------------------------
__int64 __fastcall TaskXmlWriter::ElementTSDateTime(__int64 a1, int a2, TSTime *a3)
{
  TSTime::ToString(a3, (unsigned __int16 *)(a1 + 24), 64);
  return TaskXmlWriter::Element(a1, a2, a1 + 24);
}

//----- (000000018001C960) ----------------------------------------------------
__int64 __fastcall Triggers::TimeTrigger::WriteXml(Triggers::TimeTrigger *this, struct TaskXmlWriter *a2)
{
  BSTR *v2; // rax
  UINT v5; // eax
  int v6; // ecx
  int v7; // edx
  _QWORD *v8; // r9
  __int64 result; // rax

  v2 = (BSTR *)*((_QWORD *)this + 12);
  if ( v2 && *v2 )
    v5 = SysStringLen(*v2);
  else
    v5 = 0;
  v6 = *((_DWORD *)this + 17);
  v7 = 39;
  if ( v5 )
  {
    v8 = (_QWORD *)*((_QWORD *)this + 12);
    if ( !v6 )
      v7 = 25;
    if ( v8 )
      v8 = (_QWORD *)*v8;
    result = TaskXmlWriter::StartElementWithAttribute((__int64)a2, v7, 109, (__int64)v8);
  }
  else
  {
    if ( !v6 )
      v7 = 25;
    result = TaskXmlWriter::StartElement((int *)a2, v7);
  }
  if ( (int)result >= 0 )
  {
    result = Triggers::TimeTrigger::WriteInnerXml(this, a2);
    if ( (int)result >= 0 )
      return TaskXmlWriter::EndElement((__int64)a2);
  }
  return result;
}

//----- (000000018001CA00) ----------------------------------------------------
__int64 __fastcall TaskXmlWriter::ElementRunLevel(__int64 a1, int a2, int a3)
{
  const unsigned __int16 *v3; // r8

  if ( !a3 )
  {
    v3 = L"LeastPrivilege";
    return TaskXmlWriter::Element(a1, a2, (__int64)v3);
  }
  if ( a3 == 1 )
  {
    v3 = L"HighestAvailable";
    return TaskXmlWriter::Element(a1, a2, (__int64)v3);
  }
  return 2147942487LL;
}

//----- (000000018001CA30) ----------------------------------------------------
__int64 __fastcall ServerXMLUpdateHandler::CreateWriter(ServerXMLUpdateHandler *this, const struct Schema *a2)
{
  LPVOID v4; // rax
  __int64 v5; // rdi
  TaskXmlWriter *v6; // rcx
  int started; // eax

  v4 = operator new(0xA0uLL);
  if ( v4 )
    v5 = TaskXmlWriter::TaskXmlWriter((__int64)v4, (__int64 *)this + 133, a2);
  else
    v5 = 0LL;
  v6 = (TaskXmlWriter *)*((_QWORD *)this + 131);
  if ( (TaskXmlWriter *)v5 != v6 && v6 )
    TaskXmlWriter::`scalar deleting destructor'(v6);
  *((_QWORD *)this + 131) = v5;
  started = TaskXmlWriter::StartDocument(v5, *(_DWORD *)a2);
  if ( started < 0 && *((int *)this + 268) >= 0 )
    *((_DWORD *)this + 268) = started;
  return *((unsigned int *)this + 268);
}

//----- (000000018001CAC0) ----------------------------------------------------
__int64 __fastcall TaskXmlWriter::TaskXmlWriter(__int64 a1, __int64 *a2, _DWORD *a3)
{
  __int64 *v4; // rcx
  __int64 result; // rax

  *(_DWORD *)a1 = *a3;
  v4 = (__int64 *)(a1 + 8);
  *v4 = *a2;
  _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::_AddRef(v4);
  *(_QWORD *)(a1 + 16) = 0LL;
  result = a1;
  *(_DWORD *)(a1 + 152) = 0;
  return result;
}

//----- (000000018001CAFC) ----------------------------------------------------
void __fastcall ServerXMLUpdateHandler::WriteURI(
        ServerXMLUpdateHandler *this,
        const struct Schema *a2,
        const struct ITaskXmlHandler::Data *a3)
{
  const unsigned __int16 *v6; // r8
  char **v7; // rdx
  char *v8; // rax
  char *v9; // rdx
  int v10; // eax
  int v11; // eax
  int v12; // eax
  bool v13; // sf
  char v14[48]; // [rsp+40h] [rbp-C0h] BYREF
  int *v15; // [rsp+70h] [rbp-90h]
  void *lpMem; // [rsp+78h] [rbp-88h]
  UUID Uuid; // [rsp+90h] [rbp-70h] BYREF
  int v18; // [rsp+A0h] [rbp-60h] BYREF
  __int64 v19; // [rsp+A8h] [rbp-58h]
  __int16 v20; // [rsp+B0h] [rbp-50h]
  char v21; // [rsp+4B2h] [rbp+3B2h]
  OLECHAR sz[40]; // [rsp+4C0h] [rbp+3C0h] BYREF
  char v23[528]; // [rsp+510h] [rbp+410h] BYREF

  Uuid = 0LL;
  memset_0(sz, 0, sizeof(sz));
  memset_0(v23, 0, 0x20AuLL);
  v7 = (char **)*((_QWORD *)this + 101);
  if ( v7 )
    v8 = *v7;
  else
    v8 = 0LL;
  if ( v8 )
  {
    if ( v7 )
      v9 = *v7;
    else
      v9 = 0LL;
    goto LABEL_6;
  }
  if ( a3 )
  {
    v9 = *(char **)(*((_QWORD *)a3 + 6) + 8LL);
    goto LABEL_6;
  }
  v12 = UuidCreate(&Uuid);
  if ( !v12 || v12 == 1824 )
  {
    if ( StringFromGUID2(&Uuid, sz, 40) )
    {
      v9 = (char *)sz;
LABEL_6:
      tsched::TaskPathCanonicalize((tsched *)v23, v9, v6);
      v21 &= 0xFCu;
      v18 = 0;
      v19 = 0LL;
      v20 = 0;
      XmlParserTempString::operator=((XmlParserTempString *)&v18, (__int64)v23);
      ITaskXmlHandler::Data::Data((ITaskXmlHandler::Data *)v14);
      v15 = &v18;
      v10 = _ProcessValue__QITaskXmlHandler__TriggersXmlHandler__MEAAJAEBUSchema__W4TaskXmlNodeId__AEBUData_1__N_Z(
              this,
              (int *)a2,
              4,
              (__int64)v14);
      if ( v10 < 0 && *((int *)this + 268) >= 0 )
        *((_DWORD *)this + 268) = v10;
      v11 = TaskXmlWriter::Element(*((_QWORD *)this + 131), 4, (__int64)v23);
      if ( v11 < 0 && *((int *)this + 268) >= 0 )
        *((_DWORD *)this + 268) = v11;
      operator delete(lpMem);
      XmlParserTempString::Clear((XmlParserTempString *)&v18);
      return;
    }
    if ( *((int *)this + 268) >= 0 )
      *((_DWORD *)this + 268) = -2147024774;
  }
  else
  {
    v13 = v12 < 0;
    if ( v12 > 0 )
    {
      v12 = (unsigned __int16)v12 | 0x80070000;
      v13 = v12 < 0;
    }
    if ( v13 && *((int *)this + 268) >= 0 )
      *((_DWORD *)this + 268) = v12;
  }
}
// 18001CB94: variable 'v6' is possibly undefined

//----- (000000018001CC50) ----------------------------------------------------
__int64 __fastcall ServerXMLUpdateHandler::RegistrationInfoHandler::Process(
        __int64 a1,
        const struct Schema *a2,
        int a3,
        const struct ITaskXmlHandler::Data *a4)
{
  __int64 result; // rax

  result = 0LL;
  if ( a3 == 3 )
  {
    *(_BYTE *)(a1 + 9) = 1;
    return result;
  }
  if ( *(_BYTE *)(a1 + 9) )
  {
    if ( a3 == 4 )
    {
      if ( *(_BYTE *)(a1 + 10) )
        return result;
      ServerXMLUpdateHandler::WriteURI(*(ServerXMLUpdateHandler **)(a1 + 16), a2, a4);
      *(_BYTE *)(a1 + 10) = 1;
    }
    else
    {
      if ( a3 != 5 || *(_BYTE *)(a1 + 11) )
        return result;
      ServerXMLUpdateHandler::WriteSecurityDescriptor(*(ServerXMLUpdateHandler **)(a1 + 16), a2, a4);
      *(_BYTE *)(a1 + 11) = 1;
    }
    return 1LL;
  }
  return result;
}

//----- (000000018001CCB8) ----------------------------------------------------
__int64 __fastcall Actions::ActionCollection::WriteXml(Actions::ActionCollection *this, struct TaskXmlWriter *a2)
{
  BSTR *v4; // rax
  UINT v5; // eax
  __int64 *v6; // rax
  __int64 v7; // r9
  __int64 result; // rax
  __int64 *v9; // rbx

  v4 = (BSTR *)*((_QWORD *)this + 2);
  if ( v4 && *v4 )
    v5 = SysStringLen(*v4);
  else
    v5 = 0;
  if ( v5 )
  {
    v6 = (__int64 *)*((_QWORD *)this + 2);
    if ( v6 )
      v7 = *v6;
    else
      v7 = 0LL;
    result = TaskXmlWriter::StartElementWithAttribute((__int64)a2, 102, 110, v7);
  }
  else
  {
    result = TaskXmlWriter::StartElement((int *)a2, 102);
  }
  if ( (int)result >= 0 )
  {
    v9 = *(__int64 **)this;
    while ( 1 )
    {
      v9 = (__int64 *)*v9;
      if ( v9 == *(__int64 **)this )
        break;
      result = (*(__int64 (__fastcall **)(__int64, struct TaskXmlWriter *))(*(_QWORD *)v9[2] + 56LL))(v9[2], a2);
      if ( (int)result < 0 )
        return result;
    }
    return TaskXmlWriter::EndElement((__int64)a2);
  }
  return result;
}
// 18001CCB8: could not find valid save-restore pair for rbp

//----- (000000018001CD8C) ----------------------------------------------------
bool __fastcall User::IsGroupAccount(User *this)
{
  int v1; // edx

  v1 = *(_DWORD *)(*(_QWORD *)this + 40LL);
  return ((v1 - 2) & 0xFFFFFFFC) == 0 && v1 != 3 && User::IsService(this) == 0;
}

//----- (000000018001CDC0) ----------------------------------------------------
char __fastcall User::IsService(User *this)
{
  char v2; // bl

  v2 = 0;
  if ( User::IsLocalSystem(this)
    || User::IsLocalService(this)
    || User::IsNetworkService(this)
    || User::IsServiceSid(this) )
  {
    return 1;
  }
  return v2;
}

//----- (000000018001CE14) ----------------------------------------------------
bool __fastcall User::IsLocalSystem(User *this)
{
  struct _RTL_CRITICAL_SECTION *v1; // rbx
  wchar_t *v3; // rdi
  void *v4; // rcx
  wchar_t *v6; // rcx
  wchar_t *v7; // rcx
  wchar_t **v8; // [rsp+30h] [rbp+8h] BYREF

  v1 = User::s_cs;
  EnterCriticalSection(User::s_cs);
  v3 = 0LL;
  if ( *(_QWORD *)this )
  {
    v4 = *(void **)(*(_QWORD *)this + 32LL);
    if ( v4 )
    {
      LOBYTE(v3) = IsWellKnownSid(v4, WinLocalSystemSid);
    }
    else
    {
      User::GetDomainAccount(this, (__int64 *)&v8);
      if ( v8 )
        v6 = *v8;
      else
        v6 = 0LL;
      if ( v6 )
      {
        v7 = v8 ? *v8 : 0LL;
        if ( *v7 )
        {
          if ( v8 )
            v3 = *v8;
          LOBYTE(v3) = User::IsLocalSystem(v3);
        }
      }
      _bstr_t::_Free((_bstr_t *)&v8);
    }
  }
  LeaveCriticalSection(v1);
  return (char)v3;
}

//----- (000000018001CE94) ----------------------------------------------------
__int64 __fastcall User::GetSidString(User *this, struct _bstr_t *a2)
{
  __int64 v3; // rcx
  unsigned int v4; // ebx
  unsigned __int16 *v5; // rax
  __int64 *v6; // rax
  signed int LastError; // eax
  LPWSTR StringSid; // [rsp+40h] [rbp+8h] BYREF
  char v10; // [rsp+50h] [rbp+18h] BYREF
  LPWSTR *p_StringSid; // [rsp+58h] [rbp+20h]

  v3 = *(_QWORD *)this;
  v4 = 0;
  if ( !v3 )
    return 2147549183LL;
  if ( ConvertSidToStringSidW(*(PSID *)(v3 + 32), &StringSid) )
  {
    p_StringSid = &StringSid;
    v5 = SysAllocString(StringSid);
    if ( v5 )
    {
      v6 = (__int64 *)_bstr_t::_bstr_t((_bstr_t *)&v10, v5);
      _bstr_t::operator=((__int64 *)a2, v6);
      _bstr_t::_Free((_bstr_t *)&v10);
    }
    else
    {
      v4 = -2147024882;
    }
    LocalFree(StringSid);
  }
  else
  {
    LastError = GetLastError();
    if ( LastError > 0 )
      return (unsigned __int16)LastError | 0x80070000;
    else
      return (unsigned int)LastError;
  }
  return v4;
}

//----- (000000018001CF48) ----------------------------------------------------
void __fastcall Actions::ActionCollection::~ActionCollection(Actions::ActionCollection *this)
{
  _QWORD *v2; // rbx
  void (__fastcall ***v3)(_QWORD, __int64); // rcx

  if ( *((_QWORD *)this + 1) )
  {
    v2 = *(_QWORD **)this;
    while ( 1 )
    {
      v2 = (_QWORD *)*v2;
      if ( v2 == *(_QWORD **)this )
        break;
      v3 = (void (__fastcall ***)(_QWORD, __int64))v2[2];
      if ( v3 )
      {
        (**v3)(v3, 1LL);
        v2[2] = 0LL;
      }
    }
    std::list<Task *>::clear((__int64)this);
  }
  _bstr_t::_Free((Actions::ActionCollection *)((char *)this + 16));
  std::list<Task *>::clear((__int64)this);
  operator delete(*(void **)this);
}

//----- (000000018001CFBC) ----------------------------------------------------
void __fastcall ServerXMLUpdateHandler::~ServerXMLUpdateHandler(ServerXMLUpdateHandler *this)
{
  TaskXmlWriter *v2; // rcx
  void *v3; // rcx

  _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::~_com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>((__int64 *)this + 133);
  v2 = (TaskXmlWriter *)*((_QWORD *)this + 131);
  if ( v2 )
    TaskXmlWriter::`scalar deleting destructor'(v2);
  _bstr_t::_Free((ServerXMLUpdateHandler *)((char *)this + 992));
  _bstr_t::_Free((ServerXMLUpdateHandler *)((char *)this + 816));
  _bstr_t::_Free((ServerXMLUpdateHandler *)((char *)this + 808));
  v3 = (void *)*((_QWORD *)this + 98);
  if ( v3 )
  {
    operator delete(v3);
    *((_QWORD *)this + 98) = 0LL;
    *((_QWORD *)this + 99) = 0LL;
    *((_QWORD *)this + 100) = 0LL;
  }
  TriggersXmlHandler::CurrentAction::~CurrentAction((ServerXMLUpdateHandler *)((char *)this + 544));
  wmi::AutoRef<User::UserEntry>::Release((char *)this + 520);
  ValidationXmlHandler::~ValidationXmlHandler(this);
}
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);

//----- (000000018001D05C) ----------------------------------------------------
TaskXmlWriter *__fastcall TaskXmlWriter::`scalar deleting destructor'(TaskXmlWriter *this)
{
  __int64 v2; // rcx

  v2 = *((_QWORD *)this + 2);
  if ( v2 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v2 + 16LL))(v2);
  _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::~_com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>((__int64 *)this + 1);
  operator delete(this);
  return this;
}

//----- (000000018001D0A8) ----------------------------------------------------
void __fastcall TriggersXmlHandler::~TriggersXmlHandler(TriggersXmlHandler *this)
{
  TriggersXmlHandler::CurrentAction::~CurrentAction((TriggersXmlHandler *)((char *)this + 544));
  wmi::AutoRef<User::UserEntry>::Release((char *)this + 520);
  ValidationXmlHandler::~ValidationXmlHandler(this);
}
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);

//----- (000000018001D0DC) ----------------------------------------------------
void __fastcall ValidationXmlHandler::~ValidationXmlHandler(ValidationXmlHandler *this)
{
  void **v2; // rbx

  v2 = (void **)((char *)this + 496);
  std::_Tree<std::_Tmap_traits<_bstr_t,std::list<_FILETIME> *,Aggregator::less,std::allocator<std::pair<_bstr_t const,std::list<_FILETIME> *>>,0>>::_Erase(
    (__int64)this + 496,
    *(__int64 **)(*((_QWORD *)this + 62) + 8LL));
  *((_QWORD *)*v2 + 1) = *v2;
  *(_QWORD *)*v2 = *v2;
  *((_QWORD *)*v2 + 2) = *v2;
  v2[1] = 0LL;
  operator delete(*v2);
  _bstr_t::_Free((ValidationXmlHandler *)((char *)this + 480));
  _bstr_t::_Free((ValidationXmlHandler *)((char *)this + 472));
  _bstr_t::_Free((ValidationXmlHandler *)((char *)this + 464));
  _bstr_t::_Free((ValidationXmlHandler *)((char *)this + 456));
  _bstr_t::_Free((ValidationXmlHandler *)((char *)this + 448));
  ValidationXmlHandler::CurrentTrigger::~CurrentTrigger((ValidationXmlHandler *)((char *)this + 112));
  _bstr_t::_Free((ValidationXmlHandler *)((char *)this + 96));
  _bstr_t::_Free((ValidationXmlHandler *)((char *)this + 88));
  _bstr_t::_Free((ValidationXmlHandler *)((char *)this + 80));
  _bstr_t::_Free((ValidationXmlHandler *)((char *)this + 72));
  wmi::AutoRef<JobBucket>::Release((wmi::RefBase **)this + 5);
  _bstr_t::_Free((ValidationXmlHandler *)((char *)this + 24));
}

//----- (000000018001D1C4) ----------------------------------------------------
void __fastcall std::_Tree<std::_Tmap_traits<_bstr_t,std::list<_FILETIME> *,Aggregator::less,std::allocator<std::pair<_bstr_t const,std::list<_FILETIME> *>>,0>>::_Erase(
        __int64 a1,
        __int64 *a2)
{
  __int64 *v2; // rbx
  __int64 *i; // rdi

  v2 = a2;
  for ( i = a2; !*((_BYTE *)i + 25); v2 = i )
  {
    std::_Tree<std::_Tmap_traits<_bstr_t,std::list<_FILETIME> *,Aggregator::less,std::allocator<std::pair<_bstr_t const,std::list<_FILETIME> *>>,0>>::_Erase(
      a1,
      i[2]);
    i = (__int64 *)*i;
    _bstr_t::_Free((_bstr_t *)(v2 + 4));
    operator delete(v2);
  }
}

//----- (000000018001D224) ----------------------------------------------------
void __fastcall ValidationXmlHandler::CurrentTrigger::~CurrentTrigger(ValidationXmlHandler::CurrentTrigger *this)
{
  void *v2; // rcx

  v2 = (void *)*((_QWORD *)this + 30);
  if ( v2 )
    operator delete(v2);
  _bstr_t::_Free((ValidationXmlHandler::CurrentTrigger *)((char *)this + 296));
  _bstr_t::_Free((ValidationXmlHandler::CurrentTrigger *)((char *)this + 288));
  _bstr_t::_Free((ValidationXmlHandler::CurrentTrigger *)((char *)this + 280));
  _bstr_t::_Free((ValidationXmlHandler::CurrentTrigger *)((char *)this + 272));
  _bstr_t::_Free((ValidationXmlHandler::CurrentTrigger *)((char *)this + 264));
  _bstr_t::_Free((ValidationXmlHandler::CurrentTrigger *)((char *)this + 256));
  _bstr_t::_Free((ValidationXmlHandler::CurrentTrigger *)((char *)this + 248));
  _bstr_t::_Free((ValidationXmlHandler::CurrentTrigger *)((char *)this + 88));
  _bstr_t::_Free((ValidationXmlHandler::CurrentTrigger *)((char *)this + 80));
  _bstr_t::_Free((ValidationXmlHandler::CurrentTrigger *)((char *)this + 72));
  std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::clear((_QWORD *)this + 7);
  operator delete(*((void **)this + 7));
  _bstr_t::_Free((ValidationXmlHandler::CurrentTrigger *)((char *)this + 48));
  _bstr_t::_Free((ValidationXmlHandler::CurrentTrigger *)((char *)this + 32));
  _bstr_t::_Free((ValidationXmlHandler::CurrentTrigger *)((char *)this + 8));
}

//----- (000000018001D304) ----------------------------------------------------
void __fastcall TriggersXmlHandler::CurrentAction::~CurrentAction(TriggersXmlHandler::CurrentAction *this)
{
  _bstr_t::_Free((TriggersXmlHandler::CurrentAction *)((char *)this + 232));
  _bstr_t::_Free((TriggersXmlHandler::CurrentAction *)((char *)this + 224));
  std::vector<_bstr_t>::_Tidy((__int64)this + 200);
  std::vector<_bstr_t>::_Tidy((__int64)this + 176);
  std::vector<_bstr_t>::_Tidy((__int64)this + 152);
  _bstr_t::_Free((TriggersXmlHandler::CurrentAction *)((char *)this + 144));
  _bstr_t::_Free((TriggersXmlHandler::CurrentAction *)((char *)this + 136));
  _bstr_t::_Free((TriggersXmlHandler::CurrentAction *)((char *)this + 128));
  _bstr_t::_Free((TriggersXmlHandler::CurrentAction *)((char *)this + 120));
  _bstr_t::_Free((TriggersXmlHandler::CurrentAction *)((char *)this + 112));
  _bstr_t::_Free((TriggersXmlHandler::CurrentAction *)((char *)this + 104));
  _bstr_t::_Free((TriggersXmlHandler::CurrentAction *)((char *)this + 96));
  _bstr_t::_Free((TriggersXmlHandler::CurrentAction *)((char *)this + 88));
  _bstr_t::_Free((TriggersXmlHandler::CurrentAction *)((char *)this + 80));
  _bstr_t::_Free((TriggersXmlHandler::CurrentAction *)((char *)this + 72));
  _bstr_t::_Free((TriggersXmlHandler::CurrentAction *)((char *)this + 64));
  _bstr_t::_Free((TriggersXmlHandler::CurrentAction *)((char *)this + 56));
  _bstr_t::_Free((TriggersXmlHandler::CurrentAction *)((char *)this + 48));
  _bstr_t::_Free((TriggersXmlHandler::CurrentAction *)((char *)this + 40));
  _bstr_t::_Free((TriggersXmlHandler::CurrentAction *)((char *)this + 24));
  _bstr_t::_Free(this);
}

//----- (000000018001D3EC) ----------------------------------------------------
Actions::ActionCollection *__fastcall Actions::ActionCollection::ActionCollection(Actions::ActionCollection *this)
{
  _QWORD *v2; // rax
  _QWORD *i; // rbx
  void (__fastcall ***v5)(_QWORD, __int64); // rcx

  *(_QWORD *)this = 0LL;
  *((_QWORD *)this + 1) = 0LL;
  v2 = std::_List_alloc<0,std::_List_base_types<std::vector<unsigned char> *,std::allocator<std::vector<unsigned char> *>>>::_Buynode0(
         (__int64)this,
         0LL,
         0LL);
  *(_QWORD *)this = v2;
  *((_QWORD *)this + 2) = 0LL;
  if ( *((_QWORD *)this + 1) )
  {
    for ( i = (_QWORD *)*v2; i != *(_QWORD **)this; i = (_QWORD *)*i )
    {
      v5 = (void (__fastcall ***)(_QWORD, __int64))i[2];
      if ( v5 )
      {
        (**v5)(v5, 1LL);
        i[2] = 0LL;
      }
    }
    std::list<Task *>::clear((__int64)this);
  }
  return this;
}

//----- (000000018001D468) ----------------------------------------------------
__int64 __fastcall TaskXmlReader::TaskXmlReader(__int64 a1, __int64 *a2, __int64 a3, char a4)
{
  int v4; // esi
  __int64 *v8; // rcx
  int *v9; // rcx

  v4 = 0;
  *(_QWORD *)a1 = &wmi::RefBase::`vftable';
  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)a1 = &TaskXmlReader::`vftable';
  *(_QWORD *)(a1 + 16) = 0LL;
  *(_QWORD *)(a1 + 24) = 0LL;
  v8 = (__int64 *)(a1 + 32);
  *v8 = *a2;
  _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::_AddRef(v8);
  *(_BYTE *)(a1 + 1106) &= 0xFCu;
  v9 = (int *)(a1 + 1116);
  *(_DWORD *)(a1 + 1116) = 65542;
  *(_BYTE *)(a1 + 40) = a4;
  *(_QWORD *)(a1 + 48) = a3;
  *(_QWORD *)(a1 + 56) = 0LL;
  *(_DWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0LL;
  *(_WORD *)(a1 + 80) = 0;
  *(_BYTE *)(a1 + 1112) = 0;
  while ( v4 < (int)Schema::GetMaxNode(v9) )
    ++v4;
  return a1;
}
// 18001D4EB: variable 'v9' is possibly undefined
// 180070980: using guessed type void *wmi::RefBase::`vftable';
// 180070B70: using guessed type void *TaskXmlReader::`vftable';

//----- (000000018001D520) ----------------------------------------------------
TaskXmlReader *__fastcall TaskXmlReader::`vector deleting destructor'(TaskXmlReader *this, char a2)
{
  TaskXmlWriter *v4; // rcx
  __int64 v5; // rcx
  __int64 v6; // rcx

  *(_QWORD *)this = &TaskXmlReader::`vftable';
  v4 = (TaskXmlWriter *)*((_QWORD *)this + 2);
  if ( v4 )
    TaskXmlWriter::`scalar deleting destructor'(v4);
  XmlParserTempString::Clear((TaskXmlReader *)((char *)this + 64));
  v5 = *((_QWORD *)this + 7);
  if ( v5 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v5 + 16LL))(v5);
  _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::~_com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>((__int64 *)this + 4);
  v6 = *((_QWORD *)this + 3);
  if ( v6 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v6 + 16LL))(v6);
  *(_QWORD *)this = &wmi::RefBase::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 180070980: using guessed type void *wmi::RefBase::`vftable';
// 180070B70: using guessed type void *TaskXmlReader::`vftable';

//----- (000000018001D5D0) ----------------------------------------------------
signed int __fastcall ExeTask::ExportToUbpmFormat(BSTR **this, struct IUbpmRegistrationParams *a2)
{
  signed int result; // eax
  BSTR v5; // rsi
  BSTR *v6; // rax
  BSTR v7; // rbp
  BSTR *v8; // rax
  BSTR v9; // r15
  BSTR *v10; // rax
  __int64 v11; // rbx
  unsigned int v12; // edi
  __int64 v13; // rax

  result = ExeTask::NormalizePathAndArguments(this);
  v5 = 0LL;
  if ( result >= 0 )
  {
    v6 = this[8];
    if ( v6 )
      v7 = *v6;
    else
      v7 = 0LL;
    v8 = this[7];
    if ( v8 )
      v9 = *v8;
    else
      v9 = 0LL;
    v10 = this[6];
    if ( v10 )
      v5 = *v10;
    v11 = *(_QWORD *)a2;
    v12 = *((unsigned __int8 *)this + 72);
    v13 = ((__int64 (__fastcall *)(BSTR **))(*this)[1])(this);
    return (*(__int64 (__fastcall **)(struct IUbpmRegistrationParams *, __int64, BSTR, _QWORD, BSTR, BSTR))(v11 + 16))(
             a2,
             v13,
             v5,
             v12,
             v9,
             v7);
  }
  return result;
}

//----- (000000018001D68C) ----------------------------------------------------
signed int __fastcall ExeTask::NormalizePathAndArguments(BSTR **this)
{
  signed int result; // eax
  signed int v3; // edi
  char ***v4; // rsi
  const wchar_t **v5; // rax
  const wchar_t *v6; // rcx
  __int64 v7; // rcx
  __int64 v8; // rax
  BSTR *v9; // rax
  UINT v10; // eax
  char **v11; // rax
  char *v12; // r8
  BSTR *v13; // rax
  BSTR v14; // rdi
  UINT v15; // eax
  __int64 v16; // rcx
  wchar_t *v17; // rax
  __int64 v18; // rdx
  __int64 v19; // rcx
  wchar_t *v20; // r8
  __int64 v21; // rax
  char *v22; // r9
  wchar_t v23; // dx
  wchar_t *v24; // rax
  char *v25; // r8
  DWORD FileAttributesW; // eax
  const wchar_t *v27; // rcx
  char *v28; // r8
  char *v29; // r8
  __int64 v30; // rcx
  wchar_t *v31; // rax
  __int64 v32; // rax
  __int64 v33; // rcx
  wchar_t *v34; // rdx
  __int64 v35; // r8
  char *v36; // r9
  wchar_t v37; // ax
  wchar_t *v38; // rax
  BSTR *v39; // rax
  UINT v40; // eax
  __int64 v41; // rcx
  wchar_t *v42; // rax
  __int64 v43; // rax
  __int64 v44; // rbx
  wchar_t *v45; // rcx
  __int64 v46; // rdx
  char *v47; // rax
  wchar_t v48; // r8
  wchar_t *v49; // rax
  __int64 *v50; // rbx
  OLECHAR **v51[2]; // [rsp+60h] [rbp-A8h] BYREF
  wchar_t Drive[4]; // [rsp+70h] [rbp-98h] BYREF
  wchar_t Dir[2]; // [rsp+78h] [rbp-90h] BYREF

  v51[1] = (OLECHAR **)-2LL;
  memset_0(Dir, 0, 0x800uLL);
  result = ExeTask::SetRealTarget((ExeTask *)this);
  v3 = result;
  if ( result < 0 )
    return result;
  ExeTask::StripQuotes((ExeTask *)this);
  *(_QWORD *)Drive = 0LL;
  v4 = (char ***)(this + 6);
  v5 = (const wchar_t **)this[6];
  if ( v5 )
    v6 = *v5;
  else
    v6 = 0LL;
  result = _wsplitpath_s(v6, Drive, 4uLL, Dir, 0x400uLL, 0LL, 0LL, 0LL, 0LL);
  if ( result )
  {
    if ( result > 0 )
      return (unsigned __int16)result | 0x80070000;
    return result;
  }
  v7 = -1LL;
  v8 = -1LL;
  do
    ++v8;
  while ( Dir[v8] );
  if ( !v8 )
  {
    do
      ++v7;
    while ( Drive[v7] );
    if ( !v7 )
    {
      v9 = this[8];
      if ( v9 && *v9 )
        v10 = SysStringLen(*v9);
      else
        v10 = 0;
      if ( v10 )
      {
        v11 = (char **)this[8];
        if ( v11 )
          v12 = *v11;
        else
          v12 = 0LL;
        result = StringCchCopyW((char *)Dir, 261LL, v12);
        if ( result < 0 )
          return result;
        v13 = this[8];
        v14 = v13 ? *v13 : 0LL;
        v15 = v13 && *v13 ? SysStringLen(*v13) : 0;
        if ( v14[v15 - 1] != 92 )
        {
          v16 = 261LL;
          v17 = Dir;
          do
          {
            if ( !*v17 )
              break;
            ++v17;
            --v16;
          }
          while ( v16 );
          result = v16 == 0 ? 0x80070057 : 0;
          v18 = v16 ? 261 - v16 : 0LL;
          if ( !v16 )
            return result;
          v19 = 261 - v18;
          v20 = &Dir[v18];
          if ( v18 != 261 )
          {
            v21 = 2147483646LL;
            v22 = (char *)((char *)L"\\" - (char *)v20);
            do
            {
              if ( !v21 )
                break;
              v23 = *(_WORD *)&v22[(_QWORD)v20];
              if ( !v23 )
                break;
              *v20++ = v23;
              --v21;
              --v19;
            }
            while ( v19 );
          }
          v24 = v20 - 1;
          if ( v19 )
            v24 = v20;
          *v24 = 0;
          result = v19 == 0 ? 0x8007007A : 0;
          if ( !v19 )
            return result;
        }
        v25 = *v4 ? **v4 : 0LL;
        result = StringCchCatW(Dir, 261LL, v25);
        v3 = result;
        if ( result < 0 )
          return result;
        FileAttributesW = GetFileAttributesW(Dir);
        if ( FileAttributesW != -1 && (FileAttributesW & 0x10) == 0 )
          _bstr_t::operator=((_bstr_t::Data_t **)this + 6, Dir);
      }
    }
  }
  if ( *v4 )
    v27 = (const wchar_t *)**v4;
  else
    v27 = 0LL;
  if ( !wcschr(v27, 0x20u) && *((_DWORD *)this + 10) )
  {
    if ( *v4 )
      v28 = **v4;
    else
      v28 = 0LL;
    StringCchCopyW((char *)Dir, 1024LL, v28);
LABEL_81:
    v39 = this[7];
    if ( v39 && *v39 )
      v40 = SysStringLen(*v39);
    else
      v40 = 0;
    if ( v40 )
    {
      v41 = 1024LL;
      v42 = Dir;
      do
      {
        if ( !*v42 )
          break;
        ++v42;
        --v41;
      }
      while ( v41 );
      v3 = v41 == 0 ? 0x80070057 : 0;
      if ( v41 )
        v43 = 1024 - v41;
      else
        v43 = 0LL;
      if ( v41 )
      {
        v44 = 1024 - v43;
        v45 = &Dir[v43];
        if ( 1024 != v43 )
        {
          v46 = 2147483646LL;
          v47 = (char *)((char *)L" " - (char *)v45);
          do
          {
            if ( !v46 )
              break;
            v48 = *(_WORD *)&v47[(_QWORD)v45];
            if ( !v48 )
              break;
            *v45++ = v48;
            --v46;
            --v44;
          }
          while ( v44 );
        }
        v49 = v45 - 1;
        if ( v44 )
          v49 = v45;
        *v49 = 0;
        v3 = v44 == 0 ? 0x8007007A : 0;
      }
      if ( v3 >= 0 )
      {
        v50 = (__int64 *)_bstr_t::_bstr_t((_bstr_t *)v51, Dir);
        _bstr_t::operator+=(v51, this + 7);
        _bstr_t::operator=((__int64 *)this + 7, v50);
        _bstr_t::_Free((_bstr_t *)v51);
      }
    }
    else
    {
      _bstr_t::operator=((_bstr_t::Data_t **)this + 7, Dir);
    }
    return v3;
  }
  wcscpy(Dir, L"\"");
  if ( *v4 )
    v29 = **v4;
  else
    v29 = 0LL;
  result = StringCchCatW(Dir, 1024LL, v29);
  if ( result >= 0 )
  {
    v30 = 1024LL;
    v31 = Dir;
    do
    {
      if ( !*v31 )
        break;
      ++v31;
      --v30;
    }
    while ( v30 );
    v3 = v30 == 0 ? 0x80070057 : 0;
    if ( v30 )
      v32 = 1024 - v30;
    else
      v32 = 0LL;
    if ( v30 )
    {
      v33 = 1024 - v32;
      v34 = &Dir[v32];
      if ( v32 != 1024 )
      {
        v35 = 2147483646LL;
        v36 = (char *)((char *)L"\"" - (char *)v34);
        do
        {
          if ( !v35 )
            break;
          v37 = *(_WORD *)&v36[(_QWORD)v34];
          if ( !v37 )
            break;
          *v34++ = v37;
          --v35;
          --v33;
        }
        while ( v33 );
      }
      v38 = v34 - 1;
      if ( v33 )
        v38 = v34;
      *v38 = 0;
      v3 = v33 == 0 ? 0x8007007A : 0;
    }
    if ( v3 < 0 )
      return v3;
    goto LABEL_81;
  }
  return result;
}

//----- (000000018001DBA4) ----------------------------------------------------
void __fastcall ExeTask::StripQuotes(ExeTask *this)
{
  _bstr_t::Data_t **v1; // rbx
  OLECHAR **v2; // rcx
  OLECHAR *v3; // rcx
  UINT v4; // eax
  const wchar_t *v5; // rcx
  OLECHAR *v6; // rax
  OLECHAR *v7; // rdx
  OLECHAR v8; // cx
  OLECHAR v9[264]; // [rsp+20h] [rbp-228h] BYREF

  v1 = (_bstr_t::Data_t **)((char *)this + 48);
  v2 = (OLECHAR **)*((_QWORD *)this + 6);
  if ( v2 && (v3 = *v2) != 0LL )
    v4 = SysStringLen(v3);
  else
    v4 = 0;
  if ( v4 <= 0x104 )
  {
    v5 = *v1 ? *(const wchar_t **)*v1 : 0LL;
    if ( wcschr(v5, 0x22u) )
    {
      if ( *v1 )
        v6 = *(OLECHAR **)*v1;
      else
        v6 = 0LL;
      v7 = v9;
      do
      {
        v8 = *v6;
        if ( *v6 != 34 )
        {
          *v7++ = v8;
          v8 = *v6;
        }
        ++v6;
      }
      while ( v8 );
      _bstr_t::operator=(v1, v9);
    }
  }
}
// 18001DBA4: using guessed type OLECHAR var_228[264];

//----- (000000018001DC8C) ----------------------------------------------------
__int64 __fastcall ExeTask::SetRealTarget(ExeTask *this)
{
  _bstr_t::Data_t **v1; // rbx
  const wchar_t **v2; // rax
  const wchar_t *v4; // rcx
  wchar_t *v5; // rax
  __int64 v6; // rsi
  __int64 v7; // rcx
  __int64 result; // rax
  int v9; // ebp
  const WCHAR *v10; // rdx
  _QWORD *v11; // rax
  const WCHAR *v12; // rcx
  const WCHAR *v13; // rdx
  const wchar_t *v14; // rcx
  wchar_t *v15; // rax
  LPWSTR v16; // rbx
  LPWSTR FilePart[2]; // [rsp+30h] [rbp-248h] BYREF
  WCHAR Buffer[264]; // [rsp+40h] [rbp-238h] BYREF

  v1 = (_bstr_t::Data_t **)((char *)this + 48);
  v2 = (const wchar_t **)*((_QWORD *)this + 6);
  if ( v2 )
    v4 = *v2;
  else
    v4 = 0LL;
  v5 = wcsrchr(v4, 0x2Eu);
  v6 = -1LL;
  *((_DWORD *)this + 10) = 0;
  if ( v5 )
  {
    v7 = -1LL;
    do
      ++v7;
    while ( v5[v7] );
    if ( v7 == 1 )
      return 1LL;
  }
  else
  {
    v9 = 0;
    if ( ExtsFound )
    {
      while ( 1 )
      {
        v10 = *v1 ? *(const WCHAR **)*v1 : 0LL;
        v11 = (_QWORD *)*((_QWORD *)this + 8);
        v12 = v11 ? (const WCHAR *)*v11 : 0LL;
        if ( SearchPathW(v12, v10, (LPCWSTR)(&PathExts)[v9], 0x105u, Buffer, FilePart) )
          break;
        v13 = *v1 ? *(const WCHAR **)*v1 : 0LL;
        if ( SearchPathW(0LL, v13, (LPCWSTR)(&PathExts)[v9], 0x105u, Buffer, FilePart) )
          break;
        if ( ++v9 >= ExtsFound )
          goto LABEL_25;
      }
      _bstr_t::operator=(v1, Buffer);
    }
  }
LABEL_25:
  if ( *v1 )
    v14 = *(const wchar_t **)*v1;
  else
    v14 = 0LL;
  v15 = wcsrchr(v14, 0x2Eu);
  FilePart[0] = v15;
  v16 = v15;
  if ( !v15 )
    return 1LL;
  do
    ++v6;
  while ( v15[v6] );
  if ( v6 == 1 )
    return 1LL;
  if ( _wcsicmp(v15 + 1, L"LNK") )
    goto LABEL_35;
  result = ExeTask::ResolveLink(this, FilePart);
  if ( (int)result >= 0 )
  {
    if ( (_DWORD)result == 1 )
      return 0LL;
    v16 = FilePart[0];
LABEL_35:
    if ( !IsOnList(v16 + 1, (const unsigned __int16 **)&off_1800AFD70, 2) )
    {
      if ( IsOnList(v16 + 1, (const unsigned __int16 **)&off_1800AFD80, 3) )
      {
        if ( (int)ExeTask::SetBatchLaunchCommand((BSTR **)this) >= 0 )
          *((_DWORD *)this + 10) = 1;
      }
      else if ( ExeTask::ResolveDocRunAssociation(this, v16) >= 0 )
      {
        *((_DWORD *)this + 10) = 2;
      }
    }
    return 0LL;
  }
  return result;
}
// 1800AF910: using guessed type unsigned __int16 * near *PathExts;
// 1800B01F0: using guessed type unsigned int ExtsFound;

//----- (000000018001DEF0) ----------------------------------------------------
__int64 __fastcall UbpmParams::AddTimeTrigger(
        UbpmParams *this,
        const struct Scheduling::JobSchedule *a2,
        __int64 a3,
        __int64 a4)
{
  UbpmParams *v5; // rcx
  int v6; // esi
  int v8; // ecx
  int v9; // ecx
  int v10; // ecx
  __int64 v11; // rax
  unsigned int v12; // edx
  unsigned int v13; // eax
  char *NewTriggerId; // rax
  bool v15; // zf
  __int128 v16; // xmm0
  int v17; // eax
  int v18; // r14d
  TSTime *v19; // rax
  __int128 v20; // xmm0
  TSTime *v21; // rax
  __int64 v22; // r8
  __int64 v23; // r9
  UbpmParams *v24; // rcx
  unsigned int v25; // eax
  __int64 v27; // [rsp+20h] [rbp-A9h]
  __int64 v28; // [rsp+28h] [rbp-A1h]
  __int128 v29; // [rsp+30h] [rbp-99h] BYREF
  __int128 v30; // [rsp+40h] [rbp-89h] BYREF
  __int128 v31; // [rsp+50h] [rbp-79h] BYREF
  int v32; // [rsp+60h] [rbp-69h]
  int v33; // [rsp+64h] [rbp-65h]
  __int64 v34; // [rsp+68h] [rbp-61h]
  int v35; // [rsp+70h] [rbp-59h]
  int v36; // [rsp+74h] [rbp-55h]
  unsigned __int16 **ActionIdArray; // [rsp+78h] [rbp-51h]
  char *v38; // [rsp+80h] [rbp-49h] BYREF
  int v39; // [rsp+88h] [rbp-41h]
  int v40; // [rsp+8Ch] [rbp-3Dh]
  __int64 v41; // [rsp+90h] [rbp-39h]
  __int128 v42; // [rsp+98h] [rbp-31h]
  __int128 v43; // [rsp+A8h] [rbp-21h]
  int v44; // [rsp+B8h] [rbp-11h]
  int v45; // [rsp+BCh] [rbp-Dh]
  __int64 v46; // [rsp+C0h] [rbp-9h]
  struct _SYSTEMTIME v47; // [rsp+D0h] [rbp+7h] BYREF
  struct _SYSTEMTIME v48; // [rsp+E0h] [rbp+17h] BYREF

  v5 = (UbpmParams *)*((unsigned int *)a2 + 15);
  v6 = -1;
  v41 = 0LL;
  v45 = 0;
  DWORD1(v31) = 0;
  v32 = 0;
  v34 = 0LL;
  v35 = 0;
  v30 = 0LL;
  if ( (_DWORD)v5 )
  {
    v8 = (_DWORD)v5 - 1;
    if ( v8 )
    {
      v9 = v8 - 1;
      if ( v9 )
      {
        v10 = v9 - 1;
        if ( v10 )
        {
          if ( v10 != 1 )
            goto LABEL_16;
          BYTE1(v29) = *((_BYTE *)a2 + 64);
          LOBYTE(v29) = *((_BYTE *)a2 + 66);
          WORD1(v29) = *((_WORD *)a2 + 34);
          LODWORD(v30) = 4;
          v11 = UbpmParams::NewHostedObject<std::vector<_DAB_SCHEDULE_BY_MONTHLY_DAY_OF_WEEK *>,_DAB_SCHEDULE_BY_MONTHLY_DAY_OF_WEEK>(
                  (__int64 *)this + 90,
                  &v29);
        }
        else
        {
          *(_QWORD *)&v29 = *((unsigned int *)a2 + 16);
          WORD2(v29) = *((_WORD *)a2 + 34);
          LODWORD(v30) = 3;
          v11 = UbpmParams::NewHostedObject<std::vector<_DAB_SCHEDULE_BY_MONTH *>,_DAB_SCHEDULE_BY_MONTH>(
                  (__int64 *)this + 87,
                  &v29);
        }
      }
      else
      {
        LOBYTE(v29) = *((_BYTE *)a2 + 64);
        BYTE1(v29) = *((_BYTE *)a2 + 66);
        LODWORD(v30) = 2;
        v11 = UbpmParams::NewHostedObject<std::vector<_DAB_SCHEDULE_BY_DAY *>,_DAB_SCHEDULE_BY_DAY>(
                (__int64 *)this + 84,
                &v29,
                a3,
                a4,
                v27,
                v28,
                v29,
                *((__int64 *)&v29 + 1),
                v30,
                *((__int64 *)&v30 + 1));
      }
    }
    else
    {
      LOWORD(v29) = *((_WORD *)a2 + 32);
      LODWORD(v30) = 1;
      v11 = UbpmParams::NewHostedObject<std::vector<_DAB_SCHEDULE_BY_DAY *>,_DAB_SCHEDULE_BY_DAY>(
              (__int64 *)this + 81,
              &v29,
              a3,
              a4,
              v27,
              v28,
              v29,
              *((__int64 *)&v29 + 1),
              v30,
              *((__int64 *)&v30 + 1));
    }
    *((_QWORD *)&v30 + 1) = v11;
  }
  else
  {
    v12 = *((_DWORD *)a2 + 12);
    LODWORD(v30) = 5;
    LODWORD(v41) = UbpmParams::ConvertToUbpmRepetitionInterval(v5, v12);
    v13 = *((_DWORD *)a2 + 13);
    if ( v13 )
    {
      if ( v13 < 0x3C )
        v13 = 60;
    }
    else
    {
      v13 = -1;
    }
    HIDWORD(v41) = v13;
  }
LABEL_16:
  NewTriggerId = UbpmParams::GetNewTriggerId(this);
  v15 = *((_BYTE *)a2 + 73) == 0;
  v16 = *(_OWORD *)a2;
  v38 = NewTriggerId;
  v17 = v15;
  v18 = v15 | 2;
  v15 = *((_BYTE *)a2 + 72) == 0;
  v29 = v16;
  if ( v15 )
    v18 = v17;
  v39 = v18;
  v19 = (TSTime *)TSTime::ToGMT(&v29, &v47);
  v20 = (__int128)*TSTime::ToSYSTEMTIME(v19, &v48);
  v29 = *((_OWORD *)a2 + 1);
  v42 = v20;
  v21 = (TSTime *)TSTime::ToGMT(&v29, &v48);
  v43 = (__int128)*TSTime::ToSYSTEMTIME(v21, &v47);
  if ( *(_BYTE *)a2 )
    v39 = v18 | 0x10;
  v40 = *((_DWORD *)a2 + 20);
  v44 = 4;
  v46 = UbpmParams::NewHostedObject<std::vector<_DAB_ETW_EVENT_TRIGGER_DATA_ITEM *>,_DAB_ETW_EVENT_TRIGGER_DATA_ITEM>(
          (__int64 *)this + 93,
          &v30,
          v22,
          v23,
          v27,
          v28,
          v29,
          *((__int64 *)&v29 + 1),
          v30,
          *((__int64 *)&v30 + 1));
  LODWORD(v31) = 1;
  *((_QWORD *)&v31 + 1) = UbpmParams::NewHostedObject<std::vector<_DAB_TRIGGER_PARAMS *>,_DAB_TRIGGER_PARAMS>(
                            (__int64 *)this + 72,
                            (__int64)&v38);
  v36 = (__int64)(*((_QWORD *)this + 44) - *((_QWORD *)this + 43)) >> 3;
  ActionIdArray = UbpmParams::GetActionIdArray(this);
  v33 = *((_DWORD *)a2 + 14);
  if ( (_DWORD)v30 != 5 )
  {
    LODWORD(v34) = UbpmParams::ConvertToUbpmRepetitionInterval(v24, *((_DWORD *)a2 + 12));
    v25 = *((_DWORD *)a2 + 13);
    if ( v25 )
    {
      v6 = *((_DWORD *)a2 + 13);
      if ( v25 < 0x3C )
        v6 = 60;
    }
    v15 = *((_BYTE *)a2 + 72) == 0;
    HIDWORD(v34) = v6;
    BYTE1(v35) = !v15;
    LOBYTE(v35) = 1;
  }
  std::vector<_UBPM_TRIGGER_PARAMS>::push_back((__int64 *)this + 112, &v31);
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
  {
    WPP_SF_SdD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x1Au,
      (__int64)&WPP_f0f7296807f33a7e423f6d049324e537_Traceguids,
      *(const wchar_t **)(*((_QWORD *)this + 1) + 24LL));
  }
  return 0LL;
}
// 18001DFF7: variable 'v27' is possibly undefined
// 18001DFF7: variable 'v28' is possibly undefined
// 18001E0F5: variable 'v22' is possibly undefined
// 18001E0F5: variable 'v23' is possibly undefined
// 18001E14A: variable 'v24' is possibly undefined
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018001E200) ----------------------------------------------------
void __fastcall ServerXMLUpdateHandler::WriteSecurityDescriptor(
        ServerXMLUpdateHandler *this,
        const struct Schema *a2,
        const struct ITaskXmlHandler::Data *a3)
{
  __int64 *v5; // rdi
  __int64 v6; // rax
  __int64 v7; // rdi
  int v8; // eax
  int v9; // eax
  char v10[48]; // [rsp+40h] [rbp-C0h] BYREF
  int *v11; // [rsp+70h] [rbp-90h]
  void *lpMem; // [rsp+78h] [rbp-88h]
  int v13; // [rsp+90h] [rbp-70h] BYREF
  __int64 v14; // [rsp+98h] [rbp-68h]
  __int16 v15; // [rsp+A0h] [rbp-60h]
  char v16; // [rsp+4A2h] [rbp+3A2h]

  v5 = (__int64 *)*((_QWORD *)this + 102);
  if ( v5 )
    v6 = *v5;
  else
    v6 = 0LL;
  if ( v6 )
  {
    if ( v5 )
      v7 = *v5;
    else
      v7 = 0LL;
  }
  else
  {
    if ( !a3 )
      return;
    v7 = *(_QWORD *)(*((_QWORD *)a3 + 6) + 8LL);
  }
  if ( v7 )
  {
    v16 &= 0xFCu;
    v13 = 0;
    v14 = 0LL;
    v15 = 0;
    XmlParserTempString::operator=((XmlParserTempString *)&v13, v7);
    ITaskXmlHandler::Data::Data((ITaskXmlHandler::Data *)v10);
    v11 = &v13;
    v8 = _ProcessValue__QITaskXmlHandler__TriggersXmlHandler__MEAAJAEBUSchema__W4TaskXmlNodeId__AEBUData_1__N_Z(
           this,
           (int *)a2,
           5,
           (__int64)v10);
    if ( v8 < 0 && *((int *)this + 268) >= 0 )
      *((_DWORD *)this + 268) = v8;
    v9 = TaskXmlWriter::Element(*((_QWORD *)this + 131), 5, v7);
    if ( v9 < 0 && *((int *)this + 268) >= 0 )
      *((_DWORD *)this + 268) = v9;
    operator delete(lpMem);
    XmlParserTempString::Clear((XmlParserTempString *)&v13);
  }
}

//----- (000000018001E31C) ----------------------------------------------------
__int64 __fastcall ATL::CComPtr<IStream>::operator=(__int64 *a1, __int64 a2)
{
  __int64 v4; // rcx

  v4 = *a1;
  if ( v4 == a2 )
    return v4;
  if ( a2 )
  {
    (*(void (__fastcall **)(__int64))(*(_QWORD *)a2 + 8LL))(a2);
    v4 = *a1;
  }
  if ( v4 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v4 + 16LL))(v4);
  *a1 = a2;
  return a2;
}

//----- (000000018001E374) ----------------------------------------------------
_OWORD *__fastcall TSTime::ToLocal(__int128 *a1, _OWORD *a2)
{
  const FILETIME *v3; // rdi
  __int128 v4; // xmm0
  _OWORD *result; // rax
  DWORD LastError; // eax
  struct _FILETIME FileTime[2]; // [rsp+20h] [rbp-19h] BYREF
  void **pExceptionObject; // [rsp+30h] [rbp-9h] BYREF
  char v9; // [rsp+38h] [rbp-1h]
  const unsigned __int16 *v10; // [rsp+40h] [rbp+7h]
  __int64 v11; // [rsp+48h] [rbp+Fh]
  int v12; // [rsp+50h] [rbp+17h]
  int v13; // [rsp+54h] [rbp+1Bh]
  DWORD v14; // [rsp+58h] [rbp+1Fh]
  int v15; // [rsp+5Ch] [rbp+23h]
  int v16; // [rsp+60h] [rbp+27h]
  struct _SYSTEMTIME SystemTime; // [rsp+68h] [rbp+2Fh] BYREF
  struct _SYSTEMTIME LocalTime; // [rsp+78h] [rbp+3Fh] BYREF

  if ( *(_BYTE *)a1
    || (v3 = (const FILETIME *)a1 + 1,
        (unsigned __int64)(*((_QWORD *)a1 + 1) - 94608000000000000LL) > 0x119C8C1114A0000LL) )
  {
    v4 = *a1;
  }
  else
  {
    TSTime::TSTime((TSTime *)FileTime);
    if ( (!FileTimeToSystemTime(v3, &SystemTime)
       || !SystemTimeToTzSpecificLocalTime(0LL, &SystemTime, &LocalTime)
       || !SystemTimeToFileTime(&LocalTime, &FileTime[1]))
      && !FileTimeToLocalFileTime(v3, &FileTime[1]) )
    {
      LastError = GetLastError();
      v11 = 0LL;
      v12 = 0;
      v13 = 0;
      v15 = -1;
      v16 = -1;
      pExceptionObject = &wmi::GenericException::`vftable';
      v10 = &word_18007630E;
      v9 = 0;
      v14 = LastError;
      CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
    }
    LOBYTE(FileTime[0].dwLowDateTime) = 1;
    v4 = *(_OWORD *)&FileTime[0].dwLowDateTime;
  }
  result = a2;
  *a2 = v4;
  return result;
}
// 1800716D8: using guessed type void *wmi::GenericException::`vftable';

//----- (000000018001E464) ----------------------------------------------------
__int64 __fastcall UbpmParams::NewHostedObject<std::vector<_DAB_TRIGGER_PARAMS *>,_DAB_TRIGGER_PARAMS>(
        __int64 *a1,
        __int64 a2)
{
  _OWORD *v4; // rax
  char v5; // dl
  __int64 *v6; // rcx
  __int64 v8; // rax
  __int64 v9; // rdi
  _OWORD *v10; // [rsp+50h] [rbp+8h] BYREF

  v4 = operator new(0x48uLL);
  if ( v4 )
  {
    *v4 = *(_OWORD *)a2;
    v4[1] = *(_OWORD *)(a2 + 16);
    v4[2] = *(_OWORD *)(a2 + 32);
    v4[3] = *(_OWORD *)(a2 + 48);
    *((_QWORD *)v4 + 8) = *(_QWORD *)(a2 + 64);
  }
  v10 = v4;
  v5 = 1;
  v6 = (__int64 *)a1[1];
  if ( &v10 >= (_OWORD **)v6 || *a1 > (unsigned __int64)&v10 )
    v5 = 0;
  if ( v5 )
  {
    v8 = *a1;
    v9 = ((__int64)&v10 - *a1) >> 3;
    if ( v6 == (__int64 *)a1[2] )
    {
      std::vector<_DAB_TRIGGER_PARAMS *>::_Reserve(a1);
      v8 = *a1;
      v6 = (__int64 *)a1[1];
    }
    v4 = *(_OWORD **)(v8 + 8 * v9);
  }
  else if ( v6 == (__int64 *)a1[2] )
  {
    std::vector<_DAB_TRIGGER_PARAMS *>::_Reserve(a1);
    v6 = (__int64 *)a1[1];
    v4 = v10;
  }
  *v6 = (__int64)v4;
  a1[1] += 8LL;
  return (__int64)v10;
}

//----- (000000018001E524) ----------------------------------------------------
__int64 __fastcall UbpmParams::ConvertToUbpmRepetitionInterval(UbpmParams *this, unsigned int a2)
{
  if ( a2 )
  {
    if ( a2 > 0x28DE80 )
    {
      return 2678400;
    }
    else if ( a2 < 0x3C )
    {
      return 60;
    }
  }
  return a2;
}

//----- (000000018001E54C) ----------------------------------------------------
__int64 __fastcall JobStore::LoadBucketFromRegistry(
        HKEY *a1,
        const unsigned __int16 *a2,
        int a3,
        __int64 a4,
        __int64 a5,
        __int64 *a6)
{
  HKEY v8; // rbx
  int TreeInfo; // esi
  JobMoniker *v10; // rax
  int v11; // r14d
  __int64 v12; // rcx
  __int64 v13; // rcx
  HKEY hKey; // [rsp+38h] [rbp-D0h] BYREF
  int v16; // [rsp+40h] [rbp-C8h] BYREF
  int v17; // [rsp+44h] [rbp-C4h]
  HKEY v18; // [rsp+48h] [rbp-C0h] BYREF
  __int64 v19; // [rsp+50h] [rbp-B8h] BYREF
  __int64 v20; // [rsp+58h] [rbp-B0h]
  __int64 v21; // [rsp+60h] [rbp-A8h] BYREF
  __int64 v22; // [rsp+68h] [rbp-A0h]
  __int64 v23; // [rsp+70h] [rbp-98h]
  struct _FILETIME v24[7]; // [rsp+78h] [rbp-90h] BYREF
  char v25[16]; // [rsp+B0h] [rbp-58h] BYREF
  char v26[16]; // [rsp+C0h] [rbp-48h] BYREF
  wmi::RefBase *v27; // [rsp+D0h] [rbp-38h] BYREF
  struct _GUID v28; // [rsp+D8h] [rbp-30h] BYREF
  char v29[16]; // [rsp+E8h] [rbp-20h] BYREF
  char v30[16]; // [rsp+F8h] [rbp-10h] BYREF
  wmi::RefBase *v31; // [rsp+108h] [rbp+0h] BYREF

  v23 = -2LL;
  v22 = a4;
  v17 = a3;
  JobMoniker::JobMoniker((JobMoniker *)v25, 0LL, 0LL);
  hKey = 0LL;
  v8 = 0LL;
  v18 = 0LL;
  Triggers::Trigulator::Trigulator(v24);
  Actions::ActionCollection::ActionCollection((Actions::ActionCollection *)&v19);
  TreeInfo = JobStore::RegGetTreeInfo(a1, a2, &v28, 0LL);
  if ( TreeInfo >= 0 )
  {
    JobStore::RegGetOverrideInfo(a1, a2, (enum JobFlags::StatePersistanceFlags *)&v16);
    v10 = JobMoniker::JobMoniker((JobMoniker *)v29, a2, &v28);
    JobMoniker::operator=((__int64)v25, (__int64)v10);
    wmi::AutoRef<JobBucket>::Release(&v31);
    _bstr_t::_Free((_bstr_t *)v30);
    TreeInfo = JobStore::RegOpenTaskKey(a1, (struct JobMoniker *)v25, &hKey, 0x20019u);
    if ( TreeInfo >= 0 )
    {
      v11 = v16;
      if ( v16 )
      {
        TreeInfo = JobStore::RegOpenTaskOverrideKey((JobStore *)a1, a2, 0x20019u, 2, &v18);
        if ( TreeInfo < 0 )
          goto LABEL_14;
        v8 = v18;
      }
      TreeInfo = Triggers::Trigulator::StreamInWithOverrides(hKey, v8, v17, v11, (__int64)v24, 0LL);
      if ( TreeInfo >= 0 )
      {
        TreeInfo = Triggers::Trigulator::GetBucket((Triggers::Trigulator *)v24, (struct JobMoniker *)v25);
        if ( TreeInfo >= 0 )
        {
          if ( !a6
            || (TreeInfo = Actions::ActionCollection::StreamIn((Actions::ActionCollection *)&v19, hKey, 0LL),
                TreeInfo >= 0) )
          {
            *((_DWORD *)v27 + 5) = v11;
            TreeInfo = 0;
            JobMoniker::operator=(v22, (__int64)v25);
            if ( a5 )
              Triggers::Trigulator::operator=(a5, (__int64)v24);
            if ( a6 )
            {
              if ( a6 != &v19 )
              {
                std::list<Task *>::clear((__int64)a6);
                v12 = *a6;
                *a6 = v19;
                v19 = v12;
                v13 = a6[1];
                a6[1] = v20;
                v20 = v13;
              }
              _bstr_t::operator=(a6 + 2, &v21);
            }
          }
        }
      }
    }
  }
LABEL_14:
  Actions::ActionCollection::~ActionCollection((Actions::ActionCollection *)&v19);
  Triggers::Trigulator::~Trigulator((Triggers::Trigulator *)v24);
  wmi::AutoRegKey::Close(&v18);
  wmi::AutoRegKey::Close(&hKey);
  wmi::AutoRef<JobBucket>::Release(&v27);
  _bstr_t::_Free((_bstr_t *)v26);
  return (unsigned int)TreeInfo;
}
// 18001E54C: using guessed type char var_60[16];
// 18001E54C: using guessed type char var_50[16];
// 18001E54C: using guessed type char var_88[16];

//----- (000000018001E798) ----------------------------------------------------
JobMoniker *__fastcall JobMoniker::JobMoniker(JobMoniker *this, const unsigned __int16 *a2, const struct _GUID *a3)
{
  wmi::RefBase **v6; // rdi
  JobBucket *v7; // rax

  *((_QWORD *)this + 2) = 0LL;
  v6 = (wmi::RefBase **)((char *)this + 32);
  *((_QWORD *)this + 4) = 0LL;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x40) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
  {
    WPP_SF_qS_guid_(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xBu, (__int64)a3, this, a2, a3, -2LL);
  }
  v7 = (JobBucket *)operator new(0xD8uLL);
  if ( v7 )
    v7 = JobBucket::JobBucket(v7);
  wmi::AutoRef<JobBucket>::operator=(v6, (volatile signed __int32 *)v7);
  JobMoniker::_SetPath((_bstr_t::Data_t **)this, a2);
  *(struct _GUID *)this = *a3;
  *((_DWORD *)*v6 + 15) = 0;
  return this;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018001E840) ----------------------------------------------------
void __fastcall JobStore::RegGetOverrideInfo(
        HKEY *this,
        const unsigned __int16 *a2,
        enum JobFlags::StatePersistanceFlags *a3)
{
  WCHAR *v6; // rbx
  JobStore *v7; // rcx
  HKEY hKey; // [rsp+30h] [rbp-20h] BYREF
  LPCWSTR lpSubKey[3]; // [rsp+38h] [rbp-18h] BYREF
  DWORD cbData; // [rsp+80h] [rbp+30h] BYREF
  DWORD Type; // [rsp+90h] [rbp+40h] BYREF
  int Data; // [rsp+98h] [rbp+48h] BYREF

  lpSubKey[1] = (LPCWSTR)-2LL;
  hKey = 0LL;
  v6 = 0LL;
  lpSubKey[0] = 0LL;
  *(_DWORD *)a3 = 0;
  if ( this[4] )
  {
    ATL::CComBSTR::operator=((BSTR *)lpSubKey, a2);
    v6 = (WCHAR *)lpSubKey[0];
    JobStore::ReverseSlashesInString(v7, (unsigned __int16 *)lpSubKey[0]);
    if ( !RegOpenKeyExW(this[4], v6, 0, 0xF003Fu, &hKey) )
    {
      cbData = 4;
      if ( !RegQueryValueExW(hKey, L"StateFlags", 0LL, &Type, (LPBYTE)&Data, &cbData)
        && Type == 4
        && cbData == 4
        && (Data | 3) == 3 )
      {
        *(_DWORD *)a3 = Data;
      }
    }
  }
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
  {
    WPP_SF_SSD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x58u,
      (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
      a2,
      (__int64)a2);
  }
  SysFreeString(v6);
  wmi::AutoRegKey::Close(&hKey);
}
// 180048554: variable 'v7' is possibly undefined
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018001E8D0) ----------------------------------------------------
__int64 __fastcall Triggers::SessionChangeTrigger::ToUbpmFormat(
        Triggers::SessionChangeTrigger *this,
        const struct Triggers::TriggerExportOptions *a2,
        struct IUbpmRegistrationParams *a3)
{
  __int64 result; // rax
  __int64 v6; // rdi
  TSTime *v7; // rax
  struct _SYSTEMTIME *v8; // rbx
  TSTime *v9; // rax
  struct _SYSTEMTIME *v10; // rax
  __int128 v11; // [rsp+50h] [rbp-68h] BYREF
  __int128 v12; // [rsp+60h] [rbp-58h] BYREF
  struct _SYSTEMTIME v13; // [rsp+70h] [rbp-48h] BYREF
  struct _SYSTEMTIME v14; // [rsp+80h] [rbp-38h] BYREF

  result = Triggers::SessionBasedTrigger::ResolveUPN(this);
  if ( (int)result >= 0 )
  {
    v6 = *(_QWORD *)a3;
    v7 = (TSTime *)TSTime::ToGMT((__int128 *)((char *)this + 24), &v11);
    v8 = TSTime::ToSYSTEMTIME(v7, &v13);
    v9 = (TSTime *)TSTime::ToGMT((__int128 *)((char *)this + 8), &v12);
    v10 = TSTime::ToSYSTEMTIME(v9, &v14);
    return (*(__int64 (__fastcall **)(struct IUbpmRegistrationParams *, _QWORD, _QWORD, char *, _DWORD, _DWORD, char *, struct _SYSTEMTIME *, struct _SYSTEMTIME *))(v6 + 40))(
             a3,
             *((unsigned __int8 *)this + 64),
             *((unsigned int *)this + 24),
             (char *)this + 88,
             *((_DWORD *)this + 10),
             *((_DWORD *)this + 11),
             (char *)this + 48,
             v10,
             v8);
  }
  return result;
}

//----- (000000018001E9AC) ----------------------------------------------------
void __fastcall std::list<Task *>::clear(__int64 a1)
{
  _QWORD *v1; // rax
  _QWORD *v3; // rcx
  _QWORD *v4; // rbx

  v1 = *(_QWORD **)a1;
  v3 = **(_QWORD ***)a1;
  *v1 = v1;
  *(_QWORD *)(*(_QWORD *)a1 + 8LL) = *(_QWORD *)a1;
  *(_QWORD *)(a1 + 8) = 0LL;
  if ( v3 != *(_QWORD **)a1 )
  {
    do
    {
      v4 = (_QWORD *)*v3;
      operator delete(v3);
      v3 = v4;
    }
    while ( v4 != *(_QWORD **)a1 );
  }
}

//----- (000000018001E9F8) ----------------------------------------------------
__int64 __fastcall RpcServer::RegisterTask(
        void **this,
        unsigned __int16 *a2,
        struct _EVENT_DESCRIPTOR *a3,
        unsigned int a4,
        unsigned __int16 *a5,
        unsigned int a6,
        unsigned int a7,
        const struct _TASK_USER_CRED *a8,
        BYTE *a9,
        unsigned __int16 **a10,
        struct _TASK_XML_ERROR_INFO **a11)
{
  unsigned __int16 *v13; // rsi
  unsigned __int16 *v14; // r15
  __int64 v15; // rcx
  int Stream; // ebx
  _QWORD *v17; // rcx
  unsigned __int16 v18; // dx
  _QWORD *v19; // rcx
  unsigned __int16 v20; // dx
  unsigned int v21; // edx
  struct _EVENT_DESCRIPTOR *v22; // rax
  __int64 v23; // rax
  unsigned __int16 *v24; // rax
  tsched *v25; // rcx
  _QWORD *v26; // rcx
  unsigned __int16 v27; // dx
  unsigned __int16 *v28; // r9
  __int64 *DomainAccount; // rax
  char v30; // r13
  const WCHAR *v31; // rax
  __int64 v32; // rax
  unsigned __int16 *v33; // rcx
  const unsigned __int16 *v34; // r9
  int *v35; // rsi
  __int64 v36; // rax
  __int64 v37; // rdx
  __int64 v38; // r8
  int v39; // r9d
  unsigned __int16 *Copy; // rax
  unsigned __int8 *v41; // r14
  HANDLE CurrentThread; // rax
  tsched *v43; // rcx
  JobBucket *v44; // rcx
  __int64 *v45; // rax
  unsigned __int16 *v46; // rcx
  unsigned __int16 *v47; // rdx
  _QWORD *v48; // rcx
  unsigned __int16 v49; // dx
  unsigned int Priority; // eax
  unsigned int v51; // edx
  _QWORD *v52; // rcx
  unsigned __int16 v53; // dx
  int v54; // eax
  signed int v55; // eax
  JobBucket *v56; // rbx
  User *LocalAdmin; // rax
  tsched *v58; // r13
  const unsigned __int16 *v59; // rdx
  char *v60; // rax
  const unsigned __int16 *v61; // rdx
  unsigned __int16 *v62; // r9
  HKEY *v63; // rbx
  const unsigned __int16 *Path; // rax
  struct _TASK_USER_CRED *v65; // rbx
  JobBucket *v66; // rax
  int v67; // ecx
  _QWORD *v68; // rcx
  unsigned __int16 v69; // dx
  unsigned __int16 *v70; // r15
  int v71; // ecx
  bool v72; // zf
  const unsigned __int16 *v73; // r8
  unsigned int v74; // ecx
  User::UserEntry *v75; // rcx
  JobStore *v76; // rcx
  const wchar_t *v77; // rax
  const struct JobMoniker *v78; // rcx
  __int64 v79; // rbx
  unsigned __int64 v80; // rbx
  void *v81; // rax
  int v82; // eax
  EventManager *v83; // rcx
  const wchar_t *v84; // rax
  RTL_SRWLOCK *v85; // rdi
  const unsigned __int16 *v86; // rdx
  char *v87; // rax
  unsigned __int8 v88; // al
  int v89; // eax
  const wchar_t *v90; // rax
  unsigned __int16 v91; // dx
  const wchar_t *v92; // rax
  unsigned __int8 v93; // al
  const wchar_t *v94; // rax
  const wchar_t *v95; // rax
  const unsigned __int16 *v96; // rax
  JobMoniker *v97; // rax
  const unsigned __int16 *v98; // rax
  __int64 *Account; // rax
  const unsigned __int16 *v100; // rdx
  __int64 *v101; // rax
  __int64 v102; // rsi
  const wchar_t *v103; // rax
  tsched *v104; // rcx
  const wchar_t *v105; // rax
  unsigned int v106; // esi
  __int64 v107; // rcx
  int v108; // r8d
  const wchar_t *v109; // rax
  int v110; // r8d
  const wchar_t *v111; // rax
  BOOL v112; // edi
  EventManager *v113; // rcx
  RpcServer *v114; // rcx
  __int64 v115; // rcx
  const struct JobSecurity *v116; // r8
  bool v117; // sf
  LPCWSTR *v118; // r8
  unsigned int v119; // eax
  unsigned int v120; // eax
  JobBucket *v121; // rax
  void **v122; // rbx
  __int64 v123; // rcx
  __int64 *v124; // rax
  const unsigned __int16 *v125; // rdx
  void *v126; // r8
  int updated; // eax
  const wchar_t *v128; // rax
  LPCWSTR *v129; // rax
  int v130; // ecx
  unsigned int v131; // eax
  const wchar_t *v132; // rax
  JobBucket *v133; // rax
  User::UserEntry *v134; // rcx
  __int64 v135; // rcx
  const unsigned __int16 ***v136; // rax
  const unsigned __int16 *v137; // rdx
  __int64 *v138; // rax
  BYTE **v139; // rax
  const wchar_t *v140; // rax
  const struct User *v141; // r9
  const wchar_t *v142; // rax
  JobStore *v143; // r14
  int TaskXmlFromCollections; // eax
  const struct JobSecurity *v145; // r8
  char v146; // si
  const wchar_t *v147; // rax
  EventManager *v148; // rcx
  const struct _EVENT_DESCRIPTOR *v149; // rax
  struct _EVENT_DESCRIPTOR *v150; // rdx
  const unsigned __int16 *v151; // rax
  const wchar_t *v152; // rax
  unsigned __int16 v153; // dx
  __int64 v154; // rcx
  __int64 v155; // r8
  __int64 v156; // r9
  unsigned __int8 v158; // [rsp+E8h] [rbp-738h] BYREF
  int v159; // [rsp+ECh] [rbp-734h] BYREF
  unsigned __int16 *v160; // [rsp+F0h] [rbp-730h]
  unsigned int v161; // [rsp+F8h] [rbp-728h]
  unsigned int v162; // [rsp+FCh] [rbp-724h] BYREF
  struct _GUID v163; // [rsp+100h] [rbp-720h] BYREF
  JobStore *v164; // [rsp+110h] [rbp-710h] BYREF
  unsigned int v165[2]; // [rsp+118h] [rbp-708h] BYREF
  User::UserEntry *v166; // [rsp+120h] [rbp-700h] BYREF
  void **v167; // [rsp+128h] [rbp-6F8h] BYREF
  unsigned __int16 *v168; // [rsp+130h] [rbp-6F0h] BYREF
  struct _TASK_USER_CRED *v169; // [rsp+138h] [rbp-6E8h] BYREF
  bool v170; // [rsp+140h] [rbp-6E0h]
  unsigned int v171; // [rsp+144h] [rbp-6DCh]
  _QWORD *v172; // [rsp+148h] [rbp-6D8h] BYREF
  BYTE *lpData; // [rsp+150h] [rbp-6D0h] BYREF
  PSECURITY_DESCRIPTOR NewDescriptor[2]; // [rsp+158h] [rbp-6C8h] BYREF
  BSTR v175; // [rsp+168h] [rbp-6B8h] BYREF
  unsigned int v176; // [rsp+170h] [rbp-6B0h] BYREF
  unsigned __int16 *p_Id; // [rsp+178h] [rbp-6A8h]
  void *TokenHandle; // [rsp+180h] [rbp-6A0h] BYREF
  User::UserEntry *v179; // [rsp+188h] [rbp-698h] BYREF
  EventManager *v180; // [rsp+190h] [rbp-690h] BYREF
  struct _EVENT_DESCRIPTOR *v181; // [rsp+198h] [rbp-688h] BYREF
  const WCHAR *v182; // [rsp+1A0h] [rbp-680h] BYREF
  unsigned __int16 *v183; // [rsp+1A8h] [rbp-678h] BYREF
  unsigned __int16 *v184; // [rsp+1B0h] [rbp-670h] BYREF
  void *v185; // [rsp+1B8h] [rbp-668h] BYREF
  unsigned __int16 *v186; // [rsp+1C0h] [rbp-660h] BYREF
  LPCWSTR StringSecurityDescriptor; // [rsp+1C8h] [rbp-658h] BYREF
  unsigned __int16 **v188; // [rsp+1D0h] [rbp-650h]
  tsched *v189; // [rsp+1D8h] [rbp-648h] BYREF
  tsched **v190; // [rsp+1E0h] [rbp-640h] BYREF
  void *v191; // [rsp+1E8h] [rbp-638h] BYREF
  void *v192; // [rsp+1F0h] [rbp-630h] BYREF
  PSECURITY_DESCRIPTOR pSecurityDescriptor[2]; // [rsp+1F8h] [rbp-628h] BYREF
  char v194[24]; // [rsp+208h] [rbp-618h] BYREF
  __int64 v195[3]; // [rsp+220h] [rbp-600h] BYREF
  struct _FILETIME v196[6]; // [rsp+238h] [rbp-5E8h] BYREF
  wmi::RefBase *v197; // [rsp+268h] [rbp-5B8h] BYREF
  __int64 v198[2]; // [rsp+270h] [rbp-5B0h] BYREF
  int v199; // [rsp+280h] [rbp-5A0h]
  __int64 v200; // [rsp+288h] [rbp-598h]
  void **v201; // [rsp+290h] [rbp-590h]
  struct _FILETIME v202[7]; // [rsp+298h] [rbp-588h] BYREF
  char pExceptionObject[56]; // [rsp+2D0h] [rbp-550h] BYREF
  struct _GUID v204; // [rsp+308h] [rbp-518h] BYREF
  JobBucket *v205; // [rsp+328h] [rbp-4F8h]
  struct _GUID v206; // [rsp+338h] [rbp-4E8h] BYREF
  BSTR *v207[4]; // [rsp+348h] [rbp-4D8h] BYREF
  __int64 v208; // [rsp+368h] [rbp-4B8h]
  wmi::RefBase *v209[5]; // [rsp+370h] [rbp-4B0h] BYREF
  unsigned __int16 v210[256]; // [rsp+398h] [rbp-488h] BYREF
  unsigned __int8 v211; // [rsp+598h] [rbp-288h]
  CBstrWriter *v212; // [rsp+7B8h] [rbp-68h]

  v200 = -2LL;
  p_Id = &a3->Id;
  v160 = a2;
  v167 = this;
  v181 = a3;
  v168 = a5;
  v169 = a8;
  lpData = a9;
  v188 = a10;
  v172 = a11;
  v161 = 0;
  v171 = 0;
  v180 = 0LL;
  v13 = 0LL;
  v186 = 0LL;
  StringSecurityDescriptor = 0LL;
  v179 = 0LL;
  JobMoniker::JobMoniker((JobMoniker *)v207, 0LL, 0LL);
  JobSecurity::JobSecurity((JobSecurity *)pSecurityDescriptor);
  Triggers::Trigulator::Trigulator(v202);
  Actions::ActionCollection::ActionCollection((Actions::ActionCollection *)v195);
  v14 = 0LL;
  v184 = 0LL;
  v191 = 0LL;
  TokenHandle = 0LL;
  v190 = 0LL;
  Triggers::Trigulator::Trigulator(v196);
  Actions::ActionCollection::ActionCollection((Actions::ActionCollection *)v194);
  v189 = 0LL;
  v175 = 0LL;
  v183 = 0LL;
  v192 = 0LL;
  JobMoniker::JobMoniker((JobMoniker *)&v204, a2, 0LL);
  tsched::SecretGuard::operator=(&v192);
  if ( (unsigned int)dword_1800AFF68 > 5 && tlgKeywordOn((__int64)&dword_1800AFF68, 0LL) )
    _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<>(
      v15,
      byte_18007F0D2);
  RpcAutoImpersonate::RpcAutoImpersonate((RpcAutoImpersonate *)&v162, L"RpcServer::RegisterTask", 1);
  if ( !RpcServer::CheckIntegrityLevel() )
  {
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_S(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x1Cu,
        (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids,
        a2);
    }
    Stream = -2147024891;
    if ( v162 )
      RpcRevertToSelf();
    goto LABEL_507;
  }
  if ( v162 )
    RpcRevertToSelf();
  if ( v188 )
    *v188 = 0LL;
  if ( a11 )
    *a11 = 0LL;
  if ( a6 > 6 )
  {
    v17 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
      || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) == 0
      || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
    {
      goto LABEL_506;
    }
    v18 = 29;
    goto LABEL_22;
  }
  if ( !p_Id )
  {
    v19 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
      || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) == 0
      || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
    {
      goto LABEL_506;
    }
    v20 = (_WORD)p_Id + 30;
    goto LABEL_504;
  }
  v21 = 2;
  if ( a4 )
    v21 = a4;
  v162 = v21;
  v176 = v21;
  if ( (v21 & 0xFFFFFFC0) != 0 || (v21 & 7) == 0 || (v21 & 0xFFFFFFFE) != 0 && (v21 & 1) != 0 )
  {
    v19 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
      || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) == 0
      || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
    {
      goto LABEL_506;
    }
    v20 = 31;
    goto LABEL_504;
  }
  if ( a7 )
  {
    if ( (*((_DWORD *)v169 + 4) & 0xFFFFFFFE) == 0 )
    {
      if ( a7 > 1 )
      {
        v17 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
          || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) == 0
          || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
        {
          goto LABEL_506;
        }
        v18 = 34;
LABEL_22:
        WPP_SF_SD(v17[2], v18, (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids, a2);
LABEL_506:
        Stream = -2147024809;
        goto LABEL_507;
      }
      goto LABEL_49;
    }
    v19 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
      || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) == 0
      || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
    {
      goto LABEL_506;
    }
    v20 = 33;
LABEL_504:
    v62 = a2;
LABEL_505:
    WPP_SF_S(v19[2], v20, (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids, v62);
    goto LABEL_506;
  }
  if ( v169 )
  {
    v19 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
      || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) == 0
      || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
    {
      goto LABEL_506;
    }
    v20 = 32;
    goto LABEL_504;
  }
LABEL_49:
  if ( (v21 & 1) != 0 )
  {
    v169 = 0LL;
    Stream = StringReader::CreateStream((__int64)p_Id, (__int64 *)&v169);
    if ( Stream >= 0 )
    {
      v168 = 0LL;
      v164 = 0LL;
      v22 = (struct _EVENT_DESCRIPTOR *)operator new(0x460uLL);
      v181 = v22;
      if ( v22 )
        v23 = TaskXmlReader::TaskXmlReader((__int64)v22, (__int64 *)&v169, (__int64)&v168, 0);
      else
        v23 = 0LL;
      wmi::AutoRef<TaskXmlReader>::operator=(&v164, v23);
      ValidationXmlHandler::ValidationXmlHandler(
        (ValidationXmlHandler *)v210,
        (const struct JobMoniker *)&v204,
        2LL,
        0LL,
        0LL);
      Stream = TaskXmlReader::ProcessXml(v164, (struct ITaskXmlHandler *)v210);
      if ( a11 )
      {
        v24 = v168;
        if ( v168 )
        {
          v168 = 0LL;
          *a11 = (struct _TASK_XML_ERROR_INFO *)v24;
        }
      }
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) != 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        WPP_SF_SD(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x24u,
          (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids,
          a2);
      }
      ValidationXmlHandler::~ValidationXmlHandler((ValidationXmlHandler *)v210);
      wmi::AutoRef<TaskXmlReader>::~AutoRef<TaskXmlReader>(&v164);
      std::_Tree_comp<0,std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::~_Tree_comp<0,std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>((void **)&v168);
    }
    else if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
           && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) != 0
           && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_SD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x23u,
        (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids,
        a2);
    }
    _com_ptr_t<_com_IIID<IStream,&__s_GUID const _GUID_0000000c_0000_0000_c000_000000000046>>::~_com_ptr_t<_com_IIID<IStream,&__s_GUID const _GUID_0000000c_0000_0000_c000_000000000046>>(&v169);
    goto LABEL_507;
  }
  *(_QWORD *)v165 = 0LL;
  v166 = 0LL;
  RpcAutoImpersonate::RpcAutoImpersonate((RpcAutoImpersonate *)&v159, L"RpcServer::RegisterTask", 1);
  Stream = User::FromImpersonationToken((struct User *)&v166, 0LL);
  if ( Stream < 0 )
  {
    v26 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      v27 = 37;
      v28 = a2;
LABEL_72:
      WPP_SF_SD(v26[2], v27, (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids, v28);
      goto LABEL_73;
    }
    goto LABEL_73;
  }
  if ( !a7 )
  {
    DomainAccount = User::GetDomainAccount((User *)&v166, (__int64 *)&v185);
    _bstr_t::operator=((__int64 *)&v190, DomainAccount);
    _bstr_t::~_bstr_t((_bstr_t *)&v185);
    v198[1] = 0LL;
    if ( v190 )
      v25 = *v190;
    else
      v25 = 0LL;
    v198[0] = (__int64)v25;
    v199 = 1;
    v169 = (struct _TASK_USER_CRED *)v198;
  }
  if ( (unsigned int)tsched::IsUserAdmin(v25) || (v30 = 0, User::IsLocalSystem((User *)&v166)) )
    v30 = 1;
  if ( *((_DWORD *)v167 + 7) && !v30 )
  {
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_S(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x26u,
        (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids,
        a2);
    }
LABEL_90:
    Stream = -2147024891;
    goto LABEL_73;
  }
  v164 = 0LL;
  Stream = StringReader::CreateStream((__int64)p_Id, (__int64 *)&v164);
  if ( Stream < 0 )
  {
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_SD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x27u,
        (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids,
        a2);
    }
    goto LABEL_96;
  }
  *(_QWORD *)&v163.Data1 = 0LL;
  v31 = (const WCHAR *)operator new(0x460uLL);
  v182 = v31;
  if ( v31 )
    v32 = TaskXmlReader::TaskXmlReader((__int64)v31, (__int64 *)&v164, (__int64)v165, 0);
  else
    v32 = 0LL;
  wmi::AutoRef<TaskXmlReader>::operator=(&v163, v32);
  if ( !v168 || (v33 = 0LL, *v168) )
    v33 = v168;
  if ( !a2 || (v34 = 0LL, *a2) )
    v34 = a2;
  ServerXMLUpdateHandler::ServerXMLUpdateHandler(
    (ServerXMLUpdateHandler *)v210,
    (v162 & 8) != 0,
    (v162 & 8) == 0,
    v34,
    v33,
    v169,
    a6,
    (const struct JobMoniker *)&v204,
    &v166,
    (struct Triggers::Trigulator *)v196,
    (struct Actions::ActionCollection *)v194,
    1,
    (struct ATL::CComBSTR *)&v189,
    (struct ATL::CComBSTR *)&v175,
    0);
  Stream = TaskXmlReader::ProcessXml(*(TaskXmlReader **)&v163.Data1, (struct ITaskXmlHandler *)v210);
  if ( Stream < 0 )
  {
    v35 = *(int **)v165;
    *(_QWORD *)v165 = 0LL;
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      if ( v35 )
      {
        v36 = *((_QWORD *)v35 + 2);
        v37 = *((_QWORD *)v35 + 1);
        v38 = (unsigned int)v35[1];
        v39 = *v35;
      }
      else
      {
        v36 = 0LL;
        v37 = 0LL;
        v38 = 0LL;
        LOBYTE(v39) = 0;
      }
      WPP_SF_SDddSS(*((_QWORD *)WPP_GLOBAL_Control + 2), v37, v38, a2, Stream, v39, v38, v37, v36);
    }
    if ( v172 && v35 )
      *v172 = v35;
    goto LABEL_117;
  }
  v158 = v211;
  Copy = CBstrWriter::GetCopy(v212);
  ATL::CComBSTR::Attach(&v183, Copy);
  v41 = (unsigned __int8 *)v183;
  if ( !v183 )
  {
    Stream = -2147024882;
LABEL_117:
    ServerXMLUpdateHandler::~ServerXMLUpdateHandler((ServerXMLUpdateHandler *)v210);
    wmi::AutoRef<TaskXmlReader>::~AutoRef<TaskXmlReader>(&v163);
LABEL_96:
    _com_ptr_t<_com_IIID<IStream,&__s_GUID const _GUID_0000000c_0000_0000_c000_000000000046>>::~_com_ptr_t<_com_IIID<IStream,&__s_GUID const _GUID_0000000c_0000_0000_c000_000000000046>>(&v164);
    goto LABEL_73;
  }
  wmi::AutoRef<JobBucket>::operator=(&v197, (volatile signed __int32 *)v205);
  ServerXMLUpdateHandler::~ServerXMLUpdateHandler((ServerXMLUpdateHandler *)v210);
  wmi::AutoRef<TaskXmlReader>::~AutoRef<TaskXmlReader>(&v163);
  _com_ptr_t<_com_IIID<IStream,&__s_GUID const _GUID_0000000c_0000_0000_c000_000000000046>>::~_com_ptr_t<_com_IIID<IStream,&__s_GUID const _GUID_0000000c_0000_0000_c000_000000000046>>(&v164);
  if ( !v30 && v158 )
  {
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_SD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x29u,
        (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids,
        v160);
    }
    goto LABEL_90;
  }
  CurrentThread = GetCurrentThread();
  if ( !OpenThreadToken(CurrentThread, 0x2000Eu, 1, &TokenHandle) )
  {
    Stream = tsched::GetLastHrError(v43);
    v26 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      v27 = 42;
      v28 = v160;
      goto LABEL_72;
    }
LABEL_73:
    if ( v159 )
      RpcRevertToSelf();
    goto LABEL_75;
  }
  if ( v159 )
    RpcRevertToSelf();
  v44 = v205;
  if ( (*((_DWORD *)v205 + 4) & 0x40000) != 0 && (!v169 || !*((_QWORD *)v169 + 1)) )
  {
    v158 = 0;
    v45 = User::GetDomainAccount((JobBucket *)((char *)v205 + 64), (__int64 *)&v172);
    if ( *v45 )
      v47 = *(unsigned __int16 **)*v45;
    else
      v47 = 0LL;
    Stream = IsPasswordManagedServiceAccount(v46, v47, (bool *)&v158);
    _bstr_t::~_bstr_t((_bstr_t *)&v172);
    if ( Stream < 0 )
    {
      v48 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
        || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) == 0
        || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
      {
        goto LABEL_75;
      }
      v49 = 43;
      goto LABEL_144;
    }
    v44 = v205;
    if ( v158 == 1 )
    {
      *((_DWORD *)v205 + 4) |= 0x80000000;
      v44 = v205;
    }
  }
  if ( !v30 )
  {
    Priority = JobBucket::GetPriority(v44);
    if ( Priority <= v51 )
    {
      v52 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
        || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) == 0
        || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
      {
        goto LABEL_154;
      }
      v53 = 44;
LABEL_153:
      WPP_SF_S(v52[2], v53, (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids, v160);
LABEL_154:
      Stream = -2147024891;
      goto LABEL_75;
    }
  }
  v159 = 0;
  v54 = LUAIsElevatedToken(TokenHandle, &v159, &v163);
  if ( v54 < 0 )
  {
    v55 = RtlNtStatusToDosError(v54);
    Stream = v55;
    if ( v55 > 0 )
      Stream = (unsigned __int16)v55 | 0x80070000;
    v48 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
      || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) == 0
      || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
    {
      goto LABEL_75;
    }
    v49 = 45;
LABEL_144:
    WPP_SF_SD(v48[2], v49, (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids, v160);
LABEL_75:
    std::pair<User const,LogonJob *>::~pair<User const,LogonJob *>(&v166);
    std::_Tree_comp<0,std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::~_Tree_comp<0,std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>((void **)v165);
LABEL_507:
    v70 = v160;
    goto LABEL_508;
  }
  v56 = v205;
  if ( (*((_DWORD *)v205 + 4) & 0x1000000) != 0
    || (LocalAdmin = User::GetLocalAdmin(), User::operator==((JobBucket *)((char *)v56 + 64), LocalAdmin))
    || (*((_DWORD *)v205 + 4) & 0xFC000) == 0x4000 )
  {
    if ( !v159 && !v30 )
    {
      v52 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
        || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) == 0
        || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
      {
        goto LABEL_154;
      }
      v53 = 46;
      goto LABEL_153;
    }
  }
  std::pair<User const,LogonJob *>::~pair<User const,LogonJob *>(&v166);
  std::_Tree_comp<0,std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::~_Tree_comp<0,std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>((void **)v165);
  v58 = v189;
  v160 = (unsigned __int16 *)v189;
  v185 = v189;
  v60 = tsched::PathCopy(v189, v59);
  wmi::AutoVectorPtr<unsigned char>::operator=((void **)&v180, v60);
  if ( tsched::IsRoot(v58, v61) )
  {
    v19 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
      || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) == 0
      || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
    {
      goto LABEL_506;
    }
    v20 = 47;
    v62 = v160;
    goto LABEL_505;
  }
  JobMoniker::_SetPath((_bstr_t::Data_t **)&v204, (const unsigned __int16 *)v58);
  v63 = (HKEY *)JobStore::m_pCommonStore;
  v164 = JobStore::m_pCommonStore;
  Path = JobMoniker::GetPath((JobMoniker *)&v204);
  JobStore::RegGetOverrideInfo(v63, Path, (enum JobFlags::StatePersistanceFlags *)&v166);
  *((_DWORD *)v205 + 5) = (_DWORD)v166;
  v65 = v169;
  v66 = v205;
  if ( !v169 || !*((_QWORD *)v169 + 1) )
    goto LABEL_515;
  v67 = *((_DWORD *)v205 + 4);
  if ( (v67 & 0x20000) != 0 || v67 < 0 )
  {
    Stream = -2147023570;
    v68 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
      || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) == 0
      || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
    {
      goto LABEL_507;
    }
    v69 = 48;
    goto LABEL_184;
  }
  if ( !*((_QWORD *)v169 + 1) )
  {
LABEL_515:
    if ( (v71 = *((_DWORD *)v205 + 4), (v71 & 0x100000) != 0)
      || (v71 & 0x20000) != 0
      || (v71 & 0x40000) == 0 && (v71 & 0x80000) == 0
      || v71 < 0
      || (v72 = !PlugIn::IsRegistering((PlugIn *)&PlugIn::s_singleton, (const unsigned __int16 *)v58, p_Id),
          v66 = v205,
          !v72) )
    {
      v75 = (User::UserEntry *)*((_QWORD *)v66 + 8);
      *(_QWORD *)&v163.Data1 = v75;
      if ( v75 )
      {
        User::UserEntry::AddRef(v75);
        v66 = v205;
      }
      Stream = IsPrincipalAllowed((User *)&v163, *((_DWORD *)v66 + 4));
      if ( Stream < 0 )
      {
        v68 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
          || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) == 0
          || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
        {
          goto LABEL_507;
        }
        v69 = 50;
LABEL_184:
        v70 = v160;
LABEL_185:
        WPP_SF_SD(v68[2], v69, (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids, v70);
        goto LABEL_508;
      }
LABEL_212:
      LODWORD(v166) = Stream == 267036;
      v170 = Stream == 267036;
      Stream = JobStore::ComputeHash((struct JobMoniker *)&v204, v41);
      if ( Stream < 0 )
      {
        v68 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) == 0 )
          goto LABEL_507;
        v70 = v160;
        if ( *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
        {
          v69 = 51;
          goto LABEL_185;
        }
        goto LABEL_508;
      }
      Stream = JobStore::SetSchedulingEngineFlag(
                 v76,
                 (struct JobMoniker *)&v204,
                 (struct Triggers::Trigulator *)v196,
                 (struct Actions::ActionCollection *)v194,
                 (bool *)v163.Data4,
                 (int *)&v163);
      if ( Stream < 0 )
      {
        if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
          && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) != 0
          && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
        {
          v77 = JobMoniker::GetPath((JobMoniker *)&v204);
          WPP_SF_SD(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x34u,
            (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids,
            v77);
        }
        goto LABEL_507;
      }
      if ( (*((_DWORD *)v205 + 4) & 0x40000) != 0 || (*((_DWORD *)v205 + 4) & 0x80000) != 0 )
      {
        if ( a7 )
        {
          if ( v169 )
          {
            v78 = (const struct JobMoniker *)*((_QWORD *)v169 + 1);
            if ( v78 )
            {
              if ( (*((_DWORD *)v205 + 4) & 0x2000000) != 0 )
              {
                v79 = -1LL;
                do
                  ++v79;
                while ( *((_WORD *)v78 + v79) );
                v80 = v79 + 1;
                v81 = operator new(saturated_mul(v80, 2uLL));
                wmi::AutoVectorPtr<unsigned char>::operator=((void **)&v184, v81);
                v14 = v184;
                tsched::SecretGuard::operator=(&v191);
                v82 = StringCchCopyW((char *)v14, v80, *((char **)v169 + 1));
                if ( v82 < 0 )
                {
                  wmi::GenericException::GenericException((wmi::GenericException *)pExceptionObject, v82);
                  CxxThrowException_0(pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
                }
              }
              Stream = RpcServer::SavePasswords(v78, a7, v169);
              if ( Stream < 0 )
              {
                if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
                  && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) != 0
                  && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
                {
                  v84 = JobMoniker::GetPath((JobMoniker *)&v204);
                  WPP_SF_SD(
                    *((_QWORD *)WPP_GLOBAL_Control + 2),
                    0x35u,
                    (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids,
                    v84);
                }
                EventManager::EvtReport(
                  v83,
                  &TASK_REGISTERED_WITHOUT_CREDENTIALS,
                  (const unsigned __int16 *)v180,
                  Stream);
                goto LABEL_507;
              }
            }
          }
        }
      }
      v165[0] = 0;
      v158 = 0;
      v163.Data4[0] = 1;
      v85 = (RTL_SRWLOCK *)(v167 + 2);
      v201 = v167 + 2;
      AcquireSRWLockExclusive((PSRWLOCK)v167 + 2);
      memset_0(v210, 0, 0x20AuLL);
      if ( (*((_DWORD *)v205 + 4) & 0x200000) != 0 )
      {
        if ( !PlugIn::IsRegistering((PlugIn *)&PlugIn::s_singleton, (const unsigned __int16 *)v58, p_Id) )
        {
          Stream = PlugIn::RegisterTask(
                     (PlugIn *)&PlugIn::s_singleton,
                     (const unsigned __int16 *)v58,
                     (const unsigned __int16 *)v41,
                     v168,
                     v162,
                     v210);
          if ( Stream < 0 )
          {
            if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) == 0 )
            {
              v70 = v160;
            }
            else
            {
              v70 = v160;
              if ( *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
                WPP_SF_SD(
                  *((_QWORD *)WPP_GLOBAL_Control + 2),
                  0x36u,
                  (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids,
                  v160);
            }
LABEL_245:
            ReleaseSRWLockExclusive(v85);
            goto LABEL_508;
          }
        }
        if ( !Stream && v210[0] )
        {
          JobMoniker::_SetPath((_bstr_t::Data_t **)&v204, v210);
          v160 = (unsigned __int16 *)JobMoniker::GetPath((JobMoniker *)&v204);
          v185 = v160;
          v87 = tsched::PathCopy((tsched *)v160, v86);
          wmi::AutoVectorPtr<unsigned char>::operator=((void **)&v180, v87);
        }
      }
      else
      {
        if ( qword_1800B0D30 )
          v89 = qword_1800B0D30(v58);
        else
          v89 = 1;
        if ( v89 < 0
          && WPP_GLOBAL_Control != &WPP_GLOBAL_Control
          && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) != 0
          && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
        {
          WPP_SF_SD(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x37u,
            (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids,
            v160);
        }
      }
      v206 = 0LL;
      LODWORD(v167) = 0;
      Stream = JobStore::RegGetTreeInfo((HKEY *)v164, v160, &v206, (enum JobStore::TaskIndex *)&v167);
      v159 = Stream;
      if ( Stream >= 0 && !(_DWORD)v167 )
      {
        JobMoniker::JobMoniker((JobMoniker *)v209, v160, &v206);
        JobStore::RemoveTaskEntry((HKEY *)v164, (const struct JobMoniker *)v209);
        Stream = -2147024894;
        v159 = -2147024894;
        JobMoniker::~JobMoniker(v209);
      }
      if ( tsched::IsErrorNotFound((tsched *)(unsigned int)Stream) )
      {
        v88 = 1;
        v158 = 1;
        Stream = 0;
        v159 = 0;
      }
      else
      {
        v88 = v158;
      }
      if ( Stream < 0 )
      {
        if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
          || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) == 0
          || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
        {
          goto LABEL_269;
        }
        v90 = JobMoniker::GetPath((JobMoniker *)&v204);
        v91 = 56;
LABEL_268:
        WPP_SF_SD(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          v91,
          (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids,
          v90);
LABEL_269:
        ReleaseSRWLockExclusive(v85);
        goto LABEL_507;
      }
      if ( v88 )
      {
        if ( (v162 & 2) == 0 )
        {
          if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
            && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) != 0
            && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
          {
            v92 = JobMoniker::GetPath((JobMoniker *)&v204);
            WPP_SF_S(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              0x39u,
              (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids,
              v92);
          }
          Stream = -2147024894;
          goto LABEL_269;
        }
        JobMoniker::_GenId(&v204);
        v93 = v163.Data4[0];
      }
      else
      {
        if ( (v162 & 4) == 0 )
        {
          if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
            && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) != 0
            && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
          {
            v94 = JobMoniker::GetPath((JobMoniker *)&v204);
            WPP_SF_S(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              0x3Au,
              (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids,
              v94);
          }
          Stream = -2147024713;
          goto LABEL_269;
        }
        v204 = v206;
        Stream = JobStore::RegJobSecurityQuery((HKEY *)v164, v160, pSecurityDescriptor);
        if ( Stream < 0 )
        {
          if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
            && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) != 0
            && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
          {
            v95 = JobMoniker::GetPath((JobMoniker *)&v204);
            WPP_SF_S(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              0x3Bu,
              (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids,
              v95);
          }
          goto LABEL_269;
        }
        Stream = JobSecurity::GetSddl(pSecurityDescriptor, 7u, (unsigned __int16 **)&StringSecurityDescriptor);
        if ( Stream < 0 )
        {
          if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
            || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) == 0
            || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
          {
            goto LABEL_269;
          }
          v90 = JobMoniker::GetPath((JobMoniker *)&v204);
          v91 = 60;
          goto LABEL_268;
        }
        Stream = JobAccessCheck(TokenHandle, pSecurityDescriptor[0], 2u);
        if ( Stream < 0 )
        {
          if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
            || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) == 0
            || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
          {
            goto LABEL_269;
          }
          v90 = JobMoniker::GetPath((JobMoniker *)&v204);
          v91 = 61;
          goto LABEL_268;
        }
        v96 = JobMoniker::GetPath((JobMoniker *)&v204);
        v97 = JobMoniker::JobMoniker((JobMoniker *)v209, v96, &v204);
        JobMoniker::operator=((__int64)v207, (__int64)v97);
        JobMoniker::~JobMoniker(v209);
        v98 = JobMoniker::GetPath((JobMoniker *)&v204);
        Stream = JobStore::LoadBucketFromRegistry((HKEY *)v164, v98, 15, (__int64)v207, (__int64)v202, v195);
        v159 = Stream;
        if ( Stream < 0 )
        {
          if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
            || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) == 0
            || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
          {
            goto LABEL_269;
          }
          v90 = JobMoniker::GetPath((JobMoniker *)v207);
          v91 = 62;
          goto LABEL_268;
        }
        v165[0] = *(_DWORD *)(v208 + 16) & 0xFC000;
        wmi::AutoRef<User::UserEntry>::operator=(&v179, *(User::UserEntry **)(v208 + 64));
        if ( User::IsAlias((User *)&v179) )
        {
          Account = User::GetAccount(v208 + 64, (__int64 *)&v172);
          v100 = *Account ? *(const unsigned __int16 **)*Account : 0LL;
          Stream = CredStore::ResolveAlias((HKEY *)CredStore::g_pCommonStore, v100, &v179);
          v159 = Stream;
          _bstr_t::~_bstr_t((_bstr_t *)&v172);
          if ( Stream < 0 )
          {
            if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
              && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) != 0
              && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
            {
              v101 = User::GetAccount(v208 + 64, (__int64 *)&v172);
              v161 = 1;
              if ( *v101 )
                v102 = *(_QWORD *)*v101;
              else
                v102 = 0LL;
              v103 = JobMoniker::GetPath((JobMoniker *)v207);
              WPP_SF_SSD(
                *((_QWORD *)WPP_GLOBAL_Control + 2),
                0x3Fu,
                (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids,
                v103,
                v102);
            }
            if ( (v161 & 1) != 0 )
              _bstr_t::~_bstr_t((_bstr_t *)&v172);
            goto LABEL_269;
          }
        }
        if ( !JobMoniker::HasEqualTaskHardeningSettings((JobMoniker *)v207, (const struct JobMoniker *)&v204) )
        {
          RpcAutoImpersonate::RpcAutoImpersonate((RpcAutoImpersonate *)&v167, L"RpcServer::RegisterTask", 1);
          if ( !(unsigned int)tsched::IsUserAdmin(v104) )
          {
            Stream = -2147024891;
            if ( (_DWORD)v167 )
              RpcRevertToSelf();
            goto LABEL_269;
          }
          if ( (_DWORD)v167 )
            RpcRevertToSelf();
        }
        if ( (-(__int64)(*((_DWORD *)v205 + 15) != 0) & ((unsigned __int64)v205 + 28)) == 0
          || ((v208 + 28) & -(__int64)(*(_DWORD *)(v208 + 60) != 0)) == 0
          || memcmp_0(
               (const void *)(((unsigned __int64)v205 + 28) & -(__int64)(*((_DWORD *)v205 + 15) != 0)),
               (const void *)((v208 + 28) & -(__int64)(*(_DWORD *)(v208 + 60) != 0)),
               0x20uLL) )
        {
          goto LABEL_371;
        }
        v93 = 0;
      }
      if ( v158 )
      {
        JobSecurity::JobSecurity((JobSecurity *)NewDescriptor);
        Stream = RpcServer::CreateRegistrationPath(v114, v160, (struct JobSecurity *)NewDescriptor, TokenHandle);
        v159 = Stream;
        if ( Stream < 0 )
          goto LABEL_368;
        Stream = JobAccessCheck(TokenHandle, NewDescriptor[0], 2u);
        v159 = Stream;
        if ( Stream < 0 )
          goto LABEL_368;
        JobSecurity::~JobSecurity((JobSecurity *)NewDescriptor);
      }
      else if ( !v93 && !lpData )
      {
        goto LABEL_331;
      }
LABEL_371:
      JobSecurity::JobSecurity((JobSecurity *)NewDescriptor);
      if ( !v168 )
      {
        if ( !v158 )
        {
          if ( !v175 )
          {
            Stream = JobSecurity::Assign(NewDescriptor, pSecurityDescriptor[0]);
            v159 = Stream;
            v117 = Stream < 0;
            goto LABEL_383;
          }
          goto LABEL_376;
        }
        if ( v175 )
        {
LABEL_376:
          v118 = (LPCWSTR *)ATL::CComBSTR::CComBSTR((ATL::CComBSTR *)&v163, (LPCSTR *)&v175);
          v119 = 2;
LABEL_378:
          v171 = v119;
          v161 = v119;
          Stream = JobStore::GenerateJobSecurity((HKEY *)v164, (tsched *)v160, *v118, 0, TokenHandle, NewDescriptor);
          v159 = Stream;
          v120 = v161;
          if ( (v161 & 4) != 0 )
          {
            v161 &= ~4u;
            v171 = v120 & 0xFFFFFFFB;
            ATL::CComBSTR::~CComBSTR((BSTR *)&v172);
            v120 = v161;
          }
          if ( (v120 & 2) != 0 )
          {
            v161 = v120 & 0xFFFFFFFD;
            v171 = v120 & 0xFFFFFFFD;
            ATL::CComBSTR::~CComBSTR((BSTR *)&v163);
          }
          v117 = Stream < 0;
LABEL_383:
          if ( v117 )
            goto LABEL_368;
          v163.Data1 = v162 & 0x10;
          if ( (v162 & 0x10) == 0 )
          {
            v121 = v205;
            v122 = (void **)*((_QWORD *)v205 + 8);
            v167 = v122;
            if ( v122 )
            {
              User::UserEntry::AddRef((User::UserEntry *)v122);
              v121 = v205;
            }
            if ( User::IsAlias((JobBucket *)((char *)v121 + 64)) )
            {
              v124 = User::GetAccount(v123, (__int64 *)&v172);
              if ( *v124 )
                v125 = *(const unsigned __int16 **)*v124;
              else
                v125 = 0LL;
              Stream = CredStore::ResolveAlias((HKEY *)CredStore::g_pCommonStore, v125, (User::UserEntry **)&v167);
              v159 = Stream;
              _bstr_t::~_bstr_t((_bstr_t *)&v172);
              if ( Stream < 0 )
              {
LABEL_393:
                std::pair<User const,LogonJob *>::~pair<User const,LogonJob *>(&v167);
                goto LABEL_368;
              }
              v122 = v167;
            }
            v126 = 0LL;
            if ( !v158 && !v168 && !v175 )
              v126 = (void *)*((_QWORD *)v179 + 4);
            Stream = JobSecurity::AddRemovePrincipalAce(NewDescriptor, v122[4], v126);
            v159 = Stream;
            if ( Stream < 0 )
              goto LABEL_393;
            std::pair<User const,LogonJob *>::~pair<User const,LogonJob *>(&v167);
          }
          if ( v158 )
            updated = JobStore::RegTaskEntryCreate(
                        (HKEY *)v164,
                        (const struct JobMoniker *)&v204,
                        (const struct JobSecurity *)NewDescriptor,
                        (const struct Triggers::Trigulator *)v196,
                        (const struct Actions::ActionCollection *)v194,
                        lpData);
          else
            updated = JobStore::UpdateTaskEntry(
                        (HKEY *)v164,
                        (const struct JobMoniker *)&v204,
                        v116,
                        (const struct Triggers::Trigulator *)v196,
                        (const struct Actions::ActionCollection *)v194,
                        lpData);
          Stream = updated;
          v159 = updated;
          if ( updated >= 0 )
          {
            JobSecurity::~JobSecurity((JobSecurity *)NewDescriptor);
            RpcAutoImpersonate::RpcAutoImpersonate((RpcAutoImpersonate *)&v167, L"RpcServer::RegisterTask", 1);
            if ( v168 || !v175 )
            {
              v129 = (LPCWSTR *)ATL::CComBSTR::CComBSTR((ATL::CComBSTR *)&v172, v168);
              v130 = v161 | 0x10;
            }
            else
            {
              v129 = (LPCWSTR *)ATL::CComBSTR::CComBSTR((ATL::CComBSTR *)&v182, (LPCSTR *)&v175);
              v130 = v161 | 8;
            }
            v171 = v130;
            v161 = v130;
            Stream = JobStore::XmlSaveTaskFile(
                       v164,
                       (const struct JobMoniker *)&v204,
                       (const unsigned __int16 *)v41,
                       *v129);
            v159 = Stream;
            v131 = v161;
            if ( (v161 & 0x10) != 0 )
            {
              v161 &= ~0x10u;
              ATL::CComBSTR::~CComBSTR((BSTR *)&v172);
              v131 = v161;
            }
            if ( (v131 & 8) != 0 )
            {
              v161 = v131 & 0xFFFFFFF7;
              ATL::CComBSTR::~CComBSTR((BSTR *)&v182);
            }
            if ( Stream >= 0 )
            {
              if ( (_DWORD)v167 )
                RpcRevertToSelf();
              if ( !v163.Data1 )
              {
                v133 = v205;
                v134 = (User::UserEntry *)*((_QWORD *)v205 + 8);
                *(_QWORD *)&v163.Data1 = v134;
                if ( v134 )
                {
                  User::UserEntry::AddRef(v134);
                  v133 = v205;
                }
                if ( User::IsAlias((JobBucket *)((char *)v133 + 64))
                  && ((v136 = (const unsigned __int16 ***)User::GetAccount(v135, (__int64 *)&lpData), !*v136)
                    ? (v137 = 0LL)
                    : (v137 = **v136),
                      Stream = CredStore::ResolveAlias(
                                 (HKEY *)CredStore::g_pCommonStore,
                                 v137,
                                 (User::UserEntry **)&v163),
                      v159 = Stream,
                      _bstr_t::~_bstr_t((_bstr_t *)&lpData),
                      Stream < 0) )
                {
                  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
                    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) != 0
                    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
                  {
                    v138 = User::GetAccount((__int64)v205 + 64, (__int64 *)&v168);
                    v161 |= 0x20u;
                    v139 = (BYTE **)*v138;
                    if ( v139 )
                      lpData = *v139;
                    else
                      lpData = 0LL;
                    v140 = JobMoniker::GetPath((JobMoniker *)&v204);
                    WPP_SF_SSD(
                      *((_QWORD *)WPP_GLOBAL_Control + 2),
                      0x42u,
                      (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids,
                      v140,
                      (__int64)lpData);
                  }
                  if ( (v161 & 0x20) != 0 )
                    _bstr_t::~_bstr_t((_bstr_t *)&v168);
                }
                else
                {
                  RpcAutoImpersonate::RpcAutoImpersonate((RpcAutoImpersonate *)&v167, L"RpcServer::RegisterTask", 1);
                  v141 = (const struct User *)&v179;
                  if ( v168 )
                    v141 = 0LL;
                  Stream = JobStore::HammerAcl(v164, (const struct JobMoniker *)&v204, (const struct User *)&v163, v141);
                  v159 = Stream;
                  if ( Stream < 0
                    && WPP_GLOBAL_Control != &WPP_GLOBAL_Control
                    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) != 0
                    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
                  {
                    v142 = JobMoniker::GetPath((JobMoniker *)&v204);
                    WPP_SF_SD(
                      *((_QWORD *)WPP_GLOBAL_Control + 2),
                      0x43u,
                      (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids,
                      v142);
                  }
                  if ( (_DWORD)v167 )
                    RpcRevertToSelf();
                }
                std::pair<User const,LogonJob *>::~pair<User const,LogonJob *>(&v163);
              }
            }
            else
            {
              if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
                && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) != 0
                && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
              {
                v132 = JobMoniker::GetPath((JobMoniker *)&v204);
                WPP_SF_SD(
                  *((_QWORD *)WPP_GLOBAL_Control + 2),
                  0x41u,
                  (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids,
                  v132);
              }
              if ( (_DWORD)v167 )
                RpcRevertToSelf();
            }
LABEL_453:
            if ( Stream < 0 )
            {
              if ( v158 )
              {
                RpcAutoImpersonate::RpcAutoImpersonate((RpcAutoImpersonate *)&v163, L"RpcServer::RegisterTask", 1);
                v143 = v164;
                JobStore::FileRemoveTaskXml(v164, (const struct JobMoniker *)&v204);
                if ( v163.Data1 )
                  RpcRevertToSelf();
                JobStore::RemoveTaskEntry((HKEY *)v143, (const struct JobMoniker *)&v204);
              }
              else
              {
                TaskXmlFromCollections = JobStore::GenerateTaskXmlFromCollections(
                                           v115,
                                           (__int64)v207,
                                           (Triggers::Trigulator *)v202,
                                           (Actions::ActionCollection *)v195,
                                           (char **)&v186);
                v13 = v186;
                if ( TaskXmlFromCollections >= 0
                  && (int)JobStore::ComputeHash((struct JobMoniker *)v207, (unsigned __int8 *)v186) >= 0 )
                {
                  RpcAutoImpersonate::RpcAutoImpersonate((RpcAutoImpersonate *)&v163, L"RpcServer::RegisterTask", 1);
                  JobStore::XmlSaveTaskFile(v164, (const struct JobMoniker *)v207, v13, StringSecurityDescriptor);
                  if ( v163.Data1 )
                    RpcRevertToSelf();
                }
                JobStore::UpdateTaskEntry(
                  (HKEY *)v164,
                  (const struct JobMoniker *)v207,
                  v145,
                  (const struct Triggers::Trigulator *)v202,
                  (const struct Actions::ActionCollection *)v195,
                  0LL);
              }
              v70 = v160;
              if ( (*(_DWORD *)(v208 + 16) & 0x200000) != 0 )
              {
                if ( !PlugIn::IsRegistering((PlugIn *)&PlugIn::s_singleton, v160, p_Id) )
                  PlugIn::RegisterTask((PlugIn *)&PlugIn::s_singleton, v70, v13, StringSecurityDescriptor, v162, v210);
              }
              else if ( qword_1800B0D30 )
              {
                qword_1800B0D30(v160);
              }
              goto LABEL_245;
            }
LABEL_331:
            if ( ((v165[0] - 0x40000) & 0xFFFBFFFF) == 0 )
            {
              Stream = CredStore::DeleteNtCredential(CredStore::g_pCommonStore, (const struct User *)&v179);
              v159 = Stream;
              if ( Stream < 0 )
              {
                if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
                  && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) != 0
                  && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
                {
                  v105 = JobMoniker::GetPath((JobMoniker *)&v204);
                  WPP_SF_SD(
                    *((_QWORD *)WPP_GLOBAL_Control + 2),
                    0x44u,
                    (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids,
                    v105);
                }
                Stream = 0;
                v159 = 0;
              }
            }
            ReleaseSRWLockExclusive(v85);
            v106 = v158;
            if ( !v158 )
            {
              RpcServer::FlushTriggers((BSTR **)&v204);
              v107 = v208;
              if ( (*(_DWORD *)(v208 + 16) & 0x2000000) != 0 )
                goto LABEL_351;
              if ( (*((_DWORD *)v205 + 4) & 0x2000000) != 0 )
              {
                Stream = RpcServer::FlushTriggers(v207);
                v159 = Stream;
                if ( tsched::IsErrorNotFound((tsched *)(unsigned int)Stream) )
                {
                  Stream = 0;
                  v159 = 0;
                  v108 = 0;
                }
                if ( v108 < 0 )
                {
                  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
                    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) != 0
                    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
                  {
                    v109 = JobMoniker::GetPath((JobMoniker *)&v204);
                    WPP_SF_SD(
                      *((_QWORD *)WPP_GLOBAL_Control + 2),
                      0x45u,
                      (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids,
                      v109);
                  }
                  Stream = 267035;
                  v159 = 267035;
                  v70 = v160;
                  goto LABEL_508;
                }
                v107 = v208;
              }
              if ( (*(_DWORD *)(v107 + 16) & 0x2000000) != 0 )
              {
LABEL_351:
                if ( (*((_DWORD *)v205 + 4) & 0x2000000) == 0 )
                {
                  Stream = (*((__int64 (__fastcall **)(void ***, BSTR **))UbpmProxySingleton::s_singleton[0] + 1))(
                             UbpmProxySingleton::s_singleton,
                             v207);
                  v159 = Stream;
                  if ( tsched::IsErrorNotFound((tsched *)(unsigned int)Stream) )
                  {
                    Stream = 0;
                    v159 = 0;
                    v110 = 0;
                  }
                  if ( v110 < 0 )
                  {
                    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
                      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) != 0
                      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
                    {
                      v111 = JobMoniker::GetPath((JobMoniker *)&v204);
                      WPP_SF_SD(
                        *((_QWORD *)WPP_GLOBAL_Control + 2),
                        0x46u,
                        (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids,
                        v111);
                    }
                    Stream = 267035;
                    v159 = 267035;
                    v70 = v160;
                    goto LABEL_508;
                  }
                }
              }
            }
            v112 = (v162 & 0x20) == 0;
            if ( (*((_DWORD *)v205 + 4) & 0x2000000) != 0 )
            {
              v165[0] = -1;
              lpData = 0LL;
              if ( Triggers::Trigulator::HasTrigger((__int64)v196, 34952) )
              {
                RpcAutoImpersonate::RpcAutoImpersonate((RpcAutoImpersonate *)&v163, L"RpcServer::RegisterTask", 1);
                Stream = User::GetSessionIdForUser(v165, (unsigned __int64 *)&lpData);
                v159 = Stream;
                if ( v163.Data1 )
                  RpcRevertToSelf();
              }
              if ( Stream >= 0 )
              {
                Stream = (*(__int64 (__fastcall **)(void ***, _QWORD, struct _GUID *, _QWORD, struct _FILETIME *, char *, BOOL, unsigned int, BYTE *, unsigned __int16 *))UbpmProxySingleton::s_singleton[0])(
                           UbpmProxySingleton::s_singleton,
                           0LL,
                           &v204,
                           v106,
                           v196,
                           v194,
                           v112,
                           v165[0],
                           lpData,
                           v14);
                v159 = Stream;
              }
              tsched::SecretGuard::Erase(&v191);
              wmi::AutoVectorPtr<unsigned char>::operator=((void **)&v184, 0LL);
            }
            else
            {
              LOBYTE(v206.Data1) = 0;
              *(_QWORD *)v206.Data4 = -1LL;
              *(struct _GUID *)NewDescriptor = v206;
              LOBYTE(v206.Data1) = 0;
              *(_QWORD *)v206.Data4 = 0LL;
              Stream = Triggers::Trigulator::RegisterAll(
                         (Triggers::Trigulator *)v196,
                         (struct JobMoniker *)&v204,
                         (__int128 *)&v206,
                         (__int128 *)NewDescriptor,
                         (v162 & 0x20) == 0);
              if ( Stream == 1 )
                Stream = 0;
              v159 = Stream;
            }
            v70 = v160;
            v146 = v162;
            if ( Stream >= 0 )
            {
              v148 = v180;
              v168 = (unsigned __int16 *)v180;
            }
            else
            {
              if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
                && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) != 0
                && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
              {
                v147 = JobMoniker::GetPath((JobMoniker *)&v204);
                WPP_SF_SD(
                  *((_QWORD *)WPP_GLOBAL_Control + 2),
                  0x47u,
                  (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids,
                  v147);
              }
              v168 = (unsigned __int16 *)v180;
              EventManager::EvtReport(
                v113,
                &TASK_REGISTERED_WITHOUT_SOME_TRIGGERS,
                (const unsigned __int16 *)v180,
                Stream);
              Stream = 267035;
              v148 = (EventManager *)v168;
            }
            v149 = &TASK_DISABLED;
            if ( (v146 & 8) == 0 )
              v149 = &JOB_REGISTERED;
            v150 = (struct _EVENT_DESCRIPTOR *)&TASK_UPDATED;
            if ( (v162 & 4) == 0 )
              v150 = (struct _EVENT_DESCRIPTOR *)v149;
            v181 = v150;
            if ( v158 && &JOB_REGISTERED != v150 )
            {
              EventManager::EvtReport(
                v148,
                &JOB_REGISTERED,
                (const unsigned __int16 *)v148,
                *(const unsigned __int16 **)v169);
              v150 = v181;
            }
            EventManager::EvtReport(v148, v150, v168, *(const unsigned __int16 **)v169);
            v151 = JobMoniker::GetPath((JobMoniker *)&v204);
            if ( v158 )
            {
              Auditor::AuditJobOperation((__int64 *)g_pAuditor, 0, (__int64)v151, (char *)v41);
              if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
                || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) == 0
                || *((_BYTE *)WPP_GLOBAL_Control + 25) < 4u )
              {
                goto LABEL_495;
              }
              v152 = JobMoniker::GetPath((JobMoniker *)&v204);
              v153 = 72;
            }
            else
            {
              Auditor::AuditJobOperation((__int64 *)g_pAuditor, 2, (__int64)v151, (char *)v41);
              if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
                || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) == 0
                || *((_BYTE *)WPP_GLOBAL_Control + 25) < 4u )
              {
                goto LABEL_495;
              }
              v152 = JobMoniker::GetPath((JobMoniker *)&v204);
              v153 = 73;
            }
            WPP_SF_SD(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              v153,
              (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids,
              v152);
LABEL_495:
            if ( v188 )
            {
              v180 = 0LL;
              *v188 = v168;
            }
            if ( (_BYTE)v166 && Stream != 267035 )
              Stream = 267036;
            goto LABEL_508;
          }
          if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
            && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) != 0
            && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
          {
            v128 = JobMoniker::GetPath((JobMoniker *)&v204);
            WPP_SF_SD(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              0x40u,
              (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids,
              v128);
          }
LABEL_368:
          JobSecurity::~JobSecurity((JobSecurity *)NewDescriptor);
          goto LABEL_453;
        }
      }
      v118 = (LPCWSTR *)ATL::CComBSTR::CComBSTR((ATL::CComBSTR *)&v172, v168);
      v119 = 4;
      goto LABEL_378;
    }
  }
  if ( v65 )
    v73 = (const unsigned __int16 *)*((_QWORD *)v65 + 1);
  else
    v73 = 0LL;
  v74 = 2;
  if ( (*((_DWORD *)v66 + 4) & 0x10000) == 0 )
    v74 = 4;
  Stream = RpcServer::ValidatePasswords(v74, (JobBucket *)((char *)v66 + 64), v73);
  if ( Stream >= 0 )
  {
    v58 = (tsched *)v160;
    goto LABEL_212;
  }
  v68 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) == 0 )
    goto LABEL_507;
  v70 = v160;
  if ( *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
  {
    v69 = 49;
    goto LABEL_185;
  }
LABEL_508:
  if ( (unsigned int)dword_1800AFF68 > 4 && tlgKeywordOn((__int64)&dword_1800AFF68, 0LL) )
  {
    v181 = (struct _EVENT_DESCRIPTOR *)p_Id;
    v176 = Stream;
    v182 = v70;
    _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapSz<unsigned short>,_tlgWrapperByVal<4>,_tlgWrapSz<unsigned short>>(
      v154,
      byte_18007F0F2,
      v155,
      v156,
      &v182,
      (__int64)&v176,
      (const WCHAR **)&v181);
  }
  JobMoniker::~JobMoniker((wmi::RefBase **)&v204);
  tsched::SecretGuard::~SecretGuard((tsched::SecretGuard *)&v192);
  ATL::CComBSTR::~CComBSTR(&v183);
  ATL::CComBSTR::~CComBSTR(&v175);
  ATL::CComBSTR::~CComBSTR((BSTR *)&v189);
  Actions::ActionCollection::~ActionCollection((Actions::ActionCollection *)v194);
  Triggers::Trigulator::~Trigulator((Triggers::Trigulator *)v196);
  _bstr_t::~_bstr_t((_bstr_t *)&v190);
  wmi::AutoHandle::~AutoHandle((wmi::AutoHandle *)&TokenHandle);
  tsched::SecretGuard::~SecretGuard((tsched::SecretGuard *)&v191);
  std::_Tree_comp<0,std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::~_Tree_comp<0,std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>((void **)&v184);
  Actions::ActionCollection::~ActionCollection((Actions::ActionCollection *)v195);
  Triggers::Trigulator::~Trigulator((Triggers::Trigulator *)v202);
  JobSecurity::~JobSecurity((JobSecurity *)pSecurityDescriptor);
  JobMoniker::~JobMoniker((wmi::RefBase **)v207);
  std::pair<User const,LogonJob *>::~pair<User const,LogonJob *>(&v179);
  std::_Tree_comp<0,std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::~_Tree_comp<0,std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>((void **)&StringSecurityDescriptor);
  std::_Tree_comp<0,std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::~_Tree_comp<0,std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>((void **)&v186);
  std::_Tree_comp<0,std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::~_Tree_comp<0,std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>((void **)&v180);
  return (unsigned int)Stream;
}
// 18001E9F8: could not find valid save-restore pair for rbp
// 180021402: conditional instruction was optimized away because ebx.4>=0
// 18001EBC7: variable 'v15' is possibly undefined
// 18001F104: variable 'v25' is possibly undefined
// 18001F4E3: variable 'v43' is possibly undefined
// 18001F59D: variable 'v46' is possibly undefined
// 18001F63F: variable 'v51' is possibly undefined
// 18001F7C4: variable 'v59' is possibly undefined
// 18001F7DC: variable 'v61' is possibly undefined
// 18001FAF7: variable 'v76' is possibly undefined
// 18001FC32: variable 'v78' is possibly undefined
// 18001FC9D: variable 'v83' is possibly undefined
// 18001FE0C: variable 'v86' is possibly undefined
// 180020430: variable 'v104' is possibly undefined
// 180020606: variable 'v108' is possibly undefined
// 1800206DA: variable 'v110' is possibly undefined
// 180020890: variable 'v114' is possibly undefined
// 180020A7A: variable 'v123' is possibly undefined
// 180020B7B: variable 'v116' is possibly undefined
// 180020DAD: variable 'v135' is possibly undefined
// 180021013: variable 'v115' is possibly undefined
// 1800210B4: variable 'v145' is possibly undefined
// 180021289: variable 'v113' is possibly undefined
// 180021323: variable 'v148' is possibly undefined
// 1800214C6: variable 'v154' is possibly undefined
// 1800214C6: variable 'v155' is possibly undefined
// 1800214C6: variable 'v156' is possibly undefined
// 180021628: using guessed type __int64 __fastcall std::pair<User const,LogonJob *>::~pair<User const,LogonJob *>(_QWORD);
// 1800567B8: using guessed type __int64 __fastcall wmi::AutoRef<TaskXmlReader>::~AutoRef<TaskXmlReader>(_QWORD);
// 18005698C: using guessed type __int64 __fastcall _com_ptr_t<_com_IIID<IStream,&__s_GUID const _GUID_0000000c_0000_0000_c000_000000000046>>::~_com_ptr_t<_com_IIID<IStream,&__s_GUID const _GUID_0000000c_0000_0000_c000_000000000046>>(_QWORD);
// 18007F0D2: using guessed type unsigned __int8 byte_18007F0D2[32];
// 18007F0F2: using guessed type unsigned __int8 byte_18007F0F2[52];
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 1800AFFB0: using guessed type void **UbpmProxySingleton::s_singleton[2];
// 1800B0CE0: using guessed type _RTL_CRITICAL_SECTION PlugIn::s_singleton;
// 1800B0D30: using guessed type __int64 (__fastcall *qword_1800B0D30)(_QWORD);
// 18001E9F8: using guessed type __int64 var_600[3];

//----- (0000000180021634) ----------------------------------------------------
User::UserEntry **__fastcall User::CreateUser(
        User::UserEntry **a1,
        __int64 **a2,
        const wchar_t ***a3,
        enum _SID_NAME_USE a4,
        struct _RTL_CRITICAL_SECTION *a5)
{
  char v9; // si
  _QWORD *v10; // rdx
  _QWORD *v11; // r8
  BSTR **v12; // r8
  BSTR *v13; // rax
  UINT v14; // eax
  LPCRITICAL_SECTION v15; // rbx
  User::UserEntry **v16; // rax
  User::UserEntry *v17; // rcx
  struct _RTL_CRITICAL_SECTION *v18; // rcx
  WCHAR *v20; // rax
  User::UserEntry *v21; // rdi
  LPCRITICAL_SECTION v22; // rdi
  User::UserEntry **v23; // rax
  User::UserEntry *v24; // rbx
  __int64 *v25; // rax
  UINT v26; // ebx
  const wchar_t **v27; // rax
  UINT v28; // eax
  __int64 v29; // rsi
  char *v30; // rax
  unsigned __int16 *v31; // rbx
  char *v32; // rax
  User::UserEntry *v33; // rax
  User::UserEntry *v34; // rbx
  __int64 v35; // rcx
  __int64 v36; // r8
  __int64 v37; // r9
  __int64 v38; // rcx
  __int64 v39; // r8
  __int64 v40; // r9
  const WCHAR *v41; // [rsp+58h] [rbp-61h] BYREF
  User::UserEntry *v42; // [rsp+60h] [rbp-59h] BYREF
  enum _SID_NAME_USE v43; // [rsp+68h] [rbp-51h] BYREF
  User::UserEntry *v44; // [rsp+70h] [rbp-49h] BYREF
  unsigned __int16 *v45; // [rsp+78h] [rbp-41h] BYREF
  LPCRITICAL_SECTION v46; // [rsp+80h] [rbp-39h] BYREF
  int v47; // [rsp+88h] [rbp-31h]
  const WCHAR *v48; // [rsp+90h] [rbp-29h] BYREF
  const WCHAR *v49[3]; // [rsp+98h] [rbp-21h] BYREF
  char pExceptionObject[56]; // [rsp+B0h] [rbp-9h] BYREF

  v49[1] = (const WCHAR *)-2LL;
  v9 = 0;
  v47 = 0;
  User::User((User *)&v42);
  if ( _bstr_t::operator!(v10) || _bstr_t::operator!(v11) || !a5 )
  {
    wmi::GenericException::GenericException((wmi::GenericException *)pExceptionObject, 87);
    CxxThrowException_0(pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
  }
  v13 = *v12;
  if ( *v12 && *v13 )
    v14 = SysStringLen(*v13);
  else
    v14 = 0;
  if ( v14 )
  {
    v22 = User::s_cs;
    v49[2] = (const WCHAR *)User::s_cs;
    EnterCriticalSection(User::s_cs);
    v23 = User::LookupUser(&v44, a5);
    wmi::AutoRef<User::UserEntry>::operator=(&v42, *v23);
    wmi::AutoRef<User::UserEntry>::Release(&v44);
    v24 = v42;
    if ( v42 )
    {
      v41 = 0LL;
      User::UpdateEntry((void ***)&v42, a2, a3, (const struct _bstr_t *)&v41, a4, a5, 0);
      _bstr_t::_Free((_bstr_t *)&v41);
      *a1 = v24;
      User::UserEntry::AddRef(v24);
    }
    else
    {
      v25 = *a2;
      if ( *a2 && *v25 )
        v26 = SysStringLen((BSTR)*v25);
      else
        v26 = 0;
      v27 = *a3;
      if ( *a3 && *v27 )
        v28 = SysStringLen((BSTR)*v27);
      else
        v28 = 0;
      v29 = v28 + v26 + 1;
      ATL::CComBSTR::CComBSTR((ATL::CComBSTR *)&v45, v28 + v26 + 1);
      ++v29;
      v30 = (char *)_bstr_t::operator unsigned short const *((__int64)a3);
      v31 = v45;
      StringCchCopyW((char *)v45, v29, v30);
      StringCchCatW(v31, v29, (char *)L"\\");
      v32 = (char *)_bstr_t::operator unsigned short const *((__int64)a2);
      StringCchCatW(v31, v29, v32);
      _bstr_t::_bstr_t((_bstr_t *)&v41, v31);
      v45 = 0LL;
      v33 = (User::UserEntry *)operator new(0x30uLL);
      v46 = (LPCRITICAL_SECTION)v33;
      if ( v33 )
        v34 = User::UserEntry::UserEntry(
                v33,
                0,
                (const struct _bstr_t *)a2,
                (const struct _bstr_t *)a3,
                (const struct _bstr_t *)&v41,
                a4,
                a5);
      else
        v34 = 0LL;
      if ( !v34 )
      {
        if ( (unsigned int)dword_1800AFF68 > 2 && tlgKeywordOn((__int64)&dword_1800AFF68, 0LL) )
        {
          v43 = a4;
          v44 = (User::UserEntry *)_bstr_t::operator unsigned short const *((__int64)&v41);
          v49[0] = (const WCHAR *)_bstr_t::operator unsigned short const *((__int64)a2);
          v48 = (const WCHAR *)_bstr_t::operator unsigned short const *((__int64)a3);
          v46 = a5;
          _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapSid<_SID>,_tlgWrapSz<unsigned short>,_tlgWrapSz<unsigned short>,_tlgWrapSz<unsigned short>,_tlgWrapperByVal<4>>(
            v35,
            byte_18007EAC8,
            v36,
            v37,
            (__int64)&v46,
            &v48,
            v49,
            (const WCHAR **)&v44,
            (__int64)&v43);
        }
        wmi::OutOfMemoryException::OutOfMemoryException((wmi::OutOfMemoryException *)pExceptionObject);
        CxxThrowException_0(pExceptionObject, (_ThrowInfo *)&TI4_AVOutOfMemoryException_wmi__);
      }
      v46 = (LPCRITICAL_SECTION)v34;
      User::UserEntry::AddRef(v34);
      *a1 = v34;
      User::UserEntry::AddRef(v34);
      wmi::AutoRef<User::UserEntry>::Release(&v46);
      _bstr_t::_Free((_bstr_t *)&v41);
      SysFreeString(0LL);
    }
    v18 = v22;
  }
  else
  {
    v15 = User::s_cs;
    v46 = User::s_cs;
    EnterCriticalSection(User::s_cs);
    v16 = User::LookupUser((User::UserEntry **)&v45, a5);
    wmi::AutoRef<User::UserEntry>::operator=(&v42, *v16);
    wmi::AutoRef<User::UserEntry>::Release(&v45);
    v17 = v42;
    if ( v42 )
    {
      *a1 = v42;
      User::UserEntry::AddRef(v17);
    }
    else
    {
      v20 = (WCHAR *)operator new(0x30uLL);
      v48 = v20;
      if ( v20 )
      {
        v41 = 0LL;
        v9 = 2;
        v47 = 2;
        v21 = User::UserEntry::UserEntry(
                (User::UserEntry *)v20,
                0,
                (const struct _bstr_t *)a2,
                (const struct _bstr_t *)&v41,
                (const struct _bstr_t *)a2,
                a4,
                a5);
      }
      else
      {
        v21 = 0LL;
      }
      if ( (v9 & 2) != 0 )
        _bstr_t::_Free((_bstr_t *)&v41);
      if ( !v21 )
      {
        if ( (unsigned int)dword_1800AFF68 > 2 && tlgKeywordOn((__int64)&dword_1800AFF68, 0LL) )
        {
          v43 = a4;
          v45 = (unsigned __int16 *)_bstr_t::operator unsigned short const *((__int64)a2);
          v41 = (const WCHAR *)_bstr_t::operator unsigned short const *((__int64)a3);
          v44 = (User::UserEntry *)a5;
          _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapSid<_SID>,_tlgWrapSz<unsigned short>,_tlgWrapSz<unsigned short>,_tlgWrapperByVal<4>>(
            v38,
            byte_18007EB26,
            v39,
            v40,
            (__int64)&v44,
            &v41,
            (const WCHAR **)&v45,
            (__int64)&v43);
        }
        wmi::OutOfMemoryException::OutOfMemoryException((wmi::OutOfMemoryException *)pExceptionObject);
        CxxThrowException_0(pExceptionObject, (_ThrowInfo *)&TI4_AVOutOfMemoryException_wmi__);
      }
      v44 = v21;
      User::UserEntry::AddRef(v21);
      *a1 = v21;
      User::UserEntry::AddRef(v21);
      wmi::AutoRef<User::UserEntry>::Release(&v44);
    }
    v18 = v15;
  }
  LeaveCriticalSection(v18);
  wmi::AutoRef<User::UserEntry>::Release(&v42);
  return a1;
}
// 180021681: variable 'v10' is possibly undefined
// 180021691: variable 'v11' is possibly undefined
// 1800216AB: variable 'v12' is possibly undefined
// 180021A17: variable 'v35' is possibly undefined
// 180021A17: variable 'v36' is possibly undefined
// 180021A17: variable 'v37' is possibly undefined
// 180021ABD: variable 'v38' is possibly undefined
// 180021ABD: variable 'v39' is possibly undefined
// 180021ABD: variable 'v40' is possibly undefined
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);
// 18007EAC8: using guessed type unsigned __int8 byte_18007EAC8[94];
// 18007EB26: using guessed type unsigned __int8 byte_18007EB26[78];

//----- (0000000180021AE4) ----------------------------------------------------
bool __fastcall _bstr_t::operator!(_QWORD *a1)
{
  return !*a1 || *(_QWORD *)*a1 == 0LL;
}

//----- (0000000180021B04) ----------------------------------------------------
__int64 __fastcall User::UserEntry::AddRef(User::UserEntry *this)
{
  struct _RTL_CRITICAL_SECTION *v1; // rbx
  unsigned int v3; // edi

  v1 = User::s_cs;
  EnterCriticalSection(User::s_cs);
  v3 = *((_DWORD *)this + 11) + 1;
  *((_DWORD *)this + 11) = v3;
  LeaveCriticalSection(v1);
  return v3;
}

//----- (0000000180021B5C) ----------------------------------------------------
User *__fastcall User::User(User *this)
{
  *(_QWORD *)this = 0LL;
  return this;
}

//----- (0000000180021B6C) ----------------------------------------------------
__int64 __fastcall _bstr_t::operator unsigned short const *(__int64 a1)
{
  __int64 result; // rax

  result = 0LL;
  if ( *(_QWORD *)a1 )
    return **(_QWORD **)a1;
  return result;
}

//----- (0000000180021B84) ----------------------------------------------------
__int64 __fastcall User::FromImpersonationToken(struct User *a1, void *a2)
{
  void *v2; // rax
  HANDLE CurrentThread; // rax
  void *v5; // rbx
  _QWORD *v6; // rbx
  __int64 v7; // r14
  ULONG v8; // eax
  WCHAR *v9; // rax
  WCHAR *v10; // rdi
  wchar_t *v11; // rax
  wchar_t *v12; // rsi
  _QWORD *User; // rax
  signed int LastError; // eax
  unsigned int v16; // ebx
  signed int v17; // eax
  signed int v18; // eax
  unsigned int v19; // edi
  signed int v20; // eax
  unsigned int v21; // esi
  void *v22; // [rsp+30h] [rbp-49h] BYREF
  char v23[8]; // [rsp+38h] [rbp-41h] BYREF
  char v24[8]; // [rsp+40h] [rbp-39h] BYREF
  void **pExceptionObject; // [rsp+48h] [rbp-31h] BYREF
  char v26; // [rsp+50h] [rbp-29h]
  const unsigned __int16 *v27; // [rsp+58h] [rbp-21h]
  __int64 v28; // [rsp+60h] [rbp-19h]
  __int64 v29; // [rsp+68h] [rbp-11h]
  int v30; // [rsp+70h] [rbp-9h]
  int v31; // [rsp+74h] [rbp-5h]
  int v32; // [rsp+78h] [rbp-1h]
  char v33[8]; // [rsp+80h] [rbp+7h] BYREF
  __int64 v34; // [rsp+88h] [rbp+Fh]
  _QWORD *v35; // [rsp+90h] [rbp+17h]
  WCHAR *v36; // [rsp+98h] [rbp+1Fh]
  DWORD TokenInformationLength; // [rsp+E8h] [rbp+6Fh] BYREF
  ULONG nSize; // [rsp+F0h] [rbp+77h] BYREF
  void *TokenHandle; // [rsp+F8h] [rbp+7Fh] BYREF

  v34 = -2LL;
  v2 = a2;
  TokenHandle = a2;
  v22 = 0LL;
  if ( !a2 )
  {
    CurrentThread = GetCurrentThread();
    if ( !OpenThreadToken(CurrentThread, 0x20008u, 1, &TokenHandle) )
    {
      LastError = GetLastError();
      v16 = LastError;
      if ( LastError > 0 )
        v16 = (unsigned __int16)LastError | 0x80070000;
      goto LABEL_38;
    }
    v5 = TokenHandle;
    wmi::AutoHandle::Close((wmi::AutoHandle *)&v22);
    v22 = v5;
    v2 = TokenHandle;
  }
  TokenInformationLength = 0;
  if ( !GetTokenInformation(v2, TokenUser, 0LL, 0, &TokenInformationLength) && GetLastError() != 122 )
  {
    v17 = GetLastError();
    if ( v17 > 0 )
      v17 = (unsigned __int16)v17 | 0x80070000;
    v16 = v17;
    goto LABEL_38;
  }
  v6 = operator new(TokenInformationLength);
  v35 = v6;
  if ( !v6 )
  {
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && *((char *)WPP_GLOBAL_Control + 28) < 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 19LL, &WPP_0a02ad6f637a3dce55ae09b3fc909c99_Traceguids);
    }
    v26 = 0;
    v27 = &word_18007630E;
    v28 = 0LL;
    v29 = 0LL;
    v30 = 14;
    v31 = -1;
    v32 = -1;
    pExceptionObject = &wmi::OutOfMemoryException::`vftable';
    CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI4_AVOutOfMemoryException_wmi__);
  }
  if ( !GetTokenInformation(TokenHandle, TokenUser, v6, TokenInformationLength, &TokenInformationLength)
    || (v7 = *v6, nSize = 0, !GetUserNameExW(NameSamCompatible, 0LL, &nSize)) && GetLastError() != 234 )
  {
    v18 = GetLastError();
    v19 = v18;
    if ( v18 > 0 )
      v19 = (unsigned __int16)v18 | 0x80070000;
    operator delete(v6);
    v16 = v19;
    goto LABEL_38;
  }
  v8 = nSize;
  if ( nSize )
  {
    ++nSize;
    v9 = (WCHAR *)operator new(saturated_mul(v8 + 1, 2uLL));
    v10 = v9;
    v36 = v9;
    if ( !v9 )
    {
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && *((char *)WPP_GLOBAL_Control + 28) < 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 20LL, &WPP_0a02ad6f637a3dce55ae09b3fc909c99_Traceguids);
      }
      v26 = 0;
      v27 = &word_18007630E;
      v28 = 0LL;
      v29 = 0LL;
      v30 = 14;
      v31 = -1;
      v32 = -1;
      pExceptionObject = &wmi::OutOfMemoryException::`vftable';
      CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI4_AVOutOfMemoryException_wmi__);
    }
    if ( !GetUserNameExW(NameSamCompatible, v9, &nSize) )
    {
      v20 = GetLastError();
      v21 = v20;
      if ( v20 > 0 )
        v21 = (unsigned __int16)v20 | 0x80070000;
      operator delete(v10);
      operator delete(v6);
      v16 = v21;
      goto LABEL_38;
    }
    v11 = wcschr(v10, 0x5Cu);
    v12 = v11;
    if ( v11 )
    {
      *v11 = 0;
      _bstr_t::_bstr_t((_bstr_t *)v24, v10);
      _bstr_t::_bstr_t((_bstr_t *)v23, v12 + 1);
      User = (_QWORD *)User::CreateUser(v33, v23, v24, 8LL, v7);
      wmi::AutoRef<User::UserEntry>::operator=(a1, *User);
      wmi::AutoRef<User::UserEntry>::Release(v33);
      _bstr_t::_Free((_bstr_t *)v23);
      _bstr_t::_Free((_bstr_t *)v24);
      operator delete(v10);
      operator delete(v6);
      wmi::AutoHandle::Close((wmi::AutoHandle *)&v22);
      return 0LL;
    }
    operator delete(v10);
  }
  operator delete(v6);
  v16 = -2147418113;
LABEL_38:
  wmi::AutoHandle::Close((wmi::AutoHandle *)&v22);
  return v16;
}
// 180006E04: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::operator=(_QWORD, _QWORD);
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);
// 180021634: using guessed type __int64 __fastcall User::CreateUser(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 18004B234: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 180073740: using guessed type void *wmi::OutOfMemoryException::`vftable';
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 180021B84: using guessed type char var_90[8];
// 180021B84: using guessed type char var_98[8];
// 180021B84: using guessed type char var_50[8];

//----- (0000000180021DCC) ----------------------------------------------------
__int64 __fastcall User::FromUsername(User::UserEntry **this, LPCWSTR lpAccountName)
{
  enum _SID_NAME_USE v4; // r8d
  unsigned int v5; // edi
  UINT v7; // edx
  signed int v8; // eax
  signed int LastError; // eax
  enum _SID_NAME_USE peUse; // [rsp+30h] [rbp-50h] BYREF
  PSID Sid; // [rsp+38h] [rbp-48h] BYREF
  LPWSTR ReferencedDomainName; // [rsp+40h] [rbp-40h] BYREF
  void **pExceptionObject; // [rsp+48h] [rbp-38h] BYREF
  char v14; // [rsp+50h] [rbp-30h]
  const unsigned __int16 *v15; // [rsp+58h] [rbp-28h]
  __int64 v16; // [rsp+60h] [rbp-20h]
  int v17; // [rsp+68h] [rbp-18h]
  int v18; // [rsp+6Ch] [rbp-14h]
  int v19; // [rsp+70h] [rbp-10h]
  int v20; // [rsp+74h] [rbp-Ch]
  int v21; // [rsp+78h] [rbp-8h]
  DWORD cchReferencedDomainName; // [rsp+A0h] [rbp+20h] BYREF
  DWORD cbSid; // [rsp+A8h] [rbp+28h] BYREF

  cchReferencedDomainName = 0;
  cbSid = 0;
  Sid = 0LL;
  peUse = SidTypeUnknown;
  if ( ConvertStringSidToSidW(lpAccountName, &Sid) )
  {
    v4 = SidTypeUnknown;
LABEL_3:
    v5 = User::FromSid(this, Sid, v4);
    goto LABEL_4;
  }
  LookupAccountNameLocalW(lpAccountName, 0LL, &cbSid, 0LL, &cchReferencedDomainName, &peUse);
  if ( GetLastError() == 122 )
  {
    Sid = LocalAlloc(0, cbSid + 1);
    if ( !Sid )
    {
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && *((char *)WPP_GLOBAL_Control + 28) < 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x15u, (__int64)&WPP_0a02ad6f637a3dce55ae09b3fc909c99_Traceguids);
      }
      v16 = 0LL;
      v17 = 0;
      v18 = 0;
      v20 = -1;
      v21 = -1;
      v15 = &word_18007630E;
      pExceptionObject = &wmi::OutOfMemoryException::`vftable';
      v14 = 0;
      v19 = 14;
      CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI4_AVOutOfMemoryException_wmi__);
    }
    v7 = cchReferencedDomainName++;
    ATL::CComBSTR::CComBSTR((ATL::CComBSTR *)&ReferencedDomainName, v7);
    if ( LookupAccountNameLocalW(lpAccountName, Sid, &cbSid, ReferencedDomainName, &cchReferencedDomainName, &peUse) )
    {
      SysFreeString(ReferencedDomainName);
      v4 = peUse;
      if ( peUse > 0 && peUse != SidTypeDomain && peUse < SidTypeDeletedAccount )
        goto LABEL_3;
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && *((char *)WPP_GLOBAL_Control + 28) < 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x16u, (__int64)&WPP_0a02ad6f637a3dce55ae09b3fc909c99_Traceguids);
      }
      v5 = -2147024809;
    }
    else
    {
      LastError = GetLastError();
      v5 = LastError;
      if ( LastError > 0 )
        v5 = (unsigned __int16)LastError | 0x80070000;
      SysFreeString(ReferencedDomainName);
    }
  }
  else
  {
    v8 = GetLastError();
    v5 = v8;
    if ( v8 > 0 )
      v5 = (unsigned __int16)v8 | 0x80070000;
  }
LABEL_4:
  if ( Sid )
    LocalFree(Sid);
  return v5;
}
// 180073740: using guessed type void *wmi::OutOfMemoryException::`vftable';
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180021F38) ----------------------------------------------------
__int64 __fastcall User::FromSid(User::UserEntry **this, void *a2, enum _SID_NAME_USE a3)
{
  char v6; // di
  struct _RTL_CRITICAL_SECTION *v7; // rbx
  User::UserEntry **v8; // rax
  User::UserEntry *v10; // rax
  User::UserEntry *v11; // rsi
  unsigned int updated; // edi
  __int64 v13; // [rsp+48h] [rbp-29h] BYREF
  __int64 v14; // [rsp+50h] [rbp-21h] BYREF
  void **pExceptionObject; // [rsp+58h] [rbp-19h] BYREF
  char v16; // [rsp+60h] [rbp-11h]
  const unsigned __int16 *v17; // [rsp+68h] [rbp-9h]
  __int64 v18; // [rsp+70h] [rbp-1h]
  __int64 v19; // [rsp+78h] [rbp+7h]
  int v20; // [rsp+80h] [rbp+Fh]
  int v21; // [rsp+84h] [rbp+13h]
  int v22; // [rsp+88h] [rbp+17h]
  __int64 v23; // [rsp+90h] [rbp+1Fh]
  LPCRITICAL_SECTION v24; // [rsp+98h] [rbp+27h]
  User::UserEntry *v25; // [rsp+A0h] [rbp+2Fh]
  __int64 *v26; // [rsp+E0h] [rbp+6Fh] BYREF
  const wchar_t **v27; // [rsp+F0h] [rbp+7Fh] BYREF

  v23 = -2LL;
  v6 = 0;
  LODWORD(v26) = 0;
  if ( !a2 )
    return 2147942487LL;
  v7 = User::s_cs;
  v24 = User::s_cs;
  EnterCriticalSection(User::s_cs);
  v8 = User::LookupUser((User::UserEntry **)&v26, a2);
  wmi::AutoRef<User::UserEntry>::operator=(this, *v8);
  wmi::AutoRef<User::UserEntry>::Release(&v26);
  if ( *this )
  {
    v13 = 0LL;
    v27 = 0LL;
    v26 = 0LL;
    User::UpdateEntry((void ***)this, &v26, &v27, (const struct _bstr_t *)&v13, a3, 0LL, 0);
    _bstr_t::_Free((_bstr_t *)&v26);
    _bstr_t::_Free((_bstr_t *)&v27);
    _bstr_t::_Free((_bstr_t *)&v13);
    LeaveCriticalSection(v7);
    return 0LL;
  }
  else
  {
    v10 = (User::UserEntry *)operator new(0x30uLL);
    v25 = v10;
    if ( v10 )
    {
      v14 = 0LL;
      v13 = 0LL;
      v27 = 0LL;
      v6 = 7;
      LODWORD(v26) = 7;
      v11 = User::UserEntry::UserEntry(
              v10,
              0,
              (const struct _bstr_t *)&v27,
              (const struct _bstr_t *)&v13,
              (const struct _bstr_t *)&v14,
              a3,
              a2);
    }
    else
    {
      v11 = 0LL;
    }
    if ( (v6 & 4) != 0 )
    {
      v6 &= ~4u;
      _bstr_t::_Free((_bstr_t *)&v27);
    }
    if ( (v6 & 2) != 0 )
    {
      v6 &= ~2u;
      _bstr_t::_Free((_bstr_t *)&v13);
    }
    if ( (v6 & 1) != 0 )
      _bstr_t::_Free((_bstr_t *)&v14);
    if ( !v11 )
    {
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && *((char *)WPP_GLOBAL_Control + 28) < 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x17u, (__int64)&WPP_0a02ad6f637a3dce55ae09b3fc909c99_Traceguids);
      }
      v16 = 0;
      v17 = &word_18007630E;
      v18 = 0LL;
      v19 = 0LL;
      v20 = 14;
      v21 = -1;
      v22 = -1;
      pExceptionObject = &wmi::OutOfMemoryException::`vftable';
      CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI4_AVOutOfMemoryException_wmi__);
    }
    wmi::AutoRef<User::UserEntry>::operator=(this, v11);
    updated = User::UpdateEntry((User *)this);
    LeaveCriticalSection(v7);
    return updated;
  }
}
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);
// 180073740: using guessed type void *wmi::OutOfMemoryException::`vftable';
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180022100) ----------------------------------------------------
void __fastcall User::UpdateEntry(
        void ***this,
        __int64 **a2,
        const wchar_t ***a3,
        const struct _bstr_t *a4,
        enum _SID_NAME_USE a5,
        void *a6,
        bool a7)
{
  char *v11; // rsi
  struct _RTL_CRITICAL_SECTION *v12; // rdi
  __int64 *v13; // rcx
  _QWORD *v15; // rax
  const wchar_t *v17; // rdx
  const wchar_t *v18; // rcx
  const wchar_t **v19; // rdx
  const wchar_t *v20; // rax
  const wchar_t **v21; // rcx
  const wchar_t *v22; // rax
  const wchar_t *v23; // rax
  const wchar_t *v24; // rcx
  char v25; // bl
  __int64 v26; // rcx
  __int64 *v27; // rcx
  const wchar_t *v29; // rcx
  __int64 *v30; // rcx
  __int64 v32; // rcx
  __int64 *v33; // rcx
  __int64 v34; // rax
  BSTR *v35; // rax
  UINT v36; // ebx
  BSTR *v37; // rax
  UINT v38; // eax
  __int64 v39; // rbp
  __int64 v40; // rbp
  char *v41; // r8
  unsigned __int16 *v42; // rbx
  unsigned __int16 *v43[4]; // [rsp+20h] [rbp-48h] BYREF
  __int64 v44; // [rsp+70h] [rbp+8h] BYREF

  v43[1] = (unsigned __int16 *)-2LL;
  v11 = 0LL;
  if ( *this )
  {
    v12 = User::s_cs;
    v43[2] = (unsigned __int16 *)User::s_cs;
    EnterCriticalSection(User::s_cs);
    if ( a6 && !(*this)[4] )
      User::UserEntry::CopySid(*this, a6);
    if ( a7 || (unsigned int)(*((_DWORD *)*this + 10) - 4) <= 1 )
      goto LABEL_38;
    v13 = *a2;
    if ( *a2 ? *v13 : 0LL )
    {
      v15 = (*this)[2];
      if ( v15 ? *v15 : 0LL )
      {
        v17 = v15 ? (const wchar_t *)*v15 : 0LL;
        v18 = v13 ? (const wchar_t *)*v13 : 0LL;
        if ( _wcsicmp(v18, v17) )
          goto LABEL_37;
      }
    }
    v19 = *a3;
    v20 = *a3 ? *v19 : 0LL;
    if ( v20
      && ((v21 = (const wchar_t **)(*this)[3]) == 0LL ? (v22 = 0LL) : (v22 = *v21),
          v22 && (!v21 ? (v23 = 0LL) : (v23 = *v21), !v19 ? (v24 = 0LL) : (v24 = *v19), _wcsicmp(v24, v23))) )
    {
LABEL_37:
      _bstr_t::operator=((_bstr_t::Data_t **)*this + 1, 0LL);
      _bstr_t::operator=((_bstr_t::Data_t **)*this + 2, 0LL);
      _bstr_t::operator=((_bstr_t::Data_t **)*this + 3, 0LL);
      User::UpdateEntry((User *)this);
    }
    else
    {
LABEL_38:
      v25 = 0;
      if ( *a2 )
        v26 = **a2;
      else
        v26 = 0LL;
      if ( v26 )
      {
        v27 = (__int64 *)(*this + 2);
        if ( !(*v27 ? *(_QWORD *)*v27 : 0LL) )
        {
          v25 = 1;
          _bstr_t::operator=(v27, (__int64 *)a2);
        }
      }
      if ( *a3 )
        v29 = **a3;
      else
        v29 = 0LL;
      if ( v29 )
      {
        v30 = (__int64 *)(*this + 3);
        if ( !(*v30 ? *(_QWORD *)*v30 : 0LL) )
        {
          v25 = 1;
          _bstr_t::operator=(v30, (__int64 *)a3);
        }
      }
      if ( *(_QWORD *)a4 )
        v32 = **(_QWORD **)a4;
      else
        v32 = 0LL;
      if ( !v32 || ((v33 = (__int64 *)(*this + 1), !*v33) ? (v34 = 0LL) : (v34 = *(_QWORD *)*v33), v34) )
      {
        if ( v25 )
        {
          v35 = (BSTR *)*a2;
          if ( *a2 && *v35 )
            v36 = SysStringLen(*v35);
          else
            v36 = 0;
          v37 = (BSTR *)*a3;
          if ( *a3 && *v37 )
            v38 = SysStringLen(*v37);
          else
            v38 = 0;
          v39 = v36 + v38 + 1;
          ATL::CComBSTR::CComBSTR((ATL::CComBSTR *)v43, v36 + v38 + 1);
          v40 = v39 + 1;
          if ( *a3 )
            v41 = (char *)**a3;
          else
            v41 = 0LL;
          v42 = v43[0];
          StringCchCopyW((char *)v43[0], v40, v41);
          StringCchCatW(v42, v40, (char *)L"\\");
          if ( *a2 )
            v11 = (char *)**a2;
          StringCchCatW(v42, v40, v11);
          _bstr_t::_bstr_t((_bstr_t *)&v44, v42);
          _bstr_t::operator=((__int64 *)*this + 1, &v44);
          _bstr_t::_Free((_bstr_t *)&v44);
          SysFreeString(0LL);
        }
      }
      else
      {
        _bstr_t::operator=(v33, (__int64 *)a4);
      }
      if ( a5 != SidTypeUnknown )
        *((_DWORD *)*this + 10) = a5;
    }
    LeaveCriticalSection(v12);
  }
}

//----- (0000000180022454) ----------------------------------------------------
__int64 __fastcall Triggers::SessionBasedTrigger::ResolveUPN(Triggers::SessionBasedTrigger *this)
{
  const wchar_t *v1; // rdi
  int v2; // esi
  User::UserEntry **v3; // rbp
  const wchar_t **v5; // rbx
  const wchar_t *v6; // rcx
  const wchar_t *v7; // rcx
  const WCHAR *v8; // rdx
  const wchar_t **v9; // [rsp+50h] [rbp+8h] BYREF

  v1 = 0LL;
  v2 = 0;
  v3 = (User::UserEntry **)((char *)this + 88);
  if ( *((_QWORD *)this + 11) )
  {
    User::GetDomainAccount((Triggers::SessionBasedTrigger *)((char *)this + 88), (__int64 *)&v9);
    if ( !_bstr_t::operator!(&v9) )
    {
      v5 = v9;
      v6 = v9 ? *v9 : 0LL;
      if ( !wcschr(v6, 0x5Cu) )
      {
        v7 = v5 ? *v5 : 0LL;
        if ( wcschr(v7, 0x40u) )
        {
          v8 = v5 ? *v5 : 0LL;
          v2 = User::FromUsername(v3, v8);
          if ( v2 < 0
            && WPP_GLOBAL_Control != &WPP_GLOBAL_Control
            && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) != 0
            && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
          {
            if ( v5 )
              v1 = *v5;
            WPP_SF_SD(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              0x17u,
              (__int64)&WPP_9c6330531b9f37c0b720c7be8cd79119_Traceguids,
              v1);
          }
        }
      }
    }
    _bstr_t::_Free((_bstr_t *)&v9);
  }
  return (unsigned int)v2;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (00000001800224AC) ----------------------------------------------------
User::UserEntry *__fastcall User::UserEntry::UserEntry(
        User::UserEntry *this,
        char a2,
        const struct _bstr_t *a3,
        const struct _bstr_t *a4,
        const struct _bstr_t *a5,
        enum _SID_NAME_USE a6,
        void *a7)
{
  __int64 v8; // rcx
  char v9; // bp
  __int64 v10; // rax
  __int64 v11; // rax
  struct _RTL_CRITICAL_SECTION *v12; // rbx
  __int64 *v13; // rdi
  const struct _bstr_t **v14; // rcx
  __int64 v16; // rax
  __int64 v17; // rbp

  *(_BYTE *)this = a2;
  v8 = *(_QWORD *)a5;
  *((_QWORD *)this + 1) = *(_QWORD *)a5;
  v9 = 1;
  if ( v8 )
    _InterlockedAdd((volatile signed __int32 *)(v8 + 16), 1u);
  v10 = *(_QWORD *)a3;
  *((_QWORD *)this + 2) = *(_QWORD *)a3;
  if ( v10 )
    _InterlockedAdd((volatile signed __int32 *)(v10 + 16), 1u);
  v11 = *(_QWORD *)a4;
  *((_QWORD *)this + 3) = *(_QWORD *)a4;
  if ( v11 )
    _InterlockedAdd((volatile signed __int32 *)(v11 + 16), 1u);
  *((_QWORD *)this + 4) = 0LL;
  *((_DWORD *)this + 10) = a6;
  *((_DWORD *)this + 11) = 0;
  User::UserEntry::CopySid((void **)this, a7);
  v12 = User::s_cs;
  EnterCriticalSection(User::s_cs);
  a5 = this;
  v13 = (__int64 *)User::s_userTable;
  v14 = (const struct _bstr_t **)*((_QWORD *)User::s_userTable + 1);
  if ( &a5 >= v14 || *(_QWORD *)User::s_userTable > (unsigned __int64)&a5 )
    v9 = 0;
  if ( v9 )
  {
    v16 = *(_QWORD *)User::s_userTable;
    v17 = ((__int64)&a5 - *(_QWORD *)User::s_userTable) >> 3;
    if ( v14 == *((const struct _bstr_t ***)User::s_userTable + 2) )
    {
      std::vector<ServerXMLUpdateHandler::ISubHandler *>::_Reserve(User::s_userTable);
      v16 = *v13;
      v14 = (const struct _bstr_t **)v13[1];
    }
    *v14 = *(const struct _bstr_t **)(v16 + 8 * v17);
  }
  else
  {
    if ( v14 == *((const struct _bstr_t ***)User::s_userTable + 2) )
    {
      std::vector<ServerXMLUpdateHandler::ISubHandler *>::_Reserve(User::s_userTable);
      v14 = (const struct _bstr_t **)v13[1];
    }
    *v14 = this;
  }
  v13[1] += 8LL;
  LeaveCriticalSection(v12);
  return this;
}

//----- (00000001800225AC) ----------------------------------------------------
void __fastcall User::UserEntry::CopySid(void **this, void *a2)
{
  DWORD LengthSid; // esi
  void *v5; // rax
  void *v6; // rdx
  int LastError; // ebx
  void **pExceptionObject; // [rsp+20h] [rbp-40h] BYREF
  char v9; // [rsp+28h] [rbp-38h]
  const unsigned __int16 *v10; // [rsp+30h] [rbp-30h]
  __int64 v11; // [rsp+38h] [rbp-28h]
  int v12; // [rsp+40h] [rbp-20h]
  int v13; // [rsp+44h] [rbp-1Ch]
  int v14; // [rsp+48h] [rbp-18h]
  int v15; // [rsp+4Ch] [rbp-14h]
  int v16; // [rsp+50h] [rbp-10h]

  if ( a2 )
  {
    LengthSid = GetLengthSid(a2);
    v5 = operator new(LengthSid);
    wmi::AutoVectorPtr<unsigned char>::operator=(this + 4, v5);
    v6 = this[4];
    if ( !v6 )
    {
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && *((char *)WPP_GLOBAL_Control + 28) < 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x11u, (__int64)&WPP_0a02ad6f637a3dce55ae09b3fc909c99_Traceguids);
      }
      v11 = 0LL;
      v12 = 0;
      v13 = 0;
      v15 = -1;
      v16 = -1;
      v10 = &word_18007630E;
      pExceptionObject = &wmi::OutOfMemoryException::`vftable';
      v9 = 0;
      v14 = 14;
      CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI4_AVOutOfMemoryException_wmi__);
    }
    if ( !CopySid(LengthSid, v6, a2) )
    {
      LastError = GetLastError();
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && *((char *)WPP_GLOBAL_Control + 28) < 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        WPP_SF_D(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x12u,
          (__int64)&WPP_0a02ad6f637a3dce55ae09b3fc909c99_Traceguids,
          LastError);
      }
      v11 = 0LL;
      v12 = 0;
      v13 = 0;
      v15 = -1;
      v16 = -1;
      pExceptionObject = &wmi::GenericException::`vftable';
      v10 = &word_18007630E;
      v9 = 0;
      v14 = LastError;
      CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
    }
  }
}
// 1800716D8: using guessed type void *wmi::GenericException::`vftable';
// 180073740: using guessed type void *wmi::OutOfMemoryException::`vftable';
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180022638) ----------------------------------------------------
ATL::CComBSTR *__fastcall ATL::CComBSTR::CComBSTR(ATL::CComBSTR *this, UINT a2)
{
  BSTR v3; // rax

  if ( a2 )
  {
    v3 = SysAllocStringLen(0LL, a2);
    *(_QWORD *)this = v3;
    if ( !v3 )
      ATL::PrivateAtlThrow(-2147024882);
  }
  else
  {
    *(_QWORD *)this = 0LL;
  }
  return this;
}

//----- (0000000180022678) ----------------------------------------------------
__int64 __fastcall EventManager::EvtReport(
        EventManager *this,
        const struct _EVENT_DESCRIPTOR *a2,
        const unsigned __int16 *a3,
        const unsigned __int16 *a4)
{
  EventManager *v4; // rdi
  int v9; // eax
  EventManager *v10; // rcx
  int v11; // ebx
  struct _EVENT_DATA_DESCRIPTOR v12; // [rsp+20h] [rbp-48h] BYREF
  struct _EVENT_DATA_DESCRIPTOR v13; // [rsp+30h] [rbp-38h] BYREF

  v4 = g_pEventManager;
  if ( !*(_QWORD *)g_pEventManager )
    return 1LL;
  if ( !(unsigned __int8)EtwEventEnabled() )
    return 0LL;
  CreateDataDescriptor(&v12, a3);
  CreateDataDescriptor(&v13, a4);
  v9 = EtwEventWrite(*(_QWORD *)v4, a2, 2LL, &v12);
  v11 = v9;
  if ( !v9 )
    return 0LL;
  EventManager::LogIt(v10, L"EventWrite error", v9);
  if ( v11 > 0 )
    return (unsigned __int16)v11 | 0x80070000;
  return (unsigned int)v11;
}
// 180048BE9: variable 'v10' is possibly undefined
// 1800746B8: using guessed type __int64 EtwEventEnabled(void);
// 180074768: using guessed type __int64 __fastcall EtwEventWrite(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001800226EC) ----------------------------------------------------
void __fastcall tsched::SecretGuard::Erase(void **this)
{
  _WORD *v1; // rdi
  __int64 v3; // rcx

  v1 = *this;
  if ( *this )
  {
    v3 = -1LL;
    do
      ++v3;
    while ( v1[v3] );
    memset(v1, 0, 2 * v3);
    *this = 0LL;
  }
}

//----- (0000000180022718) ----------------------------------------------------
__int64 __fastcall RpcServer::FlushTriggers(BSTR **a1)
{
  int v2; // eax
  PseudoEventTrap *v3; // rcx
  unsigned int v4; // edi
  int v5; // eax
  PseudoEventTrap *v6; // rcx
  int v7; // eax
  PseudoEventTrap *v8; // rcx
  int v9; // eax
  int v10; // eax

  v2 = Scheduler::DeleteJobSchedule(g_pScheduler, a1);
  v4 = 0;
  if ( v2 < 0 )
    v4 = v2;
  v5 = PseudoEventTrap::UnregisterIdleJob(v3, a1);
  if ( v5 < 0 )
    v4 = v5;
  v7 = PseudoEventTrap::UnregisterLogonJob(v6, a1);
  if ( v7 < 0 )
    v4 = v7;
  v9 = PseudoEventTrap::UnregisterSessionChangeJob(v8, a1);
  if ( v9 < 0 )
    v4 = v9;
  v10 = (*(__int64 (__fastcall **)(EventTrapMap *, BSTR **))(*(_QWORD *)g_pEventTrapMap + 8LL))(g_pEventTrapMap, a1);
  if ( v10 < 0 )
    return (unsigned int)v10;
  return v4;
}
// 18002273E: variable 'v3' is possibly undefined
// 18002274B: variable 'v6' is possibly undefined
// 180022758: variable 'v8' is possibly undefined

//----- (0000000180022794) ----------------------------------------------------
__int64 __fastcall PseudoEventTrap::UnregisterSessionChangeJob(PseudoEventTrap *this, BSTR **a2)
{
  PseudoEventTrap *v3; // rbx
  unsigned int v4; // ebp
  struct _RTL_CRITICAL_SECTION *v5; // rdi
  const wchar_t *Path; // rax
  _QWORD *v8; // r14
  _QWORD *v9; // rbx
  LogonJob *v10; // rcx
  __int64 v11; // rcx
  __int64 i; // rcx
  __int64 *v13; // [rsp+60h] [rbp+18h] BYREF

  v3 = g_pPseudoEventTrap;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
  {
    Path = JobMoniker::GetPath((JobMoniker *)a2);
    WPP_SF_S(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x1Bu,
      (__int64)&WPP_c0b0770bd08e382a040e2237764c2feb_Traceguids,
      Path);
  }
  v4 = 1;
  v5 = (struct _RTL_CRITICAL_SECTION *)((char *)v3 + 160);
  EnterCriticalSection((LPCRITICAL_SECTION)v3 + 4);
  if ( *((_QWORD *)v3 + 26) )
  {
    v8 = (_QWORD *)((char *)v3 + 200);
    v9 = (_QWORD *)**((_QWORD **)v3 + 25);
    do
    {
      if ( (unsigned int)_bstr_t::_Compare((BSTR **)(v9[5] + 16LL), a2 + 2) )
      {
        if ( !*((_BYTE *)v9 + 25) )
        {
          v11 = v9[2];
          if ( *(_BYTE *)(v11 + 25) )
          {
            for ( i = v9[1]; !*(_BYTE *)(i + 25) && v9 == *(_QWORD **)(i + 16); i = *(_QWORD *)(i + 8) )
              v9 = (_QWORD *)i;
            v9 = (_QWORD *)i;
          }
          else
          {
            v9 = std::_Tree_val<std::_Tree_simple_types<std::pair<_bstr_t const,std::list<_FILETIME> *>>>::_Min((_QWORD *)v11);
          }
        }
      }
      else
      {
        v10 = (LogonJob *)v9[5];
        if ( v10 )
          LogonJob::`scalar deleting destructor'(v10);
        v9 = *std::_Tree<std::_Tmap_traits<User,LogonJob *,User::less,std::allocator<std::pair<User const,LogonJob *>>,1>>::erase(
                v8,
                &v13,
                v9);
        v4 = 0;
      }
    }
    while ( v9 != (_QWORD *)*v8 );
  }
  LeaveCriticalSection(v5);
  return v4;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180022838) ----------------------------------------------------
__int64 __fastcall PseudoEventTrap::UnregisterLogonJob(PseudoEventTrap *this, BSTR **a2)
{
  PseudoEventTrap *v3; // rsi
  unsigned int v4; // r15d
  const wchar_t *Path; // rax
  _QWORD *v7; // rbx
  LogonJob *v8; // rcx
  __int64 v9; // rcx
  __int64 i; // rcx
  __int64 *v11; // [rsp+70h] [rbp+18h] BYREF

  v3 = g_pPseudoEventTrap;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
  {
    Path = JobMoniker::GetPath((JobMoniker *)a2);
    WPP_SF_S(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x14u,
      (__int64)&WPP_c0b0770bd08e382a040e2237764c2feb_Traceguids,
      Path);
  }
  v4 = 1;
  EnterCriticalSection((LPCRITICAL_SECTION)((char *)v3 + 96));
  if ( *((_QWORD *)v3 + 19) )
  {
    v7 = (_QWORD *)**((_QWORD **)v3 + 18);
    do
    {
      if ( (unsigned int)_bstr_t::_Compare((BSTR **)(v7[5] + 16LL), a2 + 2) )
      {
        if ( !*((_BYTE *)v7 + 25) )
        {
          v9 = v7[2];
          if ( *(_BYTE *)(v9 + 25) )
          {
            for ( i = v7[1]; !*(_BYTE *)(i + 25) && v7 == *(_QWORD **)(i + 16); i = *(_QWORD *)(i + 8) )
              v7 = (_QWORD *)i;
            v7 = (_QWORD *)i;
          }
          else
          {
            v7 = std::_Tree_val<std::_Tree_simple_types<std::pair<_bstr_t const,std::list<_FILETIME> *>>>::_Min((_QWORD *)v9);
          }
        }
      }
      else
      {
        v8 = (LogonJob *)v7[5];
        if ( v8 )
          LogonJob::`scalar deleting destructor'(v8);
        v7 = *std::_Tree<std::_Tmap_traits<User,LogonJob *,User::less,std::allocator<std::pair<User const,LogonJob *>>,1>>::erase(
                (_QWORD *)v3 + 18,
                &v11,
                v7);
        --*((_DWORD *)v3 + 34);
        v4 = 0;
      }
    }
    while ( v7 != *((_QWORD **)v3 + 18) );
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)((char *)v3 + 96));
  return v4;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (00000001800228D8) ----------------------------------------------------
__int64 __fastcall PseudoEventTrap::UnregisterIdleJob(PseudoEventTrap *this, BSTR **a2)
{
  PseudoEventTrap *v2; // rsi
  unsigned int v4; // r15d
  const wchar_t *Path; // rax
  __int64 *v7; // rbx
  BSTR **v8; // rbp
  __int64 *v9; // rbx
  BSTR **v10; // rbp
  PseudoEventTrap *v11; // [rsp+50h] [rbp+8h] BYREF

  v11 = this;
  v2 = g_pPseudoEventTrap;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
  {
    Path = JobMoniker::GetPath((JobMoniker *)a2);
    WPP_SF_S(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x10u,
      (__int64)&WPP_c0b0770bd08e382a040e2237764c2feb_Traceguids,
      Path);
  }
  v4 = 1;
  EnterCriticalSection((LPCRITICAL_SECTION)((char *)v2 + 8));
  if ( *((_QWORD *)v2 + 7) )
  {
    v7 = (__int64 *)*((_QWORD *)v2 + 6);
    while ( 1 )
    {
      v7 = (__int64 *)*v7;
      if ( v7 == *((__int64 **)v2 + 6) )
        break;
      v8 = (BSTR **)v7[2];
      if ( !(unsigned int)_bstr_t::_Compare(v8 + 2, a2 + 2) )
      {
        v4 = 0;
        std::list<IdleJob *>::erase((__int64 **)v2 + 6, &v11, v7);
        if ( v8 )
          LogonJob::`scalar deleting destructor'((LogonJob *)v8);
        --*((_DWORD *)v2 + 22);
        break;
      }
    }
  }
  if ( *((_QWORD *)v2 + 9) )
  {
    v9 = (__int64 *)*((_QWORD *)v2 + 8);
    while ( 1 )
    {
      v9 = (__int64 *)*v9;
      if ( v9 == *((__int64 **)v2 + 8) )
        break;
      v10 = (BSTR **)v9[2];
      if ( !(unsigned int)_bstr_t::_Compare(v10 + 2, a2 + 2) )
      {
        v4 = 0;
        std::list<IdleJob *>::erase((__int64 **)v2 + 8, &v11, v9);
        if ( v10 )
          LogonJob::`scalar deleting destructor'((LogonJob *)v10);
        --*((_DWORD *)v2 + 22);
        break;
      }
    }
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)((char *)v2 + 8));
  return v4;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018002297C) ----------------------------------------------------
__int64 __fastcall Scheduler::DeleteJobSchedule(Scheduler *this, BSTR **a2)
{
  struct _RTL_CRITICAL_SECTION *v2; // rbx
  unsigned int v5; // esi
  __int64 v6; // rdi
  __int64 i; // rdi
  FILETIME *v8; // rbp
  const wchar_t *Path; // rax
  __int64 v11; // r15
  const wchar_t *v12; // rax
  __int64 v13; // rbp
  JobStore *v14; // rdi
  const wchar_t *v15; // rax
  signed int LastError; // eax
  FILETIME FileTime1; // [rsp+60h] [rbp+8h] BYREF

  v2 = (struct _RTL_CRITICAL_SECTION *)((char *)this + 32);
  v5 = 0;
  EnterCriticalSection((LPCRITICAL_SECTION)((char *)this + 32));
  v6 = *((_QWORD *)this + 41);
  if ( (Scheduler *)v6 == (Scheduler *)((char *)this + 320) )
  {
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x2000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
    {
      Path = JobMoniker::GetPath((JobMoniker *)a2);
      WPP_SF_S(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x13u,
        (__int64)&WPP_5435fee58aaf3c352ed5cdc6abf88a31_Traceguids,
        Path);
    }
  }
  else if ( v6 )
  {
    do
    {
      if ( (Scheduler *)v6 == (Scheduler *)((char *)this + 320) )
        break;
      v11 = *(_QWORD *)(v6 + 8);
      if ( !(unsigned int)_bstr_t::_Compare((BSTR **)(v6 + 40), a2 + 2) )
      {
        if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
          && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x2000) != 0
          && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 5u )
        {
          v12 = JobMoniker::GetPath((JobMoniker *)a2);
          WPP_SF_Sq(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x14u,
            (__int64)&WPP_5435fee58aaf3c352ed5cdc6abf88a31_Traceguids,
            v12);
        }
        ScheduleListItem::Delete((ScheduleListItem *)v6);
      }
      v6 = v11;
    }
    while ( v11 );
    v2 = (struct _RTL_CRITICAL_SECTION *)((char *)this + 32);
  }
  for ( i = *((_QWORD *)this + 10); *(_DWORD *)(i + 24) || *(_DWORD *)(i + 28); i = v13 )
  {
    v13 = *(_QWORD *)(i + 8);
    if ( !(unsigned int)_bstr_t::_Compare((BSTR **)(i + 56), a2 + 2) )
      SortedRunListItem::Delete((SortedRunListItem *)i);
  }
  v8 = (FILETIME *)*((_QWORD *)this + 10);
  FileTime1 = (FILETIME)-1LL;
  if ( v8[3].dwLowDateTime || v8[3].dwHighDateTime )
    FileTime1 = v8[3];
  if ( CompareFileTime(&FileTime1, (const FILETIME *)this + 21) > 0 )
  {
    v14 = JobStore::m_pCommonStore;
    JobStore::WaitForConfiguration(JobStore::m_pCommonStore);
    if ( *(_DWORD *)(*((_QWORD *)v14 + 10) + 136LL) > 9u )
      TraceTime("DeleteJobSchedule, nextRun:", &FileTime1, (const struct JobMoniker *)&v8[5]);
    *((FILETIME *)this + 21) = FileTime1;
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x2000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
    {
      v15 = JobMoniker::GetPath((JobMoniker *)a2);
      WPP_SF_S(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x15u,
        (__int64)&WPP_5435fee58aaf3c352ed5cdc6abf88a31_Traceguids,
        v15);
    }
    if ( !SetEvent(*((HANDLE *)this + 3)) )
    {
      LastError = GetLastError();
      if ( LastError > 0 )
        v5 = (unsigned __int16)LastError | 0x80070000;
      else
        v5 = LastError;
    }
  }
  LeaveCriticalSection(v2);
  return v5;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180022A80) ----------------------------------------------------
DWORD __fastcall ItSpUserDetectionCallback(struct _ITSRV_GLOBAL_CONTEXT *a1, int a2, _DWORD *a3)
{
  __int32 v4; // ebx
  struct _TP_WORK **v5; // rcx
  void (__stdcall *v6)(struct _TP_CALLBACK_INSTANCE *, void *, struct _TP_WORK *); // r8
  __int32 v7; // ebx
  struct _FILETIME SystemTimeAsFileTime; // [rsp+40h] [rbp+8h] BYREF
  int v10; // [rsp+48h] [rbp+10h]
  struct _FILETIME v11; // [rsp+58h] [rbp+20h]

  if ( a2 != 32787 || a3[4] != 4 )
    return 87;
  v10 = a3[5];
  v4 = v10;
  EventManager::EvtReport(a1, &ItSpEvt_PowerNotificationReceived, L"UserPresence", v10);
  v7 = _InterlockedExchange((volatile __int32 *)a1 + 192, v4);
  if ( v7 == v10 )
    return 0;
  if ( v10 )
  {
    GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
    v11 = SystemTimeAsFileTime;
    _InterlockedExchange64((volatile __int64 *)a1 + 98, *(_QWORD *)&SystemTimeAsFileTime);
  }
  return ItSpSubmitThreadpoolWork(v5, a1, v6);
}
// 180022B04: variable 'v5' is possibly undefined
// 180022B04: variable 'v6' is possibly undefined

//----- (0000000180022B20) ----------------------------------------------------
__int64 __fastcall EventManager::EvtReport(
        EventManager *this,
        const struct _EVENT_DESCRIPTOR *a2,
        const unsigned __int16 *a3,
        int a4)
{
  EventManager *v4; // rdi
  __int64 v8; // rcx
  int v9; // eax
  EventManager *v10; // rcx
  int v11; // ebx
  struct _EVENT_DATA_DESCRIPTOR v12; // [rsp+20h] [rbp-48h] BYREF
  int *v13; // [rsp+30h] [rbp-38h]
  int v14; // [rsp+38h] [rbp-30h]
  int v15; // [rsp+3Ch] [rbp-2Ch]
  int v16; // [rsp+88h] [rbp+20h] BYREF

  v16 = a4;
  v4 = g_pEventManager;
  if ( !*(_QWORD *)g_pEventManager )
    return 1LL;
  if ( !(unsigned __int8)EtwEventEnabled() )
    return 0LL;
  CreateDataDescriptor(&v12, a3);
  v15 = 0;
  v13 = &v16;
  v8 = *(_QWORD *)v4;
  v14 = 4;
  v9 = EtwEventWrite(v8, a2, 2LL, &v12);
  v11 = v9;
  if ( !v9 )
    return 0LL;
  EventManager::LogIt(v10, L"EventWrite error", v9);
  if ( v11 > 0 )
    return (unsigned __int16)v11 | 0x80070000;
  return (unsigned int)v11;
}
// 180049936: variable 'v10' is possibly undefined
// 1800746B8: using guessed type __int64 EtwEventEnabled(void);
// 180074768: using guessed type __int64 __fastcall EtwEventWrite(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180022B8C) ----------------------------------------------------
DWORD __fastcall ItSpSubmitThreadpoolWork(
        struct _TP_WORK **a1,
        struct _ITSRV_GLOBAL_CONTEXT *a2,
        void (__stdcall *a3)(struct _TP_CALLBACK_INSTANCE *, void *, struct _TP_WORK *))
{
  char *v3; // rdi
  struct _TP_WORK *ThreadpoolWork; // rax

  v3 = (char *)a2 + 312;
  RtlAcquireSRWLockExclusive((char *)a2 + 312);
  ThreadpoolWork = CreateThreadpoolWork(
                     (PTP_WORK_CALLBACK)ItSpPowerNotificationWorker,
                     a2,
                     (PTP_CALLBACK_ENVIRON)((char *)a2 + 232));
  if ( ThreadpoolWork )
  {
    SubmitThreadpoolWork(ThreadpoolWork);
    RtlReleaseSRWLockExclusive(v3);
    return 0;
  }
  else
  {
    RtlReleaseSRWLockExclusive(v3);
    return GetLastError();
  }
}
// 180074660: using guessed type __int64 __fastcall RtlAcquireSRWLockExclusive(_QWORD);
// 180074670: using guessed type __int64 __fastcall RtlReleaseSRWLockExclusive(_QWORD);

//----- (0000000180022C08) ----------------------------------------------------
__int64 __fastcall TaskXmlReader::LoadSessionStateChange(TaskXmlReader *this, unsigned int *a2)
{
  const wchar_t **v2; // rdi
  __int64 result; // rax

  v2 = (const wchar_t **)((char *)this + 64);
  result = TaskXmlReader::LoadRawValue(this, (TaskXmlReader *)((char *)this + 64));
  if ( (int)result >= 0 )
  {
    if ( XmlParserTempString::IsEqualTo(v2, L"ConsoleConnect", 0xEuLL) )
    {
      *a2 = 1;
    }
    else if ( XmlParserTempString::IsEqualTo(v2, L"ConsoleDisconnect", 0x11uLL) )
    {
      *a2 = 2;
    }
    else if ( XmlParserTempString::IsEqualTo(v2, L"RemoteConnect", 0xDuLL) )
    {
      *a2 = 3;
    }
    else if ( XmlParserTempString::IsEqualTo(v2, L"RemoteDisconnect", 0x10uLL) )
    {
      *a2 = 4;
    }
    else if ( XmlParserTempString::IsEqualTo(v2, L"SessionLock", 0xBuLL) )
    {
      *a2 = 7;
    }
    else
    {
      if ( !XmlParserTempString::IsEqualTo(v2, L"SessionUnlock", 0xDuLL) )
        return 2147750680LL;
      *a2 = 8;
    }
    return 0LL;
  }
  return result;
}

//----- (0000000180022CBC) ----------------------------------------------------
wmi::Exception *__fastcall wmi::Exception::Exception(wmi::Exception *this, const struct wmi::Exception *a2)
{
  *((_BYTE *)this + 8) = *((_BYTE *)a2 + 8);
  return this;
}

//----- (0000000180022CD0) ----------------------------------------------------
wmi::IException *__fastcall wmi::IException::IException(wmi::IException *this, const struct wmi::IException *a2)
{
  return this;
}

//----- (0000000180022CF0) ----------------------------------------------------
__int64 __fastcall wmi::GenericException::GetErrorCode(wmi::GenericException *this)
{
  return *((unsigned int *)this + 10);
}

//----- (0000000180022D00) ----------------------------------------------------
__int64 __fastcall wmi::GenericException::GetErrorParam(wmi::GenericException *this)
{
  return *((unsigned int *)this + 9);
}

//----- (0000000180022D10) ----------------------------------------------------
const char *__fastcall wmi::GenericException::GetFileName(wmi::GenericException *this)
{
  return (const char *)*((_QWORD *)this + 2);
}

//----- (0000000180022D20) ----------------------------------------------------
__int64 __fastcall wmi::GenericException::GetLineNumber(wmi::GenericException *this)
{
  return *((unsigned int *)this + 12);
}

//----- (0000000180022D30) ----------------------------------------------------
__int64 __fastcall Triggers::GenericTrigger::GetTimeoutSeconds(Triggers::GenericTrigger *this)
{
  return *((unsigned int *)this + 11);
}

//----- (0000000180022D40) ----------------------------------------------------
const unsigned __int16 *__fastcall wmi::GenericException::GetMessageParam(wmi::GenericException *this)
{
  return (const unsigned __int16 *)*((_QWORD *)this + 3);
}

//----- (0000000180022D50) ----------------------------------------------------
__int64 __fastcall wmi::GenericException::GetSubErrorCode(wmi::GenericException *this)
{
  return *((unsigned int *)this + 8);
}

//----- (0000000180022D60) ----------------------------------------------------
__int64 __fastcall ComHandlerTask::Grip::PrepStop(ComHandlerTask::Grip *this)
{
  return 1LL;
}

//----- (0000000180022D70) ----------------------------------------------------
__int64 _LockRegion__QIStream__StringStream__EEAAJT_ULARGE_INTEGER__0K_Z()
{
  return 2147500033LL;
}

//----- (0000000180022D80) ----------------------------------------------------
__int64 __fastcall ExeTask::GetEnginePID(ExeTask *this)
{
  return *((unsigned int *)this + 22);
}

//----- (0000000180022D90) ----------------------------------------------------
__int64 __fastcall Triggers::RegistrationTrigger::GetTypeTag(Triggers::RegistrationTrigger *this)
{
  return 34952LL;
}

//----- (0000000180022DA0) ----------------------------------------------------
__int64 __fastcall Triggers::WnfStateChangeTrigger::GetTypeTag(Triggers::WnfStateChangeTrigger *this)
{
  return 26214LL;
}

//----- (0000000180022DB0) ----------------------------------------------------
void __fastcall wmi::RefBase::~RefBase(wmi::RefBase *this)
{
  *(_QWORD *)this = &wmi::RefBase::`vftable';
}
// 180070980: using guessed type void *wmi::RefBase::`vftable';

//----- (0000000180022DD0) ----------------------------------------------------
void __fastcall std::auto_ptr<User>::`default constructor closure'(_QWORD *a1)
{
  *a1 = 0LL;
}

//----- (0000000180022DDC) ----------------------------------------------------
void __fastcall CDLink::~CDLink(CDLink *this)
{
  *((_QWORD *)this + 1) = 0LL;
  *((_QWORD *)this + 2) = 0LL;
  *(_QWORD *)this = &RunListItem::`vftable';
}
// 180070228: using guessed type void *RunListItem::`vftable';

//----- (0000000180022E00) ----------------------------------------------------
__int64 __fastcall tsched::EvtNopCallback(tsched *this, enum _EVT_SUBSCRIBE_NOTIFY_ACTION a2, void *a3, void *a4)
{
  return 0LL;
}

//----- (0000000180022E10) ----------------------------------------------------
struct _GUID *__fastcall ATL::CAcl::CAce::ObjectType(ATL::CAcl::CAce *this, struct _GUID *__return_ptr retstr)
{
  struct _GUID *result; // rax

  result = retstr;
  *retstr = GUID_NULL;
  return result;
}

//----- (0000000180022E30) ----------------------------------------------------
char __fastcall ATL::CDacl::CAccessObjectAce::IsObjectAce(ATL::CDacl::CAccessObjectAce *this)
{
  return 1;
}

//----- (0000000180022E40) ----------------------------------------------------
bool __fastcall ATL::CAcl::CAce::IsObjectAce(ATL::CAcl::CAce *this)
{
  return 0;
}

//----- (0000000180022E50) ----------------------------------------------------
__int64 __fastcall wil::details::RecordFailFast(wil::details *this)
{
  `wil::details::RecordFailFast'::`2'::s_hrErrorLast = (int)this;
  return 1LL;
}
// 1800B09B4: using guessed type int `wil::details::RecordFailFast'::`2'::s_hrErrorLast;

//----- (0000000180022E70) ----------------------------------------------------
bool __fastcall Triggers::GenericTrigger::Enabled(Triggers::GenericTrigger *this)
{
  return *((_BYTE *)this + 64);
}

//----- (0000000180022E80) ----------------------------------------------------
bool __fastcall Triggers::TimeTrigger::Enabled(Triggers::TimeTrigger *this)
{
  return *((_BYTE *)this + 81);
}

//----- (0000000180022E90) ----------------------------------------------------
_OWORD *__fastcall Triggers::GenericTrigger::GetEndBoundary(__int64 a1, _OWORD *a2)
{
  _OWORD *result; // rax

  result = a2;
  *a2 = *(_OWORD *)(a1 + 24);
  return result;
}

//----- (0000000180022EB0) ----------------------------------------------------
_OWORD *__fastcall Triggers::TimeTrigger::GetStartBoundary(__int64 a1, _OWORD *a2)
{
  _OWORD *result; // rax

  result = a2;
  *a2 = *(_OWORD *)(a1 + 8);
  return result;
}

//----- (0000000180022ED0) ----------------------------------------------------
__int64 __fastcall Triggers::TimeTrigger::GetTimeoutSeconds(Triggers::TimeTrigger *this)
{
  return *((unsigned int *)this + 16);
}

//----- (0000000180022EE0) ----------------------------------------------------
__int64 __fastcall Triggers::BootTrigger::GetTypeTag(Triggers::BootTrigger *this)
{
  return 0xFFFFLL;
}

//----- (0000000180022EF0) ----------------------------------------------------
__int64 __fastcall Triggers::EventTrigger::GetTypeTag(Triggers::EventTrigger *this)
{
  return 52428LL;
}

//----- (0000000180022F00) ----------------------------------------------------
__int64 __fastcall Triggers::IdleTrigger::GetTypeTag(Triggers::IdleTrigger *this)
{
  return 61166LL;
}

//----- (0000000180022F10) ----------------------------------------------------
__int64 __fastcall Triggers::ImmediateTrigger::GetTypeTag(Triggers::ImmediateTrigger *this)
{
  return 17476LL;
}

//----- (0000000180022F20) ----------------------------------------------------
__int64 __fastcall Triggers::LogonTrigger::GetTypeTag(Triggers::LogonTrigger *this)
{
  return 43690LL;
}

//----- (0000000180022F30) ----------------------------------------------------
__int64 __fastcall Triggers::MaintenanceTrigger::GetTypeTag(Triggers::MaintenanceTrigger *this)
{
  return 21845LL;
}

//----- (0000000180022F40) ----------------------------------------------------
__int64 __fastcall Triggers::SessionChangeTrigger::GetTypeTag(Triggers::SessionChangeTrigger *this)
{
  return 30583LL;
}

//----- (0000000180022F50) ----------------------------------------------------
__int64 __fastcall Triggers::TimeTrigger::GetTypeTag(Triggers::TimeTrigger *this)
{
  return 56797LL;
}

//----- (0000000180022F60) ----------------------------------------------------
__int64 __fastcall Triggers::MaintenanceTrigger::RegisterThyself(
        Triggers::MaintenanceTrigger *this,
        struct JobMoniker *a2,
        struct Triggers::TriggerOptions *a3)
{
  return 2147549183LL;
}

//----- (0000000180022F70) ----------------------------------------------------
__int64 __fastcall MessageBoxTask::GetTypeTag(MessageBoxTask *this)
{
  return 39321LL;
}

//----- (0000000180022F80) ----------------------------------------------------
__int64 __fastcall ValidationXmlHandler::InvalidNode(__int64 a1)
{
  return *(unsigned int *)(a1 + 108);
}

//----- (0000000180022F90) ----------------------------------------------------
__int64 __fastcall SchRpcGetNumberOfMissedRuns(__int64 a1, __int64 a2, _DWORD *a3)
{
  *a3 = 0;
  return 0LL;
}

//----- (0000000180022FA0) ----------------------------------------------------
void __fastcall UbpmParams::SetDynamicTaskInfo(UbpmParams *this, const struct DynamicTaskInfo *a2)
{
  *((_DWORD *)this + 18) = *((_DWORD *)a2 + 5);
  *(_QWORD *)((char *)this + 76) = *(_QWORD *)((char *)a2 + 12);
  *(_QWORD *)((char *)this + 92) = *(_QWORD *)((char *)a2 + 28);
  *(_QWORD *)((char *)this + 84) = *(_QWORD *)((char *)a2 + 4);
}

//----- (0000000180022FD0) ----------------------------------------------------
struct ATL::CStringData *__fastcall ATL::CAtlStringMgr::GetNilString(ATL::CAtlStringMgr *this)
{
  _InterlockedIncrement((volatile signed __int32 *)this + 8);
  return (ATL::CAtlStringMgr *)((char *)this + 16);
}

//----- (0000000180022FE0) ----------------------------------------------------
__int64 __fastcall StringStream::AddRef(StringStream *this)
{
  __int64 result; // rax

  result = (unsigned int)(*((_DWORD *)this + 2) + 1);
  *((_DWORD *)this + 2) = result;
  return result;
}

//----- (0000000180022FF0) ----------------------------------------------------
void __fastcall HashCompute::~HashCompute(struct _RTL_CRITICAL_SECTION *this)
{
  HANDLE OwningThread; // rcx
  HANDLE LockSemaphore; // rcx

  this->DebugInfo = (PRTL_CRITICAL_SECTION_DEBUG)&HashCompute::`vftable';
  OwningThread = this->OwningThread;
  if ( OwningThread )
    operator delete(OwningThread);
  LockSemaphore = this->LockSemaphore;
  if ( LockSemaphore )
    BCryptCloseAlgorithmProvider(LockSemaphore, 0);
  DeleteCriticalSection(this + 1);
}
// 180070428: using guessed type void *HashCompute::`vftable';

//----- (0000000180023040) ----------------------------------------------------
__int64 __fastcall EventTrapMap::ConsumerCallback(
        EventTrapMap *Action,
        struct EventTrap *UserContext,
        EVT_HANDLE Event)
{
  unsigned int v3; // edi
  __int32 v5; // [rsp+80h] [rbp+20h] BYREF

  v5 = 0;
  _InterlockedExchange(&v5, 0);
  _InterlockedIncrement(&ShutdownMgr::s_sync);
  _InterlockedExchange(&v5, _InterlockedCompareExchange(&dword_1800B0A14, 0, 0) != 0);
  if ( _InterlockedCompareExchange(&v5, 0, 0) && (_DWORD)Action == 1 )
  {
    v3 = EventTrapMap::EventReceived(Action, UserContext, Event);
    _InterlockedExchange(&v5, 0);
    if ( _InterlockedExchangeAdd(&ShutdownMgr::s_sync, 0xFFFFFFFF) == 1 )
      SetEvent((HANDLE)_InterlockedCompareExchange64((volatile signed __int64 *)&ShutdownMgr::s_hEvent, -1LL, -1LL));
    return v3;
  }
  else
  {
    _InterlockedExchange(&v5, 0);
    if ( _InterlockedExchangeAdd(&ShutdownMgr::s_sync, 0xFFFFFFFF) == 1 )
      SetEvent((HANDLE)_InterlockedCompareExchange64((volatile signed __int64 *)&ShutdownMgr::s_hEvent, -1LL, -1LL));
    return 0LL;
  }
}
// 180023040: could not find valid save-restore pair for rbp
// 1800B0A10: using guessed type int ShutdownMgr::s_sync;
// 1800B0A14: using guessed type int dword_1800B0A14;

//----- (00000001800230D4) ----------------------------------------------------
__int64 __fastcall Aggregator::AddEvent(Aggregator *this, const unsigned __int16 *a2, int *a3)
{
  __int64 *v7; // rdi
  __int64 v8; // rcx
  __int64 v9; // r14
  _QWORD **v10; // rbx
  _QWORD *v11; // rdx
  __int64 v12; // rax
  _QWORD *v13; // rbx
  __int64 v14; // rax
  __int64 v15; // rcx
  _QWORD **v16; // rdi
  __int64 v17; // rax
  __int64 *v18; // rax
  __int64 v19; // rcx
  __int64 *v20; // rbx
  _QWORD *v21; // rdi
  _QWORD *v22; // rdx
  __int64 v23; // rax
  const wchar_t ***lpMem; // rax
  __int64 v25; // r8
  __int128 v26; // [rsp+50h] [rbp-50h] BYREF
  int v27[2]; // [rsp+60h] [rbp-40h] BYREF
  struct _FILETIME v28; // [rsp+68h] [rbp-38h]
  struct _FILETIME SystemTimeAsFileTime; // [rsp+B8h] [rbp+18h] BYREF
  __int64 *v30; // [rsp+C0h] [rbp+20h] BYREF

  *a3 = 0;
  if ( *((_DWORD *)this + 5) < 2u )
  {
    *a3 = 1;
    return 0LL;
  }
  GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
  _bstr_t::_bstr_t((_bstr_t *)&v30, a2);
  v7 = (__int64 *)*std::_Tree<std::_Tmap_traits<_bstr_t,std::list<_FILETIME> *,Aggregator::less,std::allocator<std::pair<_bstr_t const,std::list<_FILETIME> *>>,0>>::find(
                     (__int64 *)this,
                     &v26,
                     (const wchar_t ***)&v30);
  _bstr_t::_Free((_bstr_t *)&v30);
  if ( v7 == *(__int64 **)this )
  {
    v18 = (__int64 *)operator new(0x10uLL);
    v20 = v18;
    v30 = v18;
    if ( v18 )
    {
      *v18 = 0LL;
      v18[1] = 0LL;
      *v18 = (__int64)std::_List_alloc<0,std::_List_base_types<_FILETIME>>::_Buynode0(v19, 0LL, 0LL);
    }
    else
    {
      v20 = 0LL;
    }
    v21 = (_QWORD *)*v20;
    v22 = std::_List_buy<_FILETIME>::_Buynode<_FILETIME const &>(
            v19,
            (_QWORD *)*v20,
            *(_QWORD **)(*v20 + 8),
            &SystemTimeAsFileTime);
    v23 = v20[1];
    if ( v23 == 0xAAAAAAAAAAAAAA9LL )
      std::_Xlength_error("list<T> too long");
    v20[1] = v23 + 1;
    v21[1] = v22;
    *(_QWORD *)v22[1] = v22;
    *(_QWORD *)v27 = a2;
    v28 = (struct _FILETIME)v20;
    lpMem = (const wchar_t ***)std::_Tree_buy<std::pair<_bstr_t const,std::list<_FILETIME> *>>::_Buynode<std::pair<unsigned short const *,std::list<_FILETIME> *>>(
                                 this,
                                 (__int64)v27);
    std::_Tree<std::_Tmap_traits<_bstr_t,std::list<_FILETIME> *,Aggregator::less,std::allocator<std::pair<_bstr_t const,std::list<_FILETIME> *>>,0>>::_Insert_nohint<std::pair<_bstr_t const,std::list<_FILETIME> *> &,std::_Tree_node<std::pair<_bstr_t const,std::list<_FILETIME> *>,void *> *>(
      (__int64 *)this,
      (__int64)v27,
      v25,
      lpMem + 4,
      (char *)lpMem);
  }
  else
  {
    v9 = v7[5];
    v10 = *(_QWORD ***)v9;
    if ( *(_QWORD *)(v9 + 8) >= (unsigned __int64)(unsigned int)(*((_DWORD *)this + 5) - 1) )
    {
      v13 = *v10;
      v14 = v13[2];
      LOBYTE(v26) = 0;
      *((_QWORD *)&v26 + 1) = v14;
      LOBYTE(v27[0]) = 0;
      v28 = SystemTimeAsFileTime;
      if ( (unsigned int)TSTime::operator-((__int64)v27, &v26) <= *((_DWORD *)this + 4) )
      {
        *a3 = 1;
        std::_Tree<std::_Tmap_traits<_bstr_t,std::list<_FILETIME> *,Aggregator::less,std::allocator<std::pair<_bstr_t const,std::list<_FILETIME> *>>,0>>::erase(
          this,
          &v30,
          v7);
        return 0LL;
      }
      v16 = *(_QWORD ***)v9;
      if ( v13 != *(_QWORD **)v9 )
      {
        *(_QWORD *)v13[1] = *v13;
        *(_QWORD *)(*v13 + 8LL) = v13[1];
        operator delete(v13);
        --*(_QWORD *)(v9 + 8);
        v16 = *(_QWORD ***)v9;
      }
      v11 = std::_List_buy<_FILETIME>::_Buynode<_FILETIME const &>(v15, v16, v16[1], &SystemTimeAsFileTime);
      v17 = *(_QWORD *)(v9 + 8);
      if ( v17 == 0xAAAAAAAAAAAAAA9LL )
        std::_Xlength_error("list<T> too long");
      *(_QWORD *)(v9 + 8) = v17 + 1;
      v16[1] = v11;
    }
    else
    {
      v11 = std::_List_buy<_FILETIME>::_Buynode<_FILETIME const &>(v8, *(_QWORD **)v9, v10[1], &SystemTimeAsFileTime);
      v12 = *(_QWORD *)(v9 + 8);
      if ( v12 == 0xAAAAAAAAAAAAAA9LL )
        std::_Xlength_error("list<T> too long");
      *(_QWORD *)(v9 + 8) = v12 + 1;
      v10[1] = v11;
    }
    *(_QWORD *)v11[1] = v11;
  }
  return 0LL;
}
// 1800230D4: could not find valid save-restore pair for rbp
// 18003BA98: variable 'v8' is possibly undefined
// 18003BB68: variable 'v15' is possibly undefined
// 18003BBD0: variable 'v19' is possibly undefined
// 18003BC54: variable 'v25' is possibly undefined

//----- (000000018002313C) ----------------------------------------------------
__int64 __fastcall TSTime::operator+(__int64 a1, __int64 a2, int a3)
{
  __int64 v3; // r9
  bool v4; // sf
  unsigned __int64 v5; // r8

  v3 = 10000000LL * a3;
  v4 = a3 < 0;
  v5 = *(_QWORD *)(a1 + 8);
  if ( v4 )
  {
    if ( v3 < -(__int64)v5 )
    {
      *(_BYTE *)a2 = 0;
      *(_QWORD *)(a2 + 8) = 0LL;
      return a2;
    }
LABEL_7:
    *(_BYTE *)a2 = *(_BYTE *)a1;
    *(_QWORD *)(a2 + 8) = v5 + v3;
    return a2;
  }
  if ( v5 <= ~v3 )
    goto LABEL_7;
  *(_QWORD *)(a2 + 8) = -1LL;
  *(_BYTE *)a2 = 0;
  return a2;
}

//----- (0000000180023178) ----------------------------------------------------
__int64 __fastcall EventTrapMap::EventReceived(EventTrapMap *this, struct EventTrap *a2, void *a3)
{
  EventTrapMap *v5; // r12
  void **v6; // rax
  int v7; // r13d
  __int64 v8; // r15
  PVOID v9; // rdi
  char *v10; // rcx
  int v11; // esi
  char *v12; // rcx
  __int64 v13; // rsi
  __int128 *v14; // rax
  JobMoniker *v15; // r14
  int v16; // esi
  const unsigned __int16 *Path; // rax
  void *v19; // rax
  signed int LastError; // ebx
  int v21; // r15d
  const unsigned __int16 *v22; // rax
  EventManager *v23; // rcx
  const unsigned __int16 *v24; // rax
  EventManager *v25; // rcx
  const struct _EVENT_DESCRIPTOR *v26; // rdx
  void *v27; // rax
  _QWORD *v28; // rbx
  int v29; // r12d
  const unsigned __int16 *v30; // rax
  EventManager *v31; // rcx
  __int64 *v32; // rax
  __int64 v33; // r8
  __int64 v34; // r8
  const wchar_t *v35; // r9
  __int64 v36; // rcx
  _QWORD *i; // rax
  signed int v38; // eax
  int v39; // ebx
  const unsigned __int16 *v40; // rax
  EventManager *v41; // rcx
  const unsigned __int16 *v42; // rax
  EventManager *v43; // rcx
  const unsigned __int16 *v44; // rax
  EventManager *v45; // rcx
  void *v46; // r9
  _bstr_t::Data_t *v47; // [rsp+48h] [rbp-49h] BYREF
  const wchar_t **v48; // [rsp+50h] [rbp-41h] BYREF
  void *lpMem[2]; // [rsp+58h] [rbp-39h] BYREF
  unsigned __int16 *v50[2]; // [rsp+68h] [rbp-29h] BYREF
  __int64 v51; // [rsp+78h] [rbp-19h]
  __int64 v52; // [rsp+80h] [rbp-11h] BYREF
  char v53[8]; // [rsp+88h] [rbp-9h] BYREF
  char v54[8]; // [rsp+90h] [rbp-1h] BYREF
  __int64 v55[9]; // [rsp+A0h] [rbp+Fh] BYREF
  EventTrapMap *BufferSize; // [rsp+F8h] [rbp+67h] BYREF
  DWORD PropertyCount; // [rsp+100h] [rbp+6Fh] BYREF
  PVOID Buffer; // [rsp+110h] [rbp+7Fh] BYREF

  BufferSize = this;
  v55[2] = -2LL;
  v5 = g_pEventTrapMap;
  v55[0] = (__int64)g_pEventTrapMap;
  v6 = (void **)WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
  {
    WPP_SF_q(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xFu, (__int64)&WPP_16de8f11014e3cd60e9c758468ee516f_Traceguids, a2);
    v6 = (void **)WPP_GLOBAL_Control;
  }
  v7 = 0;
  if ( !a2 )
    return 0LL;
  if ( v6 != &WPP_GLOBAL_Control && (*((_BYTE *)v6 + 28) & 4) != 0 && *((_BYTE *)v6 + 25) >= 4u )
  {
    Path = JobMoniker::GetPath((struct EventTrap *)((char *)a2 + 8));
    WPP_SF_qS(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x10u,
      (__int64)&WPP_16de8f11014e3cd60e9c758468ee516f_Traceguids,
      a2,
      Path);
  }
  v8 = *((_QWORD *)a2 + 6);
  v9 = 0LL;
  Buffer = 0LL;
  *(_OWORD *)v50 = 0LL;
  v51 = 0LL;
  if ( !(*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v8 + 32LL))(v8) )
  {
LABEL_15:
    std::vector<unsigned short>::_Tidy((__int64)v50);
    operator delete(v9);
    return 0LL;
  }
  v10 = (char *)*((_QWORD *)a2 + 8);
  if ( (unsigned __int64)(v10 - 1) > 0xFFFFFFFFFFFFFFFDuLL )
    goto LABEL_8;
  PropertyCount = 0;
  if ( EvtRender(v10, a3, 0, 0, 0LL, (PDWORD)&BufferSize, &PropertyCount) || GetLastError() != 122 )
    goto LABEL_8;
  v19 = operator new((unsigned int)BufferSize);
  wmi::AutoVectorPtr<unsigned char>::operator=(&Buffer, v19);
  v9 = Buffer;
  if ( !EvtRender(*((EVT_HANDLE *)a2 + 8), a3, 0, (DWORD)BufferSize, Buffer, (PDWORD)&BufferSize, &PropertyCount) )
  {
    LastError = GetLastError();
    v11 = (unsigned __int16)LastError | 0x80070000;
    v21 = LastError;
    if ( LastError > 0 )
      v21 = (unsigned __int16)LastError | 0x80070000;
    v22 = JobMoniker::GetPath((struct EventTrap *)((char *)a2 + 8));
    EventManager::EvtReport(v23, &EVENT_RENDER_FAILED, v22, v21);
    if ( LastError <= 0 )
      v11 = LastError;
    goto LABEL_34;
  }
  v11 = EventTrapMap::FormatEvtVariant((char *)v50, (LPCCH *)v9);
  if ( v11 >= 0 )
  {
LABEL_8:
    LODWORD(BufferSize) = 0;
    v11 = Aggregator::AddEvent(*((Aggregator **)a2 + 7), v50[0], (int *)&BufferSize);
    if ( v11 < 0 )
    {
      v24 = JobMoniker::GetPath((struct EventTrap *)((char *)a2 + 8));
      v26 = &EVENT_AGGREGATE_FAILED;
      goto LABEL_32;
    }
    if ( !(_DWORD)BufferSize )
    {
      v11 = 1;
      goto LABEL_34;
    }
    lpMem[1] = 0LL;
    lpMem[0] = std::_Tree_alloc<0,std::_Tree_base_types<std::pair<User const,LogonJob *>>>::_Buyheadnode();
    v12 = (char *)*((_QWORD *)a2 + 9);
    if ( (unsigned __int64)(v12 - 1) <= 0xFFFFFFFFFFFFFFFDuLL )
    {
      PropertyCount = 0;
      if ( !EvtRender(v12, a3, 0, 0, 0LL, (PDWORD)&BufferSize, &PropertyCount) && GetLastError() == 122 )
      {
        v27 = operator new((unsigned int)BufferSize);
        wmi::AutoVectorPtr<unsigned char>::operator=(&Buffer, v27);
        v9 = Buffer;
        if ( EvtRender(*((EVT_HANDLE *)a2 + 9), a3, 0, (DWORD)BufferSize, Buffer, (PDWORD)&BufferSize, &PropertyCount)
          && *(_QWORD *)(v8 + 120) == PropertyCount )
        {
          v28 = **(_QWORD ***)(v8 + 112);
          while ( v28 != *(_QWORD **)(v8 + 112) )
          {
            v29 = EventTrapMap::FormatEvtVariant((char *)v50, (LPCCH *)v9 + 2 * v7);
            if ( v29 < 0 )
            {
              v30 = JobMoniker::GetPath((struct EventTrap *)((char *)a2 + 8));
              EventManager::EvtReport(v31, &EVENT_RENDER_FAILED, v30, v29);
            }
            v48 = 0LL;
            v47 = 0LL;
            _bstr_t::operator=((__int64 *)&v48, v28 + 4);
            _bstr_t::operator=(&v47, v50[0]);
            v32 = std::pair<_bstr_t,_bstr_t>::pair<_bstr_t,_bstr_t>(&v52, (__int64 *)&v48, (__int64 *)&v47);
            std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::_Insert_nohint<std::pair<_bstr_t const,_bstr_t>,std::_Nil>(
              (__int64 *)lpMem,
              (__int64)v54,
              v33,
              (BSTR **)v32);
            _bstr_t::_Free((_bstr_t *)v53);
            _bstr_t::_Free((_bstr_t *)&v52);
            if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
              && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0
              && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
            {
              if ( v47 )
                v34 = *(_QWORD *)v47;
              else
                v34 = 0LL;
              if ( v48 )
                v35 = *v48;
              else
                v35 = 0LL;
              WPP_SF_SSD(
                *((_QWORD *)WPP_GLOBAL_Control + 2),
                0x11u,
                (__int64)&WPP_16de8f11014e3cd60e9c758468ee516f_Traceguids,
                v35,
                v34);
            }
            _bstr_t::_Free((_bstr_t *)&v47);
            _bstr_t::_Free((_bstr_t *)&v48);
            if ( !*((_BYTE *)v28 + 25) )
            {
              v36 = v28[2];
              if ( *(_BYTE *)(v36 + 25) )
              {
                for ( i = (_QWORD *)v28[1]; !*((_BYTE *)i + 25) && v28 == (_QWORD *)i[2]; i = (_QWORD *)i[1] )
                  v28 = i;
              }
              else
              {
                i = std::_Tree_val<std::_Tree_simple_types<std::pair<_bstr_t const,std::list<_FILETIME> *>>>::_Min((_QWORD *)v36);
              }
              v28 = i;
            }
            ++v7;
          }
          v5 = (EventTrapMap *)v55[0];
        }
        else
        {
          v38 = GetLastError();
          v39 = v38;
          if ( v38 > 0 )
            v39 = (unsigned __int16)v38 | 0x80070000;
          v40 = JobMoniker::GetPath((struct EventTrap *)((char *)a2 + 8));
          EventManager::EvtReport(v41, &EVENT_RENDER_FAILED, v40, v39);
        }
      }
    }
    BufferSize = (EventTrapMap *)((char *)v5 + 8);
    EnterCriticalSection((LPCRITICAL_SECTION)((char *)v5 + 8));
    v13 = (*(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v8 + 16LL))(v8, &v52);
    TSTime::TSTime((TSTime *)v54);
    v14 = (__int128 *)TSTime::operator+(v13, (__int64)v55, 59);
    v15 = (struct EventTrap *)((char *)a2 + 8);
    if ( TSTime::operator>((__int64)v54, v14) )
    {
      v44 = JobMoniker::GetPath(v15);
      EventManager::EvtReport(v45, &IGNORED_TASK_START, v44, v46);
    }
    else
    {
      v16 = EventTrapMap::SendUbpmTriggerEmulatorEvent((__int64)v5, (__int64)v15, (_QWORD **)lpMem);
      if ( v16 < 0 )
      {
        v42 = JobMoniker::GetPath(v15);
        EventManager::EvtReport(v43, &EVENT_RENDER_FAILED, v42, v16);
      }
    }
    LeaveCriticalSection((LPCRITICAL_SECTION)((char *)v5 + 8));
    std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::clear(lpMem);
    operator delete(lpMem[0]);
    goto LABEL_15;
  }
  v24 = JobMoniker::GetPath((struct EventTrap *)((char *)a2 + 8));
  v26 = &EVENT_RENDER_FAILED;
LABEL_32:
  EventManager::EvtReport(v25, v26, v24, v11);
LABEL_34:
  std::vector<unsigned short>::_Tidy((__int64)v50);
  operator delete(v9);
  return (unsigned int)v11;
}
// 18003C0A2: variable 'v43' is possibly undefined
// 18003BDCD: variable 'v23' is possibly undefined
// 18003BE17: variable 'v25' is possibly undefined
// 18003BF2D: variable 'v31' is possibly undefined
// 18003BF7E: variable 'v33' is possibly undefined
// 18003C079: variable 'v41' is possibly undefined
// 18003C0BF: variable 'v45' is possibly undefined
// 18003C0BF: variable 'v46' is possibly undefined
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 180023178: using guessed type char var_58[8];
// 180023178: using guessed type char var_60[8];

//----- (000000018002334C) ----------------------------------------------------
__int64 __fastcall EventTrapMap::SendUbpmTriggerEmulatorEvent(__int64 a1, __int64 a2, _QWORD **a3)
{
  unsigned int v4; // esi
  void *v5; // rdi
  SIZE_T v6; // r12
  _QWORD *v7; // rbx
  signed int v8; // eax
  bool v9; // cc
  _QWORD **v10; // r9
  _QWORD *v11; // rax
  __int64 v12; // r15
  _QWORD *v13; // rax
  __int64 v14; // rcx
  __int64 v15; // rcx
  __int64 *v17; // rcx
  __int64 v18; // rdx
  __int64 v19; // r8
  __int64 *v20; // rcx
  __int64 v21; // rdx
  __int64 v22; // rcx
  __int64 v23; // rcx
  __int64 i; // rcx
  void *v25; // rax
  char *v26; // r14
  _QWORD *v27; // rbx
  _QWORD *v28; // rax
  _WORD *v29; // rdx
  __int64 v30; // rcx
  _WORD *v31; // rdx
  __int64 *v32; // rcx
  __int64 v33; // rcx
  __int64 v34; // rax
  char *v35; // r14
  _QWORD *v36; // rcx
  _WORD *v37; // rdx
  __int64 v38; // rax
  _WORD *v39; // rdx
  __int64 *v40; // rcx
  __int64 v41; // rcx
  __int64 v42; // rax
  __int64 v43; // rcx
  _QWORD *j; // rax
  void *v45; // [rsp+20h] [rbp-50h] BYREF
  _QWORD *v46; // [rsp+28h] [rbp-48h]
  __int64 v47; // [rsp+30h] [rbp-40h]
  __int64 v48; // [rsp+38h] [rbp-38h]
  __int128 v49; // [rsp+40h] [rbp-30h] BYREF
  __int128 v50; // [rsp+50h] [rbp-20h]

  v48 = -2LL;
  v47 = a2;
  v4 = 0;
  v49 = 0LL;
  v50 = 0LL;
  v5 = 0LL;
  v45 = 0LL;
  v6 = 0LL;
  v7 = (_QWORD *)(a1 + 2088);
  v46 = (_QWORD *)(a1 + 2088);
  if ( !*(_QWORD *)(a1 + 2088) )
  {
    v8 = EtwEventRegister(&TRIGGER_EMULATOR_PROVIDER_GUID, 0LL, 0LL, a1 + 2088);
    v9 = v8 <= 0;
    if ( v8 )
      goto LABEL_70;
  }
  v10 = (_QWORD **)*a3;
  v11 = (_QWORD *)**a3;
  v12 = -1LL;
  while ( v11 != v10 )
  {
    v17 = (__int64 *)v11[4];
    if ( v17 )
      v18 = *v17;
    else
      v18 = 0LL;
    v19 = -1LL;
    do
      ++v19;
    while ( *(_WORD *)(v18 + 2 * v19) );
    v20 = (__int64 *)v11[5];
    if ( v20 )
      v21 = *v20;
    else
      v21 = 0LL;
    v22 = -1LL;
    do
      ++v22;
    while ( *(_WORD *)(v21 + 2 * v22) );
    v6 += 2 * (v19 + v22) + 4;
    if ( !*((_BYTE *)v11 + 25) )
    {
      v23 = v11[2];
      if ( *(_BYTE *)(v23 + 25) )
      {
        for ( i = v11[1]; !*(_BYTE *)(i + 25) && v11 == *(_QWORD **)(i + 16); i = *(_QWORD *)(i + 8) )
          v11 = (_QWORD *)i;
        v11 = (_QWORD *)i;
      }
      else
      {
        v11 = std::_Tree_val<std::_Tree_simple_types<std::pair<_bstr_t const,std::list<_FILETIME> *>>>::_Min((_QWORD *)v23);
      }
    }
  }
  if ( v6 )
  {
    v25 = operator new(v6);
    wmi::AutoVectorPtr<unsigned char>::operator=(&v45, v25);
    v5 = v45;
    v26 = (char *)v45;
    v27 = (_QWORD *)**a3;
    while ( v27 != *a3 )
    {
      v28 = (_QWORD *)v27[4];
      if ( v28 )
        v29 = (_WORD *)*v28;
      else
        v29 = 0LL;
      v30 = -1LL;
      do
        ++v30;
      while ( v29[v30] );
      if ( v28 )
        v31 = (_WORD *)*v28;
      else
        v31 = 0LL;
      memcpy_0(v26, v31, 2 * v30 + 2);
      v32 = (__int64 *)v27[4];
      if ( v32 )
        v33 = *v32;
      else
        v33 = 0LL;
      v34 = -1LL;
      do
        ++v34;
      while ( *(_WORD *)(v33 + 2 * v34) );
      v35 = &v26[2 * v34 + 2];
      v36 = (_QWORD *)v27[5];
      if ( v36 )
        v37 = (_WORD *)*v36;
      else
        v37 = 0LL;
      v38 = -1LL;
      do
        ++v38;
      while ( v37[v38] );
      if ( v36 )
        v39 = (_WORD *)*v36;
      else
        v39 = 0LL;
      memcpy_0(v35, v39, 2 * v38 + 2);
      v40 = (__int64 *)v27[5];
      if ( v40 )
        v41 = *v40;
      else
        v41 = 0LL;
      v42 = -1LL;
      do
        ++v42;
      while ( *(_WORD *)(v41 + 2 * v42) );
      v26 = &v35[2 * v42 + 2];
      if ( !*((_BYTE *)v27 + 25) )
      {
        v43 = v27[2];
        if ( *(_BYTE *)(v43 + 25) )
        {
          for ( j = (_QWORD *)v27[1]; !*((_BYTE *)j + 25) && v27 == (_QWORD *)j[2]; j = (_QWORD *)j[1] )
            v27 = j;
        }
        else
        {
          j = std::_Tree_val<std::_Tree_simple_types<std::pair<_bstr_t const,std::list<_FILETIME> *>>>::_Min((_QWORD *)v43);
        }
        v27 = j;
      }
    }
    v7 = v46;
  }
  v13 = *(_QWORD **)(v47 + 16);
  v14 = v13 ? *v13 : 0LL;
  do
    ++v12;
  while ( *(_WORD *)(v14 + 2 * v12) );
  v15 = v13 ? *v13 : 0LL;
  *(_QWORD *)&v49 = v15;
  *((_QWORD *)&v49 + 1) = (unsigned int)(2 * v12 + 2);
  *(_QWORD *)&v50 = v5;
  *((_QWORD *)&v50 + 1) = (unsigned int)v6;
  v8 = EtwEventWrite(*v7, &UBPM_TRIGGER_EMULATOR_EVENT, 2LL, &v49);
  v9 = v8 <= 0;
  if ( v8 )
  {
LABEL_70:
    if ( v9 )
      v4 = v8;
    else
      v4 = (unsigned __int16)v8 | 0x80070000;
  }
  operator delete(v5);
  return v4;
}
// 1800233DF: variable 'v10' is possibly undefined
// 180074760: using guessed type __int64 __fastcall EtwEventRegister(_QWORD, _QWORD, _QWORD, _QWORD);
// 180074768: using guessed type __int64 __fastcall EtwEventWrite(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000018002349C) ----------------------------------------------------
__int64 __fastcall Scheduler::EvaluateMissedRuns(Scheduler *this)
{
  JobStore *v2; // rbx

  Scheduler::EnqueueMissedRuns(this);
  v2 = JobStore::m_pCommonStore;
  JobStore::WaitForConfiguration(JobStore::m_pCommonStore);
  return Scheduler::StartFirstMissedRun(this, *(_DWORD *)(*((_QWORD *)v2 + 10) + 88LL));
}

//----- (00000001800234DC) ----------------------------------------------------
__int64 __fastcall Scheduler::EnqueueMissedRuns(Scheduler *this)
{
  unsigned int v2; // edi
  int v3; // r15d
  __int64 v4; // r14
  unsigned int v6; // esi
  int v7; // eax
  unsigned int v8[2]; // [rsp+28h] [rbp-A9h] BYREF
  __int64 v9; // [rsp+30h] [rbp-A1h]
  __int64 v10; // [rsp+38h] [rbp-99h]
  _OWORD v11[5]; // [rsp+48h] [rbp-89h] BYREF
  __int64 v12; // [rsp+98h] [rbp-39h]
  char v13[16]; // [rsp+A8h] [rbp-29h] BYREF
  BSTR *v14[2]; // [rsp+B8h] [rbp-19h] BYREF
  wmi::RefBase *v15; // [rsp+C8h] [rbp-9h] BYREF
  char v16[16]; // [rsp+D0h] [rbp-1h] BYREF
  BSTR *v17[2]; // [rsp+E0h] [rbp+Fh] BYREF
  wmi::RefBase *v18; // [rsp+F0h] [rbp+1Fh] BYREF

  v9 = -2LL;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x21u, (__int64)&WPP_5435fee58aaf3c352ed5cdc6abf88a31_Traceguids);
  }
  v2 = 0;
  v3 = 0;
  Scheduling::JobSchedule::JobSchedule((struct _FILETIME *)v11);
  JobMoniker::JobMoniker((JobMoniker *)v13, 0LL, 0LL);
  v10 = (__int64)this + 32;
  EnterCriticalSection((LPCRITICAL_SECTION)((char *)this + 32));
  v4 = *((_QWORD *)this + 41);
  if ( (Scheduler *)v4 != (Scheduler *)((char *)this + 320) )
  {
    JobMoniker::JobMoniker((JobMoniker *)v16, 0LL, 0LL);
    v6 = 0;
    v8[0] = 0;
    do
    {
      v11[0] = *(_OWORD *)(v4 + 64);
      v11[1] = *(_OWORD *)(v4 + 80);
      v11[2] = *(_OWORD *)(v4 + 96);
      v11[3] = *(_OWORD *)(v4 + 112);
      v11[4] = *(_OWORD *)(v4 + 128);
      v12 = *(_QWORD *)(v4 + 144);
      JobMoniker::operator=((__int64)v13, v4 + 24);
      v4 = *(_QWORD *)(v4 + 8);
      if ( (unsigned int)_bstr_t::_Compare(v17, v14) )
      {
        JobMoniker::operator=((__int64)v16, (__int64)v13);
        v6 = 0;
        v8[0] = 0;
      }
      if ( !v6 && (*((_BYTE *)v15 + 16) & 0x40) != 0 )
      {
        v7 = Scheduler::EnqueueMissedRun(this, (struct Scheduling::JobSchedule *)v11, (struct JobMoniker *)v13, v8);
        if ( v7 < 0 )
          v3 = v7;
        v6 = v8[0];
      }
    }
    while ( (Scheduler *)v4 != (Scheduler *)((char *)this + 320) );
    v2 = v3;
    wmi::AutoRef<JobBucket>::Release(&v18);
    _bstr_t::_Free((_bstr_t *)v17);
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)((char *)this + 32));
  wmi::AutoRef<JobBucket>::Release(&v15);
  _bstr_t::_Free((_bstr_t *)v14);
  return v2;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (00000001800235DC) ----------------------------------------------------
struct _ITSRV_GLOBAL_CONTEXT near **wil::details_abi::ThreadLocalStorage<wil::details::ThreadFailureCallbackHolder *>::~ThreadLocalStorage<wil::details::ThreadFailureCallbackHolder *>()
{
  struct _ITSRV_GLOBAL_CONTEXT near **v0; // rdi
  struct _ITSRV_GLOBAL_CONTEXT near *v1; // rsi
  struct _ITSRV_GLOBAL_CONTEXT near **result; // rax
  struct _ITSRV_GLOBAL_CONTEXT near *v3; // rbx
  HANDLE ProcessHeap; // rax

  v0 = (struct _ITSRV_GLOBAL_CONTEXT near **)&wil::details::g_threadFailureCallbacks;
  do
  {
    v1 = *v0;
    while ( v1 )
    {
      v3 = v1;
      v1 = (struct _ITSRV_GLOBAL_CONTEXT near *)*((_QWORD *)v1 + 1);
      ProcessHeap = GetProcessHeap();
      HeapFree(ProcessHeap, 0, v3);
    }
    *v0 = 0LL;
    result = &ItSrvGlobalContext;
    ++v0;
  }
  while ( v0 != &ItSrvGlobalContext );
  return result;
}
// 1800B0EF0: using guessed type struct _ITSRV_GLOBAL_CONTEXT near *ItSrvGlobalContext;

//----- (0000000180023628) ----------------------------------------------------
void __fastcall wil::manually_managed_shutdown_aware_object<wil::details::FeatureStateManager>::destroy(wil *a1)
{
  if ( wil::ProcessShutdownInProgress(a1) )
  {
    wil::details::g_featureStateManager = 0;
    if ( qword_1800B0D90 )
      wil::details_abi::ProcessLocalStorageData<wil::details_abi::FeatureStateData>::Release((HANDLE *)qword_1800B0D90);
  }
  else
  {
    wil::details::FeatureStateManager::~FeatureStateManager((wil::details::FeatureStateManager *)&wil::details::g_featureStateManager);
  }
}

//----- (0000000180023664) ----------------------------------------------------
void __fastcall wil::manually_managed_shutdown_aware_object<wil::details::EnabledStateManager>::destroy(wil *a1)
{
  if ( wil::ProcessShutdownInProgress(a1) )
  {
    wil::details::g_enabledStateManager = 0;
    wil::details::EnabledStateManager::RecordCachedUsageUnderLock((wil::details::EnabledStateManager *)&wil::details::g_enabledStateManager);
  }
  else
  {
    wil::details::EnabledStateManager::~EnabledStateManager((struct _TP_TIMER **)&wil::details::g_enabledStateManager);
  }
}

//----- (0000000180023698) ----------------------------------------------------
char __fastcall wil::ProcessShutdownInProgress(wil *this)
{
  char v1; // bl

  v1 = 0;
  if ( wil::details::g_processShutdownInProgress )
    return 1;
  if ( wil::details::g_pfnDllShutdownInProgress ? wil::details::g_pfnDllShutdownInProgress() : 0 )
    return 1;
  return v1;
}
// 1800B14D8: using guessed type unsigned __int8 (*wil::details::g_pfnDllShutdownInProgress)(void);
// 1800B1550: using guessed type bool wil::details::g_processShutdownInProgress;

//----- (00000001800236D8) ----------------------------------------------------
char __fastcall Scheduler::GetWakeupCall(Scheduler *this, struct TSTime *a2, struct JobMoniker *a3)
{
  Scheduler *v5; // r14
  struct _RTL_CRITICAL_SECTION *v6; // rbx
  __int64 v7; // r8
  __int64 v8; // rdi
  char v9; // si
  __int128 v12; // [rsp+20h] [rbp-50h]
  char v13[16]; // [rsp+38h] [rbp-38h] BYREF
  char v14[16]; // [rsp+48h] [rbp-28h] BYREF
  wmi::RefBase *v15; // [rsp+58h] [rbp-18h] BYREF

  v5 = g_pScheduler;
  v6 = (struct _RTL_CRITICAL_SECTION *)((char *)g_pScheduler + 32);
  *(_QWORD *)&v12 = (char *)g_pScheduler + 32;
  EnterCriticalSection((LPCRITICAL_SECTION)((char *)g_pScheduler + 32));
  v8 = *((_QWORD *)v5 + 10);
  v9 = 1;
  while ( 1 )
  {
    if ( !*(_DWORD *)(v8 + 24) && !*(_DWORD *)(v8 + 28) )
    {
      v9 = ScheduleList::GetWakeupCall((Scheduler *)((char *)v5 + 320), a2, a3);
      goto LABEL_7;
    }
    JobMoniker::JobMoniker((JobMoniker *)v13, (const struct JobMoniker *)(v8 + 40), v7);
    if ( (*((_DWORD *)v15 + 4) & 0x200) != 0 )
      break;
    v8 = *(_QWORD *)(v8 + 8);
    wmi::AutoRef<JobBucket>::Release(&v15);
    _bstr_t::_Free((_bstr_t *)v14);
  }
  LOBYTE(v12) = 0;
  *((_QWORD *)&v12 + 1) = *(_QWORD *)(v8 + 24);
  *(_OWORD *)a2 = v12;
  JobMoniker::operator=((__int64)a3, (__int64)v13);
  wmi::AutoRef<JobBucket>::Release(&v15);
  _bstr_t::_Free((_bstr_t *)v14);
LABEL_7:
  LeaveCriticalSection(v6);
  return v9;
}
// 18003EC04: variable 'v7' is possibly undefined

//----- (00000001800237A4) ----------------------------------------------------
char __fastcall ScheduleList::GetWakeupCall(ScheduleList *this, struct TSTime *a2, struct JobMoniker *a3)
{
  char v6; // si
  __int64 v7; // rbx
  __int128 v9; // [rsp+28h] [rbp-99h] BYREF
  __int128 v10; // [rsp+38h] [rbp-89h] BYREF
  __int64 v11; // [rsp+48h] [rbp-79h]
  __int128 v12; // [rsp+58h] [rbp-69h] BYREF
  __int128 v13[5]; // [rsp+68h] [rbp-59h] BYREF
  __int64 v14; // [rsp+B8h] [rbp-9h]
  char v15[16]; // [rsp+C8h] [rbp+7h] BYREF
  char v16[16]; // [rsp+D8h] [rbp+17h] BYREF
  wmi::RefBase *v17; // [rsp+E8h] [rbp+27h] BYREF

  v11 = -2LL;
  v6 = 0;
  v10 = *(_OWORD *)a2;
  v7 = *((_QWORD *)this + 1);
  while ( v7 && (ScheduleList *)v7 != this )
  {
    JobMoniker::JobMoniker((JobMoniker *)v15, (const struct JobMoniker *)(v7 + 24), (__int64)a3);
    if ( (*((_DWORD *)v17 + 4) & 0x200) != 0 )
    {
      v13[0] = *(_OWORD *)(v7 + 64);
      v13[1] = *(_OWORD *)(v7 + 80);
      v13[2] = *(_OWORD *)(v7 + 96);
      v13[3] = *(_OWORD *)(v7 + 112);
      v13[4] = *(_OWORD *)(v7 + 128);
      v14 = *(_QWORD *)(v7 + 144);
      TSTime::TSTime((TSTime *)&v9);
      v12 = v10;
      if ( !(unsigned int)Scheduling::JobSchedule::GetNextRun((__int64)v13, &v12, &v9)
        && TSTime::operator>((__int64)&v9, &v10) )
      {
        if ( v6 )
        {
          if ( TSTime::operator<((__int64)&v9, (__int128 *)a2) )
          {
            *(_OWORD *)a2 = v9;
            JobMoniker::operator=((__int64)a3, (__int64)v15);
          }
        }
        else
        {
          *(_OWORD *)a2 = v9;
          JobMoniker::operator=((__int64)a3, (__int64)v15);
          v6 = 1;
        }
      }
    }
    v7 = *(_QWORD *)(v7 + 8);
    wmi::AutoRef<JobBucket>::Release(&v17);
    _bstr_t::_Free((_bstr_t *)v16);
  }
  return v6;
}
// 18003EC74: variable 'a3' is possibly undefined
// 1800237A4: using guessed type char var_40[16];

//----- (0000000180023828) ----------------------------------------------------
void __fastcall Scheduler::NotifySleep(Scheduler *this, unsigned __int8 a2)
{
  Scheduler *v2; // rbx

  v2 = g_pScheduler;
  *((_BYTE *)g_pScheduler + 472) = a2;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x2000) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
  {
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x2Fu, (__int64)&WPP_5435fee58aaf3c352ed5cdc6abf88a31_Traceguids, a2);
  }
  if ( !a2 )
  {
    *((_BYTE *)v2 + 473) = 1;
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x2000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x30u, (__int64)&WPP_5435fee58aaf3c352ed5cdc6abf88a31_Traceguids);
    }
    SetEvent(*((HANDLE *)v2 + 2));
  }
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (00000001800238C0) ----------------------------------------------------
char __fastcall wil::details::RtlDllShutdownInProgress(wil::details *this)
{
  FARPROC ProcAddress; // rax
  char v2; // bl
  HMODULE NtDllModuleHandle; // rax

  ProcAddress = (FARPROC)`wil::details::RtlDllShutdownInProgress'::`2'::s_pfnRtlDllShutdownInProgress;
  v2 = 0;
  if ( `wil::details::RtlDllShutdownInProgress'::`2'::s_pfnRtlDllShutdownInProgress )
    return ((__int64 (__fastcall *)(wil::details *))ProcAddress)(this);
  NtDllModuleHandle = wil_details_GetNtDllModuleHandle();
  ProcAddress = GetProcAddress(NtDllModuleHandle, "RtlDllShutdownInProgress");
  `wil::details::RtlDllShutdownInProgress'::`2'::s_pfnRtlDllShutdownInProgress = (__int64)ProcAddress;
  if ( ProcAddress )
    return ((__int64 (__fastcall *)(wil::details *))ProcAddress)(this);
  return v2;
}
// 1800238FB: variable 'this' is possibly undefined
// 1800B0AE0: using guessed type __int64 `wil::details::RtlDllShutdownInProgress'::`2'::s_pfnRtlDllShutdownInProgress;

//----- (0000000180023914) ----------------------------------------------------
HINSTANCE wil_details_GetNtDllModuleHandle(void)
{
  HINSTANCE result; // rax

  result = g_wil_details_ntdllModuleHandle;
  if ( !g_wil_details_ntdllModuleHandle )
  {
    result = GetModuleHandleW(L"ntdll.dll");
    g_wil_details_ntdllModuleHandle = result;
  }
  return result;
}
// 1800B0AE8: using guessed type HINSTANCE g_wil_details_ntdllModuleHandle;

//----- (0000000180023950) ----------------------------------------------------
char __fastcall Triggers::TriggerBase::Active(Triggers::TriggerBase *this)
{
  char v2; // bl
  __int64 v3; // rax
  __int128 *v4; // rax
  __int128 v6; // [rsp+20h] [rbp-38h] BYREF
  char v7[16]; // [rsp+30h] [rbp-28h] BYREF
  char v8[24]; // [rsp+40h] [rbp-18h] BYREF

  v2 = 0;
  if ( !(*(unsigned __int8 (__fastcall **)(Triggers::TriggerBase *))(*(_QWORD *)this + 24LL))(this) )
    return 0;
  TSTime::TSTime((TSTime *)&v6);
  v3 = (*(__int64 (__fastcall **)(Triggers::TriggerBase *, char *))(*(_QWORD *)this + 8LL))(this, v7);
  if ( TSTime::operator<=(v3, &v6) )
  {
    v4 = (__int128 *)(*(__int64 (__fastcall **)(Triggers::TriggerBase *, char *))(*(_QWORD *)this + 16LL))(this, v8);
    return TSTime::operator<=((__int64)&v6, v4);
  }
  return v2;
}
// 180023950: using guessed type char var_28[16];
// 180023950: using guessed type char var_18[24];

//----- (00000001800239E0) ----------------------------------------------------
void __fastcall ItSrvNotifyResume(char a1)
{
  struct _FILETIME SystemTimeAsFileTime; // [rsp+38h] [rbp+10h] BYREF
  struct _FILETIME v2; // [rsp+40h] [rbp+18h]

  if ( !a1 )
  {
    GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
    v2 = SystemTimeAsFileTime;
    _InterlockedExchange64(&qword_1800B1250, *(_QWORD *)&SystemTimeAsFileTime + 10000LL * DueTime);
    if ( NtIsSystemResumeAutomatic() )
    {
      if ( _InterlockedCompareExchange(&dword_1800B11F0, 0, 0) )
      {
        RtlAcquireSRWLockShared(&unk_1800B1088);
        ChangeTimerQueueTimer(0LL, Timer, 0x32u, xmmword_1800B1070);
        RtlReleaseSRWLockShared(&unk_1800B1088);
      }
    }
    else
    {
      v2 = SystemTimeAsFileTime;
      _InterlockedExchange64(&qword_1800B1248, *(_QWORD *)&SystemTimeAsFileTime + 10000LL * DueTime);
    }
  }
}
// 180074650: using guessed type __int64 __fastcall RtlReleaseSRWLockShared(_QWORD);
// 180074658: using guessed type __int64 __fastcall RtlAcquireSRWLockShared(_QWORD);
// 1800B11F0: using guessed type int dword_1800B11F0;
// 1800B1248: using guessed type __int64 qword_1800B1248;
// 1800B1250: using guessed type __int64 qword_1800B1250;

//----- (0000000180023A74) ----------------------------------------------------
__int64 __fastcall TSTime::operator-(__int64 a1, __int128 *a2)
{
  unsigned __int64 v3; // rcx
  unsigned __int64 v4; // rcx
  __int128 v6; // [rsp+20h] [rbp-18h] BYREF

  TSTime::EqualizeLocality((char *)a1, &v6, a2);
  v3 = *(_QWORD *)(a1 + 8);
  if ( v3 <= *((_QWORD *)&v6 + 1) )
    v4 = *((_QWORD *)&v6 + 1) - v3;
  else
    v4 = v3 - *((_QWORD *)&v6 + 1);
  if ( v4 >= 0x98968000000000LL )
    return 0xFFFFFFFFLL;
  else
    return (unsigned int)(v4 / 0x989680);
}

//----- (0000000180023AD8) ----------------------------------------------------
__int64 WppCleanupUm()
{
  _QWORD *v0; // rbx
  __int64 result; // rax

  v0 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control )
  {
    while ( v0 )
    {
      if ( v0[1] )
      {
        result = EtwUnregisterTraceGuids();
        v0[1] = 0LL;
      }
      v0 = (_QWORD *)*v0;
    }
    WPP_GLOBAL_Control = &WPP_GLOBAL_Control;
  }
  return result;
}
// 180074788: using guessed type __int64 EtwUnregisterTraceGuids(void);
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180023B34) ----------------------------------------------------
void __fastcall Scheduler::NotifyTimeChange(Scheduler *this)
{
  Scheduler *v1; // rbx
  void *v2; // rcx

  v1 = g_pScheduler;
  if ( *((_QWORD *)g_pScheduler + 2) )
  {
    v2 = (void *)*((_QWORD *)g_pScheduler + 2);
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x2000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x31u, (__int64)&WPP_5435fee58aaf3c352ed5cdc6abf88a31_Traceguids);
      v2 = (void *)*((_QWORD *)v1 + 2);
    }
    SetEvent(v2);
  }
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180023B88) ----------------------------------------------------
void __fastcall Idolater::~Idolater(Idolater *this)
{
  wmi::AutoHandle::Close(&WaitHandle + 1);
  wmi::AutoHandle::Close((void **)&xmmword_1800B0C80);
  wmi::AutoHandle::Close((void **)&hSourceHandle);
}

//----- (0000000180023BBC) ----------------------------------------------------
void __fastcall _variant_t::~_variant_t(_variant_t *this)
{
  HRESULT v1; // eax
  void **pExceptionObject; // [rsp+20h] [rbp-28h] BYREF
  HRESULT v3; // [rsp+28h] [rbp-20h]
  __int128 v4; // [rsp+30h] [rbp-18h]

  v1 = VariantClear(&vtMissing);
  if ( v1 < 0 )
  {
    v3 = v1;
    pExceptionObject = &_com_error::`vftable';
    v4 = 0LL;
    CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI1_AV_com_error__);
  }
}
// 180071858: using guessed type void *_com_error::`vftable';

//----- (0000000180023BE8) ----------------------------------------------------
void __fastcall wil::details::EnabledStateManager::RecordCachedUsageUnderLock(wil::details::EnabledStateManager *this)
{
  __int64 v2; // rcx
  __int64 v3; // rbx
  __int64 v4; // [rsp+30h] [rbp+8h] BYREF
  __int64 v5; // [rsp+38h] [rbp+10h] BYREF

  v2 = *((_QWORD *)this + 7);
  v3 = *((_QWORD *)this + 6);
  if ( (unsigned __int64)(v2 - v3) >= 0x10 )
  {
    v5 = v2;
    while ( 1 )
    {
      v4 = v3;
      if ( !wil::details_abi::operator!=(&v4, &v5) )
        break;
      wil_details_RecordCachedUsage(*(_DWORD *)v3, *(_QWORD *)(v3 + 8));
      v3 += 16LL;
    }
    *((_QWORD *)this + 7) = *((_QWORD *)this + 6);
    wil::details::WilApi_RecordFeatureUsage(0LL);
  }
}

//----- (0000000180023C64) ----------------------------------------------------
void __fastcall SortedRunList::FreeList(SortedRunList *this)
{
  __int64 i; // rcx
  __int64 v2; // rbx
  void (__fastcall ***v3)(_QWORD, __int64); // rcx

  for ( i = *((_QWORD *)this + 1); *(_DWORD *)(i + 24) || *(_DWORD *)(i + 28); i = v2 )
  {
    v2 = *(_QWORD *)(i + 8);
    CDLink::UnLink((CDLink *)i);
    (**v3)(v3, 1LL);
  }
}
// 180023C8A: variable 'v3' is possibly undefined

//----- (0000000180023CA8) ----------------------------------------------------
void __fastcall std::vector<unsigned short>::_Tidy(__int64 a1)
{
  void *v2; // rcx

  v2 = *(void **)a1;
  if ( v2 )
  {
    operator delete(v2);
    *(_QWORD *)a1 = 0LL;
    *(_QWORD *)(a1 + 8) = 0LL;
    *(_QWORD *)(a1 + 16) = 0LL;
  }
}

//----- (0000000180023CCC) ----------------------------------------------------
void __fastcall PrivateHeap::~PrivateHeap(PrivateHeap *this)
{
  if ( dword_1800B0C58 )
    HeapDestroy(g_PrivateHeap);
}
// 1800B0C58: using guessed type int dword_1800B0C58;

//----- (0000000180023CF8) ----------------------------------------------------
void __fastcall RpcServer::~RpcServer(RpcServer *this)
{
  int v1; // eax

  if ( RpcServer::s_singleton )
  {
    v1 = RpcBindingVectorFree((RPC_BINDING_VECTOR **)&RpcServer::s_singleton);
    if ( v1
      && WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x200) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xAu, (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids, v1);
    }
    RpcServer::s_singleton = 0LL;
  }
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 1800B0D48: using guessed type __int64 RpcServer::s_singleton;

//----- (0000000180023D20) ----------------------------------------------------
__int64 wil::details_abi::ProcessLocalStorage<wil::details_abi::ProcessLocalData>::~ProcessLocalStorage<wil::details_abi::ProcessLocalData>()
{
  __int64 result; // rax

  if ( qword_1800AFFA8 )
    return wil::details_abi::ProcessLocalStorageData<wil::details_abi::ProcessLocalData>::Release((HANDLE *)qword_1800AFFA8);
  return result;
}

//----- (0000000180023D40) ----------------------------------------------------
HashCompute *__fastcall HashCompute::HashCompute(HashCompute *this)
{
  JobStore::m_hashObject = &HashCompute::`vftable';
  *(_OWORD *)&pbHashObject = 0LL;
  *(_QWORD *)&dwBytes = 0LL;
  dword_1800B0A40 = 0;
  InitializeCriticalSection(&CriticalSection);
  return (HashCompute *)&JobStore::m_hashObject;
}
// 180070428: using guessed type void *HashCompute::`vftable';
// 1800B0A40: using guessed type int dword_1800B0A40;

//----- (0000000180023D94) ----------------------------------------------------
Idolater *__fastcall Idolater::Idolater(Idolater *this)
{
  Idolater *result; // rax

  TSTime::TSTime((TSTime *)&g_Idolater);
  byte_1800B0C70 = 0;
  hSourceHandle = 0LL;
  result = (Idolater *)&g_Idolater;
  xmmword_1800B0C80 = 0LL;
  *(_OWORD *)&WaitHandle = 0LL;
  byte_1800B0CC8 = 0;
  qword_1800B0CD0 = 0LL;
  return result;
}
// 1800B0C60: using guessed type __int128 g_Idolater;
// 1800B0C70: using guessed type char byte_1800B0C70;
// 1800B0CC8: using guessed type char byte_1800B0CC8;
// 1800B0CD0: using guessed type __int64 qword_1800B0CD0;

//----- (0000000180023DEC) ----------------------------------------------------
__int64 wil::manually_managed_shutdown_aware_object<wil::details::EnabledStateManager>::construct()
{
  __int64 result; // rax

  result = 0LL;
  wil::details::g_enabledStateManager = 1;
  qword_1800B0A80 = 0LL;
  qword_1800B0A78 = 0LL;
  byte_1800B0A88 = 0;
  xmmword_1800B0A90 = 0LL;
  xmmword_1800B0AA0 = 0LL;
  xmmword_1800B0AB0 = 0LL;
  xmmword_1800B0AC0 = 0LL;
  xmmword_1800B0AD0 = 0LL;
  return result;
}
// 1800B0A78: using guessed type __int64 qword_1800B0A78;
// 1800B0A80: using guessed type __int64 qword_1800B0A80;
// 1800B0A88: using guessed type char byte_1800B0A88;
// 1800B0A90: using guessed type __int128 xmmword_1800B0A90;
// 1800B0AA0: using guessed type __int128 xmmword_1800B0AA0;
// 1800B0AB0: using guessed type __int128 xmmword_1800B0AB0;
// 1800B0AD0: using guessed type __int128 xmmword_1800B0AD0;

//----- (0000000180023E40) ----------------------------------------------------
wil::details::FeatureStateManager *__fastcall wil::details::FeatureStateManager::FeatureStateManager(
        wil::details::FeatureStateManager *this)
{
  wil::details::FeatureStateManager *result; // rax

  *(_BYTE *)this = 0;
  *((_QWORD *)this + 1) = "WilStaging_02";
  *((_QWORD *)this + 2) = 0LL;
  *((_QWORD *)this + 3) = 0LL;
  *((_OWORD *)this + 2) = 0LL;
  *((_QWORD *)this + 6) = 0LL;
  *((_QWORD *)this + 7) = 0LL;
  *((_WORD *)this + 32) = 0;
  wil::details_abi::SubscriptionList::SubscriptionList((struct _RTL_CRITICAL_SECTION *)((char *)this + 72));
  *((_QWORD *)this + 18) = 0LL;
  *((_QWORD *)this + 19) = 0LL;
  *((_QWORD *)this + 20) = 0LL;
  wil::details_abi::SubscriptionList::SubscriptionList((struct _RTL_CRITICAL_SECTION *)((char *)this + 168));
  result = this;
  *((_QWORD *)this + 30) = 0LL;
  *((_QWORD *)this + 31) = 0LL;
  *((_QWORD *)this + 32) = 0LL;
  *((_QWORD *)this + 33) = 0LL;
  *((_QWORD *)this + 34) = 0LL;
  *(_BYTE *)this = 1;
  return result;
}

//----- (0000000180023EE0) ----------------------------------------------------
struct _RTL_CRITICAL_SECTION *__fastcall wil::details_abi::SubscriptionList::SubscriptionList(
        struct _RTL_CRITICAL_SECTION *this)
{
  InitializeCriticalSectionEx(this, 0, 0);
  this[1].DebugInfo = 0LL;
  *(_QWORD *)&this[1].LockCount = 0LL;
  this[1].OwningThread = 0LL;
  this[1].LockSemaphore = 0LL;
  return this;
}

//----- (0000000180023F20) ----------------------------------------------------
__int64 __fastcall JobsService::HandlerEx(JobsService *this, unsigned int a2, unsigned int a3, DWORD *a4)
{
  unsigned int v8; // edi
  LPWSTR v9; // rcx
  bool v10; // zf
  Scheduler *v12; // rcx
  struct _RTL_CRITICAL_SECTION *v13; // rax
  Scheduler *v14; // rcx
  int v15; // eax
  __int128 v16; // xmm6
  Scheduler *v17; // rcx
  Scheduler *v18; // rcx
  __int64 v19; // rdx
  __int64 v20; // r8
  __int64 v21; // r10
  char *v22; // rdx
  __int32 v23; // [rsp+88h] [rbp-1D8h] BYREF
  __int32 v24; // [rsp+90h] [rbp-1D0h] BYREF
  __int32 v25; // [rsp+94h] [rbp-1CCh] BYREF
  __int32 v26; // [rsp+98h] [rbp-1C8h] BYREF
  __int32 v27; // [rsp+9Ch] [rbp-1C4h] BYREF
  int v28; // [rsp+A0h] [rbp-1C0h]
  unsigned int v29; // [rsp+A4h] [rbp-1BCh]
  LPWSTR ppBuffer[2]; // [rsp+A8h] [rbp-1B8h] BYREF
  __int128 v31; // [rsp+B8h] [rbp-1A8h] BYREF
  DWORD pBytesReturned[4]; // [rsp+C8h] [rbp-198h] BYREF
  __int128 v33; // [rsp+D8h] [rbp-188h] BYREF
  __int128 v34; // [rsp+E8h] [rbp-178h] BYREF
  EXECUTION_STATE PreviousFlags; // [rsp+F8h] [rbp-168h] BYREF
  char *v36; // [rsp+100h] [rbp-160h] BYREF
  char *v37; // [rsp+108h] [rbp-158h] BYREF
  __int128 v38; // [rsp+118h] [rbp-148h] BYREF
  __int128 v39; // [rsp+128h] [rbp-138h] BYREF
  unsigned __int64 v40; // [rsp+138h] [rbp-128h]
  __int64 v41; // [rsp+140h] [rbp-120h]
  __int64 v42; // [rsp+148h] [rbp-118h]
  LPWSTR *v43; // [rsp+150h] [rbp-110h]
  char v44[16]; // [rsp+158h] [rbp-108h] BYREF
  __int128 v45; // [rsp+168h] [rbp-F8h] BYREF
  __int128 v46; // [rsp+178h] [rbp-E8h] BYREF
  char v47[16]; // [rsp+188h] [rbp-D8h] BYREF
  char v48[16]; // [rsp+198h] [rbp-C8h] BYREF
  char v49[16]; // [rsp+1A8h] [rbp-B8h] BYREF
  wmi::RefBase *v50; // [rsp+1B8h] [rbp-A8h] BYREF
  char v51[16]; // [rsp+1C0h] [rbp-A0h] BYREF
  char v52[16]; // [rsp+1D0h] [rbp-90h] BYREF
  wmi::RefBase *v53; // [rsp+1E0h] [rbp-80h] BYREF
  char v54[16]; // [rsp+1E8h] [rbp-78h] BYREF
  char v55[16]; // [rsp+1F8h] [rbp-68h] BYREF
  wmi::RefBase *v56; // [rsp+208h] [rbp-58h] BYREF

  v42 = -2LL;
  v8 = 0;
  v28 = 0;
  v29 = 0;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x400) != 0 )
  {
    ControlEventToStrings(a2, a3, (const char **)&v37, (const char **)&v36);
    if ( *(_BYTE *)(v21 + 25) >= 4u )
      WPP_SF_DsDsqq(*(_QWORD *)(v21 + 16), v19, v20, a2, (__int64)v37, a3, (__int64)v36);
  }
  if ( a2 == 13 )
  {
    v23 = 0;
    _InterlockedExchange(&v23, 0);
    _InterlockedIncrement(&ShutdownMgr::s_sync);
    v12 = (Scheduler *)(unsigned int)_InterlockedExchange(
                                       &v23,
                                       _InterlockedCompareExchange(&dword_1800B0A14, 0, 0) != 0);
    if ( !_InterlockedCompareExchange(&v23, 0, 0) )
    {
      _InterlockedExchange(&v23, 0);
      if ( _InterlockedExchangeAdd(&ShutdownMgr::s_sync, 0xFFFFFFFF) == 1 )
        SetEvent((HANDLE)_InterlockedCompareExchange64((volatile signed __int64 *)&ShutdownMgr::s_hEvent, -1LL, -1LL));
      return 0LL;
    }
    if ( !*((_BYTE *)this + 128) )
    {
      _InterlockedExchange(&v23, 0);
      if ( _InterlockedExchangeAdd(&ShutdownMgr::s_sync, 0xFFFFFFFF) == 1 )
        SetEvent((HANDLE)_InterlockedCompareExchange64((volatile signed __int64 *)&ShutdownMgr::s_hEvent, -1LL, -1LL));
      return 0LL;
    }
    if ( a3 && a3 != 4 )
    {
      if ( a3 != 2 )
      {
        if ( a3 <= 5 || a3 > 7 && a3 != 18 || !byte_1800B0AF0 )
          goto LABEL_33;
        v27 = 0;
        _InterlockedExchange(&v27, 0);
        _InterlockedIncrement(&ShutdownMgr::s_sync);
        _InterlockedExchange(&v27, _InterlockedCompareExchange(&dword_1800B0A14, 0, 0) != 0);
        if ( !_InterlockedCompareExchange(&v27, 0, 0) )
        {
          _InterlockedExchange(&v27, 0);
          if ( _InterlockedExchangeAdd(&ShutdownMgr::s_sync, 0xFFFFFFFF) == 1 )
            SetEvent((HANDLE)_InterlockedCompareExchange64(
                               (volatile signed __int64 *)&ShutdownMgr::s_hEvent,
                               -1LL,
                               -1LL));
          _InterlockedExchange(&v23, 0);
          if ( _InterlockedExchangeAdd(&ShutdownMgr::s_sync, 0xFFFFFFFF) == 1 )
            SetEvent((HANDLE)_InterlockedCompareExchange64(
                               (volatile signed __int64 *)&ShutdownMgr::s_hEvent,
                               -1LL,
                               -1LL));
          return 0LL;
        }
        TSTime::TSTime((TSTime *)v44);
        LOBYTE(v39) = 0;
        *((_QWORD *)&v39 + 1) = 0LL;
        if ( TSTime::operator!=((__int64)this + 152, &v39)
          && TSTime::operator>=((__int64)v44, (__int128 *)((char *)this + 152)) )
        {
          NtSetThreadExecutionState(1u, &PreviousFlags);
          LOBYTE(v40) = 0;
          v41 = 0LL;
          *(_OWORD *)((char *)this + 152) = v40;
        }
        v15 = Scheduler::EvaluateMissedRuns(g_pScheduler);
        v28 = v15;
        if ( v15 < 0
          && WPP_GLOBAL_Control != &WPP_GLOBAL_Control
          && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x400) != 0
          && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
        {
          WPP_SF_D(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x17u,
            (__int64)&WPP_e3966bf9b81b3ab085a9dfdc4dace9ef_Traceguids,
            v15);
        }
        ItSrvNotifyResume(0);
        _InterlockedExchange(&v27, 0);
        if ( _InterlockedExchangeAdd(&ShutdownMgr::s_sync, 0xFFFFFFFF) == 1 )
          SetEvent((HANDLE)_InterlockedCompareExchange64((volatile signed __int64 *)&ShutdownMgr::s_hEvent, -1LL, -1LL));
      }
      if ( byte_1800B0AF0 )
      {
        byte_1800B0AF0 = 0;
        Scheduler::NotifySleep(v12, 0);
      }
      goto LABEL_33;
    }
    if ( byte_1800B0AF0 )
    {
LABEL_33:
      _InterlockedExchange(&v23, 0);
      v10 = _InterlockedExchangeAdd(&ShutdownMgr::s_sync, 0xFFFFFFFF) == 1;
LABEL_15:
      if ( v10 )
        SetEvent((HANDLE)_InterlockedCompareExchange64((volatile signed __int64 *)&ShutdownMgr::s_hEvent, -1LL, -1LL));
      return v8;
    }
    TSTime::TSTime((TSTime *)&v31);
    v16 = v31;
    v38 = v31;
    v34 = v31;
    v33 = v31;
    JobMoniker::JobMoniker((JobMoniker *)v48, 0LL, 0LL);
    JobMoniker::JobMoniker((JobMoniker *)v54, 0LL, 0LL);
    JobMoniker::JobMoniker((JobMoniker *)v51, 0LL, 0LL);
    byte_1800B0AF0 = 1;
    TSTime::TSTime((TSTime *)&v45);
    *(_OWORD *)((char *)this + 168) = v45;
    Scheduler::NotifySleep(v17, byte_1800B0AF0);
    Scheduler::GetWakeupCall(v18, (struct TSTime *)&v34, (struct JobMoniker *)v51);
    if ( TSTime::operator>((__int64)&v38, &v31) && TSTime::operator>((__int64)&v34, &v31) )
    {
      if ( TSTime::operator<((__int64)&v38, &v34) )
        goto LABEL_89;
    }
    else
    {
      if ( TSTime::operator>((__int64)&v38, &v31) )
      {
LABEL_89:
        v22 = v54;
LABEL_91:
        v33 = v16;
        JobMoniker::operator=((__int64)v48, (__int64)v22);
        goto LABEL_55;
      }
      if ( !TSTime::operator>((__int64)&v34, &v31) )
      {
LABEL_55:
        if ( TSTime::operator>((__int64)&v33, &v31) )
        {
          if ( (unsigned int)TSTime::operator-((__int64)&v33, &v31) < 0x5A )
          {
            v16 = *(_OWORD *)TSTime::operator+((__int64)&v31, (__int64)v47, 90);
            v33 = v16;
          }
          v46 = v16;
          JobsService::SetWakeupTimer((__int64)this, (__int64)&v46, (JobMoniker *)v48);
        }
        ItSrvNotifyResume(1);
        wmi::AutoRef<JobBucket>::Release(&v53);
        _bstr_t::_Free((_bstr_t *)v52);
        wmi::AutoRef<JobBucket>::Release(&v56);
        _bstr_t::_Free((_bstr_t *)v55);
        wmi::AutoRef<JobBucket>::Release(&v50);
        _bstr_t::_Free((_bstr_t *)v49);
        goto LABEL_33;
      }
    }
    v22 = v51;
    v16 = v34;
    goto LABEL_91;
  }
  if ( a2 != 14 )
  {
    if ( a2 != 16 )
    {
      if ( a2 != 33 )
      {
        v8 = CNtService::HandlerEx(this, a2, a3, a4);
        v29 = v8;
        return v8;
      }
      v24 = 0;
      _InterlockedExchange(&v24, 0);
      _InterlockedIncrement(&ShutdownMgr::s_sync);
      _InterlockedExchange(&v24, _InterlockedCompareExchange(&dword_1800B0A14, 0, 0) != 0);
      if ( _InterlockedCompareExchange(&v24, 0, 0) )
      {
        if ( !*((_BYTE *)this + 128) )
        {
          _InterlockedExchange(&v24, 0);
          if ( _InterlockedExchangeAdd(&ShutdownMgr::s_sync, 0xFFFFFFFF) == 1 )
            SetEvent((HANDLE)_InterlockedCompareExchange64(
                               (volatile signed __int64 *)&ShutdownMgr::s_hEvent,
                               -1LL,
                               -1LL));
          return 0LL;
        }
        UbpmSessionStateChanged(a3, a4[1], *((_QWORD *)a4 + 1));
      }
      _InterlockedExchange(&v24, 0);
      goto LABEL_14;
    }
    v25 = 0;
    _InterlockedExchange(&v25, 0);
    _InterlockedIncrement(&ShutdownMgr::s_sync);
    v14 = (Scheduler *)(unsigned int)_InterlockedExchange(
                                       &v25,
                                       _InterlockedCompareExchange(&dword_1800B0A14, 0, 0) != 0);
    if ( _InterlockedCompareExchange(&v25, 0, 0) && g_pScheduler )
    {
      if ( !*((_BYTE *)this + 128) )
      {
        _InterlockedExchange(&v25, 0);
        if ( _InterlockedExchangeAdd(&ShutdownMgr::s_sync, 0xFFFFFFFF) == 1 )
          SetEvent((HANDLE)_InterlockedCompareExchange64((volatile signed __int64 *)&ShutdownMgr::s_hEvent, -1LL, -1LL));
        return 0LL;
      }
      Scheduler::NotifyTimeChange(v14);
    }
    _InterlockedExchange(&v25, 0);
    goto LABEL_14;
  }
  v26 = 0;
  _InterlockedExchange(&v26, 0);
  _InterlockedIncrement(&ShutdownMgr::s_sync);
  _InterlockedExchange(&v26, _InterlockedCompareExchange(&dword_1800B0A14, 0, 0) != 0);
  if ( !_InterlockedCompareExchange(&v26, 0, 0) )
  {
LABEL_13:
    _InterlockedExchange(&v26, 0);
LABEL_14:
    v10 = _InterlockedExchangeAdd(&ShutdownMgr::s_sync, 0xFFFFFFFF) == 1;
    goto LABEL_15;
  }
  if ( *((_BYTE *)this + 128) )
  {
    UbpmSessionStateChanged(a3, a4[1], 0LL);
    ppBuffer[0] = 0LL;
    v43 = ppBuffer;
    if ( WTSQuerySessionInformationW(0LL, a4[1], WTSUserName, ppBuffer, pBytesReturned) && pBytesReturned[0] >= 2 )
    {
      v9 = ppBuffer[0];
      if ( !ppBuffer[0] || !*ppBuffer[0] || (v13 = (struct _RTL_CRITICAL_SECTION *)g_pPseudoEventTrap) == 0LL )
      {
LABEL_11:
        if ( v9 )
          WTSFreeMemory(v9);
        goto LABEL_13;
      }
      if ( a3 == 5 )
      {
        User::NotifyLogon(a4[1], ppBuffer[0]);
        v13 = (struct _RTL_CRITICAL_SECTION *)g_pPseudoEventTrap;
      }
      PseudoEventTrap::QueueOrProcessSessionChange(v13, a3, a4[1]);
    }
    v9 = ppBuffer[0];
    goto LABEL_11;
  }
  _InterlockedExchange(&v26, 0);
  if ( _InterlockedExchangeAdd(&ShutdownMgr::s_sync, 0xFFFFFFFF) == 1 )
    SetEvent((HANDLE)_InterlockedCompareExchange64((volatile signed __int64 *)&ShutdownMgr::s_hEvent, -1LL, -1LL));
  return 0LL;
}
// 180023F20: could not find valid save-restore pair for rbp
// 18002430A: variable 'v12' is possibly undefined
// 1800243B3: variable 'v17' is possibly undefined
// 1800243C8: variable 'v18' is possibly undefined
// 18003EEF6: variable 'v21' is possibly undefined
// 18003EF30: variable 'v19' is possibly undefined
// 18003EF30: variable 'v20' is possibly undefined
// 180073D48: using guessed type __int64 __fastcall UbpmSessionStateChanged(_QWORD, _QWORD, _QWORD);
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 1800B0A10: using guessed type int ShutdownMgr::s_sync;
// 1800B0A14: using guessed type int dword_1800B0A14;
// 180023F20: using guessed type DWORD var_198[4];
// 180023F20: using guessed type char var_90[16];
// 180023F20: using guessed type char var_68[16];
// 180023F20: using guessed type char var_B8[16];
// 180023F20: using guessed type char var_D8[16];

//----- (00000001800244B0) ----------------------------------------------------
void __fastcall PseudoEventTrap::QueueOrProcessSessionChange(
        struct _RTL_CRITICAL_SECTION *this,
        unsigned int a2,
        DWORD a3)
{
  struct _RTL_CRITICAL_SECTION *v6; // rbx
  _QWORD **OwningThread; // rsi
  __int64 v8; // rcx
  _QWORD *v9; // rdx
  char *LockSemaphore; // rax
  unsigned __int64 v11; // [rsp+50h] [rbp+8h] BYREF
  struct _RTL_CRITICAL_SECTION *v12; // [rsp+68h] [rbp+20h]

  v6 = this + 4;
  EnterCriticalSection(this + 4);
  if ( LOBYTE(this[5].SpinCount) )
  {
    LeaveCriticalSection(v6);
    PseudoEventTrap::ProcessSessionChange((PseudoEventTrap *)this, a2, a3);
  }
  else
  {
    v11 = __PAIR64__(a3, a2);
    v12 = v6;
    EnterCriticalSection(v6);
    LeaveCriticalSection(v6);
    OwningThread = (_QWORD **)this[5].OwningThread;
    v9 = std::_List_buy<wmi::AutoVectorPtr<_SID_AND_ATTRIBUTES> *,std::allocator<wmi::AutoVectorPtr<_SID_AND_ATTRIBUTES> *>>::_Buynode<wmi::AutoVectorPtr<_SID_AND_ATTRIBUTES> * const &>(
           v8,
           OwningThread,
           OwningThread[1],
           &v11);
    LockSemaphore = (char *)this[5].LockSemaphore;
    if ( LockSemaphore == (char *)0xAAAAAAAAAAAAAA9LL )
      std::_Xlength_error("list<T> too long");
    this[5].LockSemaphore = LockSemaphore + 1;
    OwningThread[1] = v9;
    *(_QWORD *)v9[1] = v9;
    LeaveCriticalSection(v6);
  }
}
// 18003F2D8: variable 'v8' is possibly undefined

//----- (0000000180024524) ----------------------------------------------------
void __fastcall PseudoEventTrap::ProcessSessionChange(PseudoEventTrap *this, unsigned int a2, DWORD a3)
{
  __int64 v6; // rdx
  __int64 v7; // r8
  const char *v8; // [rsp+30h] [rbp-18h] BYREF
  const char *v9; // [rsp+68h] [rbp+20h] BYREF

  ControlEventToStrings(0xEu, a2, &v8, &v9);
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
  {
    WPP_SF_dsd(*((_QWORD *)WPP_GLOBAL_Control + 2), v6, v7, a2, (__int64)v9);
  }
  if ( a2 == 5 )
    PseudoEventTrap::NotifyLogon(this, a3);
  else
    PseudoEventTrap::NotifyOtherSessionChanges((struct _RTL_CRITICAL_SECTION *)this, a2, a3);
}
// 18003F351: variable 'v6' is possibly undefined
// 18003F351: variable 'v7' is possibly undefined
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180024598) ----------------------------------------------------
void __fastcall PseudoEventTrap::NotifyLogon(PseudoEventTrap *this, DWORD a2)
{
  void *v4; // r8
  int v5; // eax
  __int64 v6; // rsi
  struct _RTL_CRITICAL_SECTION *v7; // rdi
  __int64 **v8; // r14
  __int64 *v9; // rbx
  __int64 v10; // r15
  __int64 v11; // r8
  const struct JobMoniker *v12; // rdx
  __int64 v13; // rsi
  LogonJob *v14; // rcx
  __int64 v15; // rcx
  __int64 *i; // rax
  __int64 *v17; // rbx
  __int64 v18; // r8
  const struct JobMoniker *v19; // rdx
  __int64 v20; // rsi
  LogonJob *v21; // rcx
  __int64 v22; // rcx
  __int64 *j; // rax
  __int64 v24; // rdx
  __int64 v25; // r8
  User::UserEntry *v26; // [rsp+38h] [rbp-49h] BYREF
  unsigned __int64 v27; // [rsp+40h] [rbp-41h] BYREF
  DWORD pBytesReturned; // [rsp+48h] [rbp-39h] BYREF
  LPWSTR ppBuffer; // [rsp+50h] [rbp-31h] BYREF
  __int64 *v30[5]; // [rsp+58h] [rbp-29h] BYREF
  char v31[16]; // [rsp+80h] [rbp-1h] BYREF
  char v32[16]; // [rsp+90h] [rbp+Fh] BYREF
  wmi::RefBase *v33; // [rsp+A0h] [rbp+1Fh] BYREF

  v30[1] = (__int64 *)-2LL;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
  {
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x15u, (__int64)&WPP_c0b0770bd08e382a040e2237764c2feb_Traceguids, a2);
  }
  ppBuffer = 0LL;
  v30[2] = (__int64 *)&ppBuffer;
  v30[3] = 0LL;
  if ( *((_QWORD *)this + 19) )
  {
    if ( WTSQuerySessionInformationW(0LL, a2, WTSUserName, &ppBuffer, &pBytesReturned) )
    {
      if ( ppBuffer && pBytesReturned >= 2 && (int)StringCbLengthW(ppBuffer, pBytesReturned, &v27) >= 0 && v27 )
      {
        if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
          && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0
          && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
        {
          WPP_SF_dS(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x18u,
            (__int64)&WPP_c0b0770bd08e382a040e2237764c2feb_Traceguids,
            a2,
            (__int64)ppBuffer);
        }
        v26 = 0LL;
        v5 = User::FromUserSession(&v26, a2, v4);
        v6 = v5;
        if ( v5 >= 0 )
        {
          v7 = (struct _RTL_CRITICAL_SECTION *)((char *)this + 96);
          v30[4] = (__int64 *)((char *)this + 96);
          EnterCriticalSection((LPCRITICAL_SECTION)((char *)this + 96));
          v8 = (__int64 **)((char *)this + 144);
          v9 = (__int64 *)*std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::find(
                             (__int64)v8,
                             &v27,
                             &v26);
          v10 = v6;
          while ( v9 != *v8 && User::operator==((User *)(v9 + 4), (User *)&v26) )
          {
            v12 = (const struct JobMoniker *)v9[5];
            v13 = *((_QWORD *)v12 + 5);
            JobMoniker::JobMoniker((JobMoniker *)v31, v12, v11);
            if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v13 + 32LL))(v13)
              && (User::operator==((wmi::RefBase *)((char *)v33 + 64), (User *)&v26), v10 >= 0)
              && (*((_BYTE *)v33 + 16) & 1) != 0 )
            {
              v14 = (LogonJob *)v9[5];
              if ( v14 )
                LogonJob::`scalar deleting destructor'(v14);
              v9 = *std::_Tree<std::_Tmap_traits<User,LogonJob *,User::less,std::allocator<std::pair<User const,LogonJob *>>,1>>::erase(
                      v8,
                      v30,
                      v9);
            }
            else if ( !*((_BYTE *)v9 + 25) )
            {
              v15 = v9[2];
              if ( *(_BYTE *)(v15 + 25) )
              {
                for ( i = (__int64 *)v9[1]; !*((_BYTE *)i + 25) && v9 == (__int64 *)i[2]; i = (__int64 *)i[1] )
                  v9 = i;
              }
              else
              {
                i = std::_Tree_val<std::_Tree_simple_types<std::pair<_bstr_t const,std::list<_FILETIME> *>>>::_Min((_QWORD *)v15);
              }
              v9 = i;
            }
            wmi::AutoRef<JobBucket>::Release(&v33);
            _bstr_t::_Free((_bstr_t *)v32);
          }
          v27 = 0LL;
          v17 = (__int64 *)*std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::find(
                              (__int64)v8,
                              v30,
                              &v27);
          wmi::AutoRef<User::UserEntry>::Release(&v27);
          while ( v17 != *v8 && !v17[4] )
          {
            v19 = (const struct JobMoniker *)v17[5];
            v20 = *((_QWORD *)v19 + 5);
            JobMoniker::JobMoniker((JobMoniker *)v31, v19, v18);
            if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v20 + 32LL))(v20)
              && v10 >= 0
              && (*((_BYTE *)v33 + 16) & 1) != 0 )
            {
              v21 = (LogonJob *)v17[5];
              if ( v21 )
                LogonJob::`scalar deleting destructor'(v21);
              v17 = *std::_Tree<std::_Tmap_traits<User,LogonJob *,User::less,std::allocator<std::pair<User const,LogonJob *>>,1>>::erase(
                       v8,
                       (__int64 **)&v27,
                       v17);
            }
            else if ( !*((_BYTE *)v17 + 25) )
            {
              v22 = v17[2];
              if ( *(_BYTE *)(v22 + 25) )
              {
                for ( j = (__int64 *)v17[1]; !*((_BYTE *)j + 25) && v17 == (__int64 *)j[2]; j = (__int64 *)j[1] )
                  v17 = j;
              }
              else
              {
                j = std::_Tree_val<std::_Tree_simple_types<std::pair<_bstr_t const,std::list<_FILETIME> *>>>::_Min((_QWORD *)v22);
              }
              v17 = j;
            }
            wmi::AutoRef<JobBucket>::Release(&v33);
            _bstr_t::_Free((_bstr_t *)v32);
          }
          LeaveCriticalSection(v7);
        }
        else if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
               && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0
               && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
        {
          WPP_SF_D(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x19u,
            (__int64)&WPP_c0b0770bd08e382a040e2237764c2feb_Traceguids,
            v5);
        }
        wmi::AutoRef<User::UserEntry>::Release(&v26);
      }
      else if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
             && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0
             && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
      {
        WPP_SF_D(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x16u,
          (__int64)&WPP_c0b0770bd08e382a040e2237764c2feb_Traceguids,
          a2);
      }
    }
    else if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
           && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0
           && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
    {
      GetLastError();
      WPP_SF_dd(*((_QWORD *)WPP_GLOBAL_Control + 2), v24, v25, a2);
    }
  }
  operator delete(0LL);
  if ( ppBuffer )
    WTSFreeMemory(ppBuffer);
}
// 18003F437: variable 'v4' is possibly undefined
// 18003F4F3: variable 'v11' is possibly undefined
// 18003F5DB: variable 'v18' is possibly undefined
// 18003F6F4: variable 'v24' is possibly undefined
// 18003F6F4: variable 'v25' is possibly undefined
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180024658) ----------------------------------------------------
void __fastcall ControlEventToStrings(unsigned int a1, unsigned int a2, const char **a3, const char **a4)
{
  unsigned int v4; // ecx
  unsigned int v5; // ecx
  unsigned int v6; // ecx
  unsigned int v7; // ecx
  unsigned int v8; // ecx
  unsigned int v9; // edx
  unsigned int v10; // edx
  unsigned int v11; // edx
  unsigned int v12; // edx
  unsigned int v13; // edx
  const char *v14; // rax
  unsigned int v15; // ecx
  unsigned int v16; // ecx
  unsigned int v17; // ecx
  unsigned int v18; // ecx
  unsigned int v19; // ecx
  unsigned int v20; // ecx
  const char *v21; // rax
  unsigned int v22; // edx
  unsigned int v23; // edx
  unsigned int v24; // edx
  unsigned int v25; // edx
  unsigned int v26; // edx
  unsigned int v27; // edx
  unsigned int v28; // edx
  unsigned int v29; // edx
  unsigned int v30; // edx
  unsigned int v31; // edx
  unsigned int v32; // edx
  unsigned int v33; // edx

  *a4 = (const char *)&word_18007630E;
  if ( a1 > 8 )
  {
    v4 = a1 - 9;
    if ( !v4 )
    {
      v21 = "SERVICE_CONTROL_NETBINDENABLE";
      goto LABEL_77;
    }
    v5 = v4 - 1;
    if ( !v5 )
    {
      v21 = "SERVICE_CONTROL_NETBINDDISABLE";
      goto LABEL_77;
    }
    v6 = v5 - 1;
    if ( !v6 )
    {
      v21 = "SERVICE_CONTROL_DEVICEEVENT";
      goto LABEL_77;
    }
    v7 = v6 - 1;
    if ( !v7 )
    {
      v21 = "SERVICE_CONTROL_HARDWAREPROFILECHANGE";
      goto LABEL_77;
    }
    v8 = v7 - 1;
    if ( v8 )
    {
      if ( v8 == 1 )
      {
        *a3 = "SERVICE_CONTROL_SESSIONCHANGE";
        v9 = a2 - 1;
        if ( v9 )
        {
          v10 = v9 - 1;
          if ( v10 )
          {
            v11 = v10 - 1;
            if ( v11 )
            {
              v12 = v11 - 1;
              if ( v12 )
              {
                v13 = v12 - 1;
                if ( v13 )
                {
                  v22 = v13 - 1;
                  if ( v22 )
                  {
                    v23 = v22 - 1;
                    if ( v23 )
                    {
                      v24 = v23 - 1;
                      if ( v24 )
                      {
                        if ( v24 == 1 )
                          v14 = "WTS_SESSION_REMOTE_CONTROL";
                        else
                          v14 = "UNKNOWN SESSIONCHANGE";
                      }
                      else
                      {
                        v14 = "WTS_SESSION_UNLOCK";
                      }
                    }
                    else
                    {
                      v14 = "WTS_SESSION_LOCK";
                    }
                  }
                  else
                  {
                    v14 = "WTS_SESSION_LOGOFF";
                  }
                }
                else
                {
                  v14 = "WTS_SESSION_LOGON";
                }
              }
              else
              {
                v14 = "WTS_REMOTE_DISCONNECT";
              }
            }
            else
            {
              v14 = "WTS_REMOTE_CONNECT";
            }
          }
          else
          {
            v14 = "WTS_CONSOLE_DISCONNECT";
          }
        }
        else
        {
          v14 = "WTS_CONSOLE_CONNECT";
        }
        goto LABEL_14;
      }
      goto LABEL_35;
    }
    *a3 = "SERVICE_CONTROL_POWEREVENT";
    if ( a2 > 6 )
    {
      v29 = a2 - 7;
      if ( !v29 )
      {
        v14 = "PBT_APMRESUMESUSPEND";
        goto LABEL_14;
      }
      v30 = v29 - 1;
      if ( !v30 )
      {
        v14 = "PBT_APMRESUMESTANDBY";
        goto LABEL_14;
      }
      v31 = v30 - 1;
      if ( !v31 )
      {
        v14 = "PBT_APMBATTERYLOW";
        goto LABEL_14;
      }
      v32 = v31 - 1;
      if ( !v32 )
      {
        v14 = "PBT_APMPOWERSTATUSCHANGE";
        goto LABEL_14;
      }
      v33 = v32 - 1;
      if ( !v33 )
      {
        v14 = "PBT_APMOEMEVENT";
        goto LABEL_14;
      }
      if ( v33 == 7 )
      {
        v14 = "PBT_APMRESUMEAUTOMATIC";
        goto LABEL_14;
      }
    }
    else
    {
      if ( a2 == 6 )
      {
        v14 = "PBT_APMRESUMECRITICAL";
        goto LABEL_14;
      }
      if ( !a2 )
      {
        v14 = "PBT_APMQUERYSUSPEND";
        goto LABEL_14;
      }
      v25 = a2 - 1;
      if ( !v25 )
      {
        v14 = "PBT_APMQUERYSTANDBY";
        goto LABEL_14;
      }
      v26 = v25 - 1;
      if ( !v26 )
      {
        v14 = "PBT_APMQUERYSUSPENDFAILED";
        goto LABEL_14;
      }
      v27 = v26 - 1;
      if ( !v27 )
      {
        v14 = "PBT_APMQUERYSTANDBYFAILED";
        goto LABEL_14;
      }
      v28 = v27 - 1;
      if ( !v28 )
      {
        v14 = "PBT_APMSUSPEND";
        goto LABEL_14;
      }
      if ( v28 == 1 )
      {
        v14 = "PBT_APMSTANDBY";
LABEL_14:
        *a4 = v14;
        return;
      }
    }
    v14 = "UNKNOWN POWEREVENT";
    goto LABEL_14;
  }
  if ( a1 == 8 )
  {
    v21 = "SERVICE_CONTROL_NETBINDREMOVE";
  }
  else
  {
    v15 = a1 - 1;
    if ( v15 )
    {
      v16 = v15 - 1;
      if ( v16 )
      {
        v17 = v16 - 1;
        if ( v17 )
        {
          v18 = v17 - 1;
          if ( v18 )
          {
            v19 = v18 - 1;
            if ( v19 )
            {
              v20 = v19 - 1;
              if ( v20 )
              {
                if ( v20 != 1 )
                {
LABEL_35:
                  v21 = "UNKNOWN SERVICE CONTROL";
                  goto LABEL_77;
                }
                v21 = "SERVICE_CONTROL_NETBINDADD";
              }
              else
              {
                v21 = "SERVICE_CONTROL_PARAMCHANGE";
              }
            }
            else
            {
              v21 = "SERVICE_CONTROL_SHUTDOWN";
            }
          }
          else
          {
            v21 = "SERVICE_CONTROL_INTERROGATE";
          }
        }
        else
        {
          v21 = "SERVICE_CONTROL_CONTINUE";
        }
      }
      else
      {
        v21 = "SERVICE_CONTROL_PAUSE";
      }
    }
    else
    {
      v21 = "SERVICE_CONTROL_STOP";
    }
  }
LABEL_77:
  *a3 = v21;
}

//----- (00000001800246FC) ----------------------------------------------------
void __fastcall User::NotifyLogon(DWORD SessionId, const unsigned __int16 *a2)
{
  LPWSTR v3; // rcx
  const char *v4; // rdx
  const unsigned __int16 *v5; // r8
  const WCHAR *v6; // rdx
  void **v7; // [rsp+48h] [rbp-C0h] BYREF
  LPWSTR ppBuffer; // [rsp+50h] [rbp-B8h] BYREF
  const WCHAR **v9; // [rsp+58h] [rbp-B0h] BYREF
  DWORD pBytesReturned; // [rsp+60h] [rbp-A8h] BYREF
  __int64 *v11; // [rsp+68h] [rbp-A0h] BYREF
  const wchar_t **v12[3]; // [rsp+70h] [rbp-98h] BYREF
  char v13[8]; // [rsp+88h] [rbp-80h] BYREF
  char v14[72]; // [rsp+90h] [rbp-78h] BYREF
  enum _SID_NAME_USE v15; // [rsp+D8h] [rbp-30h]

  v12[1] = (const wchar_t **)-2LL;
  ppBuffer = 0LL;
  v12[2] = (const wchar_t **)&ppBuffer;
  if ( WTSQuerySessionInformationW(0LL, SessionId, WTSDomainName, &ppBuffer, &pBytesReturned) && pBytesReturned >= 2 )
  {
    v3 = ppBuffer;
    if ( !ppBuffer || !*ppBuffer )
      goto LABEL_13;
    ATL::CSid::CSid((ATL::CSid *)v13);
    _bstr_t::_bstr_t((_bstr_t *)&v9, ppBuffer);
    _bstr_t::_bstr_t((_bstr_t *)&v7, v4);
    _bstr_t::operator+=((OLECHAR ***)&v9, (BSTR **)&v7);
    _bstr_t::_Free((_bstr_t *)&v7);
    _bstr_t::_bstr_t((_bstr_t *)&v7, a2);
    _bstr_t::operator+=((OLECHAR ***)&v9, (BSTR **)&v7);
    _bstr_t::_Free((_bstr_t *)&v7);
    if ( v9 )
      v6 = *v9;
    else
      v6 = 0LL;
    if ( ATL::CSid::LoadAccount((ATL::CSid *)v13, v6, v5) )
    {
      User::LookupUser((User::UserEntry **)&v7, v14);
      if ( v7 )
      {
        _bstr_t::_bstr_t((_bstr_t *)v12, ppBuffer);
        _bstr_t::_bstr_t((_bstr_t *)&v11, a2);
        User::UpdateEntry(&v7, &v11, v12, (const struct _bstr_t *)&v9, v15, v14, 0);
        _bstr_t::_Free((_bstr_t *)&v11);
        _bstr_t::_Free((_bstr_t *)v12);
      }
      wmi::AutoRef<User::UserEntry>::Release(&v7);
    }
    _bstr_t::_Free((_bstr_t *)&v9);
    ATL::CSid::~CSid((ATL::CSid *)v13);
  }
  v3 = ppBuffer;
LABEL_13:
  if ( v3 )
    WTSFreeMemory(v3);
}
// 1800247AA: variable 'v4' is possibly undefined
// 180024807: variable 'v5' is possibly undefined
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);
// 1800246FC: using guessed type char var_90[8];

//----- (0000000180024890) ----------------------------------------------------
char __fastcall ATL::CSid::LoadAccount(ATL::CSid *this, LPCWSTR lpAccountName, const unsigned __int16 *a3)
{
  WCHAR *v5; // rsi
  __int64 v6; // rdi
  __int64 v7; // rax
  DWORD cbSid[2]; // [rsp+48h] [rbp-C0h] BYREF
  __int64 v10; // [rsp+50h] [rbp-B8h]
  LPWSTR ReferencedDomainName; // [rsp+58h] [rbp-B0h] BYREF
  char v12[136]; // [rsp+60h] [rbp-A8h] BYREF
  char Sid[80]; // [rsp+E8h] [rbp-20h] BYREF

  v10 = -2LL;
  ATL::CSid::Clear(this);
  if ( !lpAccountName )
    return 0;
  ReferencedDomainName = 0LL;
  ATL::CTempBuffer<unsigned short,128,ATL::CCRTAllocator>::AllocateBytes(&ReferencedDomainName, 0x100uLL);
  v5 = ReferencedDomainName;
  cbSid[1] = 68;
  cbSid[0] = 128;
  if ( !LookupAccountNameW(0LL, lpAccountName, Sid, &cbSid[1], ReferencedDomainName, cbSid, (PSID_NAME_USE)this + 20) )
  {
    if ( GetLastError() != 122 )
      goto LABEL_20;
    if ( cbSid[1] > 0x44 )
      ATL::PrivateAtlThrow(-2147467259);
    if ( cbSid[0] > 0x80 )
    {
      ATL::CTempBuffer<unsigned short,128,ATL::CCRTAllocator>::Reallocate(
        (void **)&ReferencedDomainName,
        2LL * cbSid[0]);
      v5 = ReferencedDomainName;
    }
    if ( !LookupAccountNameW(0LL, lpAccountName, Sid, &cbSid[1], v5, cbSid, (PSID_NAME_USE)this + 20) )
      goto LABEL_20;
  }
  *((_BYTE *)this + 76) = 1;
  if ( !CopySid(cbSid[1], (char *)this + 8, Sid) )
  {
LABEL_20:
    ATL::CSid::Clear(this);
    if ( ReferencedDomainName != (LPWSTR)v12 )
      ATL::CTempBuffer<unsigned short,128,ATL::CCRTAllocator>::FreeHeap((void **)&ReferencedDomainName);
    return 0;
  }
  v6 = -1LL;
  if ( v5 )
  {
    v7 = -1LL;
    do
      ++v7;
    while ( v5[v7] );
  }
  else
  {
    LODWORD(v7) = 0;
  }
  ATL::CSimpleStringT<unsigned short,0>::SetString((__int64 *)this + 12, v5, v7);
  do
    ++v6;
  while ( lpAccountName[v6] );
  ATL::CSimpleStringT<unsigned short,0>::SetString((__int64 *)this + 11, lpAccountName, v6);
  ATL::CSimpleStringT<unsigned short,0>::SetString((__int64 *)this + 14, 0LL, 0);
  if ( ReferencedDomainName != (LPWSTR)v12 )
    ATL::CTempBuffer<unsigned short,128,ATL::CCRTAllocator>::FreeHeap((void **)&ReferencedDomainName);
  return 1;
}

//----- (00000001800249F8) ----------------------------------------------------
void __fastcall ATL::CTempBuffer<unsigned short,128,ATL::CCRTAllocator>::FreeHeap(void **a1)
{
  free(*a1);
}

//----- (0000000180024A10) ----------------------------------------------------
_QWORD *__fastcall ATL::CTempBuffer<unsigned short,128,ATL::CCRTAllocator>::AllocateBytes(_QWORD *a1, size_t a2)
{
  _QWORD *result; // rax

  if ( a2 <= 0x80 )
  {
    result = a1 + 1;
    *a1 = a1 + 1;
  }
  else
  {
    ATL::CTempBuffer<unsigned short,128,ATL::CCRTAllocator>::AllocateHeap(a1, a2);
    return (_QWORD *)*a1;
  }
  return result;
}

//----- (0000000180024A40) ----------------------------------------------------
void *__fastcall ATL::CTempBuffer<unsigned short,128,ATL::CCRTAllocator>::AllocateHeap(_QWORD *a1, size_t a2)
{
  void *result; // rax

  result = malloc(a2);
  if ( !result )
    ATL::PrivateAtlThrow(-2147024882);
  *a1 = result;
  return result;
}

//----- (0000000180024A80) ----------------------------------------------------
struct ATL::CStringData *__fastcall ATL::CAtlStringMgr::Allocate(ATL::CAtlStringMgr *this, int a2, int a3)
{
  signed int v4; // ebx
  struct ATL::CStringData *result; // rax
  unsigned __int64 v6; // [rsp+48h] [rbp+20h] BYREF

  if ( a2 < 0 )
    return 0LL;
  if ( 0x7FFFFFFF - a2 < 1 )
    return 0LL;
  v4 = (a2 + 8) & 0xFFFFFFF8;
  if ( a2 >= v4 )
    return 0LL;
  if ( (int)ATL::AtlMultiply<unsigned __int64>(&v6, v4, a3) < 0 )
    return 0LL;
  if ( v6 > 0xFFFFFFFFFFFFFFE7uLL )
    return 0LL;
  result = (struct ATL::CStringData *)(***((__int64 (__fastcall ****)(_QWORD, __int64))this + 1))(
                                        *((_QWORD *)this + 1),
                                        v6 + 24);
  if ( !result )
    return 0LL;
  *((_DWORD *)result + 2) = 0;
  *((_DWORD *)result + 3) = v4 - 1;
  *(_QWORD *)result = this;
  *((_DWORD *)result + 4) = 1;
  return result;
}

//----- (0000000180024B0C) ----------------------------------------------------
__int64 __fastcall ATL::AtlMultiply<unsigned __int64>(_QWORD *a1, unsigned __int64 a2, unsigned __int64 a3)
{
  if ( !a2 )
  {
    *a1 = 0LL;
    return 0LL;
  }
  if ( 0xFFFFFFFFFFFFFFFFuLL / a2 >= a3 )
  {
    *a1 = a3 * a2;
    return 0LL;
  }
  return 2147942487LL;
}

//----- (0000000180024B40) ----------------------------------------------------
_bstr_t *__fastcall _bstr_t::_bstr_t(_bstr_t *this, const char *a2)
{
  BSTR *v3; // rax
  const char *v4; // rcx
  BSTR *v5; // rbx
  BSTR v6; // rax
  void **pExceptionObject; // [rsp+28h] [rbp-30h] BYREF
  int v9; // [rsp+30h] [rbp-28h]
  __int128 v10; // [rsp+38h] [rbp-20h]

  v3 = (BSTR *)operator new(0x18uLL);
  v5 = v3;
  if ( v3 )
  {
    v3[1] = 0LL;
    *((_DWORD *)v3 + 4) = 1;
    v6 = _com_util::_ConvertStringToBSTR(v4);
    *v5 = v6;
    if ( !v6 )
    {
      pExceptionObject = &_com_error::`vftable';
      v9 = -2147024882;
      v10 = 0LL;
      CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI1_AV_com_error__);
    }
  }
  else
  {
    v5 = 0LL;
  }
  *(_QWORD *)this = v5;
  if ( !v5 )
  {
    pExceptionObject = &_com_error::`vftable';
    v9 = -2147024882;
    v10 = 0LL;
    CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI1_AV_com_error__);
  }
  return this;
}
// 180024B7E: variable 'v4' is possibly undefined
// 180071858: using guessed type void *_com_error::`vftable';

//----- (0000000180024BC0) ----------------------------------------------------
__int64 __fastcall SchRpcDelete(__int64 a1, unsigned __int16 *a2, int a3)
{
  return RpcServer::Delete((RTL_SRWLOCK *)&RpcServer::s_singleton, a2, a3);
}
// 180024BC0: could not find valid save-restore pair for rbp
// 1800B0D48: using guessed type __int64 RpcServer::s_singleton;

//----- (0000000180024BF4) ----------------------------------------------------
__int64 __fastcall RpcServer::Delete(RTL_SRWLOCK *this, unsigned __int16 *a2, int a3)
{
  __int64 v6; // rcx
  int CallerToken; // esi
  const unsigned __int16 *v8; // r8
  RTL_SRWLOCK *v9; // rbx
  JobStore *v10; // r15
  RTL_SRWLOCK *v11; // rcx
  wchar_t *v12; // rdi
  __int64 v13; // rcx
  int v15[2]; // [rsp+38h] [rbp-D0h] BYREF
  HANDLE ClientToken; // [rsp+40h] [rbp-C8h] BYREF
  unsigned __int16 *v17; // [rsp+48h] [rbp-C0h]
  __int64 v18; // [rsp+50h] [rbp-B8h]
  char v19[16]; // [rsp+58h] [rbp-B0h] BYREF
  char v20[16]; // [rsp+68h] [rbp-A0h] BYREF
  __int64 v21; // [rsp+78h] [rbp-90h] BYREF
  wchar_t Str[264]; // [rsp+88h] [rbp-80h] BYREF

  v18 = -2LL;
  JobMoniker::JobMoniker((JobMoniker *)v19, 0LL, 0LL);
  v15[0] = 1;
  ClientToken = 0LL;
  if ( (unsigned int)dword_1800AFF68 > 5 && (unsigned __int8)tlgKeywordOn(&dword_1800AFF68, 0LL) )
    _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<>(
      v6,
      &unk_18007F16E);
  if ( !a2 || a3 )
  {
    CallerToken = -2147024809;
    goto LABEL_21;
  }
  memset_0(Str, 0, 0x20AuLL);
  CallerToken = tsched::TaskPathCanonicalize((tsched *)Str, a2, v8);
  if ( CallerToken < 0 )
    goto LABEL_21;
  a2 = Str;
  v9 = this + 2;
  v17 = (unsigned __int16 *)&this[2];
  AcquireSRWLockExclusive(this + 2);
  v10 = JobStore::m_pCommonStore;
  CallerToken = GetCallerToken(L"Delete", &ClientToken);
  if ( CallerToken < 0 )
    goto LABEL_9;
  v12 = wcsrchr(Str, 0x5Cu);
  *v12 = 0;
  CallerToken = TaskAccessCheck(ClientToken, Str, 0x40u);
  *v12 = 92;
  if ( CallerToken == -2147024891 )
    CallerToken = TaskAccessCheck(ClientToken, Str, 0x10000u);
  if ( CallerToken < 0 )
  {
LABEL_9:
    v11 = v9;
LABEL_10:
    ReleaseSRWLockExclusive(v11);
    goto LABEL_21;
  }
  CallerToken = JobStore::RemoveTaskOrFolder(v10, Str, v15, (struct JobMoniker *)v19);
  v11 = v9;
  if ( CallerToken < 0 )
    goto LABEL_10;
  ReleaseSRWLockExclusive(v9);
  if ( v15[0] )
  {
    if ( (*(_DWORD *)(v21 + 16) & 0x2000000) != 0 )
    {
      CallerToken = (*((__int64 (__fastcall **)(void ***, char *))UbpmProxySingleton::s_singleton[0] + 1))(
                      UbpmProxySingleton::s_singleton,
                      v19);
      if ( CallerToken < 0 )
        CallerToken = 0;
    }
    else
    {
      CallerToken = RpcServer::FlushTriggers((const struct JobMoniker *)v19);
      if ( CallerToken < 0 )
        CallerToken = 0;
    }
  }
LABEL_21:
  if ( (unsigned int)dword_1800AFF68 > 4 && (unsigned __int8)tlgKeywordOn(&dword_1800AFF68, 0LL) )
  {
    v15[0] = CallerToken;
    v17 = a2;
    _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapSz<unsigned short>,_tlgWrapperByVal<4>>(
      v13,
      &unk_18007F126);
  }
  wmi::AutoHandle::~AutoHandle((wmi::AutoHandle *)&ClientToken);
  wmi::AutoRef<JobBucket>::Release(&v21);
  _bstr_t::_Free((_bstr_t *)v20);
  return (unsigned int)CallerToken;
}
// 180024C7F: variable 'v6' is possibly undefined
// 180024CAF: variable 'v8' is possibly undefined
// 180024E24: variable 'v13' is possibly undefined
// 180001008: using guessed type __int64 __fastcall _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<>(_QWORD, _QWORD);
// 180001454: using guessed type __int64 __fastcall _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapSz<unsigned short>,_tlgWrapperByVal<4>>(_QWORD, _QWORD);
// 18001306C: using guessed type __int64 __fastcall wmi::AutoRef<JobBucket>::Release(_QWORD);
// 18002B810: using guessed type __int64 __fastcall tlgKeywordOn(_QWORD, _QWORD);
// 1800AFFB0: using guessed type void **UbpmProxySingleton::s_singleton[2];
// 180024BF4: using guessed type char var_260[16];

//----- (0000000180024E84) ----------------------------------------------------
void __fastcall ATL::CSimpleStringT<unsigned short,0>::PrepareWrite2(__int64 *a1, signed int a2)
{
  __int64 v2; // rax
  signed int v3; // r8d
  int v5; // ecx
  int v6; // eax
  int v7; // eax

  v2 = *a1;
  v3 = a2;
  if ( *(_DWORD *)(*a1 - 16) > a2 )
    v3 = *(_DWORD *)(v2 - 16);
  if ( *(int *)(v2 - 8) <= 1 )
  {
    v5 = *(_DWORD *)(v2 - 12);
    if ( v5 < v3 )
    {
      if ( v5 <= 0x40000000 )
        v6 = v5 / 2;
      else
        v6 = 0x100000;
      v7 = v5 + v6;
      if ( v7 >= v3 )
        v3 = v7;
      ATL::CSimpleStringT<unsigned short,0>::Reallocate(a1, v3);
    }
  }
  else
  {
    ATL::CSimpleStringT<unsigned short,0>::Fork((const void **)a1, v3);
  }
}

//----- (0000000180024EB8) ----------------------------------------------------
void __fastcall ATL::CSimpleStringT<unsigned short,0>::Fork(const void **a1, unsigned int a2)
{
  char *v2; // rbp
  int v5; // edi
  __int64 (__fastcall ***v6)(_QWORD, _QWORD, __int64); // rax
  __int64 v7; // rsi

  v2 = (char *)*a1;
  v5 = *((_DWORD *)*a1 - 4);
  v6 = (__int64 (__fastcall ***)(_QWORD, _QWORD, __int64))(*(__int64 (__fastcall **)(_QWORD))(**((_QWORD **)*a1 - 3)
                                                                                            + 32LL))(*((_QWORD *)*a1 - 3));
  v7 = (**v6)(v6, a2, 2LL);
  if ( !v7 )
    ATL::CSimpleStringT<unsigned short,0>::ThrowMemoryException();
  if ( v5 < (int)a2 )
    a2 = v5;
  memcpy_s((void *const)(v7 + 24), 2LL * (int)(a2 + 1), v2, 2LL * (int)(a2 + 1));
  *(_DWORD *)(v7 + 8) = v5;
  ATL::CStringData::Release((ATL::CStringData *)(v2 - 24));
  *a1 = (const void *)(v7 + 24);
}

//----- (0000000180024F68) ----------------------------------------------------
void __fastcall ATL::CSimpleStringT<unsigned short,0>::SetString(__int64 *a1, const void *a2, signed int a3)
{
  __int64 v3; // rdi
  char *v6; // r10
  unsigned __int64 v7; // rsi
  unsigned __int64 v8; // r14
  rsize_t v9; // rdx
  rsize_t v10; // r9

  v3 = a3;
  if ( a3 )
  {
    if ( !a2 )
      ATL::PrivateAtlThrow(-2147024809);
    v6 = (char *)*a1;
    v7 = ((__int64)a2 - *a1) >> 1;
    v8 = *(unsigned int *)(*a1 - 16);
    if ( ((*(_DWORD *)(*a1 - 12) - a3) | (1 - *(_DWORD *)(*a1 - 8))) < 0 )
    {
      ATL::CSimpleStringT<unsigned short,0>::PrepareWrite2(a1, a3);
      v6 = (char *)*a1;
    }
    v9 = 2 * v3;
    v10 = 2 * v3;
    if ( v7 <= v8 )
      memmove_s(v6, v9, &v6[2 * v7], v10);
    else
      memcpy_s(v6, v9, a2, v10);
    ATL::CSimpleStringT<unsigned short,0>::SetLength(a1, v3);
  }
  else
  {
    ATL::CSimpleStringT<unsigned short,0>::Empty(a1);
  }
}

//----- (0000000180025024) ----------------------------------------------------
__int64 __fastcall Scheduler::CalcWait(Scheduler *this, struct _FILETIME *const a2, struct _FILETIME *const a3)
{
  __int64 v6; // rbx
  __int64 v7; // r13
  JobStore *v8; // rbx
  struct _SYSTEMTIME LocalTime; // [rsp+80h] [rbp-19h] BYREF
  struct _SYSTEMTIME v11; // [rsp+90h] [rbp-9h] BYREF
  struct _SYSTEMTIME SystemTime; // [rsp+A0h] [rbp+7h] BYREF

  v6 = 0LL;
  if ( CompareFileTime(a2, a3) < 0 )
  {
    *(struct _FILETIME *)&v11.wYear = *a2;
    *(struct _FILETIME *)&LocalTime.wYear = *a3;
    v6 = (*(_QWORD *)&LocalTime.wYear - *(_QWORD *)&v11.wYear) / 10000LL;
    if ( v6 > 0xFFFFFFFFLL )
      v6 = 0xFFFFFFFFLL;
  }
  v7 = *((_BYTE *)this + 472) != 0 ? 10000LL : 200LL;
  if ( v6 >= v7 )
    v7 = v6;
  v8 = JobStore::m_pCommonStore;
  if ( v7 > 4294547295LL )
    LODWORD(v7) = -420001;
  JobStore::WaitForConfiguration(JobStore::m_pCommonStore);
  if ( *(_DWORD *)(*((_QWORD *)v8 + 10) + 136LL) > 8u )
  {
    FileTimeToSystemTime(a2, &SystemTime);
    SystemTimeToTzSpecificLocalTime(0LL, &SystemTime, &LocalTime);
    FileTimeToSystemTime(a3, &SystemTime);
    SystemTimeToTzSpecificLocalTime(0LL, &SystemTime, &v11);
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x2000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
    {
      WPP_SF_ddddddddddddd(*((_QWORD *)WPP_GLOBAL_Control + 2), v11.wMinute, v11.wHour, LocalTime.wYear);
    }
  }
  return (unsigned int)v7;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180025140) ----------------------------------------------------
__int64 __fastcall CNtService::_HandlerEx(DWORD dwControl, DWORD dwEventType, LPVOID lpEventData, LPVOID lpContext)
{
  return (*(__int64 (__fastcall **)(LPVOID, _QWORD, _QWORD, LPVOID, LPVOID))(*(_QWORD *)lpContext + 64LL))(
           lpContext,
           dwControl,
           dwEventType,
           lpEventData,
           lpContext);
}

//----- (0000000180025170) ----------------------------------------------------
__int64 __fastcall Scheduler::EvaluateScheduledJobs(__int64 a1, __int64 a2, __int64 a3)
{
  _OWORD *v3; // r15
  unsigned int v5; // esi
  int v6; // r14d
  struct _RTL_CRITICAL_SECTION *v7; // rbx
  __int64 v8; // rdi
  __int128 *v10; // rbx
  int v11; // r15d
  const wchar_t *Path; // rax
  _QWORD v13[3]; // [rsp+30h] [rbp-B1h] BYREF
  _OWORD *v14; // [rsp+48h] [rbp-99h]
  struct _RTL_CRITICAL_SECTION *v15; // [rsp+50h] [rbp-91h]
  __int64 v16; // [rsp+58h] [rbp-89h]
  __int128 v17; // [rsp+68h] [rbp-79h] BYREF
  __int128 v18[5]; // [rsp+78h] [rbp-69h] BYREF
  __int64 v19; // [rsp+C8h] [rbp-19h]
  char v20[16]; // [rsp+D8h] [rbp-9h] BYREF
  char v21[16]; // [rsp+E8h] [rbp+7h] BYREF
  wmi::RefBase *v22; // [rsp+F8h] [rbp+17h] BYREF

  v16 = -2LL;
  v3 = (_OWORD *)a3;
  v14 = (_OWORD *)a3;
  v13[1] = a2;
  v5 = 0;
  v6 = 0;
  Scheduling::JobSchedule::JobSchedule((struct _FILETIME *)v18);
  JobMoniker::JobMoniker((JobMoniker *)v20, 0LL, 0LL);
  v7 = (struct _RTL_CRITICAL_SECTION *)(a1 + 32);
  v15 = (struct _RTL_CRITICAL_SECTION *)(a1 + 32);
  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 32));
  v8 = *(_QWORD *)(a1 + 328);
  if ( v8 != a1 + 320 )
  {
    v10 = (__int128 *)v13[1];
    do
    {
      v18[0] = *(_OWORD *)(v8 + 64);
      v18[1] = *(_OWORD *)(v8 + 80);
      v18[2] = *(_OWORD *)(v8 + 96);
      v18[3] = *(_OWORD *)(v8 + 112);
      v18[4] = *(_OWORD *)(v8 + 128);
      v19 = *(_QWORD *)(v8 + 144);
      JobMoniker::operator=((__int64)v20, v8 + 24);
      v8 = *(_QWORD *)(v8 + 8);
      *(_OWORD *)&v13[1] = *v3;
      v17 = *v10;
      v11 = Scheduler::EvaluateScheduledJob(a1, (__int64)v18, (JobMoniker *)v20, &v17, (__int128 *)&v13[1]);
      if ( v11 < 0 )
      {
        if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
          && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x2000) != 0
          && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
        {
          Path = JobMoniker::GetPath((JobMoniker *)v20);
          WPP_SF_SD(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x10u,
            (__int64)&WPP_5435fee58aaf3c352ed5cdc6abf88a31_Traceguids,
            Path);
        }
        v6 = v11;
      }
      v3 = v14;
    }
    while ( v8 != a1 + 320 );
    v5 = v6;
    v7 = v15;
  }
  LeaveCriticalSection(v7);
  wmi::AutoRef<JobBucket>::Release(&v22);
  _bstr_t::_Free((_bstr_t *)v21);
  return v5;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 180025170: using guessed type char var_50[16];

//----- (0000000180025258) ----------------------------------------------------
__int64 __fastcall Scheduler::StartFirstMissedRun(Scheduler *this, int a2)
{
  struct _RTL_CRITICAL_SECTION *v2; // rbx
  __int64 v5; // r8
  unsigned int v6; // edi
  _DWORD *v8; // rsi
  const wchar_t *Path; // rax
  const unsigned __int16 *v10; // rax
  EventManager *v11; // rcx
  struct _GUID v12; // [rsp+30h] [rbp-58h] BYREF
  char v13[16]; // [rsp+40h] [rbp-48h] BYREF
  char v14[16]; // [rsp+50h] [rbp-38h] BYREF
  wmi::RefBase *v15; // [rsp+60h] [rbp-28h] BYREF

  v2 = (struct _RTL_CRITICAL_SECTION *)((char *)this + 32);
  EnterCriticalSection((LPCRITICAL_SECTION)((char *)this + 32));
  if ( *((Scheduler **)this + 23) == (Scheduler *)((char *)this + 176) )
  {
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
    {
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x1Du,
        (__int64)&WPP_5435fee58aaf3c352ed5cdc6abf88a31_Traceguids,
        a2);
    }
    v6 = 0;
  }
  else
  {
    v8 = (_DWORD *)*((_QWORD *)this + 23);
    v6 = 0;
    if ( v8[6] || v8[7] )
    {
      JobMoniker::JobMoniker((JobMoniker *)v13, (const struct JobMoniker *)(v8 + 10), v5);
      v12 = 0LL;
      SortedRunListItem::Delete((SortedRunListItem *)v8);
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
      {
        Path = JobMoniker::GetPath((JobMoniker *)v13);
        WPP_SF_SD(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x1Fu,
          (__int64)&WPP_5435fee58aaf3c352ed5cdc6abf88a31_Traceguids,
          Path);
      }
      v10 = JobMoniker::GetPath((JobMoniker *)v13);
      EventManager::EvtReport(v11, &MISSED_TASK_LAUNCHED, v10, &v12);
      wmi::AutoRef<JobBucket>::Release(&v15);
      _bstr_t::_Free((_bstr_t *)v14);
    }
    else
    {
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        WPP_SF_D(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x1Eu,
          (__int64)&WPP_5435fee58aaf3c352ed5cdc6abf88a31_Traceguids,
          a2);
      }
      v6 = -2147418113;
    }
  }
  LeaveCriticalSection(v2);
  return v6;
}
// 18003FD55: variable 'v5' is possibly undefined
// 18003FDCF: variable 'v11' is possibly undefined
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 180025258: using guessed type char var_38[16];

//----- (00000001800252F0) ----------------------------------------------------
__int64 __fastcall TraceLoggingRegisterEx_EventRegister_EventSetInformation(ULONGLONG *CallbackContext)
{
  GUID v2; // xmm0
  signed int v3; // eax
  unsigned int v4; // ebx
  GUID ProviderId; // [rsp+20h] [rbp-28h] BYREF

  v2 = *(GUID *)(CallbackContext[1] - 16);
  CallbackContext[5] = 0LL;
  CallbackContext[6] = 0LL;
  ProviderId = v2;
  v3 = EventRegister(&ProviderId, (PENABLECALLBACK)tlgEnableCallback, CallbackContext, CallbackContext + 4);
  v4 = v3;
  if ( v3 )
  {
    if ( v3 > 0 )
      return (unsigned __int16)v3 | 0x80070000;
  }
  else
  {
    EventSetInformation(CallbackContext[4], 2LL, CallbackContext[1], *(unsigned __int16 *)CallbackContext[1]);
  }
  return v4;
}
// 180074348: using guessed type __int64 __fastcall EventSetInformation(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180025394) ----------------------------------------------------
BSTR __fastcall _com_util::_ConvertStringToBSTR(const char *a1)
{
  int cchWideChar; // ebx
  WCHAR *lpWideCharStr; // rax
  WCHAR *v3; // rdi
  BSTR v4; // rbx
  signed int LastError; // eax
  void **pExceptionObject; // [rsp+30h] [rbp-28h] BYREF
  int v8; // [rsp+38h] [rbp-20h]
  __int128 v9; // [rsp+40h] [rbp-18h]

  cchWideChar = lstrlenA("\\") + 1;
  lpWideCharStr = (WCHAR *)malloc_0(2LL * cchWideChar);
  v3 = lpWideCharStr;
  if ( !lpWideCharStr )
  {
    v8 = -2147024882;
    pExceptionObject = &_com_error::`vftable';
    v9 = 0LL;
    CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI1_AV_com_error__);
  }
  *lpWideCharStr = 0;
  if ( !MultiByteToWideChar(0, 0, "\\", -1, lpWideCharStr, cchWideChar) )
  {
    free_0(v3);
    LastError = GetLastError();
    if ( LastError > 0 )
      LastError = (unsigned __int16)LastError | 0x80070000;
    v8 = LastError;
    pExceptionObject = &_com_error::`vftable';
    v9 = 0LL;
    CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI1_AV_com_error__);
  }
  v4 = SysAllocString(v3);
  free_0(v3);
  return v4;
}
// 180071858: using guessed type void *_com_error::`vftable';

//----- (0000000180025438) ----------------------------------------------------
__int64 __fastcall ATL::CSimpleStringT<unsigned short,0>::SetLength(__int64 *a1, int a2)
{
  __int64 result; // rax

  if ( a2 < 0 || a2 > *(_DWORD *)(*a1 - 12) )
    ATL::PrivateAtlThrow(-2147024809);
  *(_DWORD *)(*a1 - 16) = a2;
  result = *a1;
  *(_WORD *)(*a1 + 2LL * a2) = 0;
  return result;
}

//----- (0000000180025470) ----------------------------------------------------
__int64 WppInitUm()
{
  _QWORD *v0; // rbx
  __int64 *v1; // rdi
  __int64 v2; // r8
  __int64 result; // rax
  __int64 v4[3]; // [rsp+40h] [rbp-18h] BYREF

  v0 = WPP_GLOBAL_Control;
  v1 = &WPP_REGISTRATION_GUIDS;
  while ( v0 )
  {
    v2 = *v1;
    v4[1] = 0LL;
    ++v1;
    v4[0] = v2;
    v0[4] = v2;
    result = ((__int64 (__fastcall *)(__int64 (__fastcall *)(int, __int64, _DWORD *, __int64), _QWORD *, __int64, __int64, __int64 *, _QWORD, _QWORD, _QWORD *))EtwRegisterTraceGuidsW)(
               WppControlCallback,
               v0,
               v2,
               1LL,
               v4,
               0LL,
               0LL,
               v0 + 1);
    v0 = (_QWORD *)*v0;
  }
  return result;
}
// 180074790: using guessed type __int64 __fastcall EtwRegisterTraceGuidsW(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 1800B0C48: using guessed type __int64 WPP_REGISTRATION_GUIDS;

//----- (0000000180025500) ----------------------------------------------------
void __fastcall tlgEnableCallback(
        LPCGUID SourceId,
        __int64 IsEnabled,
        __int64 Level,
        ULONGLONG MatchAnyKeyword,
        ULONGLONG MatchAllKeyword,
        PEVENT_FILTER_DESCRIPTOR FilterData,
        _QWORD *CallbackContext)
{
  int v7; // eax
  void (__fastcall *v8)(LPCGUID, __int64, __int64, ULONGLONG, ULONGLONG, PEVENT_FILTER_DESCRIPTOR, _QWORD); // rax

  if ( CallbackContext )
  {
    if ( (_DWORD)IsEnabled )
    {
      if ( (_DWORD)IsEnabled == 1 )
      {
        if ( (_BYTE)Level )
          v7 = (unsigned __int8)Level + 1;
        else
          v7 = 256;
        *(_DWORD *)CallbackContext = v7;
        CallbackContext[2] = MatchAnyKeyword;
        CallbackContext[3] = MatchAllKeyword;
      }
    }
    else
    {
      *(_DWORD *)CallbackContext = 0;
    }
    v8 = (void (__fastcall *)(LPCGUID, __int64, __int64, ULONGLONG, ULONGLONG, PEVENT_FILTER_DESCRIPTOR, _QWORD))CallbackContext[5];
    if ( v8 )
      v8(SourceId, IsEnabled, Level, MatchAnyKeyword, MatchAllKeyword, FilterData, CallbackContext[6]);
  }
}

//----- (0000000180025560) ----------------------------------------------------
PrivateHeap *__fastcall PrivateHeap::PrivateHeap(PrivateHeap *this)
{
  HANDLE ProcessHeap; // rax
  PrivateHeap *HeapInformation; // [rsp+30h] [rbp+8h] BYREF

  HeapInformation = this;
  dword_1800B0C58 = 0;
  ProcessHeap = HeapCreate(0, 0LL, 0LL);
  g_PrivateHeap = ProcessHeap;
  if ( ProcessHeap )
  {
    dword_1800B0C58 = 1;
  }
  else
  {
    ProcessHeap = GetProcessHeap();
    g_PrivateHeap = ProcessHeap;
  }
  LODWORD(HeapInformation) = 2;
  HeapSetInformation(ProcessHeap, HeapCompatibilityInformation, &HeapInformation, 4uLL);
  return (PrivateHeap *)&g_PrivateHeap;
}
// 1800B0C58: using guessed type int dword_1800B0C58;

//----- (00000001800255D4) ----------------------------------------------------
void *__fastcall InterlockedAutoHandle::operator=(__int64 a1, __int64 a2)
{
  char *v2; // rdx

  v2 = (char *)_InterlockedExchange64((volatile __int64 *)&ShutdownMgr::s_hEvent, a2);
  if ( (unsigned __int64)(v2 - 1) <= 0xFFFFFFFFFFFFFFFDuLL )
    CloseHandle(v2);
  return &ShutdownMgr::s_hEvent;
}

//----- (0000000180025600) ----------------------------------------------------
_variant_t *__fastcall _variant_t::_variant_t(_variant_t *this)
{
  vtMissing.lVal = -2147352572;
  vtMissing.vt = 10;
  return (_variant_t *)&vtMissing;
}

//----- (0000000180025628) ----------------------------------------------------
__int64 __fastcall EventManager::EvtReport(
        EventManager *this,
        const struct _EVENT_DESCRIPTOR *a2,
        void *a3,
        const struct _GUID *a4)
{
  EventManager *v4; // rdi
  int v7; // eax
  EventManager *v8; // rcx
  int v9; // ebx

  v4 = g_pEventManager;
  if ( !*(_QWORD *)g_pEventManager )
    return 1LL;
  if ( !(unsigned __int8)EtwEventEnabled(*(_QWORD *)g_pEventManager, a2, a3, a4) )
    return 0LL;
  v7 = EtwEventWrite(*(_QWORD *)v4, a2, 0LL, 0LL);
  v9 = v7;
  if ( !v7 )
    return 0LL;
  EventManager::LogIt(v8, L"EventWrite error", v7);
  if ( v9 > 0 )
    return (unsigned __int16)v9 | 0x80070000;
  return (unsigned int)v9;
}
// 18003FEFC: variable 'v8' is possibly undefined
// 1800746B8: using guessed type __int64 __fastcall EtwEventEnabled(_QWORD, _QWORD, _QWORD, _QWORD);
// 180074768: using guessed type __int64 __fastcall EtwEventWrite(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180025680) ----------------------------------------------------
void __fastcall ATL::CWin32Heap::Free(HANDLE *this, void *a2)
{
  if ( a2 )
    HeapFree(this[1], 0, a2);
}

//----- (00000001800256B0) ----------------------------------------------------
LPVOID __fastcall ATL::CWin32Heap::Allocate(HANDLE *this, SIZE_T a2)
{
  return HeapAlloc(this[1], 0, a2);
}

//----- (00000001800256D0) ----------------------------------------------------
void __fastcall ATL::CAtlStringMgr::Free(ATL::CAtlStringMgr *this, struct ATL::CStringData *a2)
{
  (*(void (__fastcall **)(_QWORD, struct ATL::CStringData *))(**((_QWORD **)this + 1) + 8LL))(*((_QWORD *)this + 1), a2);
}

//----- (00000001800256E8) ----------------------------------------------------
__int64 WPP_INIT_CONTROL_ARRAY()
{
  __int64 result; // rax

  result = 0LL;
  qword_1800B0C38 = 1LL;
  qword_1800B0C30 = 0LL;
  WPP_MAIN_CB = 0LL;
  return result;
}
// 1800B0C20: using guessed type __int64 WPP_MAIN_CB;
// 1800B0C30: using guessed type __int64 qword_1800B0C30;
// 1800B0C38: using guessed type __int64 qword_1800B0C38;

//----- (000000018002570C) ----------------------------------------------------
int *__fastcall ShutdownMgr::Sync::Sync(ShutdownMgr::Sync *this)
{
  ShutdownMgr::s_sync = 0;
  dword_1800B0A14 = 0;
  _InterlockedExchange(&dword_1800B0A14, 0);
  return &ShutdownMgr::s_sync;
}
// 1800B0A10: using guessed type int ShutdownMgr::s_sync;
// 1800B0A14: using guessed type int dword_1800B0A14;

//----- (0000000180025730) ----------------------------------------------------
__int64 __fastcall ItSpConsoleDisplayStateChangeCallback(volatile __int32 *a1, int a2, _DWORD *a3)
{
  int v4; // ebx

  if ( a2 != 32787 || a3[4] != 4 )
    return 87LL;
  v4 = a3[5];
  EventManager::EvtReport((EventManager *)a1, &ItSpEvt_PowerNotificationReceived, L"ConsoleDisplay", v4);
  _InterlockedExchange(a1 + 212, v4);
  return 0LL;
}

//----- (0000000180025790) ----------------------------------------------------
__int64 __fastcall ItSpRpcSecurityCallback(RPC_IF_HANDLE InterfaceUuid, void *Context)
{
  char v2; // di
  char v3; // si
  unsigned int LastError; // ebx
  HANDLE CurrentThread; // rax
  RPC_WSTR StringBinding; // [rsp+60h] [rbp+7h] BYREF
  RPC_WSTR Protseq; // [rsp+68h] [rbp+Fh] BYREF
  WINBOOL IsMember; // [rsp+70h] [rbp+17h] BYREF
  void *TokenHandle; // [rsp+78h] [rbp+1Fh] BYREF
  PSID SidToCheck; // [rsp+80h] [rbp+27h] BYREF
  struct _SID_IDENTIFIER_AUTHORITY pIdentifierAuthority; // [rsp+88h] [rbp+2Fh] BYREF

  *(_WORD *)&pIdentifierAuthority.Value[4] = 1280;
  *(_DWORD *)pIdentifierAuthority.Value = 0;
  StringBinding = 0LL;
  Protseq = 0LL;
  v2 = 0;
  v3 = 0;
  SidToCheck = 0LL;
  TokenHandle = 0LL;
  if ( RpcBindingToStringBindingW(Context, &StringBinding)
    || RpcStringBindingParseW(StringBinding, 0LL, &Protseq, 0LL, 0LL, 0LL)
    || _wcsicmp(Protseq, L"ncalrpc") )
  {
    LastError = 5;
  }
  else
  {
    if ( !AllocateAndInitializeSid(&pIdentifierAuthority, 2u, 0x20u, 0x220u, 0, 0, 0, 0, 0, 0, &SidToCheck) )
      goto LABEL_21;
    LastError = RpcImpersonateClient(0LL);
    if ( LastError )
      goto LABEL_9;
    v2 = 1;
    CurrentThread = GetCurrentThread();
    if ( OpenThreadToken(CurrentThread, 0x20008u, 0, &TokenHandle)
      && (v3 = 1, CheckTokenMembership(TokenHandle, SidToCheck, &IsMember)) )
    {
      LastError = IsMember == 0 ? 5 : 0;
    }
    else
    {
LABEL_21:
      LastError = GetLastError();
    }
  }
LABEL_9:
  if ( StringBinding )
    RpcStringFreeW(&StringBinding);
  if ( Protseq )
    RpcStringFreeW(&Protseq);
  if ( v3 )
    CloseHandle(TokenHandle);
  if ( SidToCheck )
    FreeSid(SidToCheck);
  if ( v2 )
    RpcRevertToSelf();
  return LastError;
}

//----- (00000001800259A0) ----------------------------------------------------
void __fastcall JobsService::SCMEventLogNotificationWorker(
        PTP_CALLBACK_INSTANCE Instance,
        PVOID Context,
        PTP_WORK Work)
{
  EventTrapMap *v3; // rcx
  __int32 v5; // ebx

  v3 = 0LL;
  v5 = _InterlockedCompareExchange((volatile signed __int32 *)&JobsService::s_dwLastNotificationMaskReceived, 0, 0);
  if ( (v5 & 8) != 0 )
    JobsService::ControlOperationalLog();
  if ( (v5 & 9) != 0 )
    EventTrapMap::ProcessSCMNotification(v3, v5);
  CloseThreadpoolWork(Work);
}
// 1800259CB: variable 'v3' is possibly undefined
// 1800B1260: using guessed type unsigned int JobsService::s_dwLastNotificationMaskReceived;

//----- (00000001800259F0) ----------------------------------------------------
void __fastcall EventTrapMap::ProcessSCMNotification(EventTrapMap *this, __int32 a2)
{
  EventTrapMap *v2; // rdi
  char v3; // bp
  struct _RTL_CRITICAL_SECTION *v4; // rbx
  __int64 *v5; // r14
  __int64 v6; // r15
  __int64 Context; // rsi
  int LastError; // eax
  _QWORD *v9; // rcx
  const WCHAR *v10; // r9
  EVT_HANDLE v11; // rax
  signed int v12; // eax
  int v13; // edi
  int v14; // ecx
  const unsigned __int16 *Path; // rax
  EventManager *v16; // rcx

  v2 = g_pEventTrapMap;
  v3 = a2;
  if ( _InterlockedExchange((volatile __int32 *)g_pEventTrapMap + 524, a2) != a2 )
  {
    v4 = (struct _RTL_CRITICAL_SECTION *)((char *)v2 + 8);
    EnterCriticalSection((LPCRITICAL_SECTION)((char *)v2 + 8));
    v5 = (__int64 *)((char *)v2 + 48);
    v6 = 255LL;
    do
    {
      Context = *v5;
      if ( *v5 )
      {
        if ( (v3 & 1) != 0 && *(_QWORD *)Context )
        {
          if ( !EvtClose(*(EVT_HANDLE *)Context)
            && WPP_GLOBAL_Control != &WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0
            && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
          {
            LastError = GetLastError();
            WPP_SF_D(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              0x12u,
              (__int64)&WPP_16de8f11014e3cd60e9c758468ee516f_Traceguids,
              LastError);
          }
          *(_QWORD *)Context = 0LL;
        }
        if ( (v3 & 8) != 0 && !*(_QWORD *)Context )
        {
          v9 = *(_QWORD **)(*(_QWORD *)(Context + 48) + 88LL);
          v10 = v9 ? (const WCHAR *)*v9 : 0LL;
          v11 = EvtSubscribe(
                  0LL,
                  0LL,
                  &ChannelPath,
                  v10,
                  0LL,
                  (PVOID)Context,
                  (EVT_SUBSCRIBE_CALLBACK)EventTrapMap::ConsumerCallback,
                  1u);
          *(_QWORD *)Context = v11;
          if ( !v11 )
          {
            v12 = GetLastError();
            v13 = v12;
            if ( v12 > 0 )
              v13 = (unsigned __int16)v12 | 0x80070000;
            if ( (unsigned int)(v13 + 2147023181) > 7 || (v14 = 133, !_bittest(&v14, v13 + 2147023181)) )
            {
              if ( v13 != -2147019873 )
              {
                if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
                  && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0
                  && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
                {
                  WPP_SF_D(
                    *((_QWORD *)WPP_GLOBAL_Control + 2),
                    0x13u,
                    (__int64)&WPP_16de8f11014e3cd60e9c758468ee516f_Traceguids,
                    v13);
                }
                Path = JobMoniker::GetPath((JobMoniker *)(Context + 8));
                EventManager::EvtReport(v16, &TASK_EVENT_SUBSCRIPTION_FAILED, Path, v13);
              }
            }
          }
        }
      }
      ++v5;
      --v6;
    }
    while ( v6 );
    LeaveCriticalSection(v4);
  }
}
// 18003B9BE: variable 'v16' is possibly undefined
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180025A94) ----------------------------------------------------
__int64 __fastcall RpcServer::StartServer(RPC_BINDING_VECTOR **BindingVector)
{
  int v2; // ebp
  int IsHashingCompleted; // eax
  RTL_SRWLOCK *v4; // rcx
  unsigned int v5; // eax
  EventManager *v6; // rcx
  unsigned int v7; // ebx
  unsigned int v8; // ebx
  unsigned int v9; // eax
  EventManager *v10; // rcx
  unsigned int v11; // eax
  EventManager *v12; // rcx
  unsigned int v13; // eax
  EventManager *v14; // rcx
  unsigned int v15; // eax
  EventManager *v16; // rcx
  unsigned int v17; // eax
  EventManager *v18; // rcx
  unsigned int v19; // eax
  EventManager *v20; // rcx
  unsigned int v21; // eax
  EventManager *v22; // rcx
  _QWORD *v24; // rcx
  __int64 v25; // rdx
  EventManager *v26; // rcx
  void **v27; // rcx
  __int64 v28; // rdx
  void *MaxCalls; // [rsp+20h] [rbp-58h]
  void *MaxCallsa; // [rsp+20h] [rbp-58h]
  void *MaxCallsb; // [rsp+20h] [rbp-58h]
  RPC_IF_CALLBACK_FN *IfCallback; // [rsp+28h] [rbp-50h]
  RPC_IF_CALLBACK_FN *IfCallbacka; // [rsp+28h] [rbp-50h]
  RPC_IF_CALLBACK_FN *IfCallbackb; // [rsp+28h] [rbp-50h]
  RPC_WSTR PrincName; // [rsp+80h] [rbp+8h] BYREF

  v2 = 0;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x200) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 11LL, &WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids);
  }
  IsHashingCompleted = JobStore::IsHashingCompleted(JobStore::m_pCommonStore);
  *((_DWORD *)BindingVector + 6) = IsHashingCompleted == 0;
  v4 = (RTL_SRWLOCK *)(BindingVector + 2);
  if ( IsHashingCompleted )
    AcquireSRWLockShared(v4);
  else
    AcquireSRWLockExclusive(v4);
  v5 = RpcServerUseProtseqW((RPC_WSTR)L"ncalrpc", 0xAu, 0LL);
  v7 = v5;
  if ( v5 )
  {
    if ( v5 != 1703 )
    {
      EventManager::EvtReport(
        v6,
        &SCHEDULE_SERVICE_RPC_INIT_ERROR,
        L"RpcServerUseProtseq:ncalrpc",
        v5,
        MaxCalls,
        (const struct _GUID *)IfCallback);
      v24 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x200) != 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        v25 = 12LL;
LABEL_29:
        WPP_SF_D(v24[2], v25, &WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids, v7);
      }
LABEL_30:
      if ( (int)v7 > 0 )
        return (unsigned __int16)v7 | 0x80070000;
      return v7;
    }
  }
  else
  {
    v2 = 1;
  }
  if ( !(unsigned int)RpcServer::IsRpcOverTcpDisabled() )
  {
    v8 = RpcServerUseProtseqW((RPC_WSTR)L"ncacn_ip_tcp", 0xAu, 0LL);
    if ( !v8 || v8 == 1740 )
    {
      ++v2;
    }
    else
    {
      if ( !(unsigned int)JobStore::IsWinPESetupInProgress()
        && !(unsigned int)JobStore::IsSystemSetupInProgress()
        && !(unsigned int)JobStore::IsOOBEInProgress() )
      {
        EventManager::EvtReport(
          v26,
          &SCHEDULE_SERVICE_RPC_INIT_ERROR,
          L"RpcServerUseProtseq:ncacn_ip_tcp",
          v8,
          MaxCalls,
          (const struct _GUID *)IfCallback);
      }
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x200) != 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 13LL, &WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids, v8);
      }
    }
  }
  if ( v2 )
  {
    PrincName = 0LL;
    v9 = RpcServerInqDefaultPrincNameW(9u, &PrincName);
    v7 = v9;
    if ( !v9 )
    {
      v11 = RpcServerRegisterAuthInfoW(PrincName, 9u, 0LL, 0LL);
      v7 = v11;
      if ( !v11 )
        goto LABEL_13;
      EventManager::EvtReport(
        v12,
        &SCHEDULE_SERVICE_RPC_INIT_ERROR,
        L"RpcServerRegisterAuthInfo",
        v11,
        MaxCalls,
        (const struct _GUID *)IfCallback);
      v27 = (void **)WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x200) != 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 15LL, &WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids, v7);
        v27 = (void **)WPP_GLOBAL_Control;
      }
      if ( v7 == 1747 )
      {
LABEL_13:
        v13 = RpcServerRegisterIfEx(&unk_180070290, 0LL, 0LL, 9u, 0x4D2u, RpcServer::SecurityCallback);
        v7 = v13;
        if ( v13 )
        {
          EventManager::EvtReport(
            v14,
            &SCHEDULE_SERVICE_RPC_INIT_ERROR,
            L"RpcServerRegisterIfEx",
            v13,
            MaxCallsa,
            (const struct _GUID *)IfCallbacka);
          v27 = (void **)WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
            || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x200) == 0
            || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
          {
            goto LABEL_76;
          }
          v28 = 17LL;
        }
        else
        {
          *((_DWORD *)BindingVector + 2) = 1;
          v15 = RpcServerRegisterIfEx(&unk_180070230, 0LL, 0LL, 0x29u, 0x4D2u, RpcServer::SecurityCallback);
          v7 = v15;
          if ( v15 )
          {
            EventManager::EvtReport(
              v16,
              &SCHEDULE_SERVICE_RPC_INIT_ERROR,
              L"RpcServerRegisterIfEx",
              v15,
              MaxCallsb,
              (const struct _GUID *)IfCallbackb);
            v27 = (void **)WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
              || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x200) == 0
              || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
            {
              goto LABEL_76;
            }
            v28 = 18LL;
          }
          else
          {
            *((_DWORD *)BindingVector + 2) = 2;
            v17 = RpcServerInqBindings(BindingVector);
            v7 = v17;
            if ( v17 )
            {
              EventManager::EvtReport(
                v18,
                &SCHEDULE_SERVICE_RPC_INIT_ERROR,
                L"RpcServerInqBindings",
                v17,
                MaxCallsb,
                (const struct _GUID *)IfCallbackb);
              v27 = (void **)WPP_GLOBAL_Control;
              if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
                || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x200) == 0
                || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
              {
                goto LABEL_76;
              }
              v28 = 19LL;
            }
            else
            {
              v19 = RpcEpRegisterW(&unk_180070290, *BindingVector, 0LL, 0LL);
              v7 = v19;
              if ( v19 )
              {
                EventManager::EvtReport(
                  v20,
                  &SCHEDULE_SERVICE_RPC_INIT_ERROR,
                  L"RpcEpRegister",
                  v19,
                  MaxCallsb,
                  (const struct _GUID *)IfCallbackb);
                v27 = (void **)WPP_GLOBAL_Control;
                if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
                  || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x200) == 0
                  || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
                {
                  goto LABEL_76;
                }
                v28 = 20LL;
              }
              else
              {
                *((_DWORD *)BindingVector + 2) = 3;
                v21 = RpcEpRegisterW(&unk_180070230, *BindingVector, 0LL, 0LL);
                v7 = v21;
                if ( !v21 )
                {
                  *((_DWORD *)BindingVector + 7) = RpcServer::IsNonAdminTasksDisabled();
                  *((_DWORD *)BindingVector + 2) = 4;
LABEL_19:
                  RpcStringFreeW(&PrincName);
                  return v7;
                }
                EventManager::EvtReport(
                  v22,
                  &SCHEDULE_SERVICE_RPC_INIT_ERROR,
                  L"RpcEpRegister (I)",
                  v21,
                  MaxCallsb,
                  (const struct _GUID *)IfCallbackb);
                v27 = (void **)WPP_GLOBAL_Control;
                if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
                  || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x200) == 0
                  || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
                {
LABEL_76:
                  if ( (int)v7 > 0 )
                    v7 = (unsigned __int16)v7 | 0x80070000;
                  goto LABEL_19;
                }
                v28 = 21LL;
              }
            }
          }
        }
      }
      else
      {
        if ( v27 == &WPP_GLOBAL_Control || (*((_DWORD *)v27 + 7) & 0x200) == 0 || *((_BYTE *)v27 + 25) < 2u )
          goto LABEL_76;
        v28 = 16LL;
      }
      WPP_SF_D(v27[2], v28, &WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids, v7);
      goto LABEL_76;
    }
    EventManager::EvtReport(
      v10,
      &SCHEDULE_SERVICE_RPC_INIT_ERROR,
      L"RpcServerInqDefaultPrincName",
      v9,
      MaxCalls,
      (const struct _GUID *)IfCallback);
    v24 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x200) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      v25 = 14LL;
      goto LABEL_29;
    }
    goto LABEL_30;
  }
  return 2147944103LL;
}
// 18003C11C: variable 'v6' is possibly undefined
// 18003C11C: variable 'MaxCalls' is possibly undefined
// 18003C11C: variable 'IfCallback' is possibly undefined
// 18003C19E: variable 'v26' is possibly undefined
// 18003C1F8: variable 'v10' is possibly undefined
// 18003C233: variable 'v12' is possibly undefined
// 18003C2AB: variable 'v14' is possibly undefined
// 18003C2AB: variable 'MaxCallsa' is possibly undefined
// 18003C2AB: variable 'IfCallbacka' is possibly undefined
// 18003C2EB: variable 'v16' is possibly undefined
// 18003C2EB: variable 'MaxCallsb' is possibly undefined
// 18003C2EB: variable 'IfCallbackb' is possibly undefined
// 18003C32B: variable 'v18' is possibly undefined
// 18003C360: variable 'v20' is possibly undefined
// 18003C391: variable 'v22' is possibly undefined
// 18004B234: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 18004B260: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180025D20) ----------------------------------------------------
__int64 ItSrvInitialize()
{
  char v0; // di
  BOOL Version; // ebx
  __int32 v2; // eax
  __int128 v3; // xmm0
  __int128 v4; // xmm1
  struct _ITSRV_GLOBAL_CONTEXT *v5; // rcx
  unsigned int LastError; // ebx
  struct _ITSRV_GLOBAL_CONTEXT *v7; // rcx
  __int32 v9; // eax
  __int32 v10; // eax
  __int128 IfCallback_8; // [rsp+38h] [rbp-D0h] BYREF
  __int128 v12; // [rsp+48h] [rbp-C0h]
  int v13; // [rsp+58h] [rbp-B0h]
  struct _OSVERSIONINFOW VersionInformation; // [rsp+68h] [rbp-A0h] BYREF
  char v15; // [rsp+182h] [rbp+7Ah]

  v0 = 0;
  memset_0(&ItSrvGlobalContext, 0, 0x368uLL);
  VersionInformation.dwOSVersionInfoSize = 284;
  stru_1800B0F40.Blink = &stru_1800B0F40;
  stru_1800B0F40.Flink = &stru_1800B0F40;
  Version = GetVersionExW(&VersionInformation);
  if ( !Version || (byte_1800B11C2 = 1, v15 != 1) )
    byte_1800B11C2 = 0;
  dword_1800B10C4 &= 0xFFFFFFC0;
  dword_1800B111C &= 0xFFFFFFC0;
  dword_1800B10D0 = 0;
  qword_1800B10D8 = 0LL;
  dword_1800B1128 = 0;
  qword_1800B1130 = 0LL;
  LODWORD(ItSrvGlobalContext) = 1147547697;
  xmmword_1800B0EF4 = (__int128)_mm_load_si128((const __m128i *)&_xmm);
  dword_1800B10C0 = -1;
  xmmword_1800B0F04 = xmmword_1800B0EF4;
  dword_1800B1118 = -1;
  memset_0(&unk_1800B1170, 0, 0x40uLL);
  InitializeCriticalSection(&stru_1800B0F18);
  InitializeCriticalSection(&stru_1800B0F60);
  InitializeCriticalSection(&stru_1800B0F90);
  stru_1800B0FB8.Blink = &stru_1800B0FB8;
  stru_1800B0FB8.Flink = &stru_1800B0FB8;
  hObject = CreateEventW(0LL, 1, 0, 0LL);
  if ( !hObject
    || (hEvent = CreateEventW(0LL, 1, 1, 0LL)) == 0LL
    || (hHandle = CreateEventW(0LL, 1, 1, 0LL)) == 0LL
    || (qword_1800B11C8 = CreateEventW(0LL, 1, 0, 0LL)) == 0LL
    || (qword_1800B1050 = CreateEventW(0LL, 1, 1, 0LL)) == 0LL
    || (qword_1800B11D0 = CreateEventW(0LL, 1, 0, 0LL)) == 0LL
    || (qword_1800B1058 = CreateEventW(0LL, 1, 0, 0LL)) == 0LL
    || (qword_1800B0F50 = CreateEventW(0LL, 1, 1, 0LL)) == 0LL )
  {
    LastError = GetLastError();
    goto LABEL_25;
  }
  RtlInitializeSRWLock(&unk_1800B1088);
  if ( !Version )
  {
LABEL_29:
    v3 = xmmword_18007DCF0;
    v4 = xmmword_18007DD00;
    goto LABEL_15;
  }
  if ( v15 != 1 )
  {
    v3 = xmmword_18007DD38;
    v4 = xmmword_18007DD48;
    goto LABEL_15;
  }
  v2 = PowerDeterminePlatformRole() - 1;
  if ( v2 )
  {
    v9 = v2 - 1;
    if ( !v9 )
    {
      v3 = xmmword_18007DD5C;
      v4 = xmmword_18007DD6C;
      goto LABEL_15;
    }
    v10 = v9 - 1;
    if ( v10 )
    {
      if ( v10 == 5 )
      {
        v3 = xmmword_18007DD80;
        v4 = xmmword_18007DD90;
        goto LABEL_15;
      }
      goto LABEL_29;
    }
  }
  v3 = xmmword_18007DD14;
  v4 = xmmword_18007DD24;
LABEL_15:
  v13 = 512;
  v12 = v4;
  IfCallback_8 = v3;
  LastError = ItSpRetrieveDetectionOverrides((struct _IT_IDLE_DETECTION_PARAMETERS *)&IfCallback_8);
  if ( LastError )
    goto LABEL_38;
  EnterCriticalSection(&stru_1800B0F18);
  RtlAcquireSRWLockExclusive(&unk_1800B1088);
  dword_1800B1080 = v13;
  unk_1800B1060 = IfCallback_8;
  *(_OWORD *)&xmmword_1800B1070 = v12;
  RtlReleaseSRWLockExclusive(&unk_1800B1088);
  *(__int64 *)((char *)&qword_1800B1094 + 4) = 0LL;
  qword_1800B1094 = 0LL;
  byte_1800B1090 = 0;
  LastError = ItSpRetrieveRuntimeOverrides((struct _IT_IDLE_RUNTIME_PARAMETERS *)&byte_1800B1090);
  if ( !LastError )
  {
    v0 = 1;
    LastError = ItSpStartIdleDetection(v7);
    if ( !LastError )
    {
      ItSpUpdateStatus((unsigned int *)&ItSrvGlobalContext, 0x44663032u);
      LastError = RpcServerUseProtseqW((RPC_WSTR)L"ncalrpc", 0x100u, 0LL);
      if ( !LastError )
      {
        LastError = RpcServerInqBindings(&BindingVector);
        if ( !LastError )
        {
          LastError = RpcServerRegisterIfEx(
                        &unk_1800702F0,
                        0LL,
                        0LL,
                        9u,
                        0x4D2u,
                        (RPC_IF_CALLBACK_FN *)ItSpRpcSecurityCallback);
          if ( !LastError )
          {
            LastError = RpcServerRegisterAuthInfoW(0LL, 0xAu, 0LL, 0LL);
            if ( !LastError )
            {
              byte_1800B11C1 = 1;
              LastError = RpcEpRegisterW(&unk_1800702F0, BindingVector, 0LL, 0LL);
              if ( !LastError )
                byte_1800B11C0 = 1;
            }
          }
        }
      }
    }
  }
  LeaveCriticalSection(&stru_1800B0F18);
LABEL_25:
  if ( LastError )
  {
    if ( v0 )
    {
      ItSrvUninitialize();
      return LastError;
    }
LABEL_38:
    ItSpCleanupGlobalContext(v5);
  }
  return LastError;
}
// 1800260A4: variable 'v7' is possibly undefined
// 18003C480: variable 'v5' is possibly undefined
// 180074660: using guessed type __int64 __fastcall RtlAcquireSRWLockExclusive(_QWORD);
// 180074670: using guessed type __int64 __fastcall RtlReleaseSRWLockExclusive(_QWORD);
// 180074680: using guessed type __int64 __fastcall RtlInitializeSRWLock(_QWORD);
// 18007DCF0: using guessed type __int128 xmmword_18007DCF0;
// 18007DD00: using guessed type __int128 xmmword_18007DD00;
// 18007DD14: using guessed type __int128 xmmword_18007DD14;
// 18007DD24: using guessed type __int128 xmmword_18007DD24;
// 18007DD38: using guessed type __int128 xmmword_18007DD38;
// 18007DD48: using guessed type __int128 xmmword_18007DD48;
// 18007DD5C: using guessed type __int128 xmmword_18007DD5C;
// 18007DD6C: using guessed type __int128 xmmword_18007DD6C;
// 18007DD80: using guessed type __int128 xmmword_18007DD80;
// 18007DD90: using guessed type __int128 xmmword_18007DD90;
// 18007DDB0: using guessed type __int128 _xmm;
// 1800B0EF0: using guessed type struct _ITSRV_GLOBAL_CONTEXT near *ItSrvGlobalContext;
// 1800B0EF4: using guessed type __int128 xmmword_1800B0EF4;
// 1800B0F04: using guessed type __int128 xmmword_1800B0F04;
// 1800B1080: using guessed type int dword_1800B1080;
// 1800B1094: using guessed type __int64 qword_1800B1094;
// 1800B10C0: using guessed type int dword_1800B10C0;
// 1800B10C4: using guessed type int dword_1800B10C4;
// 1800B10D0: using guessed type int dword_1800B10D0;
// 1800B10D8: using guessed type __int64 qword_1800B10D8;
// 1800B1118: using guessed type int dword_1800B1118;
// 1800B111C: using guessed type int dword_1800B111C;
// 1800B1128: using guessed type int dword_1800B1128;
// 1800B1130: using guessed type __int64 qword_1800B1130;
// 1800B11C0: using guessed type char byte_1800B11C0;
// 1800B11C1: using guessed type char byte_1800B11C1;
// 1800B11C2: using guessed type char byte_1800B11C2;

//----- (00000001800261DC) ----------------------------------------------------
__int64 __fastcall ItSpUpdateStatus(unsigned int *a1, unsigned int a2)
{
  __int64 v2; // r9
  _DWORD *v3; // r8
  __int64 result; // rax

  v2 = 7LL;
  v3 = a1 + 8;
  do
  {
    --v2;
    *v3 = *(v3 - 1);
    --v3;
  }
  while ( v2 > 0 );
  result = *a1;
  ++a1[9];
  a1[1] = result;
  *a1 = a2;
  return result;
}

//----- (0000000180026210) ----------------------------------------------------
__int64 __fastcall UbpmProxySingleton::RunTask(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 **a4,
        char a5,
        User *a6,
        int a7,
        __int64 a8,
        _OWORD *a9)
{
  PSID v11; // rsi
  UbpmProxySingleton *v12; // rcx
  int ActionArgs; // ebx
  BOOL v14; // ecx
  _OWORD ***v15; // r8
  int v16; // eax
  __int64 v17; // rdx
  unsigned int v19; // ecx
  const unsigned __int16 ***DomainAccount; // rax
  char v21; // di
  const unsigned __int16 **v22; // rax
  const unsigned __int16 *v23; // rsi
  const unsigned __int16 *Path; // rax
  EventManager *v25; // rcx
  PSID pSid; // [rsp+48h] [rbp-C0h] BYREF
  _OWORD **v27; // [rsp+50h] [rbp-B8h] BYREF
  void *lpMem; // [rsp+58h] [rbp-B0h] BYREF
  void *v29; // [rsp+60h] [rbp-A8h] BYREF
  __int64 v30; // [rsp+68h] [rbp-A0h] BYREF
  __int128 v31; // [rsp+70h] [rbp-98h] BYREF
  __int64 v32; // [rsp+80h] [rbp-88h]
  __int128 v33; // [rsp+88h] [rbp-80h] BYREF
  __int64 v34; // [rsp+98h] [rbp-70h]
  int v35; // [rsp+A8h] [rbp-60h] BYREF
  int v36; // [rsp+ACh] [rbp-5Ch]
  int v37; // [rsp+B0h] [rbp-58h]
  DWORD LengthSid; // [rsp+B8h] [rbp-50h]
  PSID v39; // [rsp+C0h] [rbp-48h]
  __int64 v40; // [rsp+C8h] [rbp-40h]
  char v41; // [rsp+D0h] [rbp-38h]
  void *v42; // [rsp+D8h] [rbp-30h]
  char v43; // [rsp+E0h] [rbp-28h]
  void *v44; // [rsp+E8h] [rbp-20h]
  int v45; // [rsp+F8h] [rbp-10h]
  __int64 v46[3]; // [rsp+100h] [rbp-8h] BYREF

  v46[1] = -2LL;
  v45 = 0;
  v30 = 0LL;
  memset_0(&v35, 0, 0x48uLL);
  v27 = 0LL;
  v11 = 0LL;
  pSid = 0LL;
  v33 = 0LL;
  v34 = 0LL;
  v29 = 0LL;
  v31 = 0LL;
  v32 = 0LL;
  lpMem = 0LL;
  ActionArgs = UbpmProxySingleton::OpenConsumer(
                 v12,
                 (const struct JobMoniker *)a2,
                 (struct AutoUbpmConsumerHandle *)&v30);
  if ( ActionArgs < 0 )
    goto LABEL_43;
  v35 = 1;
  v37 = -1;
  v39 = 0LL;
  LengthSid = 0;
  v40 = 0LL;
  v14 = (a5 & 2) != 0;
  v36 = v14;
  if ( (a5 & 4) != 0 )
  {
    v36 = v14 | 2;
    v37 = a7;
    if ( (*(_DWORD *)(*(_QWORD *)(a2 + 32) + 16LL) & 0x1000000) != 0 )
      v36 = v14 | 0x12;
  }
  if ( *(_QWORD *)a6 )
  {
    ActionArgs = User::LookupSid(a6, &pSid);
    v11 = pSid;
    if ( ActionArgs < 0 )
      goto LABEL_41;
    v36 |= 4u;
    v39 = pSid;
    LengthSid = GetLengthSid(pSid);
    if ( User::IsService(a6) )
    {
      v36 |= 8u;
    }
    else if ( (*(_DWORD *)(*(_QWORD *)(a2 + 32) + 16LL) & 0x1000000) != 0 )
    {
      v36 |= 0x10u;
    }
  }
  if ( *(_QWORD *)(a8 + 8) )
  {
    ActionArgs = Actions::ActionCollection::ExtractActionArgs(a4, (__int64 *)&v33, (__int64 *)&v31);
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
    {
      v19 = 4;
      if ( ActionArgs < 0 )
        v19 = 2;
      if ( *((unsigned __int8 *)WPP_GLOBAL_Control + 25) >= v19 )
        WPP_SF_D(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0xFu,
          (__int64)&WPP_ffeb42fce81a3445f9740a981b62c86a_Traceguids,
          ActionArgs);
    }
    if ( ActionArgs < 0 )
      goto LABEL_41;
    ActionArgs = UbpmProxySingleton::ExpandVariablesInStrings((BSTR **)&v33, (BSTR ***)a8);
    if ( ActionArgs < 0 )
      goto LABEL_41;
    ActionArgs = UbpmProxySingleton::CreateShallowStringArray((BSTR ***)&v33, &v29);
    if ( ActionArgs < 0 )
      goto LABEL_41;
    if ( (unsigned __int64)((__int64)(*((_QWORD *)&v33 + 1) - v33) >> 3) > 0xFF )
      goto LABEL_39;
    v41 = (__int64)(*((_QWORD *)&v33 + 1) - v33) >> 3;
    v42 = v29;
    ActionArgs = UbpmProxySingleton::ExpandVariablesInStrings((BSTR **)&v31, (BSTR ***)a8);
    if ( ActionArgs < 0 )
      goto LABEL_41;
    ActionArgs = UbpmProxySingleton::CreateShallowStringArray((BSTR ***)&v31, &lpMem);
    if ( ActionArgs < 0 )
      goto LABEL_41;
    if ( (unsigned __int64)((__int64)(*((_QWORD *)&v31 + 1) - v31) >> 3) > 0xFF )
    {
LABEL_39:
      ActionArgs = -2147024882;
      goto LABEL_41;
    }
    v43 = (__int64)(*((_QWORD *)&v31 + 1) - v31) >> 3;
    v44 = lpMem;
  }
  v15 = &v27;
  if ( !a9 )
    v15 = 0LL;
  v16 = UbpmTriggerConsumerControl(v30, &v35, v15);
  ActionArgs = v16;
  if ( v16 > 0 )
    ActionArgs = (unsigned __int16)v16 | 0x80070000;
  if ( ActionArgs >= 0 )
  {
    if ( !a9 )
      goto LABEL_23;
    if ( v27 )
    {
      *a9 = **v27;
      UbpmApiBufferFree();
      v27 = 0LL;
      goto LABEL_23;
    }
    ActionArgs = -2147418113;
  }
LABEL_41:
  if ( !v11 )
  {
LABEL_43:
    DomainAccount = (const unsigned __int16 ***)_bstr_t::_bstr_t((_bstr_t *)&pSid, L"(default user)");
    v21 = 2;
    goto LABEL_44;
  }
  DomainAccount = (const unsigned __int16 ***)User::GetDomainAccount(a6, v46);
  v21 = 1;
LABEL_44:
  v22 = *DomainAccount;
  if ( v22 )
    v23 = *v22;
  else
    v23 = 0LL;
  Path = JobMoniker::GetPath((JobMoniker *)a2);
  EventManager::EvtReport(v25, &JOB_START_FAILED, Path, v23, ActionArgs);
  if ( (v21 & 2) != 0 )
  {
    v21 &= ~2u;
    _bstr_t::_Free((_bstr_t *)&pSid);
  }
  if ( (v21 & 1) != 0 )
    _bstr_t::_Free((_bstr_t *)v46);
LABEL_23:
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0
    && *((unsigned __int8 *)WPP_GLOBAL_Control + 25) >= (int)(((ActionArgs >> 31) & 0xFFFFFFFE) + 4) )
  {
    WPP_SF_SD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0xEu,
      (__int64)&WPP_ffeb42fce81a3445f9740a981b62c86a_Traceguids,
      *(const wchar_t **)(a2 + 24));
  }
  operator delete(lpMem);
  std::vector<_bstr_t>::_Tidy((__int64)&v31);
  operator delete(v29);
  std::vector<_bstr_t>::_Tidy((__int64)&v33);
  if ( v30 )
    UbpmCloseTriggerConsumer(v30, v17);
  return (unsigned int)ActionArgs;
}
// 180026293: variable 'v12' is possibly undefined
// 180026497: variable 'v17' is possibly undefined
// 18003C5C5: variable 'v25' is possibly undefined
// 180073D60: using guessed type __int64 __fastcall UbpmCloseTriggerConsumer(_QWORD, _QWORD);
// 180073D68: using guessed type __int64 UbpmApiBufferFree(void);
// 180073D70: using guessed type __int64 __fastcall UbpmTriggerConsumerControl(_QWORD, _QWORD, _QWORD);
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (00000001800264D0) ----------------------------------------------------
__int64 __fastcall ItSpStartIdleDetection(struct _ITSRV_GLOBAL_CONTEXT *a1)
{
  int v1; // eax
  __int64 v2; // rcx
  NTSTATUS Query; // eax
  __int64 v4; // r8
  unsigned int SystemSnapshot; // ebx
  DWORD DueTime; // eax
  struct _TP_CLEANUP_GROUP *ThreadpoolCleanupGroup; // rax
  void *Recipient; // [rsp+40h] [rbp-30h] BYREF
  struct _ITSRV_GLOBAL_CONTEXT near **v11; // [rsp+48h] [rbp-28h]
  struct _UNICODE_STRING v12; // [rsp+50h] [rbp-20h] BYREF
  struct _UNICODE_STRING DestinationString; // [rsp+60h] [rbp-10h] BYREF
  struct _ITSRV_GLOBAL_CONTEXT *v14; // [rsp+A0h] [rbp+30h] BYREF
  struct _FILETIME SystemTimeAsFileTime; // [rsp+A8h] [rbp+38h] BYREF
  struct _FILETIME v16; // [rsp+B0h] [rbp+40h]

  v14 = a1;
  if ( byte_1800B11C2 && !qword_1800B10A0 )
  {
    v1 = WmiOpenBlock(&DiskPerfGuid, 0x80000000LL, &qword_1800B10A0);
    v2 = qword_1800B10A0;
    if ( v1 )
      v2 = 0LL;
    qword_1800B10A0 = v2;
  }
  if ( !qword_1800B10B8 )
  {
    Query = PcwCreateQuery(&qword_1800B10B8, 0LL);
    if ( Query < 0 )
      return RtlNtStatusToDosError(Query);
    RtlInitUnicodeString(&DestinationString, L"Processor Information");
    RtlInitUnicodeString(&v12, L"_Total");
    LOBYTE(v4) = 1;
    Query = PcwAddQueryItem(&v14, qword_1800B10B8, v4, &DestinationString, &v12, -1, 0x8000LL, 0LL);
    if ( Query < 0 )
      return RtlNtStatusToDosError(Query);
  }
  if ( (_DWORD)xmmword_1800B0EF4 != 1147547697
    || (SystemSnapshot = ItSpGetSystemSnapshot(
                           (struct _ITSRV_GLOBAL_CONTEXT *)&ItSrvGlobalContext,
                           (struct _ITSRV_SYSTEM_SNAPSHOT *)&dword_1800B10C0)) == 0
    && (SystemSnapshot = ItSpCopySystemSnapshot(
                           (struct _ITSRV_SYSTEM_SNAPSHOT *)&dword_1800B1118,
                           (struct _ITSRV_SYSTEM_SNAPSHOT *)&dword_1800B10C0)) == 0 )
  {
    ResetEvent(hEvent);
    DueTime = Period;
    if ( ::DueTime >= Period )
      DueTime = ::DueTime;
    if ( CreateTimerQueueTimer(
           &Timer,
           0LL,
           (WAITORTIMERCALLBACK)ItSpIdleDetectionCallback,
           &ItSrvGlobalContext,
           DueTime,
           Period,
           0x10u) )
    {
      InitializeSRWLock(&stru_1800B1028);
      dword_1800B0FD8 = 3;
      xmmword_1800B0FE0 = 0LL;
      xmmword_1800B0FF0 = 0LL;
      xmmword_1800B1000 = 0LL;
      dword_1800B1010 = 0;
      dword_1800B1014 = 1;
      dword_1800B1018 = 72;
      ThreadpoolCleanupGroup = CreateThreadpoolCleanupGroup();
      ptpcg = ThreadpoolCleanupGroup;
      if ( ThreadpoolCleanupGroup )
      {
        *((_QWORD *)&xmmword_1800B0FE0 + 1) = ThreadpoolCleanupGroup;
        *(_QWORD *)&xmmword_1800B0FF0 = 0LL;
        Recipient = ItSpUserDetectionCallback;
        dword_1800B11F0 = 0;
        v11 = &ItSrvGlobalContext;
        SystemSnapshot = PowerSettingRegisterNotification(
                           &GUID_GLOBAL_USER_PRESENCE,
                           2u,
                           &Recipient,
                           &RegistrationHandle);
        if ( SystemSnapshot )
        {
          RegistrationHandle = 0LL;
        }
        else
        {
          dword_1800B11F4 = 0;
          Recipient = ItSpLPEDetectionCallback;
          v11 = &ItSrvGlobalContext;
          SystemSnapshot = PowerSettingRegisterNotification(&GUID_LOW_POWER_EPOCH, 2u, &Recipient, &qword_1800B11E0);
          if ( SystemSnapshot )
          {
            qword_1800B11E0 = 0LL;
          }
          else
          {
            dword_1800B11F8 = 0;
            if ( (int)RtlSubscribeWnfStateChangeNotification(
                        &qword_1800B11E8,
                        WNF_XBOX_SYSTEM_CONSTRAINED_MODE_STATUS_CHANGED,
                        0LL,
                        ItSpConstrainedModeDetectionCallback,
                        &ItSrvGlobalContext,
                        0LL,
                        0,
                        0) < 0 )
            {
              qword_1800B11E8 = 0LL;
            }
            else
            {
              dword_1800B1210 = -1;
              Recipient = ItSpPowerSourceDetectionCallback;
              v11 = &ItSrvGlobalContext;
              SystemSnapshot = PowerSettingRegisterNotification(
                                 &GUID_ACDC_POWER_SOURCE,
                                 2u,
                                 &Recipient,
                                 &qword_1800B1208);
              if ( SystemSnapshot )
              {
                qword_1800B1208 = 0LL;
              }
              else
              {
                dword_1800B1220 = 0;
                Recipient = ItSpBatteryThesholdCallback;
                v11 = &ItSrvGlobalContext;
                SystemSnapshot = PowerSettingRegisterNotification(
                                   &GUID_BATTERY_DISCHARGE_LEVEL_1,
                                   2u,
                                   &Recipient,
                                   &qword_1800B1218);
                if ( SystemSnapshot )
                {
                  qword_1800B1218 = 0LL;
                }
                else
                {
                  dword_1800B1230 = 100;
                  Recipient = ItSpBatteryRemainingCallback;
                  v11 = &ItSrvGlobalContext;
                  SystemSnapshot = PowerSettingRegisterNotification(
                                     &GUID_BATTERY_PERCENTAGE_REMAINING,
                                     2u,
                                     &Recipient,
                                     &qword_1800B1228);
                  if ( SystemSnapshot )
                  {
                    qword_1800B1228 = 0LL;
                  }
                  else
                  {
                    dword_1800B1240 = 0;
                    Recipient = ItSpConsoleDisplayStateChangeCallback;
                    v11 = &ItSrvGlobalContext;
                    SystemSnapshot = PowerSettingRegisterNotification(
                                       &GUID_CONSOLE_DISPLAY_STATE,
                                       2u,
                                       &Recipient,
                                       &qword_1800B1238);
                    if ( SystemSnapshot )
                    {
                      qword_1800B1238 = 0LL;
                    }
                    else
                    {
                      qword_1800B1030 = 0LL;
                      GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
                      SystemSnapshot = 0;
                      _InterlockedExchange64(&qword_1800B1250, *(_QWORD *)&SystemTimeAsFileTime + 10000LL * ::DueTime);
                      v16 = SystemTimeAsFileTime;
                      _InterlockedExchange64(&qword_1800B1248, *(_QWORD *)&SystemTimeAsFileTime + 10000LL * ::DueTime);
                    }
                  }
                }
              }
            }
          }
        }
        return SystemSnapshot;
      }
    }
    Timer = 0LL;
    return GetLastError();
  }
  return SystemSnapshot;
}
// 1800265AF: variable 'v4' is possibly undefined
// 180073FC8: using guessed type __int64 __fastcall PcwCreateQuery(_QWORD, _QWORD);
// 180073FD0: using guessed type __int64 __fastcall PcwAddQueryItem(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _QWORD);
// 180074678: using guessed type __int64 __fastcall RtlSubscribeWnfStateChangeNotification(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _DWORD);
// 18007EA58: using guessed type __int64 WNF_XBOX_SYSTEM_CONSTRAINED_MODE_STATUS_CHANGED;
// 1800B0EF0: using guessed type struct _ITSRV_GLOBAL_CONTEXT near *ItSrvGlobalContext;
// 1800B0EF4: using guessed type __int128 xmmword_1800B0EF4;
// 1800B0FD8: using guessed type int dword_1800B0FD8;
// 1800B0FE0: using guessed type __int128 xmmword_1800B0FE0;
// 1800B0FF0: using guessed type __int128 xmmword_1800B0FF0;
// 1800B1000: using guessed type __int128 xmmword_1800B1000;
// 1800B1010: using guessed type int dword_1800B1010;
// 1800B1014: using guessed type int dword_1800B1014;
// 1800B1018: using guessed type int dword_1800B1018;
// 1800B1030: using guessed type __int64 qword_1800B1030;
// 1800B10A0: using guessed type __int64 qword_1800B10A0;
// 1800B10C0: using guessed type int dword_1800B10C0;
// 1800B1118: using guessed type int dword_1800B1118;
// 1800B11C2: using guessed type char byte_1800B11C2;
// 1800B11E8: using guessed type __int64 qword_1800B11E8;
// 1800B11F0: using guessed type int dword_1800B11F0;
// 1800B11F4: using guessed type int dword_1800B11F4;
// 1800B11F8: using guessed type int dword_1800B11F8;
// 1800B1210: using guessed type int dword_1800B1210;
// 1800B1220: using guessed type int dword_1800B1220;
// 1800B1230: using guessed type int dword_1800B1230;
// 1800B1240: using guessed type int dword_1800B1240;
// 1800B1248: using guessed type __int64 qword_1800B1248;
// 1800B1250: using guessed type __int64 qword_1800B1250;
// 1800B90A0: using guessed type __int64 __fastcall WmiOpenBlock(_QWORD, _QWORD, _QWORD);

//----- (0000000180026938) ----------------------------------------------------
__int64 __fastcall UbpmProxySingleton::CreateShallowStringArray(BSTR ***a1, void **a2)
{
  void *v4; // rax
  BSTR **v5; // rbx
  __int64 v6; // rdi
  BSTR *v7; // rax
  UINT v8; // eax
  BSTR v9; // rcx

  v4 = operator new(saturated_mul(a1[1] - *a1, 8uLL));
  wmi::AutoVectorPtr<unsigned char>::operator=(a2, v4);
  v5 = *a1;
  v6 = 0LL;
  while ( v5 != a1[1] )
  {
    v7 = *v5;
    if ( *v5 && *v7 )
      v8 = SysStringLen(*v7);
    else
      v8 = 0;
    if ( v8 )
    {
      if ( *v5 )
        v9 = **v5;
      else
        v9 = 0LL;
      *(_QWORD *)((char *)*a2 + v6) = v9;
    }
    else
    {
      *(_QWORD *)((char *)*a2 + v6) = 0LL;
    }
    ++v5;
    v6 += 8LL;
  }
  return 0LL;
}

//----- (00000001800269FC) ----------------------------------------------------
__int64 __fastcall UbpmProxySingleton::ExpandVariablesInStrings(BSTR **a1, BSTR ***a2)
{
  int LastHrError; // esi
  BSTR *i; // rbx
  const WCHAR *v6; // rcx
  DWORD v7; // eax
  tsched *v8; // rcx
  DWORD v9; // ebp
  WCHAR *v11; // rax
  WCHAR *v12; // rdi
  const WCHAR *v13; // rcx
  DWORD v14; // eax
  tsched *v15; // rcx
  WCHAR Dst[264]; // [rsp+30h] [rbp-238h] BYREF

  LastHrError = 0;
  memset_0(Dst, 0, 0x20AuLL);
  for ( i = *a1; i != a1[1]; ++i )
  {
    LastHrError = Task::ExpandVariablesInString(i, a2);
    if ( LastHrError < 0 )
      break;
    if ( *i )
      v6 = *(const WCHAR **)*i;
    else
      v6 = 0LL;
    v7 = ExpandEnvironmentStringsW(v6, Dst, 0x105u);
    v9 = v7;
    if ( !v7 )
      return (unsigned int)tsched::GetLastHrError(v8);
    if ( v7 > 0x105 )
    {
      v11 = (WCHAR *)operator new(saturated_mul(v7 + 1, 2uLL));
      v12 = v11;
      v13 = *i;
      if ( *i )
        v13 = *(const WCHAR **)v13;
      v14 = ExpandEnvironmentStringsW(v13, v11, v9);
      if ( !v14 )
      {
        LastHrError = tsched::GetLastHrError(v15);
        goto LABEL_20;
      }
      if ( v14 > v9 )
      {
        LastHrError = -2147467260;
LABEL_20:
        operator delete(v12);
        return (unsigned int)LastHrError;
      }
      _bstr_t::operator=((_bstr_t::Data_t **)i, v12);
      operator delete(v12);
    }
    else
    {
      _bstr_t::operator=((_bstr_t::Data_t **)i, Dst);
    }
  }
  return (unsigned int)LastHrError;
}
// 180026AB0: variable 'v8' is possibly undefined
// 18003D0F2: variable 'v15' is possibly undefined

//----- (0000000180026AF0) ----------------------------------------------------
__int64 __fastcall Task::ExpandVariablesInString(BSTR *a1, BSTR ***a2)
{
  BSTR ***v2; // rbx
  BSTR v4; // rax
  UINT v5; // esi
  BSTR v6; // rax
  const unsigned __int16 *v7; // rdx
  const unsigned __int16 *v8; // r14
  __int64 v9; // rdi
  char v10; // cl
  const unsigned __int16 *v11; // r8
  int v12; // r13d
  unsigned __int16 *v13; // r12
  unsigned __int16 *v14; // r15
  __int64 *v15; // r12
  UINT v16; // eax
  BSTR **v18; // rbx
  const unsigned __int16 *v19; // [rsp+20h] [rbp-48h]
  const unsigned __int16 *v20; // [rsp+28h] [rbp-40h]
  BSTR *v21; // [rsp+30h] [rbp-38h] BYREF
  BSTR *v22; // [rsp+38h] [rbp-30h] BYREF
  BSTR *v23; // [rsp+40h] [rbp-28h] BYREF
  BSTR **v24[4]; // [rsp+48h] [rbp-20h] BYREF
  BSTR *v25; // [rsp+B0h] [rbp+48h] BYREF
  BSTR ***v26; // [rsp+B8h] [rbp+50h]
  char v27; // [rsp+C0h] [rbp+58h]
  OLECHAR **v28; // [rsp+C8h] [rbp+60h] BYREF

  v26 = a2;
  v25 = a1;
  v24[1] = (BSTR **)-2LL;
  v2 = a2;
  v4 = *a1;
  if ( *a1 && *(_QWORD *)v4 )
    v5 = SysStringLen(*(BSTR *)v4);
  else
    v5 = 0;
  if ( !v5 )
    return 0LL;
  v6 = *a1;
  if ( *a1 )
    v7 = *(const unsigned __int16 **)v6;
  else
    v7 = 0LL;
  v19 = v7;
  if ( v6 )
    v8 = *(const unsigned __int16 **)v6;
  else
    v8 = 0LL;
  v28 = 0LL;
  LODWORD(v9) = 0;
  v10 = 0;
  v11 = 0LL;
  v20 = 0LL;
  v12 = 0;
  v13 = 0LL;
  do
  {
    v14 = (unsigned __int16 *)&v7[(unsigned int)v9];
    if ( *v14 == 36 )
    {
      if ( v14[1] == 36 )
      {
        v14[1] = 0;
        _bstr_t::_bstr_t((_bstr_t *)&v21, v8);
        _bstr_t::operator+=(&v28, &v21);
        _bstr_t::_Free((_bstr_t *)&v21);
        v14[1] = 36;
        v8 = v14 + 2;
        LODWORD(v9) = v9 + 2;
        v10 = 0;
LABEL_32:
        v7 = v19;
        v11 = v20;
        continue;
      }
      if ( v14[1] != 40 )
        goto LABEL_13;
      v13 = (unsigned __int16 *)&v7[(unsigned int)v9];
      v9 = (unsigned int)(v9 + 2);
      v11 = &v7[v9];
      v20 = v11;
      v12 = 0;
      v10 = 1;
    }
    else
    {
      if ( *v14 != 41 || !v10 )
      {
LABEL_13:
        LODWORD(v9) = v9 + 1;
        ++v12;
        continue;
      }
      v10 = 0;
      v27 = 0;
      LODWORD(v9) = v9 + 1;
      if ( v12 )
      {
        *v14 = 0;
        _bstr_t::_bstr_t((_bstr_t *)&v22, v11);
        std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::find(
          v2,
          v24,
          &v22);
        _bstr_t::_Free((_bstr_t *)&v22);
        *v14 = 41;
        v18 = v24[0];
        if ( *v26 != v24[0] )
        {
          *v13 = 0;
          _bstr_t::_bstr_t((_bstr_t *)&v23, v8);
          _bstr_t::operator+=(&v28, &v23);
          _bstr_t::_Free((_bstr_t *)&v23);
          *v13 = 36;
          _bstr_t::operator+=(&v28, v18 + 5);
          v8 = v14 + 1;
        }
        v2 = v26;
        v10 = v27;
        goto LABEL_32;
      }
    }
  }
  while ( (unsigned int)v9 < v5 );
  v15 = (__int64 *)v25;
  if ( v28 && *v28 )
    v16 = SysStringLen(*v28);
  else
    v16 = 0;
  if ( v16 )
  {
    if ( *v8 )
    {
      _bstr_t::_bstr_t((_bstr_t *)&v25, v8);
      _bstr_t::operator+=(&v28, &v25);
      _bstr_t::_Free((_bstr_t *)&v25);
    }
    _bstr_t::operator=(v15, (__int64 *)&v28);
  }
  _bstr_t::_Free((_bstr_t *)&v28);
  return 0LL;
}
// 180026B85: conditional instruction was optimized away because esi.4!=0

//----- (0000000180026C00) ----------------------------------------------------
__int64 __fastcall ItSpRetrieveDetectionOverrides(struct _IT_IDLE_DETECTION_PARAMETERS *a1)
{
  LSTATUS v2; // eax
  unsigned int OverrideValue; // ebx
  HKEY hKey; // [rsp+48h] [rbp+10h] BYREF

  hKey = 0LL;
  v2 = RegOpenKeyExW(
         HKEY_LOCAL_MACHINE,
         L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\IdleService",
         0,
         0xF003Fu,
         &hKey);
  OverrideValue = v2;
  if ( (unsigned int)(v2 - 2) <= 1 )
  {
    OverrideValue = 0;
  }
  else if ( !v2 )
  {
    OverrideValue = ItSpRetrieveOverrideValue(hKey, L"IdleCheckTimeout", (unsigned int *)a1 + 2);
    if ( !OverrideValue )
    {
      OverrideValue = ItSpRetrieveOverrideValue(hKey, L"IdleEndTimeout", (unsigned int *)a1 + 3);
      if ( !OverrideValue )
      {
        OverrideValue = ItSpRetrieveOverrideValue(hKey, L"UserInput", (bool *)a1);
        if ( !OverrideValue )
        {
          OverrideValue = ItSpRetrieveOverrideValue(hKey, L"SamplingInterval", (unsigned int *)a1 + 4);
          if ( !OverrideValue )
          {
            OverrideValue = ItSpRetrieveOverrideValue(hKey, L"SamplingNumber", (unsigned int *)a1 + 5);
            if ( !OverrideValue )
            {
              OverrideValue = ItSpRetrieveOverrideValue(hKey, L"CPUThreshold", (unsigned int *)a1 + 6);
              if ( !OverrideValue )
                OverrideValue = ItSpRetrieveOverrideValue(hKey, L"IOThreshold", (unsigned int *)a1 + 7);
            }
          }
        }
      }
    }
  }
  if ( hKey )
    RegCloseKey(hKey);
  return OverrideValue;
}

//----- (0000000180026D44) ----------------------------------------------------
LSTATUS __fastcall ItSpRetrieveOverrideValue(HKEY a1, const unsigned __int16 *a2, unsigned int *a3)
{
  LSTATUS result; // eax
  DWORD v5; // [rsp+30h] [rbp-18h] BYREF
  unsigned int v6[5]; // [rsp+34h] [rbp-14h] BYREF
  DWORD v7; // [rsp+68h] [rbp+20h] BYREF

  v5 = 4;
  v7 = 4;
  result = RegQueryValueExW(a1, a2, 0LL, &v5, (LPBYTE)v6, &v7);
  if ( (unsigned int)(result - 2) <= 1 )
    return 0;
  if ( !result )
    *a3 = v6[0];
  return result;
}
// 180026D44: using guessed type unsigned int var_14[5];

//----- (0000000180026D9C) ----------------------------------------------------
__int64 __fastcall ItSpRetrieveRuntimeOverrides(struct _IT_IDLE_RUNTIME_PARAMETERS *a1)
{
  LSTATUS v2; // eax
  unsigned int OverrideValue; // ebx
  const unsigned __int16 *v4; // rdx
  HKEY hKey; // [rsp+48h] [rbp+10h] BYREF

  hKey = 0LL;
  v2 = RegOpenKeyExW(
         HKEY_LOCAL_MACHINE,
         L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\IdleService",
         0,
         0xF003Fu,
         &hKey);
  OverrideValue = v2;
  if ( (unsigned int)(v2 - 2) <= 1 )
  {
    OverrideValue = 0;
  }
  else if ( !v2 )
  {
    OverrideValue = ItSpRetrieveOverrideValue(hKey, L"SkipNotification", (bool *)a1);
    if ( !OverrideValue )
      OverrideValue = ItSpRetrieveOverrideValue(hKey, v4, (unsigned __int16 **)a1 + 1, (unsigned int *)a1 + 1);
  }
  if ( hKey )
    RegCloseKey(hKey);
  return OverrideValue;
}
// 180026E10: variable 'v4' is possibly undefined

//----- (0000000180026E48) ----------------------------------------------------
__int64 __fastcall ItSpRetrieveOverrideValue(
        HKEY hKey,
        const unsigned __int16 *a2,
        unsigned __int16 **a3,
        unsigned int *a4)
{
  void *lpData; // rdi
  unsigned int v8; // ebx
  unsigned int v10; // eax
  DWORD v11; // ebx
  HANDLE v12; // rax
  void *v13; // rax
  void *v14; // rsi
  HANDLE v15; // rax
  HANDLE ProcessHeap; // rax
  DWORD Type[10]; // [rsp+30h] [rbp-28h] BYREF
  DWORD dwBytes; // [rsp+68h] [rbp+10h] BYREF
  int dwBytes_4; // [rsp+6Ch] [rbp+14h]

  dwBytes_4 = HIDWORD(a2);
  dwBytes = 0;
  Type[0] = 7;
  lpData = 0LL;
  v8 = RegQueryValueExW(hKey, L"ExemptRegistrationList", 0LL, Type, 0LL, &dwBytes);
  if ( v8 - 2 <= 1 )
  {
    v8 = 0;
LABEL_3:
    if ( lpData )
    {
      ProcessHeap = GetProcessHeap();
      HeapFree(ProcessHeap, 0, lpData);
    }
    return v8;
  }
  if ( v8 )
    return v8;
  v10 = dwBytes;
  if ( dwBytes )
  {
    v11 = dwBytes;
    v12 = GetProcessHeap();
    v13 = HeapAlloc(v12, 0, v11);
    lpData = v13;
    if ( !v13 )
      return 8;
    memset_0(v13, 0, dwBytes);
    v8 = RegQueryValueExW(hKey, L"ExemptRegistrationList", 0LL, Type, (LPBYTE)lpData, &dwBytes);
    if ( v8 )
      goto LABEL_3;
    v10 = dwBytes;
  }
  v14 = *a3;
  if ( *a3 )
  {
    v15 = GetProcessHeap();
    HeapFree(v15, 0, v14);
    v10 = dwBytes;
  }
  *a4 = v10;
  *a3 = (unsigned __int16 *)lpData;
  return v8;
}

//----- (0000000180026ED4) ----------------------------------------------------
LSTATUS __fastcall ItSpRetrieveOverrideValue(HKEY a1, const unsigned __int16 *a2, bool *a3)
{
  LSTATUS result; // eax
  DWORD v5; // [rsp+30h] [rbp-18h] BYREF
  int v6[5]; // [rsp+34h] [rbp-14h] BYREF
  DWORD v7; // [rsp+68h] [rbp+20h] BYREF

  v5 = 4;
  v7 = 4;
  result = RegQueryValueExW(a1, a2, 0LL, &v5, (LPBYTE)v6, &v7);
  if ( (unsigned int)(result - 2) <= 1 )
    return 0;
  if ( !result )
    *a3 = v6[0] != 0;
  return result;
}
// 180026ED4: using guessed type int var_14[5];

//----- (0000000180026F38) ----------------------------------------------------
__int64 RpcServer::IsNonAdminTasksDisabled(void)
{
  unsigned int v0; // ebx
  int v2; // [rsp+50h] [rbp+8h] BYREF
  DWORD v3; // [rsp+58h] [rbp+10h] BYREF

  v0 = 0;
  v3 = 4;
  v2 = 0;
  if ( (RegGetValueW(
          HKEY_LOCAL_MACHINE,
          L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Schedule",
          L"DisableNonAdminTasks",
          0x10u,
          0LL,
          &v2,
          &v3) & 0xFFFFFFFD) != 0 )
    return 0LL;
  LOBYTE(v0) = v2 != 0;
  return v0;
}

//----- (0000000180026FA8) ----------------------------------------------------
__int64 RpcServer::IsRpcOverTcpDisabled(void)
{
  unsigned int v0; // ebx
  int v2; // [rsp+50h] [rbp+8h] BYREF
  DWORD v3; // [rsp+58h] [rbp+10h] BYREF

  v0 = 0;
  v3 = 4;
  v2 = 0;
  if ( (RegGetValueW(
          HKEY_LOCAL_MACHINE,
          L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Schedule",
          L"DisableRpcOverTcp",
          0x10u,
          0LL,
          &v2,
          &v3) & 0xFFFFFFFD) != 0 )
    return 0LL;
  LOBYTE(v0) = v2 != 0;
  return v0;
}

//----- (0000000180027018) ----------------------------------------------------
__int64 JobsService::ControlOperationalLog(void)
{
  unsigned int IsMachineDomainJoined; // ebx
  int v1; // esi
  int v2; // ecx
  int v4; // [rsp+30h] [rbp+8h] BYREF
  int v5; // [rsp+38h] [rbp+10h] BYREF

  IsMachineDomainJoined = 0;
  if ( !(unsigned int)JobStore::IsSystemSetupInProgress()
    && !(unsigned int)JobStore::IsWinPESetupInProgress()
    && !(unsigned int)IsSystemUpgradeInProgress() )
  {
    IsMachineDomainJoined = JobsService::IsMachineDomainJoined(&v4);
    if ( (IsMachineDomainJoined & 0x80000000) == 0 )
    {
      v1 = 0;
      IsMachineDomainJoined = JobsService::IsMachineDomainJoinPrevDetected(&v5);
      if ( tsched::IsErrorNotFound((tsched *)IsMachineDomainJoined) )
      {
        v1 = 1;
      }
      else if ( v2 < 0 )
      {
        return IsMachineDomainJoined;
      }
      if ( !v1 )
      {
        if ( v4 )
        {
          if ( v5 )
            return IsMachineDomainJoined;
        }
        else if ( !v5 )
        {
          return IsMachineDomainJoined;
        }
      }
      IsMachineDomainJoined = JobsService::EnableOperationalLog(v4);
      if ( (IsMachineDomainJoined & 0x80000000) == 0 )
        return (unsigned int)JobsService::SetMachineDomainJoinPrevDetected(v4);
    }
  }
  return IsMachineDomainJoined;
}
// 18002706A: variable 'v2' is possibly undefined

//----- (00000001800270A4) ----------------------------------------------------
signed int __fastcall JobsService::IsMachineDomainJoinPrevDetected(int *a1)
{
  signed int result; // eax
  bool v3; // cc
  int v4; // [rsp+58h] [rbp+10h] BYREF
  DWORD v5; // [rsp+60h] [rbp+18h] BYREF

  v4 = 0;
  v5 = 4;
  result = RegGetValueW(
             HKEY_LOCAL_MACHINE,
             L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Schedule",
             L"DomainJoinDetected",
             0x10u,
             0LL,
             &v4,
             &v5);
  v3 = result <= 0;
  if ( !result )
  {
    v3 = 1;
    *a1 = v4 != 0;
  }
  if ( !v3 )
    return (unsigned __int16)result | 0x80070000;
  return result;
}

//----- (000000018002711C) ----------------------------------------------------
__int64 __fastcall JobsService::IsMachineDomainJoined(int *a1)
{
  signed int JoinInformation; // eax
  unsigned int v3; // ebx
  int v5; // [rsp+38h] [rbp+10h] BYREF
  LPVOID Buffer; // [rsp+40h] [rbp+18h] BYREF

  Buffer = 0LL;
  JoinInformation = NetGetJoinInformation(0LL, (LPWSTR *)&Buffer, (PNETSETUP_JOIN_STATUS)&v5);
  v3 = JoinInformation;
  if ( JoinInformation )
  {
    if ( JoinInformation > 0 )
      v3 = (unsigned __int16)JoinInformation | 0x80070000;
  }
  else if ( v5 )
  {
    LOBYTE(JoinInformation) = v5 == 3;
    *a1 = JoinInformation;
  }
  else
  {
    v3 = -2147467259;
  }
  if ( Buffer )
    NetApiBufferFree(Buffer);
  return v3;
}

//----- (0000000180027194) ----------------------------------------------------
__int64 IsSystemUpgradeInProgress()
{
  __int64 result; // rax
  int v1; // [rsp+30h] [rbp+8h] BYREF

  v1 = 0;
  if ( !(unsigned int)QueryUpgradeValue(&v1) )
    return 0LL;
  result = 1LL;
  if ( v1 != 1 )
    return 0LL;
  return result;
}

//----- (00000001800271C0) ----------------------------------------------------
__int64 __fastcall QueryUpgradeValue(_DWORD *a1)
{
  unsigned int v1; // ebx
  HKEY hKey; // [rsp+30h] [rbp-10h] BYREF
  DWORD Type; // [rsp+68h] [rbp+28h] BYREF
  int Data; // [rsp+70h] [rbp+30h] BYREF
  DWORD cbData; // [rsp+78h] [rbp+38h] BYREF

  v1 = 0;
  hKey = 0LL;
  if ( !RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"System\\Setup", 0, 1u, &hKey) )
  {
    Data = 0;
    cbData = 4;
    Type = 0;
    if ( !RegQueryValueExW(hKey, L"Upgrade", 0LL, &Type, (LPBYTE)&Data, &cbData) && Type == 4 )
    {
      if ( a1 )
        *a1 = Data;
      v1 = 1;
    }
    RegCloseKey(hKey);
  }
  return v1;
}

//----- (0000000180027268) ----------------------------------------------------
__int64 JobStore::IsWinPESetupInProgress(void)
{
  int v0; // eax
  HKEY hKey; // [rsp+40h] [rbp+8h] BYREF

  v0 = RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"System\\CurrentControlSet\\Control\\Minint", 0, 0x20019u, &hKey);
  if ( v0 )
  {
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x74u,
        (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
        v0);
    }
    return 0LL;
  }
  else
  {
    RegCloseKey(hKey);
    return 1LL;
  }
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (00000001800272D0) ----------------------------------------------------
__int64 JobStore::IsSystemSetupInProgress(void)
{
  int v0; // eax
  LSTATUS v1; // ebx
  __int64 result; // rax
  DWORD cbData; // [rsp+40h] [rbp+8h] BYREF
  int Data; // [rsp+48h] [rbp+10h] BYREF
  HKEY hKey; // [rsp+50h] [rbp+18h] BYREF

  v0 = RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"System\\Setup", 0, 0x20019u, &hKey);
  if ( v0 )
  {
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x72u,
        (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
        v0);
    }
    return 0LL;
  }
  cbData = 4;
  v1 = RegQueryValueExW(hKey, L"SystemSetupInProgress", 0LL, 0LL, (LPBYTE)&Data, &cbData);
  RegCloseKey(hKey);
  if ( v1 )
    return 0LL;
  result = 1LL;
  if ( Data != 1 )
    return 0LL;
  return result;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180027374) ----------------------------------------------------
signed int __fastcall Actions::ActionCollection::ExtractActionArgs(__int64 **a1, __int64 *a2, __int64 *a3)
{
  signed int v6; // edi
  __int64 *v7; // rbx
  __int16 v8; // ax
  const unsigned __int16 *v9; // rdx
  __int64 *v10; // rax
  _bstr_t *v11; // rcx
  signed int result; // eax
  __int64 v13; // rsi
  const unsigned __int16 **v14; // rax
  const unsigned __int16 *v15; // rdx
  __int64 *v16; // rax
  const unsigned __int16 *v17; // rdx
  __int64 *v18; // rax
  char v19[8]; // [rsp+48h] [rbp-48h] BYREF
  char v20[8]; // [rsp+50h] [rbp-40h] BYREF
  char v21[8]; // [rsp+58h] [rbp-38h] BYREF
  __int64 v22; // [rsp+60h] [rbp-30h]
  __int64 v23; // [rsp+B0h] [rbp+20h] BYREF

  v22 = -2LL;
  v6 = 0;
  v7 = *a1;
  while ( 1 )
  {
    v7 = (__int64 *)*v7;
    if ( v7 == *a1 )
      return v6;
    v8 = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v7[2] + 24LL))(v7[2]);
    if ( v8 == 30583 )
    {
      v9 = *(const unsigned __int16 **)(v7[2] + 72);
      if ( v9 )
        v9 = *(const unsigned __int16 **)v9;
      v10 = (__int64 *)_bstr_t::_bstr_t((_bstr_t *)v19, v9);
      std::vector<_bstr_t>::push_back(a2, v10);
      _bstr_t::_Free((_bstr_t *)v19);
      v23 = 0LL;
      std::vector<_bstr_t>::push_back(a3, &v23);
      v11 = (_bstr_t *)&v23;
      goto LABEL_7;
    }
    if ( v8 != 26214 )
      return -2147418113;
    v13 = v7[2];
    result = ExeTask::NormalizePathAndArguments((BSTR **)v13);
    v6 = result;
    if ( result < 0 )
      return result;
    v14 = *(const unsigned __int16 ***)(v13 + 56);
    if ( v14 )
      v15 = *v14;
    else
      v15 = 0LL;
    v16 = (__int64 *)_bstr_t::_bstr_t((_bstr_t *)v20, v15);
    std::vector<_bstr_t>::push_back(a2, v16);
    _bstr_t::_Free((_bstr_t *)v20);
    v17 = *(const unsigned __int16 **)(v13 + 64);
    if ( v17 )
      v17 = *(const unsigned __int16 **)v17;
    v18 = (__int64 *)_bstr_t::_bstr_t((_bstr_t *)v21, v17);
    std::vector<_bstr_t>::push_back(a3, v18);
    v11 = (_bstr_t *)v21;
LABEL_7:
    _bstr_t::_Free(v11);
  }
}
// 180027374: could not find valid save-restore pair for rbp
// 180027374: using guessed type char var_48[8];
// 180027374: using guessed type char var_40[8];
// 180027374: using guessed type char var_38[8];

//----- (000000018002744C) ----------------------------------------------------
__int64 *__fastcall std::vector<_bstr_t>::push_back(__int64 *a1, __int64 *a2)
{
  __int64 *result; // rax
  __int64 v6; // rcx
  __int64 v7; // rcx
  __int64 v8; // rdi

  result = (__int64 *)a1[1];
  if ( a2 < result && *a1 <= (unsigned __int64)a2 )
  {
    v7 = *a1;
    v8 = ((__int64)a2 - *a1) >> 3;
    if ( result == (__int64 *)a1[2] )
    {
      std::vector<_bstr_t>::_Reserve(a1);
      result = (__int64 *)a1[1];
      v7 = *a1;
    }
    v6 = *(_QWORD *)(v7 + 8 * v8);
  }
  else
  {
    if ( result == (__int64 *)a1[2] )
    {
      std::vector<_bstr_t>::_Reserve(a1);
      result = (__int64 *)a1[1];
    }
    v6 = *a2;
  }
  *result = v6;
  if ( v6 )
    _InterlockedIncrement((volatile signed __int32 *)(v6 + 16));
  a1[1] += 8LL;
  return result;
}

//----- (00000001800274B0) ----------------------------------------------------
__int64 __fastcall std::vector<_bstr_t>::_Reserve(_QWORD *a1)
{
  __int64 v2; // rdx
  __int64 result; // rax
  __int64 v4; // rdx
  unsigned __int64 v5; // rdx
  unsigned __int64 v6; // r9
  unsigned __int64 v7; // rcx

  v2 = a1[1];
  result = (a1[2] - v2) >> 3;
  if ( !result )
  {
    v4 = (v2 - *a1) >> 3;
    if ( v4 == 0x1FFFFFFFFFFFFFFFLL )
      std::_Xlength_error("vector<T> too long");
    v5 = v4 + 1;
    v6 = (__int64)(a1[2] - *a1) >> 3;
    v7 = 0LL;
    if ( 0x1FFFFFFFFFFFFFFFLL - (v6 >> 1) >= v6 )
      v7 = v6 + (v6 >> 1);
    if ( v7 >= v5 )
      v5 = v7;
    return (__int64)std::vector<_bstr_t>::_Reallocate((__int64)a1, v5);
  }
  return result;
}

//----- (000000018002752C) ----------------------------------------------------
__int64 *__fastcall std::vector<_bstr_t>::_Reallocate(__int64 a1, unsigned __int64 a2)
{
  __int64 *v4; // rbx
  __int64 *v5; // r12
  __int64 *v6; // rdi
  __int64 v7; // r15
  __int64 *result; // rax

  v4 = 0LL;
  if ( a2 )
  {
    if ( a2 > 0x1FFFFFFFFFFFFFFFLL || (v4 = (__int64 *)operator new(8 * a2)) == 0LL )
      std::_Xbad_alloc();
  }
  std::_Uninit_move<_bstr_t *,_bstr_t *,std::allocator<_bstr_t>,_bstr_t>(*(__int64 **)a1, *(__int64 **)(a1 + 8), v4);
  v5 = *(__int64 **)(a1 + 8);
  v6 = *(__int64 **)a1;
  v7 = ((__int64)v5 - *(_QWORD *)a1) >> 3;
  if ( *(_QWORD *)a1 )
  {
    if ( v6 != v5 )
    {
      do
        _bstr_t::_Free((_bstr_t *)v6++);
      while ( v6 != v5 );
      v6 = *(__int64 **)a1;
    }
    operator delete(v6);
  }
  *(_QWORD *)(a1 + 16) = &v4[a2];
  result = &v4[v7];
  *(_QWORD *)(a1 + 8) = result;
  *(_QWORD *)a1 = v4;
  return result;
}

//----- (00000001800275EC) ----------------------------------------------------
__int64 *__fastcall std::_Uninit_move<_bstr_t *,_bstr_t *,std::allocator<_bstr_t>,_bstr_t>(
        __int64 *a1,
        __int64 *a2,
        __int64 *a3)
{
  __int64 v4; // rax

  while ( a1 != a2 )
  {
    v4 = *a1;
    *a3 = *a1;
    if ( v4 )
      _InterlockedIncrement((volatile signed __int32 *)(v4 + 16));
    ++a3;
    ++a1;
  }
  return a3;
}

//----- (0000000180027620) ----------------------------------------------------
__int64 __fastcall JobsService::Initialize(
        JobsService *this,
        struct SERVICE_STATUS_HANDLE__ *a2,
        __int64 a3,
        const unsigned __int16 *const *a4)
{
  unsigned int TickCount; // eax
  __int64 result; // rax
  unsigned __int64 i; // rax
  char *v9; // rax
  EventManager *v10; // rsi
  int v11; // eax
  EventManager *v12; // rcx
  signed int v13; // edi
  AuthzAutoHandle *v14; // rax
  const unsigned __int16 *v15; // rdx
  Auditor *v16; // rcx
  __int64 v17; // r8
  HANDLE WaitableTimer; // rax
  unsigned int v19; // eax
  void *v20; // r9
  int v21; // edi
  HANDLE EventW; // rax
  HANDLE v23; // rax
  HRESULT v24; // eax
  void *v25; // r9
  int v26; // eax
  EventManager *v27; // rcx
  int v28; // eax
  EventManager *v29; // rcx
  int v30; // eax
  void *v31; // r9
  int CommonJobStore; // eax
  EventManager *v33; // rcx
  Scheduler *v34; // rax
  Scheduler *v35; // rax
  EventTrapMap *v36; // rax
  EventTrapMap *v37; // rax
  PseudoEventTrap *v38; // rax
  Idolater *v39; // rcx
  void *v40; // r9
  PseudoEventTrap *v41; // rax
  int v42; // eax
  int v43; // eax
  void *v44; // r9
  int v45; // eax
  JobsService *v46; // rcx
  int started; // edi
  int v48; // eax
  EventManager *v49; // rcx
  int v50; // eax
  EventManager *v51; // rcx
  int v52; // eax
  EventManager *v53; // rcx
  int LastError; // eax
  EventManager *v55; // rcx
  HKEY v56; // [rsp+88h] [rbp-38h] BYREF
  HKEY phkResult[2]; // [rsp+90h] [rbp-30h] BYREF
  Scheduler *v58; // [rsp+A0h] [rbp-20h]

  phkResult[1] = HKEY_DYN_DATA|0x7FFFFFF8LL;
  TickCount = GetTickCount();
  srand(TickCount);
  result = (__int64)CreateThreadpoolCleanupGroup();
  *((_QWORD *)this + 32) = result;
  if ( result )
  {
    *((_QWORD *)this + 25) = result;
    *((_QWORD *)this + 26) = 0LL;
    JobsService::DetectBootStart(this);
    for ( i = 0LL; i < 0x140; i += 16LL )
      *(unsigned int *)((char *)&dword_1800AFC38 + i) = -1;
    dword_1800AFD68 = InitializeCmdlineProcessing();
    v9 = (char *)operator new(0x30uLL);
    v10 = (EventManager *)v9;
    if ( v9 )
    {
      *(_QWORD *)v9 = 0LL;
      InitializeCriticalSectionEx((LPCRITICAL_SECTION)(v9 + 8), 0, 0);
    }
    else
    {
      v10 = 0LL;
    }
    g_pEventManager = v10;
    v11 = EtwEventRegister(&TASKSCHED, 0LL, 0LL, v10);
    v13 = v11;
    if ( !*(_QWORD *)v10 || v11 )
    {
      EventManager::LogIt(v12, L"EventRegister error", v11);
      *(_QWORD *)v10 = 0LL;
      if ( v13 > 0 )
        v13 = (unsigned __int16)v13 | 0x80070000;
    }
    else
    {
      v13 = 0;
    }
    dword_1800AFC48 = v13;
    v14 = (AuthzAutoHandle *)operator new(0x28uLL);
    if ( v14 )
    {
      *(_QWORD *)v14 = 0LL;
      *((_QWORD *)v14 + 1) = 0LL;
      *((_QWORD *)v14 + 2) = 0LL;
      *((_QWORD *)v14 + 3) = 0LL;
      *((_QWORD *)v14 + 4) = 0LL;
    }
    else
    {
      v14 = 0LL;
    }
    g_pAuditor = v14;
    dword_1800AFD58 = Auditor::StartupAuditing(v16, v15, v17);
    WaitableTimer = CreateWaitableTimerExW(0LL, 0LL, 0, 0x1F0003u);
    *((_QWORD *)this + 18) = WaitableTimer;
    if ( WaitableTimer )
    {
      v19 = ItSrvInitialize();
      v21 = v19;
      if ( v19
        && (EventManager::EvtReport(g_pEventManager, &SCHEDULE_SERVICE_IDLE_SERVICE_INIT_ERROR, v19, v20), v21 > 0) )
      {
        dword_1800AFC38 = (unsigned __int16)v21 | 0x80070000;
      }
      else
      {
        dword_1800AFC38 = v21;
      }
      EventW = CreateEventW(0LL, 0, 0, 0LL);
      *((_QWORD *)this + 14) = EventW;
      if ( EventW )
      {
        v23 = CreateEventW(0LL, 0, 0, 0LL);
        *((_QWORD *)this + 15) = v23;
        if ( v23 )
        {
          g_hShutdownEvent = CreateEventW(0LL, 1, 0, 0LL);
          if ( g_hShutdownEvent )
          {
            v24 = CoInitializeEx(0LL, 0);
            dword_1800AFC58 = v24;
            if ( v24 < 0 )
            {
              EventManager::EvtReport(g_pEventManager, &SCHEDULE_SERVICE_COM_INIT_ERROR, (unsigned int)v24, v25);
              return 0LL;
            }
            else
            {
              v26 = ShutdownMgr::Initialize();
              dword_1800AFC78 = v26;
              if ( v26 < 0 )
              {
                EventManager::EvtReport(v27, &SCHEDULE_SERVICE_START_FAILED, L"ShutdownGuard::Initialize", v26);
                return 0LL;
              }
              else
              {
                v28 = User::InitializeUserTable();
                dword_1800AFCE8 = v28;
                if ( v28 < 0 )
                {
                  EventManager::EvtReport(v29, &SCHEDULE_SERVICE_START_FAILED, L"User::InitializeUserTable", v28);
                  return 0LL;
                }
                else
                {
                  v30 = CredStore::Init();
                  dword_1800AFC68 = v30;
                  if ( v30 < 0 )
                  {
                    EventManager::EvtReport(
                      g_pEventManager,
                      &SCHEDULE_SERVICE_CRED_STORE_INIT_ERROR,
                      (unsigned int)v30,
                      v31);
                    return 0LL;
                  }
                  else if ( RegCreateKeyExW(
                              HKEY_LOCAL_MACHINE,
                              L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Schedule",
                              0,
                              0LL,
                              0,
                              0x20019u,
                              0LL,
                              phkResult,
                              0LL) )
                  {
                    return 0LL;
                  }
                  else
                  {
                    v56 = 0LL;
                    if ( (unsigned __int8)RtlIsStateSeparationEnabled() )
                      GetServiceRegistryStateKey(a2, 1LL, 131103LL, &v56);
                    CommonJobStore = JobStore::CreateCommonJobStore(phkResult[0], v56);
                    dword_1800AFC88 = CommonJobStore;
                    if ( CommonJobStore < 0 )
                    {
                      EventManager::EvtReport(
                        v33,
                        &SCHEDULE_SERVICE_START_FAILED,
                        L"JobStore::CreateCommonJobStore",
                        CommonJobStore);
                      return 0LL;
                    }
                    else
                    {
                      v34 = (Scheduler *)operator new(0x1E0uLL);
                      v58 = v34;
                      if ( v34 )
                        v35 = Scheduler::Scheduler(v34, *((void **)this + 14), *((void **)this + 15));
                      else
                        v35 = 0LL;
                      g_pScheduler = v35;
                      dword_1800AFCB8 = 0;
                      v36 = (EventTrapMap *)operator new(0x838uLL);
                      if ( v36 )
                        v37 = EventTrapMap::EventTrapMap(v36);
                      else
                        v37 = 0LL;
                      g_pEventTrapMap = v37;
                      dword_1800AFCC8 = 0;
                      v38 = (PseudoEventTrap *)operator new(0xF0uLL);
                      v58 = v38;
                      if ( v38 )
                        v41 = PseudoEventTrap::PseudoEventTrap(v38);
                      else
                        v41 = 0LL;
                      g_pPseudoEventTrap = v41;
                      dword_1800AFCD8 = 0;
                      v42 = dword_1800AFC38;
                      if ( (dword_1800AFC38 & 0x80000000) == 0 )
                        v42 = Idolater::Init(v39);
                      dword_1800AFCF8 = v42;
                      if ( v42 < 0 )
                        EventManager::EvtReport(
                          g_pEventManager,
                          &SCHEDULE_SERVICE_IDLE_SERVICE_INIT_ERROR,
                          (unsigned int)v42,
                          v40);
                      if ( !JobsService::IsCompatibilityAdapterDisabled() )
                      {
                        InitializeCriticalSection(&PlugIn::s_singleton);
                        dword_1800AFD08 = 0;
                        v43 = PlugIn::Load(&PlugIn::s_singleton);
                        dword_1800AFD18 = v43;
                        if ( v43 < 0 )
                          EventManager::EvtReport(g_pEventManager, &COMPAT_START_FAILED, (unsigned int)v43, v44);
                      }
                      v45 = UbpmInitialize(a2);
                      if ( v45 > 0 )
                        v45 = (unsigned __int16)v45 | 0x80070000;
                      dword_1800AFD38 = v45;
                      if ( v45 < 0 )
                      {
                        if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
                          && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x400) != 0
                          && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
                        {
                          WPP_SF_D(
                            *((_QWORD *)WPP_GLOBAL_Control + 2),
                            0x12u,
                            (__int64)&WPP_e3966bf9b81b3ab085a9dfdc4dace9ef_Traceguids,
                            v45);
                        }
                        return 0LL;
                      }
                      else
                      {
                        JobsService::InitializeSCMEventLogNotifications(this);
                        dword_1800AFD48 = JobsService::InitializeWPTS(v46);
                        started = RpcServer::StartServer((RPC_BINDING_VECTOR **)&RpcServer::s_singleton);
                        if ( started < 0 )
                          RpcServer::StopServer((RPC_BINDING_VECTOR **)&RpcServer::s_singleton);
                        dword_1800AFD28 = started;
                        if ( started < 0 )
                        {
                          if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
                            && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x400) != 0
                            && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
                          {
                            WPP_SF_D(
                              *((_QWORD *)WPP_GLOBAL_Control + 2),
                              0x13u,
                              (__int64)&WPP_e3966bf9b81b3ab085a9dfdc4dace9ef_Traceguids,
                              started);
                          }
                          return 0LL;
                        }
                        else
                        {
                          return 1LL;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          else
          {
            LastError = GetLastError();
            EventManager::EvtReport(v55, &SCHEDULE_SERVICE_START_FAILED, L"CreateEvent (Shutdown)", LastError);
            return 0LL;
          }
        }
        else
        {
          v52 = GetLastError();
          EventManager::EvtReport(v53, &SCHEDULE_SERVICE_START_FAILED, L"CreateEvent (TimeChanged)", v52);
          return 0LL;
        }
      }
      else
      {
        v50 = GetLastError();
        EventManager::EvtReport(v51, &SCHEDULE_SERVICE_START_FAILED, L"CreateEvent (Stop)", v50);
        return 0LL;
      }
    }
    else
    {
      v48 = GetLastError();
      EventManager::EvtReport(v49, &SCHEDULE_SERVICE_START_FAILED, L"CreateWaitableTimer", v48);
      return 0LL;
    }
  }
  return result;
}
// 180027620: could not find valid save-restore pair for rbp
// 180027A7B: conditional instruction was optimized away because edi.4>=0
// 18002775D: variable 'v16' is possibly undefined
// 18002775D: variable 'v15' is possibly undefined
// 18002775D: variable 'v17' is possibly undefined
// 1800279A9: variable 'v39' is possibly undefined
// 18003DA86: variable 'v40' is possibly undefined
// 18003DAA2: variable 'v44' is possibly undefined
// 180027A3C: variable 'v46' is possibly undefined
// 18003D8AC: variable 'v12' is possibly undefined
// 18003D8EF: variable 'v49' is possibly undefined
// 18003D90C: variable 'v20' is possibly undefined
// 18003D949: variable 'v51' is possibly undefined
// 18003D972: variable 'v53' is possibly undefined
// 18003D99B: variable 'v55' is possibly undefined
// 18003D9B8: variable 'v25' is possibly undefined
// 18003D9D5: variable 'v27' is possibly undefined
// 18003D9F2: variable 'v29' is possibly undefined
// 18003DA0F: variable 'v31' is possibly undefined
// 18003DA51: variable 'v33' is possibly undefined
// 180073D40: using guessed type __int64 __fastcall UbpmInitialize(_QWORD);
// 180074760: using guessed type __int64 __fastcall EtwEventRegister(_QWORD, _QWORD, _QWORD, _QWORD);
// 180074780: using guessed type __int64 RtlIsStateSeparationEnabled(void);
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 1800AFC48: using guessed type int dword_1800AFC48;
// 1800AFC58: using guessed type int dword_1800AFC58;
// 1800AFC68: using guessed type int dword_1800AFC68;
// 1800AFC78: using guessed type int dword_1800AFC78;
// 1800AFC88: using guessed type int dword_1800AFC88;
// 1800AFCB8: using guessed type int dword_1800AFCB8;
// 1800AFCC8: using guessed type int dword_1800AFCC8;
// 1800AFCD8: using guessed type int dword_1800AFCD8;
// 1800AFCE8: using guessed type int dword_1800AFCE8;
// 1800AFCF8: using guessed type int dword_1800AFCF8;
// 1800AFD08: using guessed type int dword_1800AFD08;
// 1800AFD18: using guessed type int dword_1800AFD18;
// 1800AFD28: using guessed type int dword_1800AFD28;
// 1800AFD38: using guessed type int dword_1800AFD38;
// 1800AFD48: using guessed type int dword_1800AFD48;
// 1800AFD58: using guessed type int dword_1800AFD58;
// 1800AFD68: using guessed type int dword_1800AFD68;
// 1800B0CE0: using guessed type _RTL_CRITICAL_SECTION PlugIn::s_singleton;
// 1800B0D48: using guessed type __int64 RpcServer::s_singleton;
// 1800B9230: using guessed type __int64 __fastcall GetServiceRegistryStateKey(_QWORD, _QWORD, _QWORD, _QWORD);
// 180027620: using guessed type HKEY var_30[2];

//----- (0000000180027AB4) ----------------------------------------------------
__int64 __fastcall JobsService::InitializeWPTS(JobsService *this)
{
  HMODULE Library; // rax
  __int64 (*ProcAddress)(void); // rax
  int v3; // eax
  int v4; // ebx
  signed int LastError; // eax

  Library = LoadLibraryExW(L"WPTaskScheduler.dll", 0LL, 0x800u);
  g_hModuleWpts = Library;
  if ( !Library || (ProcAddress = GetProcAddress(Library, "WptsInitialize")) == 0LL )
  {
    LastError = GetLastError();
    v4 = LastError;
    if ( LastError > 0 )
      v4 = (unsigned __int16)LastError | 0x80070000;
    goto LABEL_13;
  }
  v3 = ProcAddress();
  v4 = v3;
  if ( v3 > 0 )
    v4 = (unsigned __int16)v3 | 0x80070000;
  if ( v4 < 0 )
  {
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x400) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x1Eu,
        (__int64)&WPP_e3966bf9b81b3ab085a9dfdc4dace9ef_Traceguids,
        v4);
    }
LABEL_13:
    if ( v4 < 0 && g_hModuleWpts )
    {
      FreeLibrary(g_hModuleWpts);
      g_hModuleWpts = 0LL;
    }
  }
  return (unsigned int)v4;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180027B2C) ----------------------------------------------------
__int64 __fastcall JobsService::InitializeSCMEventLogNotifications(JobsService *this)
{
  unsigned int v1; // ebx
  SC_HANDLE v3; // rsi
  SC_HANDLE v4; // rax
  SC_HANDLE v5; // rbp
  int v6; // edi
  __int64 v7; // rax
  int LastError; // eax
  unsigned __int16 v10; // dx
  signed int v11; // eax
  int v12; // ebx
  __int64 v13; // [rsp+58h] [rbp+10h] BYREF

  v1 = 0;
  v13 = 0LL;
  v3 = 0LL;
  v4 = OpenSCManagerW(0LL, 0LL, 4u);
  v5 = v4;
  if ( !v4 )
  {
    if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
      || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0
      || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
    {
      goto LABEL_17;
    }
    LastError = GetLastError();
    v10 = 26;
    goto LABEL_16;
  }
  v3 = OpenServiceW(v4, L"EventLog", 4u);
  if ( !v3 )
  {
    if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
      || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) == 0
      || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
    {
      goto LABEL_17;
    }
    LastError = GetLastError();
    v10 = 27;
LABEL_16:
    WPP_SF_D(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      v10,
      (__int64)&WPP_e3966bf9b81b3ab085a9dfdc4dace9ef_Traceguids,
      LastError);
LABEL_17:
    v11 = GetLastError();
    v1 = v11;
    if ( v11 <= 0 )
      goto LABEL_5;
    v12 = (unsigned __int16)v11;
    goto LABEL_20;
  }
  v6 = SubscribeServiceChangeNotifications(v3, 2LL, JobsService::SCMEventLogNotificationCallback, this, &v13);
  if ( !v6 )
  {
    v7 = v13;
    v13 = 0LL;
    *((_QWORD *)this + 17) = v7;
    goto LABEL_5;
  }
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
  {
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x1Cu, (__int64)&WPP_e3966bf9b81b3ab085a9dfdc4dace9ef_Traceguids, v6);
  }
  if ( v6 > 0 )
  {
    v12 = (unsigned __int16)v6;
LABEL_20:
    v1 = v12 | 0x80070000;
    goto LABEL_5;
  }
  v1 = v6;
LABEL_5:
  if ( v13 )
    UnsubscribeServiceChangeNotifications();
  if ( v3 )
    CloseServiceHandle(v3);
  if ( v5 )
    CloseServiceHandle(v5);
  return v1;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 1800B9260: using guessed type __int64 UnsubscribeServiceChangeNotifications(void);
// 1800B9268: using guessed type __int64 __fastcall SubscribeServiceChangeNotifications(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180027C24) ----------------------------------------------------
__int64 __fastcall PlugIn::Load(struct _RTL_CRITICAL_SECTION *this)
{
  int FunctionPointers; // ebx
  JobStore *v3; // rdi
  int v4; // ebx
  unsigned int v5; // edi
  HMODULE Library; // rax
  signed int LastError; // eax
  WCHAR Dst[264]; // [rsp+30h] [rbp-228h] BYREF

  FunctionPointers = 0;
  EnterCriticalSection(this);
  if ( !this[1].DebugInfo )
  {
    v3 = JobStore::m_pCommonStore;
    JobStore::WaitForConfiguration(JobStore::m_pCommonStore);
    v4 = *(_DWORD *)(*((_QWORD *)v3 + 10) + 64LL);
    JobStore::WaitForConfiguration(v3);
    v5 = *(_DWORD *)(*((_QWORD *)v3 + 10) + 40LL);
    if ( v4 )
    {
      if ( ExpandEnvironmentStringsW(L"%windir%\\system32\\taskcomp.dll", Dst, 0x105u) - 1 <= 0x104
        && (Library = LoadLibraryExW(Dst, 0LL, 0), (this[1].DebugInfo = (PRTL_CRITICAL_SECTION_DEBUG)Library) != 0LL) )
      {
        FunctionPointers = PlugIn::LoadFunctionPointers((PlugIn *)this);
        if ( FunctionPointers < 0
          || (FunctionPointers = (*(__int64 (__fastcall **)(_QWORD))&this[1].LockCount)(v5), FunctionPointers < 0) )
        {
          PlugIn::Internal_Unload((PlugIn *)this);
        }
      }
      else
      {
        LastError = GetLastError();
        FunctionPointers = LastError;
        if ( LastError > 0 )
          FunctionPointers = (unsigned __int16)LastError | 0x80070000;
      }
    }
    else
    {
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 2) != 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 3u )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xAu, (__int64)&WPP_3bd1f756d1cf3533ff3385535c09a7f6_Traceguids);
      }
      FunctionPointers = -2147023838;
    }
  }
  LeaveCriticalSection(this);
  return (unsigned int)FunctionPointers;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180027D58) ----------------------------------------------------
signed int __fastcall PlugIn::LoadFunctionPointers(PlugIn *this)
{
  signed int result; // eax
  HMODULE v3; // rcx
  FARPROC ProcAddress; // rax
  FARPROC v5; // rax
  FARPROC v6; // rax
  FARPROC v7; // rax
  FARPROC v8; // rax
  FARPROC v9; // rax
  FARPROC v10; // rax

  result = -2147418113;
  v3 = (HMODULE)*((_QWORD *)this + 5);
  if ( v3 )
  {
    ProcAddress = GetProcAddress(v3, "InitializeAdapter");
    *((_QWORD *)this + 6) = ProcAddress;
    if ( !ProcAddress )
      goto LABEL_11;
    v5 = GetProcAddress(*((HMODULE *)this + 5), "UpdateJobStatus");
    *((_QWORD *)this + 7) = v5;
    if ( !v5 )
      goto LABEL_11;
    v6 = GetProcAddress(*((HMODULE *)this + 5), "ShutdownAdapter");
    *((_QWORD *)this + 8) = v6;
    if ( !v6 )
      goto LABEL_11;
    v7 = GetProcAddress(*((HMODULE *)this + 5), "RegisterTaskNotification");
    *((_QWORD *)this + 9) = v7;
    if ( !v7 )
      goto LABEL_11;
    v8 = GetProcAddress(*((HMODULE *)this + 5), "DeleteTaskNotification");
    *((_QWORD *)this + 10) = v8;
    if ( v8
      && (v9 = GetProcAddress(*((HMODULE *)this + 5), "SetSdNotification"), (*((_QWORD *)this + 11) = v9) != 0LL)
      && (v10 = GetProcAddress(*((HMODULE *)this + 5), "IsRegistering"), (*((_QWORD *)this + 12) = v10) != 0LL) )
    {
      return 0;
    }
    else
    {
LABEL_11:
      result = GetLastError();
      if ( result > 0 )
        return (unsigned __int16)result | 0x80070000;
    }
  }
  return result;
}

//----- (0000000180027E7C) ----------------------------------------------------
bool JobsService::IsCompatibilityAdapterDisabled(void)
{
  int v1; // [rsp+50h] [rbp+8h] BYREF
  DWORD v2; // [rsp+58h] [rbp+10h] BYREF

  v1 = 0;
  v2 = 4;
  return (RegGetValueW(
            HKEY_LOCAL_MACHINE,
            L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Schedule",
            L"DisableDownlevelCompatibilityPlugin",
            0x10u,
            0LL,
            &v1,
            &v2) & 0xFFFFFFFD) == 0
      && v1 != 0;
}

//----- (0000000180027EEC) ----------------------------------------------------
__int64 __fastcall Idolater::Init(Idolater *this)
{
  HANDLE EventW; // rbx
  signed int LastError; // eax
  signed int v3; // ebx
  bool v4; // cc
  Idolater *v5; // rcx
  Idolater *v6; // rcx
  __int64 result; // rax

  EventW = CreateEventW(0LL, 1, 0, 0LL);
  wmi::AutoHandle::Close(&WaitHandle + 1);
  *(&WaitHandle + 1) = EventW;
  if ( EventW )
  {
    LastError = EtwEventRegister(&IDLE_TRIGGER_PROVIDER_GUID, 0LL, 0LL, &qword_1800B0CD0);
    v3 = LastError;
    v4 = LastError <= 0;
    if ( !LastError )
    {
      InitializeCriticalSection(&stru_1800B0CA0);
      v3 = Idolater::RegisterWithIdleService(v5);
      if ( v3 < 0 )
      {
        Idolater::UnRegisterWithIdleService(v6);
        DeleteCriticalSection(&stru_1800B0CA0);
      }
      goto LABEL_5;
    }
  }
  else
  {
    LastError = GetLastError();
    v3 = LastError;
    v4 = LastError <= 0;
  }
  if ( !v4 )
    v3 = (unsigned __int16)LastError | 0x80070000;
LABEL_5:
  result = (unsigned int)v3;
  byte_1800B0CC8 = v3 >= 0;
  return result;
}
// 180027F65: variable 'v5' is possibly undefined
// 18003DDEC: variable 'v6' is possibly undefined
// 180074760: using guessed type __int64 __fastcall EtwEventRegister(_QWORD, _QWORD, _QWORD, _QWORD);
// 1800B0CC8: using guessed type char byte_1800B0CC8;
// 1800B0CD0: using guessed type __int64 qword_1800B0CD0;

//----- (0000000180027F94) ----------------------------------------------------
__int64 __fastcall Idolater::RegisterWithIdleService(Idolater *this)
{
  signed int v1; // ebx
  HANDLE EventW; // rdi
  HANDLE v3; // rdi
  signed int LastError; // eax

  v1 = 0;
  EnterCriticalSection(&stru_1800B0CA0);
  EventW = CreateEventW(0LL, 0, 0, 0LL);
  wmi::AutoHandle::Close((void **)&hSourceHandle);
  hSourceHandle = EventW;
  if ( !EventW
    || (*(&xmmword_1800B0C80 + 1) = RegisterWaitForSingleObjectEx(
                                      EventW,
                                      Idolater::IdleStartCallback,
                                      &g_Idolater,
                                      0xFFFFFFFFLL,
                                      0)) == 0LL
    || (v3 = CreateEventW(0LL, 0, 0, 0LL),
        wmi::AutoHandle::Close((void **)&xmmword_1800B0C80),
        (xmmword_1800B0C80 = v3) == 0LL)
    || (WaitHandle = (HANDLE)RegisterWaitForSingleObjectEx(v3, Idolater::IdleEndCallback, &g_Idolater, 0xFFFFFFFFLL, 0)) == 0LL )
  {
    LastError = GetLastError();
    v1 = LastError;
    if ( LastError <= 0 )
      goto LABEL_6;
    goto LABEL_9;
  }
  LastError = ItSrvSetTSchedHandle(hSourceHandle, xmmword_1800B0C80);
  if ( !LastError )
    goto LABEL_6;
  if ( LastError > 0 )
  {
LABEL_9:
    v1 = (unsigned __int16)LastError | 0x80070000;
    goto LABEL_6;
  }
  v1 = LastError;
LABEL_6:
  LeaveCriticalSection(&stru_1800B0CA0);
  if ( v1 < 0 )
  {
    if ( *(&xmmword_1800B0C80 + 1) )
    {
      UnregisterWaitEx(*(&xmmword_1800B0C80 + 1), 0LL);
      *(&xmmword_1800B0C80 + 1) = 0LL;
    }
    if ( hSourceHandle )
    {
      wmi::AutoHandle::Close((void **)&hSourceHandle);
      hSourceHandle = 0LL;
    }
    if ( WaitHandle )
    {
      UnregisterWaitEx(WaitHandle, 0LL);
      WaitHandle = 0LL;
    }
    if ( xmmword_1800B0C80 )
    {
      wmi::AutoHandle::Close((void **)&xmmword_1800B0C80);
      xmmword_1800B0C80 = 0LL;
    }
  }
  return (unsigned int)v1;
}
// 1800742E8: using guessed type __int64 __fastcall RegisterWaitForSingleObjectEx(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 1800B0C60: using guessed type __int128 g_Idolater;

//----- (00000001800280EC) ----------------------------------------------------
__int64 __fastcall ItSrvSetTSchedHandle(HANDLE hSourceHandle, HANDLE a2)
{
  unsigned int v4; // edi
  HANDLE CurrentProcess; // rax
  struct _ITSRV_GLOBAL_CONTEXT *v6; // rcx
  HANDLE v7; // rbx
  HANDLE v8; // rax
  HANDLE v9; // rbx
  HANDLE v10; // rax

  v4 = 0;
  CurrentProcess = GetCurrentProcess();
  if ( ItSpCheckRegistrationExempts(v6, CurrentProcess) )
  {
    v7 = GetCurrentProcess();
    v8 = GetCurrentProcess();
    if ( !DuplicateHandle(v8, hSourceHandle, v7, &TSchedStartEvent, 0, 0, 2u) )
      return GetLastError();
    v9 = GetCurrentProcess();
    v10 = GetCurrentProcess();
    if ( !DuplicateHandle(v10, a2, v9, &TSchedStopEvent, 0, 0, 2u) )
      return GetLastError();
  }
  return v4;
}
// 180028117: variable 'v6' is possibly undefined

//----- (00000001800281E0) ----------------------------------------------------
__int64 __fastcall ItSrvRegisterIdleTask(__int64 a1, _QWORD *a2, __int64 a3)
{
  char v4; // r12
  HANDLE ProcessHeap; // rax
  char *v6; // rax
  char *v7; // rdi
  DWORD LastError; // ebx
  char v9; // r13
  HANDLE v10; // rbp
  HANDLE CurrentProcess; // rax
  HANDLE v12; // rax
  EventManager *v13; // rcx
  struct _ITSRV_GLOBAL_CONTEXT *v14; // rcx
  struct _LIST_ENTRY *Flink; // rax
  struct _LIST_ENTRY *Blink; // rax
  HANDLE v18; // rax

  *a2 = 0LL;
  v4 = 0;
  ProcessHeap = GetProcessHeap();
  v6 = (char *)HeapAlloc(ProcessHeap, 0, 0x48uLL);
  v7 = v6;
  if ( !v6 )
    return 8;
  memset_0(v6, 0, 0x48uLL);
  *(_OWORD *)(v7 + 24) = *(_OWORD *)a3;
  *(_OWORD *)(v7 + 40) = *(_OWORD *)(a3 + 16);
  if ( *((_DWORD *)v7 + 6) != 32 || *((_DWORD *)v7 + 7) > 8u )
  {
    LastError = 11;
    goto LABEL_37;
  }
  LastError = RpcImpersonateClient(0LL);
  if ( !LastError )
  {
    LastError = 1;
    v9 = 1;
    v10 = OpenProcess(0x1FFFFFu, 0, *(_DWORD *)(a3 + 8));
    if ( !v10 )
    {
      LastError = GetLastError();
LABEL_29:
      RpcRevertToSelf();
LABEL_16:
      if ( !LastError )
      {
        *a2 = v7;
        goto LABEL_18;
      }
      goto LABEL_37;
    }
    CurrentProcess = GetCurrentProcess();
    if ( DuplicateHandle(v10, *(HANDLE *)(a3 + 16), CurrentProcess, (LPHANDLE)v7 + 7, 0x1F0003u, 0, 0)
      && (v12 = GetCurrentProcess(), DuplicateHandle(v10, *(HANDLE *)(a3 + 24), v12, (LPHANDLE)v7 + 8, 0x1F0003u, 0, 0))
      && (RpcRevertToSelf(), v9 = 0, ResetEvent(*((HANDLE *)v7 + 7)))
      && SetEvent(*((HANDLE *)v7 + 8)) )
    {
      EventManager::EvtReport(v13, &ItSpEvt_RegisterIdleTask, *((unsigned int *)v7 + 7), *((unsigned int *)v7 + 8));
      EnterCriticalSection(&stru_1800B0F18);
      v4 = 1;
      if ( !ItSpCheckRegistrationExempts(v14, v10) )
      {
LABEL_14:
        LastError = 0;
        goto LABEL_15;
      }
      if ( *((_DWORD *)v7 + 7) == 7 )
      {
        EnterCriticalSection(&stru_1800B0F90);
        *((_DWORD *)v7 + 4) |= 1u;
        Flink = stru_1800B0FB8.Flink;
        ++dword_1800B0FC8;
        if ( stru_1800B0FB8.Flink->Blink == &stru_1800B0FB8 )
        {
          *((_QWORD *)v7 + 1) = &stru_1800B0FB8;
          *(_QWORD *)v7 = Flink;
          Flink->Blink = (struct _LIST_ENTRY *)v7;
          stru_1800B0FB8.Flink = (struct _LIST_ENTRY *)v7;
          *((_DWORD *)v7 + 5) = 1;
          LeaveCriticalSection(&stru_1800B0F90);
          goto LABEL_14;
        }
LABEL_35:
        __fastfail(3u);
      }
      if ( dword_1800B0F58 >= (unsigned int)dword_1800B1080 )
      {
        LastError = 4;
      }
      else
      {
        if ( (_DWORD)ItSrvGlobalContext == 1147547697 )
          goto LABEL_34;
        if ( (int)ItSrvGlobalContext > 1147547697 )
        {
          if ( (int)ItSrvGlobalContext <= 1147547700 )
          {
            ++dword_1800B0F58;
            Blink = stru_1800B0F40.Blink;
            if ( stru_1800B0F40.Blink->Flink == &stru_1800B0F40 )
            {
              *(_QWORD *)v7 = &stru_1800B0F40;
              *((_QWORD *)v7 + 1) = Blink;
              Blink->Flink = (struct _LIST_ENTRY *)v7;
              stru_1800B0F40.Blink = (struct _LIST_ENTRY *)v7;
              ResetEvent(qword_1800B0F50);
              *((_DWORD *)v7 + 5) = 1;
              LeaveCriticalSection(&stru_1800B0F18);
              v4 = 0;
              goto LABEL_14;
            }
            goto LABEL_35;
          }
          if ( (_DWORD)ItSrvGlobalContext == 1147547701 || (_DWORD)ItSrvGlobalContext == 1147547702 )
LABEL_34:
            LastError = 21;
        }
      }
    }
    else
    {
      LastError = GetLastError();
    }
LABEL_15:
    CloseHandle(v10);
    if ( !v9 )
      goto LABEL_16;
    goto LABEL_29;
  }
LABEL_37:
  ItSpCleanupIdleTask((struct _ITSRV_IDLE_TASK_CONTEXT *)v7);
  v18 = GetProcessHeap();
  HeapFree(v18, 0, v7);
LABEL_18:
  if ( v4 )
    LeaveCriticalSection(&stru_1800B0F18);
  return LastError;
}
// 18002837E: variable 'v13' is possibly undefined
// 18002839C: variable 'v14' is possibly undefined
// 1800B0EF0: using guessed type struct _ITSRV_GLOBAL_CONTEXT near *ItSrvGlobalContext;
// 1800B0F58: using guessed type int dword_1800B0F58;
// 1800B0FC8: using guessed type int dword_1800B0FC8;
// 1800B1080: using guessed type int dword_1800B1080;

//----- (000000018002850C) ----------------------------------------------------
unsigned __int8 __fastcall ItSpCheckRegistrationExempts(struct _ITSRV_GLOBAL_CONTEXT *a1, void *a2)
{
  wchar_t *i; // rbx
  __int64 v4; // rax
  DWORD dwSize[4]; // [rsp+20h] [rbp-238h] BYREF
  WCHAR ExeName[264]; // [rsp+30h] [rbp-228h] BYREF

  dwSize[0] = 260;
  if ( String1 )
  {
    if ( QueryFullProcessImageNameW(a2, 0, ExeName, dwSize) )
    {
      for ( i = String1; i; i += v4 + 1 )
      {
        if ( !*i )
          break;
        if ( !_wcsicmp(i, ExeName) )
          break;
        v4 = -1LL;
        do
          ++v4;
        while ( i[v4] );
      }
    }
  }
  return 1;
}
// 18002850C: using guessed type DWORD dwSize[4];

//----- (0000000180028570) ----------------------------------------------------
__int64 __fastcall EventManager::EvtReport(
        EventManager *this,
        const struct _EVENT_DESCRIPTOR *a2,
        __int64 a3,
        __int64 a4)
{
  EventManager *v4; // rdi
  int v7; // eax
  EventManager *v8; // rcx
  int v9; // ebx
  int *v10; // [rsp+20h] [rbp-38h] BYREF
  int v11; // [rsp+28h] [rbp-30h]
  int v12; // [rsp+2Ch] [rbp-2Ch]
  int *v13; // [rsp+30h] [rbp-28h]
  int v14; // [rsp+38h] [rbp-20h]
  int v15; // [rsp+3Ch] [rbp-1Ch]
  int v16; // [rsp+70h] [rbp+18h] BYREF
  int v17; // [rsp+78h] [rbp+20h] BYREF

  v17 = a4;
  v16 = a3;
  v4 = g_pEventManager;
  if ( !*(_QWORD *)g_pEventManager )
    return 1LL;
  if ( !(unsigned __int8)EtwEventEnabled(*(_QWORD *)g_pEventManager, a2, a3, a4) )
    return 0LL;
  v12 = 0;
  v15 = 0;
  v10 = &v16;
  v11 = 4;
  v14 = 4;
  v13 = &v17;
  v7 = EtwEventWrite(*(_QWORD *)v4, a2, 2LL, &v10);
  v9 = v7;
  if ( !v7 )
    return 0LL;
  EventManager::LogIt(v8, L"EventWrite error", v7);
  if ( v9 > 0 )
    return (unsigned __int16)v9 | 0x80070000;
  return (unsigned int)v9;
}
// 18003E042: variable 'v8' is possibly undefined
// 1800746B8: using guessed type __int64 __fastcall EtwEventEnabled(_QWORD, _QWORD, _QWORD, _QWORD);
// 180074768: using guessed type __int64 __fastcall EtwEventWrite(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180028718) ----------------------------------------------------
_QWORD *std::_Tree_alloc<0,std::_Tree_base_types<std::pair<User const,LogonJob *>>>::_Buyheadnode()
{
  _QWORD *result; // rax

  result = operator new(0x30uLL);
  if ( !result )
    std::_Xbad_alloc();
  *result = result;
  result[1] = result;
  result[2] = result;
  *((_WORD *)result + 12) = 257;
  return result;
}

//----- (0000000180028764) ----------------------------------------------------
EventTrapMap *__fastcall EventTrapMap::EventTrapMap(EventTrapMap *this)
{
  *(_QWORD *)this = &EventTrapMap::`vftable';
  InitializeCriticalSectionEx((LPCRITICAL_SECTION)((char *)this + 8), 0, 0);
  *((_QWORD *)this + 261) = 0LL;
  *((_DWORD *)this + 524) = 0;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
  {
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xAu, (__int64)&WPP_16de8f11014e3cd60e9c758468ee516f_Traceguids, 255);
  }
  memset_0((char *)this + 48, 0, 0x7F8uLL);
  return this;
}
// 180070438: using guessed type void *EventTrapMap::`vftable';
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (00000001800287DC) ----------------------------------------------------
Scheduler *__fastcall Scheduler::Scheduler(Scheduler *this, void *a2, void *a3)
{
  *(_QWORD *)this = &Scheduler::`vftable';
  *((_QWORD *)this + 1) = a2;
  *((_QWORD *)this + 2) = a3;
  *((_QWORD *)this + 3) = 0LL;
  InitializeCriticalSectionEx((LPCRITICAL_SECTION)((char *)this + 32), 0, 0);
  *((_QWORD *)this + 10) = 0LL;
  *((_QWORD *)this + 11) = 0LL;
  *((_QWORD *)this + 12) = 0LL;
  *((_QWORD *)this + 13) = 0LL;
  *((_QWORD *)this + 9) = &SortedRunListItem::`vftable';
  JobMoniker::JobMoniker((Scheduler *)((char *)this + 112), 0LL, 0LL);
  TSTime::TSTime((Scheduler *)((char *)this + 152));
  *((_QWORD *)this + 10) = (char *)this + 72;
  *((_QWORD *)this + 11) = (char *)this + 72;
  *((_QWORD *)this + 21) = -1LL;
  *((_QWORD *)this + 23) = 0LL;
  *((_QWORD *)this + 24) = 0LL;
  *((_QWORD *)this + 25) = 0LL;
  *((_QWORD *)this + 26) = 0LL;
  *((_QWORD *)this + 22) = &SortedRunListItem::`vftable';
  JobMoniker::JobMoniker((Scheduler *)((char *)this + 216), 0LL, 0LL);
  TSTime::TSTime((Scheduler *)((char *)this + 256));
  *((_QWORD *)this + 23) = (char *)this + 176;
  *((_QWORD *)this + 24) = (char *)this + 176;
  *((_QWORD *)this + 34) = 0LL;
  *((_QWORD *)this + 35) = 0LL;
  *((_QWORD *)this + 34) = std::_Tree_alloc<0,std::_Tree_base_types<std::pair<JobMoniker const,_FILETIME>>>::_Buyheadnode();
  TSTime::TSTime((Scheduler *)((char *)this + 288));
  TSTime::TSTime((Scheduler *)((char *)this + 304));
  *((_QWORD *)this + 41) = 0LL;
  *((_QWORD *)this + 42) = 0LL;
  *((_QWORD *)this + 40) = &ScheduleListItem::`vftable';
  JobMoniker::JobMoniker((Scheduler *)((char *)this + 344), 0LL, 0LL);
  Scheduling::JobSchedule::JobSchedule((struct _FILETIME *)this + 48);
  *((_QWORD *)this + 41) = (char *)this + 320;
  *((_QWORD *)this + 42) = (char *)this + 320;
  *((_WORD *)this + 236) = 0;
  GetSystemTimeAsFileTime((LPFILETIME)this + 37);
  *((_OWORD *)this + 19) = *((_OWORD *)this + 18);
  return this;
}
// 180070448: using guessed type void *SortedRunListItem::`vftable';
// 180070450: using guessed type void *ScheduleListItem::`vftable';
// 180070458: using guessed type void *Scheduler::`vftable';

//----- (0000000180028994) ----------------------------------------------------
_QWORD *std::_Tree_alloc<0,std::_Tree_base_types<std::pair<JobMoniker const,_FILETIME>>>::_Buyheadnode()
{
  _QWORD *result; // rax

  result = operator new(0x50uLL);
  if ( !result )
    std::_Xbad_alloc();
  *result = result;
  result[1] = result;
  result[2] = result;
  *((_WORD *)result + 12) = 257;
  return result;
}

//----- (00000001800289E0) ----------------------------------------------------
__int64 CredStore::Init(void)
{
  signed int LastError; // eax
  signed int v1; // ebx
  signed int v2; // eax
  char *v3; // rax
  CredStore *v4; // rcx
  struct _RTL_CRITICAL_SECTION *v5; // rdi
  PSECURITY_DESCRIPTOR SecurityDescriptor; // [rsp+30h] [rbp+8h] BYREF

  if ( ConvertStringSecurityDescriptorToSecurityDescriptorW(
         L"D:P(A;OICI;KRSD;;;BA)(A;OICI;KA;;;SY)",
         1u,
         &SecurityDescriptor,
         0LL) )
  {
    v1 = 0;
    tsched::StoreSecurity::g_pRestrictedKeySecurity = SecurityDescriptor;
  }
  else
  {
    LastError = GetLastError();
    v1 = LastError;
    if ( LastError > 0 )
      v1 = (unsigned __int16)LastError | 0x80070000;
  }
  if ( v1 >= 0 )
  {
    if ( ConvertStringSecurityDescriptorToSecurityDescriptorW(
           L"D:P(A;OICI;KA;;;BA)(A;OICI;KA;;;SY)",
           1u,
           &SecurityDescriptor,
           0LL) )
    {
      v1 = 0;
      tsched::StoreSecurity::g_pConfigKeySecurity = SecurityDescriptor;
    }
    else
    {
      v2 = GetLastError();
      v1 = v2;
      if ( v2 > 0 )
        v1 = (unsigned __int16)v2 | 0x80070000;
    }
    if ( v1 >= 0 )
    {
      v3 = (char *)operator new(0x58uLL);
      SecurityDescriptor = v3;
      v5 = (struct _RTL_CRITICAL_SECTION *)v3;
      if ( v3 )
      {
        *((_QWORD *)v3 + 5) = 0LL;
        InitializeCriticalSectionEx((LPCRITICAL_SECTION)(v3 + 48), 0, 0);
        InitializeCriticalSection(v5);
      }
      else
      {
        v5 = 0LL;
      }
      CredStore::g_pCommonStore = v5;
      if ( v5 )
      {
        CredStore::Upgrade(v4);
        return (unsigned int)v1;
      }
      v1 = -2147024882;
    }
  }
  CredStore::Uninit();
  return (unsigned int)v1;
}
// 180028AF7: variable 'v4' is possibly undefined

//----- (0000000180028B04) ----------------------------------------------------
__int64 __fastcall CredStore::Upgrade(CredStore *this)
{
  struct _RTL_CRITICAL_SECTION *v1; // r12
  int started; // eax
  int v3; // edi
  unsigned int v4; // ebx
  PCREDENTIALW *v6; // rcx
  PCREDENTIALW *v7; // r14
  __int64 v8; // rsi
  PCREDENTIALW v9; // r15
  char *v10; // rax
  CredStore *v11; // rcx
  signed int LastError; // eax
  void *v13; // r9
  const BYTE *lpData; // rax
  CredStore *Count; // [rsp+90h] [rbp+40h] BYREF
  HKEY hKey; // [rsp+98h] [rbp+48h] BYREF
  PCREDENTIALW *Credential; // [rsp+A0h] [rbp+50h] BYREF

  Count = this;
  v1 = CredStore::g_pCommonStore;
  hKey = 0LL;
  started = CredStore::StartUpgrade((__int64)this, &hKey);
  v3 = started;
  v4 = -2147467259;
  if ( started != 3 )
  {
    if ( (unsigned int)(started - 1) > 1 )
      goto LABEL_3;
    Credential = 0LL;
    if ( CredEnumerateW(0LL, 1u, (DWORD *)&Count, &Credential) )
    {
      v4 = 0;
      v6 = Credential;
      v7 = Credential;
      v8 = 0LL;
      if ( (_DWORD)Count )
      {
        while ( 1 )
        {
          v9 = v6[v8];
          v10 = (char *)wcsstr(v9->TargetName, L"TaskScheduler:Task:");
          if ( v10 )
          {
            if ( !(unsigned int)CredStore::UpgradeCred(v1, hKey, v10, v9->TargetName, v9->UserName) )
              break;
          }
          v8 = (unsigned int)(v8 + 1);
          if ( (unsigned int)v8 >= (unsigned int)Count )
            goto LABEL_10;
          v6 = Credential;
        }
        v4 = -2147418113;
      }
LABEL_10:
      CredFree(v7);
    }
    else
    {
      LastError = GetLastError();
      v4 = LastError;
      if ( LastError == 1168 )
      {
        v4 = 0;
        goto LABEL_20;
      }
      if ( LastError > 0 )
        v4 = (unsigned __int16)LastError | 0x80070000;
    }
    if ( (v4 & 0x80000000) != 0 )
    {
      CredStore::WipeoutStore(v11, &hKey);
      if ( g_pEventManager )
        EventManager::EvtReport(g_pEventManager, &VISTA_BETA2_CREDSTORE_UPGRADE_FAILED, v4, v13);
    }
LABEL_20:
    if ( v3 == 1 )
    {
      lpData = L"Stage_One";
    }
    else
    {
      if ( v3 != 2 )
        goto LABEL_3;
      lpData = (const BYTE *)L"Completed";
    }
    RegSetValueExW(hKey, 0LL, 0, 1u, lpData, 0x14u);
    goto LABEL_3;
  }
  v4 = 0;
LABEL_3:
  wmi::AutoRegKey::Close(&hKey);
  return v4;
}
// 18003E174: variable 'v11' is possibly undefined
// 18003E18F: variable 'v13' is possibly undefined

//----- (0000000180028B6C) ----------------------------------------------------
__int64 __fastcall CredStore::StartUpgrade(__int64 a1, HKEY *a2)
{
  unsigned int v3; // ebx
  _BOOL8 v4; // rcx
  DWORD v6; // [rsp+40h] [rbp-38h] BYREF
  wchar_t String1[8]; // [rsp+48h] [rbp-30h] BYREF
  int v8; // [rsp+58h] [rbp-20h]
  __int16 v9; // [rsp+5Ch] [rbp-1Ch]

  v6 = 22;
  v8 = 0;
  v9 = 0;
  v3 = 1;
  *(_OWORD *)String1 = 0LL;
  if ( !RegGetValueW(
          HKEY_LOCAL_MACHINE,
          L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Schedule\\CredWom",
          0LL,
          2u,
          0LL,
          String1,
          &v6) )
  {
    if ( !wcscmp_0(String1, L"Completed") )
      return 3;
    v4 = wcscmp_0(String1, (const wchar_t *)L"Stage_One") == 0;
    v3 = v4 + 1;
  }
  if ( CredStore::OpenCredManagerKey((CredStore *)v4, a2) < 0 )
    return 0;
  return v3;
}
// 18003E1FB: variable 'v4' is possibly undefined

//----- (0000000180028C34) ----------------------------------------------------
__int64 __fastcall JobStore::CreateCommonJobStore(HKEY a1, HKEY a2)
{
  JobStore *v4; // rax
  HKEY *v5; // rcx
  LSTATUS v6; // eax
  HashCompute *v7; // rcx
  int v8; // ebx
  bool v9; // sf
  int v10; // eax
  JobStore *v11; // rcx

  v4 = (JobStore *)operator new(0x68uLL);
  if ( v4 )
    v5 = (HKEY *)JobStore::JobStore(v4, a1, a2);
  else
    v5 = 0LL;
  JobStore::m_pCommonStore = (JobStore *)v5;
  v6 = RegOpenKeyExW(v5[2], L"TaskStateFlags", 0, 0xF003Fu, v5 + 4);
  v8 = v6;
  if ( v6 == 2 || v6 == 161 )
    v8 = 0;
  v9 = v8 < 0;
  if ( !v8 )
    goto LABEL_6;
  if ( v8 > 0 )
  {
    v8 = (unsigned __int16)v8 | 0x80070000;
LABEL_6:
    v9 = v8 < 0;
  }
  if ( !v9 )
  {
    v10 = HashCompute::init(v7);
    v8 = v10;
    if ( v10 )
    {
      if ( v10 > 0 )
        v8 = (unsigned __int16)v10 | 0x80070000;
      v11 = (JobStore *)WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        WPP_SF_D(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0xBu,
          (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
          v8);
      }
    }
    if ( v8 >= 0 )
      return (unsigned int)JobStore::InitJobStore(v11);
  }
  return (unsigned int)v8;
}
// 180028CBD: variable 'v7' is possibly undefined
// 180028CD0: variable 'v11' is possibly undefined
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180028D00) ----------------------------------------------------
__int64 __fastcall JobStore::InitJobStore(JobStore *this)
{
  unsigned __int16 **v1; // rdi
  const WCHAR *v2; // rdx
  LSTATUS v3; // eax
  int LastHrError; // ebx
  unsigned __int16 *EventW; // rsi
  tsched *v6; // rcx
  __int64 v7; // rax
  _QWORD *v9; // rcx
  unsigned __int16 v10; // dx
  JobStore *v11; // rcx
  int v12; // ebx
  JobStore *v13; // rcx
  unsigned __int8 v14; // [rsp+58h] [rbp-19h] BYREF
  unsigned __int8 v15[3]; // [rsp+59h] [rbp-18h] BYREF
  int v16; // [rsp+5Ch] [rbp-15h] BYREF
  const WCHAR **v17; // [rsp+60h] [rbp-11h] BYREF
  struct _SECURITY_ATTRIBUTES SecurityAttributes; // [rsp+68h] [rbp-9h] BYREF
  __int64 v19; // [rsp+80h] [rbp+Fh]
  struct _EVENT_DATA_DESCRIPTOR v20; // [rsp+88h] [rbp+17h] BYREF
  int *v21; // [rsp+A8h] [rbp+37h]
  int v22; // [rsp+B0h] [rbp+3Fh]
  int v23; // [rsp+B4h] [rbp+43h]

  v19 = -2LL;
  v1 = (unsigned __int16 **)JobStore::m_pCommonStore;
  JobStore::InitConfig(JobStore::m_pCommonStore);
  _bstr_t::_bstr_t((_bstr_t *)&v17, L"Configuration");
  SecurityAttributes.nLength = 24;
  SecurityAttributes.lpSecurityDescriptor = tsched::StoreSecurity::g_pConfigKeySecurity;
  SecurityAttributes.bInheritHandle = 0;
  if ( v17 )
    v2 = *v17;
  else
    v2 = 0LL;
  v3 = RegCreateKeyExW((HKEY)v1[2], v2, 0, 0LL, 0, 0x20019u, &SecurityAttributes, (PHKEY)v1 + 5, 0LL);
  LastHrError = v3;
  if ( v3 )
  {
    if ( v3 > 0 )
      LastHrError = (unsigned __int16)v3 | 0x80070000;
    v9 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
      || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) == 0
      || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
    {
      goto LABEL_13;
    }
    v10 = 13;
LABEL_25:
    WPP_SF_D(v9[2], v10, (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids, LastHrError);
    goto LABEL_13;
  }
  EventW = (unsigned __int16 *)CreateEventW(0LL, 0, 0, 0LL);
  wmi::AutoHandle::Close((void **)v1 + 6);
  v1[6] = EventW;
  if ( !EventW )
  {
    LastHrError = tsched::GetLastHrError(v6);
    v9 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
      || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) == 0
      || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
    {
      goto LABEL_13;
    }
    v10 = 14;
    goto LABEL_25;
  }
  v7 = RegisterWaitForSingleObjectEx(EventW, JobStore::ConfigurationChangeCallback, v1, 0xFFFFFFFFLL, 128);
  v1[7] = (unsigned __int16 *)v7;
  if ( v7 )
  {
    JobStore::ConfigurationChangeCallback(v1);
    LastHrError = JobStore::InitStorePath((void **)v1);
    if ( LastHrError < 0 )
      goto LABEL_13;
    if ( !JobStore::GetUseXmlStore((JobStore *)v1)
      || !PathFileExistsW(v1[1])
      || (unsigned int)JobStore::IsMigrationCleanupCompleted((JobStore *)v1) )
    {
      goto LABEL_9;
    }
    JobStore::TakeBackupRestorePermissions(v11, v15, &v14);
    v12 = JobStore::CopyDirectoryWithPermissionsRecursive((char **)v1, v1[1], *v1);
    if ( v12 < 0 )
    {
      v13 = (JobStore *)WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x10u, (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids);
      }
      if ( (unsigned int)dword_1800AFF68 <= 4 )
        goto LABEL_46;
      v13 = (JobStore *)qword_1800AFF80;
      if ( (qword_1800AFF78 & 0x400000000001LL) == 0 || (qword_1800AFF80 & 0x400000000001LL) != qword_1800AFF80 )
      {
LABEL_42:
        if ( (unsigned int)dword_1800AFF68 > 4
          && (qword_1800AFF78 & 0x400000000001LL) != 0
          && (JobStore *)((unsigned __int64)v13 & 0x400000000001LL) == v13 )
        {
          v16 = v12;
          v21 = &v16;
          v22 = 4;
          v23 = 0;
          tlgWriteTransfer_EventWriteTransfer(
            (__int64)&dword_1800AFF68,
            (unsigned __int8 *)dword_18007EFCC,
            0LL,
            0LL,
            3u,
            &v20);
        }
LABEL_46:
        JobStore::DropBackupRestorePermissions(v13, v15[0], v14);
LABEL_9:
        LastHrError = JobStore::InitKnownTreeFolder(
                        (HKEY *)v1,
                        L"\\",
                        L"O:SYG:SYD:PAI(A;CI;FA;;;BA)(A;OI;FRFWSDWDWO;;;BA)(A;CI;FA;;;SY)(A;OI;FRFWSDWDWO;;;SY)(A;CI;FW;;;"
                         "AU)(A;CI;FW;;;NS)(A;CI;FW;;;LS)(A;OICIIO;FA;;;CO)");
        if ( LastHrError >= 0 )
        {
          LastHrError = JobStore::InitKnownTreeFolder(
                          (HKEY *)v1,
                          L"\\Microsoft",
                          L"O:SYG:SYD:PAI(A;CI;FA;;;BA)(A;OI;0x1f019f;;;BA)(A;CI;FA;;;SY)(A;OI;0x1f019f;;;SY)(A;OICI;FR;;;"
                           "AU)(A;OICI;FR;;;LS)(A;OICI;FR;;;NS)(A;OICIIO;FA;;;CO)S:AI");
          if ( LastHrError >= 0 )
          {
            LastHrError = JobStore::InitKnownTreeFolder(
                            (HKEY *)v1,
                            L"\\Microsoft\\Windows",
                            L"O:SYG:SYD:AI(A;CIID;FA;;;BA)(A;OIIOID;0x1f019f;;;BA)(A;CIID;FA;;;SY)(A;OIIOID;0x1f019f;;;SY)"
                             "(A;OICIID;FR;;;AU)(A;OICIID;FR;;;LS)(A;OICIID;FR;;;NS)(A;OICIIOID;FA;;;CO)S:AI");
            if ( LastHrError >= 0 )
              LastHrError = 0;
          }
        }
        goto LABEL_13;
      }
      v16 = v12;
      v21 = &v16;
      v22 = 4;
      v23 = 0;
      tlgWriteTransfer_EventWriteTransfer(
        (__int64)&dword_1800AFF68,
        (unsigned __int8 *)dword_18007EE21,
        0LL,
        0LL,
        3u,
        &v20);
    }
    v13 = (JobStore *)qword_1800AFF80;
    goto LABEL_42;
  }
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xFu, (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids);
  }
  LastHrError = -2147467259;
LABEL_13:
  _bstr_t::_Free((_bstr_t *)&v17);
  return (unsigned int)LastHrError;
}
// 18003E2AB: variable 'v6' is possibly undefined
// 18003E357: variable 'v11' is possibly undefined
// 18003E489: variable 'v13' is possibly undefined
// 1800742E8: using guessed type __int64 __fastcall RegisterWaitForSingleObjectEx(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 18007EE21: using guessed type int dword_18007EE21[12];
// 18007EFCC: using guessed type int dword_18007EFCC[10];
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 1800AFF78: using guessed type __int64 qword_1800AFF78;
// 1800AFF80: using guessed type __int64 qword_1800AFF80;
// 180028D00: using guessed type unsigned __int8 var_6F[3];

//----- (0000000180028EE8) ----------------------------------------------------
__int64 __fastcall JobStore::InitKnownTreeFolder(HKEY *this, unsigned __int16 *a2, LPCWSTR StringSecurityDescriptor)
{
  tsched *v6; // rcx
  const unsigned __int16 *v7; // rdx
  const WCHAR *v8; // rdx
  LSTATUS v9; // eax
  int LastHrError; // edi
  WCHAR *v11; // rbx
  DWORD FileAttributesW; // eax
  tsched *v14; // rcx
  LPCWSTR lpFileName[2]; // [rsp+58h] [rbp-19h] BYREF
  const WCHAR **v16; // [rsp+68h] [rbp-9h] BYREF
  HKEY phkResult; // [rsp+70h] [rbp-1h] BYREF
  PSECURITY_DESCRIPTOR SecurityDescriptor; // [rsp+78h] [rbp+7h] BYREF
  struct _SECURITY_ATTRIBUTES SecurityAttributes; // [rsp+80h] [rbp+Fh] BYREF
  struct _SECURITY_ATTRIBUTES v20; // [rsp+98h] [rbp+27h] BYREF
  __int64 v21; // [rsp+B0h] [rbp+3Fh]
  DWORD dwDisposition; // [rsp+F0h] [rbp+7Fh] BYREF

  v21 = -2LL;
  SecurityDescriptor = 0LL;
  if ( !ConvertStringSecurityDescriptorToSecurityDescriptorW(
          L"D:P(A;OICI;KRSD;;;BA)(A;OICI;KA;;;SY)",
          1u,
          &SecurityDescriptor,
          0LL) )
  {
    LastHrError = tsched::GetLastHrError(v6);
    goto LABEL_15;
  }
  SecurityAttributes.nLength = 24;
  SecurityAttributes.lpSecurityDescriptor = SecurityDescriptor;
  SecurityAttributes.bInheritHandle = 0;
  phkResult = 0LL;
  _bstr_t::_bstr_t((_bstr_t *)&v16, L"TaskCache\\Tree");
  if ( !tsched::IsRoot((tsched *)a2, v7) )
  {
    _bstr_t::_bstr_t((_bstr_t *)lpFileName, a2);
    _bstr_t::operator+=((OLECHAR ***)&v16, (BSTR **)lpFileName);
    _bstr_t::_Free((_bstr_t *)lpFileName);
  }
  if ( v16 )
    v8 = *v16;
  else
    v8 = 0LL;
  v9 = RegCreateKeyExW(this[2], v8, 0, 0LL, 0, 0xF003Fu, &SecurityAttributes, &phkResult, &dwDisposition);
  LastHrError = v9;
  if ( v9 )
  {
    if ( v9 > 0 )
      LastHrError = (unsigned __int16)v9 | 0x80070000;
    goto LABEL_14;
  }
  if ( dwDisposition == 1 )
  {
    JobSecurity::JobSecurity((JobSecurity *)lpFileName);
    LastHrError = JobSecurity::SetSddl((PSECURITY_DESCRIPTOR *)lpFileName, StringSecurityDescriptor);
    if ( LastHrError < 0
      || (LastHrError = JobSecurity::StreamOut((JobSecurity *)lpFileName, phkResult), LastHrError < 0) )
    {
      tsched::AutoLocalPtr<unsigned short>::~AutoLocalPtr<unsigned short>((void **)lpFileName);
      goto LABEL_14;
    }
    tsched::AutoLocalPtr<unsigned short>::~AutoLocalPtr<unsigned short>((void **)lpFileName);
  }
  if ( JobStore::GetUseXmlStore((JobStore *)this) )
  {
    lpFileName[0] = 0LL;
    LastHrError = JobStore::GetXmlFileSystemPath((char **)this, (char *)a2, (void **)lpFileName);
    v11 = (WCHAR *)lpFileName[0];
    if ( LastHrError >= 0 )
    {
      FileAttributesW = GetFileAttributesW(lpFileName[0]);
      if ( FileAttributesW != -1 && (FileAttributesW & 0x10) != 0 )
        goto LABEL_12;
      lpFileName[0] = 0LL;
      if ( ConvertStringSecurityDescriptorToSecurityDescriptorW(
             StringSecurityDescriptor,
             1u,
             (PSECURITY_DESCRIPTOR *)lpFileName,
             0LL) )
      {
        v20.nLength = 24;
        v20.lpSecurityDescriptor = (LPVOID)lpFileName[0];
        v20.bInheritHandle = 0;
        if ( CreateDirectoryW(v11, &v20) )
        {
          tsched::AutoLocalPtr<unsigned short>::~AutoLocalPtr<unsigned short>((void **)lpFileName);
LABEL_12:
          operator delete(v11);
          goto LABEL_13;
        }
      }
      LastHrError = tsched::GetLastHrError(v14);
      tsched::AutoLocalPtr<unsigned short>::~AutoLocalPtr<unsigned short>((void **)lpFileName);
    }
    operator delete(v11);
    goto LABEL_14;
  }
LABEL_13:
  LastHrError = 0;
LABEL_14:
  _bstr_t::_Free((_bstr_t *)&v16);
  wmi::AutoRegKey::Close(&phkResult);
LABEL_15:
  tsched::AutoLocalPtr<unsigned short>::~AutoLocalPtr<unsigned short>(&SecurityDescriptor);
  return (unsigned int)LastHrError;
}
// 180028F6A: variable 'v7' is possibly undefined
// 18003E496: variable 'v6' is possibly undefined
// 18003E566: variable 'v14' is possibly undefined

//----- (0000000180029094) ----------------------------------------------------
__int64 __fastcall JobStore::InitStorePath(void **this)
{
  __int64 result; // rax
  unsigned int v3; // ebx
  int v4; // eax

  result = JobStore::ExpandEnvironmentString(L"%SystemRoot%\\System32\\Tasks", this);
  v3 = 0;
  if ( (int)result >= 0 )
  {
    v4 = JobStore::ExpandEnvironmentString(L"%SystemRoot%\\System32\\Tasks_Migrated", this + 1);
    if ( v4 < 0 )
      return (unsigned int)v4;
    return v3;
  }
  return result;
}

//----- (00000001800290E0) ----------------------------------------------------
__int64 __fastcall JobStore::ExpandEnvironmentString(LPCWSTR lpSrc, void **a2)
{
  void *v4; // rax
  tsched *v5; // rcx
  unsigned int LastHrError; // ebx

  v4 = operator new(0x20AuLL);
  wmi::AutoVectorPtr<unsigned char>::operator=(a2, v4);
  memset_0(*a2, 0, 0x20AuLL);
  if ( ExpandEnvironmentStringsW(lpSrc, (LPWSTR)*a2, 0x105u) )
    return 0LL;
  LastHrError = tsched::GetLastHrError(v5);
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
  {
    WPP_SF_D(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0xCu,
      (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
      LastHrError);
  }
  return LastHrError;
}
// 18003E586: variable 'v5' is possibly undefined
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180029150) ----------------------------------------------------
void __fastcall JobStore::ConfigurationChangeCallback(void *a1)
{
  int v2; // eax

  JobStore::ReadConfiguration((JobStore *)a1);
  v2 = RegNotifyChangeKeyValue(*((HKEY *)a1 + 5), 0, 4u, *((HANDLE *)a1 + 6), 1);
  if ( v2
    && WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
  {
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x12u, (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids, v2);
  }
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180029198) ----------------------------------------------------
void __fastcall JobStore::ReadConfiguration(JobStore *this)
{
  __int64 i; // rsi
  __int64 v3; // rax
  HKEY v4; // rcx
  const wchar_t *v5; // r14
  __int64 v6; // rdx
  unsigned int v7; // eax
  unsigned int v8; // ecx
  unsigned int Data; // [rsp+60h] [rbp+8h] BYREF
  DWORD Type; // [rsp+68h] [rbp+10h] BYREF
  DWORD cbData; // [rsp+70h] [rbp+18h] BYREF

  for ( i = 0LL; (unsigned int)i < *((_DWORD *)this + 22); i = (unsigned int)(i + 1) )
  {
    v3 = *((_QWORD *)this + 10);
    Type = 0;
    Data = 0;
    v4 = (HKEY)*((_QWORD *)this + 5);
    cbData = 4;
    v5 = *(const wchar_t **)(v3 + 24 * i + 8);
    if ( RegQueryValueExW(v4, v5, 0LL, &Type, (LPBYTE)&Data, &cbData) )
    {
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        WPP_SF_SD(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x11u,
          (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
          v5);
      }
    }
    else if ( Type == 4 )
    {
      v6 = *((_QWORD *)this + 10);
      v7 = Data;
      v8 = *(_DWORD *)(v6 + 24 * i + 20);
      if ( v8 )
      {
        if ( Data > v8 )
          v7 = *(_DWORD *)(v6 + 24 * i + 20);
        Data = v7;
      }
      *(_DWORD *)(v6 + 24 * i + 16) = v7;
    }
  }
  _InterlockedExchange((volatile __int32 *)this + 23, 1);
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180029264) ----------------------------------------------------
void __fastcall JobStore::InitConfig(JobStore *this)
{
  unsigned int v1; // ebx
  LPVOID v3; // rax
  void *v4; // rcx
  LPVOID v5; // rsi
  __int64 v6; // rax
  __int64 v7; // rcx
  __int64 v8; // rax
  __int64 v9; // xmm1_8
  int v10; // [rsp+28h] [rbp-79h]
  const wchar_t *v11; // [rsp+30h] [rbp-71h]
  __int64 v12; // [rsp+38h] [rbp-69h]
  int v13; // [rsp+40h] [rbp-61h]
  const wchar_t *v14; // [rsp+48h] [rbp-59h]
  __int64 v15; // [rsp+50h] [rbp-51h]
  int v16; // [rsp+58h] [rbp-49h]
  const wchar_t *v17; // [rsp+60h] [rbp-41h]
  __int64 v18; // [rsp+68h] [rbp-39h]
  int v19; // [rsp+70h] [rbp-31h]
  const wchar_t *v20; // [rsp+78h] [rbp-29h]
  int v21; // [rsp+80h] [rbp-21h]
  int v22; // [rsp+84h] [rbp-1Dh]
  int v23; // [rsp+88h] [rbp-19h]
  const wchar_t *v24; // [rsp+90h] [rbp-11h]
  int v25; // [rsp+98h] [rbp-9h]
  int v26; // [rsp+9Ch] [rbp-5h]
  int v27; // [rsp+A0h] [rbp-1h]
  const wchar_t *v28; // [rsp+A8h] [rbp+7h]
  __int64 v29; // [rsp+B0h] [rbp+Fh]
  int v30; // [rsp+B8h] [rbp+17h]
  const wchar_t *v31; // [rsp+C0h] [rbp+1Fh]
  __int64 v32; // [rsp+C8h] [rbp+27h]
  int v33; // [rsp+D0h] [rbp+2Fh]
  const wchar_t *v34; // [rsp+D8h] [rbp+37h]
  int v35; // [rsp+E0h] [rbp+3Fh]
  int v36; // [rsp+E4h] [rbp+43h]

  v1 = 0;
  _InterlockedExchange((volatile __int32 *)this + 23, 0);
  v10 = 0;
  v22 = 3600;
  v11 = L"DataVersion";
  v14 = L"EnableAt";
  v17 = L"EnableBackCompat";
  v20 = L"MissedTasksStartupDelay";
  v24 = L"TasksInMemoryQueue";
  v28 = L"TracingLevel";
  v31 = L"WindowSeconds";
  v32 = 3600LL;
  v34 = L"UseXmlStore";
  v12 = 0LL;
  v13 = 1;
  v15 = 0LL;
  v16 = 2;
  v18 = 1LL;
  v19 = 3;
  v21 = 600;
  v23 = 4;
  v25 = 75;
  v26 = 1000;
  v27 = 5;
  v29 = 0LL;
  v30 = 6;
  v33 = 7;
  v35 = 0;
  v36 = 1;
  *((_DWORD *)this + 22) = 8;
  v3 = operator new(0xC0uLL);
  v4 = (void *)*((_QWORD *)this + 10);
  v5 = v3;
  if ( v4 )
    operator delete(v4);
  *((_QWORD *)this + 10) = v5;
  if ( *((_DWORD *)this + 22) )
  {
    do
    {
      v6 = v1++;
      v7 = 3 * v6;
      v8 = *((_QWORD *)this + 10);
      v9 = *(&v12 + v7);
      *(_OWORD *)(v8 + 8 * v7) = *(_OWORD *)(&v10 + 2 * v7);
      *(_QWORD *)(v8 + 8 * v7 + 16) = v9;
    }
    while ( v1 < *((_DWORD *)this + 22) );
  }
}
// 180076088: using guessed type wchar_t aUsexmlstore[12];
// 1800760A0: using guessed type wchar_t aWindowseconds[14];
// 1800760C0: using guessed type wchar_t aTracinglevel[13];
// 1800760E0: using guessed type wchar_t aTasksinmemoryq[19];
// 180076108: using guessed type wchar_t aMissedtaskssta[24];
// 180076138: using guessed type wchar_t aEnablebackcomp[17];
// 180076160: using guessed type wchar_t aEnableat[9];
// 180076178: using guessed type wchar_t aDataversion[12];

//----- (00000001800293E4) ----------------------------------------------------
__int64 __fastcall HashCompute::init(HashCompute *this)
{
  int Property; // ebx
  _QWORD *v3; // r10
  unsigned __int16 v4; // dx
  ULONG v5; // ebx
  HashCompute *pcbResult; // [rsp+40h] [rbp+8h] BYREF

  pcbResult = this;
  Property = BCryptOpenAlgorithmProvider((BCRYPT_ALG_HANDLE *)&pbHashObject + 1, L"SHA256", 0LL, 0);
  if ( Property < 0 )
  {
    v3 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
      || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) == 0
      || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
    {
      goto LABEL_24;
    }
    v4 = 10;
    goto LABEL_23;
  }
  Property = BCryptGetProperty(*(&pbHashObject + 1), L"ObjectLength", (PUCHAR)&dwBytes, 4u, (ULONG *)&pcbResult, 0);
  if ( Property < 0 )
  {
    v3 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
      || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) == 0
      || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
    {
      goto LABEL_24;
    }
    v4 = 11;
    goto LABEL_23;
  }
  pbHashObject = (PUCHAR)operator new(dwBytes);
  if ( !pbHashObject )
  {
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xCu, (__int64)&WPP_2b8d55565e60367fc767d22ca087624d_Traceguids);
    }
    v5 = 14;
    goto LABEL_25;
  }
  Property = BCryptGetProperty(
               *(&pbHashObject + 1),
               L"HashDigestLength",
               (PUCHAR)&dwBytes + 4,
               4u,
               (ULONG *)&pcbResult,
               0);
  if ( Property >= 0 )
  {
    _InterlockedIncrement(&dword_1800B0A40);
    return 0LL;
  }
  v3 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
  {
    v4 = 13;
LABEL_23:
    WPP_SF_D(v3[2], v4, (__int64)&WPP_2b8d55565e60367fc767d22ca087624d_Traceguids, Property);
  }
LABEL_24:
  v5 = RtlNtStatusToDosError(Property);
LABEL_25:
  if ( pbHashObject )
  {
    operator delete(pbHashObject);
    pbHashObject = 0LL;
  }
  if ( *(&pbHashObject + 1) )
  {
    BCryptCloseAlgorithmProvider(*(&pbHashObject + 1), 0);
    *(&pbHashObject + 1) = 0LL;
  }
  return v5;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 1800B0A40: using guessed type int dword_1800B0A40;

//----- (00000001800294CC) ----------------------------------------------------
JobStore *__fastcall JobStore::JobStore(JobStore *this, HKEY a2, HKEY a3)
{
  unsigned int TickCount; // eax

  *(_QWORD *)this = 0LL;
  *((_QWORD *)this + 1) = 0LL;
  *((_QWORD *)this + 2) = a2;
  *((_QWORD *)this + 3) = a3;
  *((_QWORD *)this + 4) = 0LL;
  *((_QWORD *)this + 5) = 0LL;
  *((_QWORD *)this + 6) = 0LL;
  *((_QWORD *)this + 7) = 0LL;
  *((_QWORD *)this + 8) = 0LL;
  *((_QWORD *)this + 9) = 0LL;
  *((_QWORD *)this + 8) = std::_Tree_alloc<0,std::_Tree_base_types<JobMoniker>>::_Buyheadnode();
  *((_QWORD *)this + 10) = 0LL;
  *((_DWORD *)this + 23) = 0;
  _InterlockedExchange((volatile __int32 *)this + 23, 0);
  TickCount = GetTickCount();
  srand(TickCount);
  return this;
}

//----- (0000000180029564) ----------------------------------------------------
_QWORD *std::_Tree_alloc<0,std::_Tree_base_types<JobMoniker>>::_Buyheadnode()
{
  _QWORD *result; // rax

  result = operator new(0x48uLL);
  if ( !result )
    std::_Xbad_alloc();
  *result = result;
  result[1] = result;
  result[2] = result;
  *((_WORD *)result + 12) = 257;
  return result;
}

//----- (00000001800295B0) ----------------------------------------------------
User::UserEntry *__fastcall User::GetLocalSystem(User::UserEntry *a1)
{
  struct _RTL_CRITICAL_SECTION *v2; // rbx
  User::UserEntry *v3; // rcx
  User::UserEntry **v4; // r15
  User **v5; // r14
  User::UserEntry *v6; // rax
  User::UserEntry **v7; // rdi
  User::UserEntry *v8; // rcx
  User *v9; // rcx
  DWORD cbSid; // [rsp+38h] [rbp-89h] BYREF
  __int64 *v12; // [rsp+40h] [rbp-81h] BYREF
  const wchar_t **v13; // [rsp+48h] [rbp-79h] BYREF
  User::UserEntry *v14[4]; // [rsp+50h] [rbp-71h] BYREF
  char pExceptionObject[56]; // [rsp+70h] [rbp-51h] BYREF
  struct _RTL_CRITICAL_SECTION pSid[2]; // [rsp+A8h] [rbp-19h] BYREF

  v14[1] = (User::UserEntry *)-2LL;
  v14[0] = a1;
  v2 = User::s_cs;
  v14[2] = (User::UserEntry *)User::s_cs;
  EnterCriticalSection(User::s_cs);
  if ( *(_QWORD *)User::s_userCache )
  {
    v3 = **(User::UserEntry ***)User::s_userCache;
  }
  else
  {
    cbSid = 68;
    CreateWellKnownSid(WinLocalSystemSid, 0LL, pSid, &cbSid);
    _bstr_t::_bstr_t((_bstr_t *)&v13, L"NT AUTHORITY");
    _bstr_t::_bstr_t((_bstr_t *)&v12, L"System");
    v4 = User::CreateUser(v14, &v12, &v13, SidTypeWellKnownGroup, pSid);
    v5 = (User **)User::s_userCache;
    v6 = (User::UserEntry *)operator new(8uLL);
    v7 = (User::UserEntry **)v6;
    v14[3] = v6;
    if ( v6 )
    {
      v8 = *v4;
      *(_QWORD *)v6 = *v4;
      if ( v8 )
        User::UserEntry::AddRef(v8);
    }
    else
    {
      v7 = 0LL;
    }
    if ( !v7 )
    {
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && *((char *)WPP_GLOBAL_Control + 28) < 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xAu, (__int64)&WPP_0a02ad6f637a3dce55ae09b3fc909c99_Traceguids);
      }
      wmi::OutOfMemoryException::OutOfMemoryException((wmi::OutOfMemoryException *)pExceptionObject);
      CxxThrowException_0(pExceptionObject, (_ThrowInfo *)&TI4_AVOutOfMemoryException_wmi__);
    }
    v9 = *v5;
    if ( v7 != (User::UserEntry **)*v5 && v9 )
      User::`scalar deleting destructor'(v9);
    *v5 = (User *)v7;
    wmi::AutoRef<User::UserEntry>::Release(v14);
    _bstr_t::_Free((_bstr_t *)&v12);
    _bstr_t::_Free((_bstr_t *)&v13);
    v3 = *v7;
  }
  *(_QWORD *)a1 = v3;
  if ( v3 )
    User::UserEntry::AddRef(v3);
  LeaveCriticalSection(v2);
  return a1;
}
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180029798) ----------------------------------------------------
User::UserEntry *__fastcall User::CreateUser(
        User::UserEntry *a1,
        WCHAR ***a2,
        enum _SID_NAME_USE a3,
        void *a4,
        bool a5)
{
  WCHAR *v9; // r12
  User::UserEntry **LocalService; // rax
  bool v11; // bl
  User::UserEntry **NetworkService; // rax
  bool v13; // bl
  const wchar_t *v14; // rax
  wchar_t v15; // r8
  wchar_t *v16; // rbx
  __int16 v17; // r10
  __int64 v18; // rdi
  unsigned int v19; // r9d
  __int64 v20; // rcx
  __int64 v21; // r8
  __int64 v22; // r9
  __int64 v23; // rcx
  __int64 *v24; // rax
  struct _RTL_CRITICAL_SECTION *v25; // rbx
  User::UserEntry *v26; // rdi
  User::UserEntry *v27; // rax
  User::UserEntry *v28; // rdi
  __int64 v30; // rcx
  __int64 v31; // r8
  __int64 v32; // r9
  User::UserEntry *v33; // [rsp+58h] [rbp-61h] BYREF
  const wchar_t **v34; // [rsp+60h] [rbp-59h] BYREF
  __int64 *v35; // [rsp+68h] [rbp-51h] BYREF
  enum _SID_NAME_USE v36; // [rsp+70h] [rbp-49h] BYREF
  const WCHAR *v37; // [rsp+78h] [rbp-41h] BYREF
  User::UserEntry *v38; // [rsp+80h] [rbp-39h] BYREF
  const WCHAR *v39; // [rsp+88h] [rbp-31h] BYREF
  const WCHAR *v40[3]; // [rsp+90h] [rbp-29h] BYREF
  char pExceptionObject[64]; // [rsp+A8h] [rbp-11h] BYREF

  v40[1] = (const WCHAR *)-2LL;
  v9 = 0LL;
  v35 = 0LL;
  v34 = 0LL;
  if ( User::IsLocalSystem(a4) )
  {
    User::GetLocalSystem(a1);
  }
  else
  {
    LocalService = User::GetLocalService(&v33);
    v11 = EqualSid(*((PSID *)*LocalService + 4), a4);
    wmi::AutoRef<User::UserEntry>::Release(&v33);
    if ( v11 )
    {
      User::GetLocalService((User::UserEntry **)a1);
    }
    else
    {
      NetworkService = User::GetNetworkService(&v33);
      v13 = EqualSid(*((PSID *)*NetworkService + 4), a4);
      wmi::AutoRef<User::UserEntry>::Release(&v33);
      if ( v13 )
      {
        User::GetNetworkService((User::UserEntry **)a1);
      }
      else
      {
        v33 = 0LL;
        _bstr_t::operator=((__int64 *)&v35, (__int64 *)&v33);
        _bstr_t::~_bstr_t((_bstr_t *)&v33);
        v33 = 0LL;
        _bstr_t::operator=((__int64 *)&v34, (__int64 *)&v33);
        _bstr_t::~_bstr_t((_bstr_t *)&v33);
        if ( !_bstr_t::operator!(a2) )
        {
          if ( *a2 )
            v9 = **a2;
          v14 = (const wchar_t *)_bstr_t::operator unsigned short const *((__int64)a2);
          v16 = wcschr(v14, v15);
          v17 = 0;
          LODWORD(v18) = 0;
          v19 = dword_1800AFF68;
          if ( (unsigned int)dword_1800AFF68 > 4 && tlgKeywordOn((__int64)&dword_1800AFF68, 0LL) )
          {
            v36 = a3;
            v33 = (User::UserEntry *)_bstr_t::operator unsigned short const *((__int64)a2);
            v39 = v16;
            v40[0] = v9;
            v37 = (const WCHAR *)a4;
            _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapSid<_SID>,_tlgWrapSz<unsigned short>,_tlgWrapSz<unsigned short>,_tlgWrapSz<unsigned short>,_tlgWrapperByVal<4>>(
              v20,
              byte_18007EC0F,
              v21,
              v22,
              (__int64)&v37,
              v40,
              &v39,
              (const WCHAR **)&v33,
              (__int64)&v36);
            v19 = dword_1800AFF68;
            v17 = 0;
          }
          if ( !v16 || (v18 = v16 - v9, ++v16 == 0LL) || *v16 == v17 )
          {
            if ( v19 > 4 && tlgKeywordOn((__int64)&dword_1800AFF68, 0LL) )
              _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<>(
                v23,
                byte_18007EBDE);
          }
          _bstr_t::operator=((_bstr_t::Data_t **)&v35, v16);
          if ( (_DWORD)v18 )
          {
            ATL::CComBSTR::CComBSTR((ATL::CComBSTR *)&v33, v18);
            StringCchCopyNW((char *)v33, (unsigned int)(v18 + 1), (char *)v9, (unsigned int)v18);
            v24 = (__int64 *)_bstr_t::_bstr_t((_bstr_t *)&v37, (unsigned __int16 *)v33);
            _bstr_t::operator=((__int64 *)&v34, v24);
            _bstr_t::~_bstr_t((_bstr_t *)&v37);
            SysFreeString(0LL);
          }
        }
        v25 = User::s_cs;
        v40[2] = (const WCHAR *)User::s_cs;
        EnterCriticalSection(User::s_cs);
        User::LookupUser(&v33, a4);
        v26 = v33;
        if ( v33 )
        {
          User::UpdateEntry((void ***)&v33, &v35, &v34, (const struct _bstr_t *)a2, a3, a4, a5);
          *(_QWORD *)a1 = v26;
          User::UserEntry::AddRef(v26);
        }
        else
        {
          v27 = (User::UserEntry *)operator new(0x30uLL);
          v38 = v27;
          if ( v27 )
            v28 = User::UserEntry::UserEntry(
                    v27,
                    0,
                    (const struct _bstr_t *)&v35,
                    (const struct _bstr_t *)&v34,
                    (const struct _bstr_t *)a2,
                    a3,
                    a4);
          else
            v28 = 0LL;
          if ( !v28 )
          {
            if ( (unsigned int)dword_1800AFF68 > 2 && tlgKeywordOn((__int64)&dword_1800AFF68, 0LL) )
            {
              v36 = a3;
              v37 = (const WCHAR *)_bstr_t::operator unsigned short const *((__int64)a2);
              v40[0] = (const WCHAR *)_bstr_t::operator unsigned short const *((__int64)&v34);
              v39 = (const WCHAR *)_bstr_t::operator unsigned short const *((__int64)&v35);
              v38 = (User::UserEntry *)a4;
              _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapSid<_SID>,_tlgWrapSz<unsigned short>,_tlgWrapSz<unsigned short>,_tlgWrapSz<unsigned short>,_tlgWrapperByVal<4>>(
                v30,
                byte_18007EB74,
                v31,
                v32,
                (__int64)&v38,
                &v39,
                v40,
                &v37,
                (__int64)&v36);
            }
            wmi::OutOfMemoryException::OutOfMemoryException((wmi::OutOfMemoryException *)pExceptionObject);
            CxxThrowException_0(pExceptionObject, (_ThrowInfo *)&TI4_AVOutOfMemoryException_wmi__);
          }
          v38 = v28;
          User::UserEntry::AddRef(v28);
          *(_QWORD *)a1 = v28;
          User::UserEntry::AddRef(v28);
          wmi::AutoRef<User::UserEntry>::Release(&v38);
        }
        std::pair<User const,LogonJob *>::~pair<User const,LogonJob *>(&v33);
        LeaveCriticalSection(v25);
      }
    }
  }
  _bstr_t::~_bstr_t((_bstr_t *)&v34);
  _bstr_t::~_bstr_t((_bstr_t *)&v35);
  return a1;
}
// 1800298D3: variable 'v15' is possibly undefined
// 180029957: variable 'v20' is possibly undefined
// 180029957: variable 'v21' is possibly undefined
// 180029957: variable 'v22' is possibly undefined
// 18002997E: variable 'v17' is possibly undefined
// 180029984: variable 'v19' is possibly undefined
// 18002999F: variable 'v23' is possibly undefined
// 180029B9A: variable 'v30' is possibly undefined
// 180029B9A: variable 'v31' is possibly undefined
// 180029B9A: variable 'v32' is possibly undefined
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);
// 180021628: using guessed type __int64 __fastcall std::pair<User const,LogonJob *>::~pair<User const,LogonJob *>(_QWORD);
// 18007EB74: using guessed type unsigned __int8 byte_18007EB74[106];
// 18007EBDE: using guessed type unsigned __int8 byte_18007EBDE[49];
// 18007EC0F: using guessed type unsigned __int8 byte_18007EC0F[90];

//----- (0000000180029BC0) ----------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
User::UserEntry **__fastcall User::GetNetworkService(User::UserEntry **a1)
{
  struct _RTL_CRITICAL_SECTION *v2; // rbx
  User::UserEntry **v3; // rcx
  User::UserEntry *v4; // rcx
  User::UserEntry **v6; // r15
  void *v7; // r14
  User::UserEntry **v8; // rax
  User::UserEntry **v9; // rdi
  User *v10; // rcx
  User::UserEntry *v11; // rcx
  void **pExceptionObject; // [rsp+28h] [rbp-38h] BYREF
  char v13; // [rsp+30h] [rbp-30h]
  const unsigned __int16 *v14; // [rsp+38h] [rbp-28h]
  __int64 v15; // [rsp+40h] [rbp-20h]
  int v16; // [rsp+48h] [rbp-18h]
  int v17; // [rsp+4Ch] [rbp-14h]
  int v18; // [rsp+50h] [rbp-10h]
  int v19; // [rsp+54h] [rbp-Ch]
  int v20; // [rsp+58h] [rbp-8h]
  User::UserEntry *v21; // [rsp+98h] [rbp+38h] BYREF
  LPCRITICAL_SECTION v22; // [rsp+A0h] [rbp+40h]
  User::UserEntry **v23; // [rsp+A8h] [rbp+48h]

  v2 = User::s_cs;
  v22 = User::s_cs;
  EnterCriticalSection(User::s_cs);
  v3 = (User::UserEntry **)*((_QWORD *)User::s_userCache + 2);
  if ( v3 )
  {
    v4 = *v3;
  }
  else
  {
    v6 = User::CreateWellKnownUser(&v21, WinNetworkServiceSid);
    v7 = User::s_userCache;
    v8 = (User::UserEntry **)operator new(8uLL);
    v9 = v8;
    v23 = v8;
    if ( v8 )
    {
      v11 = *v6;
      *v8 = *v6;
      if ( v11 )
        User::UserEntry::AddRef(v11);
    }
    if ( !v9 )
    {
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && *((char *)WPP_GLOBAL_Control + 28) < 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xAu, (__int64)&WPP_0a02ad6f637a3dce55ae09b3fc909c99_Traceguids);
      }
      v13 = 0;
      v14 = &word_18007630E;
      v15 = 0LL;
      v16 = 0;
      v17 = 0;
      v18 = 14;
      v19 = -1;
      v20 = -1;
      pExceptionObject = &wmi::OutOfMemoryException::`vftable';
      CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI4_AVOutOfMemoryException_wmi__);
    }
    v10 = (User *)*((_QWORD *)v7 + 2);
    if ( v9 != (User::UserEntry **)v10 && v10 )
      User::`scalar deleting destructor'(v10);
    *((_QWORD *)v7 + 2) = v9;
    wmi::AutoRef<User::UserEntry>::Release(&v21);
    v4 = *v9;
  }
  *a1 = v4;
  if ( v4 )
    User::UserEntry::AddRef(v4);
  LeaveCriticalSection(v2);
  return a1;
}
// 18003E813: bad sp value at call
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);
// 180073740: using guessed type void *wmi::OutOfMemoryException::`vftable';
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180029CB0) ----------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
User::UserEntry **__fastcall User::GetLocalService(User::UserEntry **a1)
{
  struct _RTL_CRITICAL_SECTION *v2; // rbx
  User::UserEntry **v3; // rcx
  User::UserEntry *v4; // rcx
  User::UserEntry **v6; // r15
  void *v7; // r14
  User::UserEntry **v8; // rax
  User::UserEntry **v9; // rdi
  User *v10; // rcx
  User::UserEntry *v11; // rcx
  void **pExceptionObject; // [rsp+28h] [rbp-38h] BYREF
  char v13; // [rsp+30h] [rbp-30h]
  const unsigned __int16 *v14; // [rsp+38h] [rbp-28h]
  __int64 v15; // [rsp+40h] [rbp-20h]
  int v16; // [rsp+48h] [rbp-18h]
  int v17; // [rsp+4Ch] [rbp-14h]
  int v18; // [rsp+50h] [rbp-10h]
  int v19; // [rsp+54h] [rbp-Ch]
  int v20; // [rsp+58h] [rbp-8h]
  User::UserEntry *v21; // [rsp+98h] [rbp+38h] BYREF
  LPCRITICAL_SECTION v22; // [rsp+A0h] [rbp+40h]
  User::UserEntry **v23; // [rsp+A8h] [rbp+48h]

  v2 = User::s_cs;
  v22 = User::s_cs;
  EnterCriticalSection(User::s_cs);
  v3 = (User::UserEntry **)*((_QWORD *)User::s_userCache + 1);
  if ( v3 )
  {
    v4 = *v3;
  }
  else
  {
    v6 = User::CreateWellKnownUser(&v21, WinLocalServiceSid);
    v7 = User::s_userCache;
    v8 = (User::UserEntry **)operator new(8uLL);
    v9 = v8;
    v23 = v8;
    if ( v8 )
    {
      v11 = *v6;
      *v8 = *v6;
      if ( v11 )
        User::UserEntry::AddRef(v11);
    }
    if ( !v9 )
    {
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && *((char *)WPP_GLOBAL_Control + 28) < 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xAu, (__int64)&WPP_0a02ad6f637a3dce55ae09b3fc909c99_Traceguids);
      }
      v13 = 0;
      v14 = &word_18007630E;
      v15 = 0LL;
      v16 = 0;
      v17 = 0;
      v18 = 14;
      v19 = -1;
      v20 = -1;
      pExceptionObject = &wmi::OutOfMemoryException::`vftable';
      CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI4_AVOutOfMemoryException_wmi__);
    }
    v10 = (User *)*((_QWORD *)v7 + 1);
    if ( v9 != (User::UserEntry **)v10 && v10 )
      User::`scalar deleting destructor'(v10);
    *((_QWORD *)v7 + 1) = v9;
    wmi::AutoRef<User::UserEntry>::Release(&v21);
    v4 = *v9;
  }
  *a1 = v4;
  if ( v4 )
    User::UserEntry::AddRef(v4);
  LeaveCriticalSection(v2);
  return a1;
}
// 18003E8A9: bad sp value at call
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);
// 180073740: using guessed type void *wmi::OutOfMemoryException::`vftable';
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180029DA0) ----------------------------------------------------
__int64 __fastcall User::UpdateEntry(User *this)
{
  _QWORD *v2; // r8
  void *v3; // rsi
  struct _RTL_CRITICAL_SECTION *v4; // rbx
  WCHAR *ComputerNameW; // rax
  int v6; // eax
  __int64 v7; // rdx
  char ***v8; // rcx
  __int64 *v9; // rdx
  __int64 v10; // r9
  __int64 v11; // r9
  __int64 v12; // r9
  __int64 v13; // r9
  __int64 v14; // r9
  __int64 v15; // rcx
  __int64 v16; // r8
  __int64 v17; // r9
  const WCHAR *v18; // rax
  LPCWSTR v19; // r10
  int LastError; // ebx
  UINT v21; // edx
  const WCHAR *v22; // rax
  OLECHAR *v23; // rdi
  LPCWSTR v24; // r10
  struct _RTL_CRITICAL_SECTION *v25; // rbx
  __int64 v26; // r8
  __int64 v27; // r8
  signed int v28; // eax
  struct _RTL_CRITICAL_SECTION *v30; // rbx
  char **v31; // [rsp+40h] [rbp-39h] BYREF
  char **v32; // [rsp+48h] [rbp-31h] BYREF
  BSTR *v33; // [rsp+50h] [rbp-29h] BYREF
  WCHAR v34[4]; // [rsp+58h] [rbp-21h] BYREF
  const WCHAR *v35; // [rsp+60h] [rbp-19h] BYREF
  const WCHAR *v36[2]; // [rsp+68h] [rbp-11h] BYREF
  char pExceptionObject[88]; // [rsp+78h] [rbp-1h] BYREF
  enum _SID_NAME_USE peUse; // [rsp+E0h] [rbp+67h] BYREF
  DWORD cchReferencedDomainName; // [rsp+E8h] [rbp+6Fh] BYREF
  DWORD cbSid; // [rsp+F0h] [rbp+77h] BYREF
  LPWSTR bstrString; // [rsp+F8h] [rbp+7Fh] BYREF

  v36[1] = (const WCHAR *)-2LL;
  v2 = *(_QWORD **)this;
  if ( !*(_QWORD *)this )
    return 2147549183LL;
  v3 = (void *)v2[4];
  if ( !v3 )
  {
    if ( !_bstr_t::operator!(v2 + 1) )
    {
      peUse = SidTypeUnknown;
      cchReferencedDomainName = 0;
      cbSid = 0;
      v31 = 0LL;
      v32 = 0LL;
      v4 = User::s_cs;
      bstrString = (LPWSTR)User::s_cs;
      EnterCriticalSection(User::s_cs);
      ComputerNameW = User::GetComputerNameW();
      _bstr_t::_bstr_t((_bstr_t *)&v33, ComputerNameW);
      v6 = _bstr_t::_Compare((BSTR **)(*(_QWORD *)this + 24LL), &v33);
      v7 = *(_QWORD *)this;
      v8 = &v31;
      if ( v6 )
      {
        v9 = (__int64 *)(v7 + 8);
      }
      else
      {
        _bstr_t::operator=((__int64 *)&v31, (__int64 *)(v7 + 16));
        v9 = (__int64 *)&v33;
        v8 = &v32;
      }
      _bstr_t::operator=((__int64 *)v8, v9);
      if ( (_bstr_t::operator!((_QWORD *)(*(_QWORD *)this + 24LL))
         || _bstr_t::operator!((_QWORD *)(v10 + 16))
         || _bstr_t::operator!((_QWORD *)(v11 + 8)))
        && (unsigned int)dword_1800AFF68 > 4
        && tlgKeywordOn((__int64)&dword_1800AFF68, 0LL) )
      {
        LODWORD(bstrString) = peUse;
        v35 = (const WCHAR *)_bstr_t::operator unsigned short const *(v12 + 8);
        v36[0] = (const WCHAR *)_bstr_t::operator unsigned short const *(v13 + 16);
        *(_QWORD *)v34 = _bstr_t::operator unsigned short const *(v14 + 24);
        _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapSz<unsigned short>,_tlgWrapSz<unsigned short>,_tlgWrapSz<unsigned short>,_tlgWrapperByVal<4>>(
          v15,
          byte_18007EA71,
          v16,
          v17,
          (const WCHAR **)v34,
          v36,
          &v35,
          (__int64)&bstrString);
      }
      _bstr_t::~_bstr_t((_bstr_t *)&v33);
      LeaveCriticalSection(v4);
      _bstr_t::operator unsigned short const *((__int64)&v31);
      v18 = (const WCHAR *)_bstr_t::operator unsigned short const *((__int64)&v32);
      if ( LookupAccountNameW(v18, v19, 0LL, &cbSid, 0LL, &cchReferencedDomainName, &peUse) )
      {
        LastError = -2147418113;
LABEL_47:
        _bstr_t::~_bstr_t((_bstr_t *)&v32);
LABEL_48:
        _bstr_t::~_bstr_t((_bstr_t *)&v31);
        return (unsigned int)LastError;
      }
      if ( GetLastError() != 122 )
      {
        LastError = GetLastError();
        if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
          && *((char *)WPP_GLOBAL_Control + 28) < 0
          && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
        {
          WPP_SF_D(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x18u,
            (__int64)&WPP_0a02ad6f637a3dce55ae09b3fc909c99_Traceguids,
            LastError);
        }
        if ( LastError > 0 )
          LastError = (unsigned __int16)LastError | 0x80070000;
        goto LABEL_47;
      }
      v3 = operator new(cbSid + 1);
      *(_QWORD *)v34 = v3;
      if ( !v3 )
      {
        if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
          && *((char *)WPP_GLOBAL_Control + 28) < 0
          && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
        {
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x19u, (__int64)&WPP_0a02ad6f637a3dce55ae09b3fc909c99_Traceguids);
        }
        wmi::OutOfMemoryException::OutOfMemoryException((wmi::OutOfMemoryException *)pExceptionObject);
        CxxThrowException_0(pExceptionObject, (_ThrowInfo *)&TI4_AVOutOfMemoryException_wmi__);
      }
      v21 = cchReferencedDomainName++;
      ATL::CComBSTR::CComBSTR((ATL::CComBSTR *)&bstrString, v21);
      _bstr_t::operator unsigned short const *((__int64)&v31);
      v22 = (const WCHAR *)_bstr_t::operator unsigned short const *((__int64)&v32);
      v23 = bstrString;
      if ( !LookupAccountNameW(v22, v24, v3, &cbSid, bstrString, &cchReferencedDomainName, &peUse) )
      {
        LastError = GetLastError();
        if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
          && *((char *)WPP_GLOBAL_Control + 28) < 0
          && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
        {
          WPP_SF_D(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x1Au,
            (__int64)&WPP_0a02ad6f637a3dce55ae09b3fc909c99_Traceguids,
            LastError);
        }
        if ( LastError > 0 )
          LastError = (unsigned __int16)LastError | 0x80070000;
        SysFreeString(v23);
        operator delete(v3);
        goto LABEL_47;
      }
      if ( peUse == SidTypeDomain || peUse <= 0 || peUse >= SidTypeDeletedAccount )
      {
        if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
          && *((char *)WPP_GLOBAL_Control + 28) < 0
          && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
        {
          WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x1Bu, (__int64)&WPP_0a02ad6f637a3dce55ae09b3fc909c99_Traceguids);
        }
        SysFreeString(v23);
        operator delete(v3);
        LastError = -2147024809;
        goto LABEL_47;
      }
      v25 = User::s_cs;
      EnterCriticalSection(User::s_cs);
      wmi::AutoVectorPtr<unsigned char>::operator=((void **)(*(_QWORD *)this + 32LL), v3);
      *(_DWORD *)(*(_QWORD *)this + 40LL) = peUse;
      LeaveCriticalSection(v25);
      SysFreeString(v23);
      operator delete(0LL);
      _bstr_t::~_bstr_t((_bstr_t *)&v32);
      _bstr_t::~_bstr_t((_bstr_t *)&v31);
      v2 = *(_QWORD **)this;
      goto LABEL_35;
    }
    return 2147549183LL;
  }
LABEL_35:
  if ( _bstr_t::operator!(v2 + 3) || _bstr_t::operator!((_QWORD *)(v26 + 16)) || *(_DWORD *)(v27 + 40) == 8 )
  {
    LODWORD(bstrString) = 8;
    v31 = 0LL;
    v32 = 0LL;
    v33 = 0LL;
    if ( !(unsigned int)User::LookupUserSid(
                          (struct _bstr_t *)&v31,
                          (struct _bstr_t *)&v32,
                          (enum _SID_NAME_USE *)&bstrString,
                          v3) )
    {
      v28 = GetLastError();
      LastError = v28;
      if ( v28 > 0 )
        LastError = (unsigned __int16)v28 | 0x80070000;
      _bstr_t::~_bstr_t((_bstr_t *)&v33);
      _bstr_t::~_bstr_t((_bstr_t *)&v32);
      goto LABEL_48;
    }
    User::AssembleFullUserName((struct _bstr_t *)&v33, &v31, &v32);
    v30 = User::s_cs;
    EnterCriticalSection(User::s_cs);
    _bstr_t::operator=((__int64 *)(*(_QWORD *)this + 16LL), (__int64 *)&v32);
    _bstr_t::operator=((__int64 *)(*(_QWORD *)this + 24LL), (__int64 *)&v31);
    _bstr_t::operator=((__int64 *)(*(_QWORD *)this + 8LL), (__int64 *)&v33);
    *(_DWORD *)(*(_QWORD *)this + 40LL) = (_DWORD)bstrString;
    LeaveCriticalSection(v30);
    _bstr_t::~_bstr_t((_bstr_t *)&v33);
    _bstr_t::~_bstr_t((_bstr_t *)&v32);
    _bstr_t::~_bstr_t((_bstr_t *)&v31);
  }
  return 0LL;
}
// 180029E75: variable 'v10' is possibly undefined
// 180029E82: variable 'v11' is possibly undefined
// 180029EB0: variable 'v12' is possibly undefined
// 180029EBD: variable 'v13' is possibly undefined
// 180029ECA: variable 'v14' is possibly undefined
// 180029F02: variable 'v15' is possibly undefined
// 180029F02: variable 'v16' is possibly undefined
// 180029F02: variable 'v17' is possibly undefined
// 180029F5A: variable 'v19' is possibly undefined
// 18002A049: variable 'v24' is possibly undefined
// 18002A15D: variable 'v26' is possibly undefined
// 18002A16A: variable 'v27' is possibly undefined
// 18007EA71: using guessed type unsigned __int8 byte_18007EA71[87];
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018002A33C) ----------------------------------------------------
__int64 __fastcall User::InitializeUserTable()
{
  unsigned int v0; // esi
  struct _RTL_CRITICAL_SECTION *v1; // rax
  struct _RTL_CRITICAL_SECTION *v2; // rbx
  _QWORD *v3; // rax
  struct _RTL_CRITICAL_SECTION *v4; // rbx
  void *v5; // rax
  void *v6; // r14
  User::UserEntry **v7; // r12
  void *v8; // r13
  User *v9; // rax
  User *v10; // r14
  User *v11; // rcx
  User::UserEntry **v12; // r12
  void *v13; // r13
  User *v14; // rax
  User *v15; // r14
  User *v16; // rcx
  User::UserEntry *v18; // rcx
  User::UserEntry *v19; // rcx
  void **v20; // [rsp+48h] [rbp-178h] BYREF
  char v21; // [rsp+50h] [rbp-170h]
  const unsigned __int16 *v22; // [rsp+58h] [rbp-168h]
  __int64 v23; // [rsp+60h] [rbp-160h]
  int v24; // [rsp+68h] [rbp-158h]
  int v25; // [rsp+6Ch] [rbp-154h]
  int v26; // [rsp+70h] [rbp-150h]
  int v27; // [rsp+74h] [rbp-14Ch]
  int v28; // [rsp+78h] [rbp-148h]
  void **v29; // [rsp+80h] [rbp-140h] BYREF
  char v30; // [rsp+88h] [rbp-138h]
  const unsigned __int16 *v31; // [rsp+90h] [rbp-130h]
  __int64 v32; // [rsp+98h] [rbp-128h]
  int v33; // [rsp+A0h] [rbp-120h]
  int v34; // [rsp+A4h] [rbp-11Ch]
  int v35; // [rsp+A8h] [rbp-118h]
  int v36; // [rsp+ACh] [rbp-114h]
  int v37; // [rsp+B0h] [rbp-110h]
  __int64 pExceptionObject; // [rsp+108h] [rbp-B8h]
  __int64 v39; // [rsp+178h] [rbp-48h]
  User::UserEntry *v40; // [rsp+1D0h] [rbp+10h] BYREF
  LPCRITICAL_SECTION v41; // [rsp+1D8h] [rbp+18h]

  v39 = -2LL;
  v0 = 0;
  v1 = (struct _RTL_CRITICAL_SECTION *)operator new(0x28uLL);
  v2 = v1;
  if ( v1 )
    InitializeCriticalSectionEx(v1, 0, 0);
  else
    v2 = 0LL;
  User::s_cs = v2;
  if ( !v2 )
  {
    v0 = -2147024882;
    LODWORD(pExceptionObject) = -2147024882;
LABEL_45:
    User::UninitializeUserTable();
    return v0;
  }
  v3 = operator new(0x18uLL);
  if ( v3 )
  {
    *v3 = 0LL;
    v3[1] = 0LL;
    v3[2] = 0LL;
  }
  User::s_userTable = v3;
  if ( !v3 )
  {
    v0 = -2147024882;
    LODWORD(pExceptionObject) = -2147024882;
    goto LABEL_45;
  }
  v4 = User::s_cs;
  v41 = User::s_cs;
  EnterCriticalSection(User::s_cs);
  if ( (unsigned __int64)((__int64)(*((_QWORD *)User::s_userTable + 2) - *(_QWORD *)User::s_userTable) >> 3) < 0x14 )
    std::vector<_CSebiSystemEventCreationParameter *>::_Reallocate((__int64)User::s_userTable, 0x14uLL);
  v5 = operator new(0x40uLL);
  v6 = v5;
  if ( v5 )
  {
    memset_0(v5, 0, 0x40uLL);
    `eh vector constructor iterator'(
      v6,
      8uLL,
      8uLL,
      (void (__stdcall *)(void *))std::auto_ptr<User>::`default constructor closure',
      (void (__stdcall *)(void *))std::auto_ptr<User>::~auto_ptr<User>);
  }
  User::s_userCache = v6;
  if ( !v6 )
  {
    v0 = -2147024882;
    LODWORD(pExceptionObject) = -2147024882;
    LeaveCriticalSection(v4);
    goto LABEL_45;
  }
  User::GetLocalSystem((User::UserEntry *)&v40);
  wmi::AutoRef<User::UserEntry>::Release(&v40);
  User::GetLocalService(&v40);
  wmi::AutoRef<User::UserEntry>::Release(&v40);
  User::GetNetworkService(&v40);
  wmi::AutoRef<User::UserEntry>::Release(&v40);
  User::GetLocalAdmin();
  v7 = User::CreateWellKnownUser(&v40, WinInteractiveSid);
  v8 = User::s_userCache;
  v9 = (User *)operator new(8uLL);
  v10 = v9;
  if ( v9 )
  {
    v18 = *v7;
    *(_QWORD *)v9 = *v7;
    if ( v18 )
      User::UserEntry::AddRef(v18);
  }
  else
  {
    v10 = 0LL;
  }
  if ( !v10 )
  {
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && *((char *)WPP_GLOBAL_Control + 28) < 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xAu, (__int64)&WPP_0a02ad6f637a3dce55ae09b3fc909c99_Traceguids);
    }
    v21 = 0;
    v22 = &word_18007630E;
    v23 = 0LL;
    v24 = 0;
    v25 = 0;
    v26 = 14;
    v27 = -1;
    v28 = -1;
    v20 = &wmi::OutOfMemoryException::`vftable';
    CxxThrowException_0(&v20, (_ThrowInfo *)&TI4_AVOutOfMemoryException_wmi__);
  }
  v11 = (User *)*((_QWORD *)v8 + 4);
  if ( v10 != v11 && v11 )
    User::`scalar deleting destructor'(v11);
  *((_QWORD *)v8 + 4) = v10;
  wmi::AutoRef<User::UserEntry>::Release(&v40);
  v12 = User::CreateWellKnownUser(&v40, WinAuthenticatedUserSid);
  v13 = User::s_userCache;
  v14 = (User *)operator new(8uLL);
  v15 = v14;
  if ( v14 )
  {
    v19 = *v12;
    *(_QWORD *)v14 = *v12;
    if ( v19 )
      User::UserEntry::AddRef(v19);
  }
  if ( !v15 )
  {
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && *((char *)WPP_GLOBAL_Control + 28) < 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xAu, (__int64)&WPP_0a02ad6f637a3dce55ae09b3fc909c99_Traceguids);
    }
    v30 = 0;
    v31 = &word_18007630E;
    v32 = 0LL;
    v33 = 0;
    v34 = 0;
    v35 = 14;
    v36 = -1;
    v37 = -1;
    v29 = &wmi::OutOfMemoryException::`vftable';
    CxxThrowException_0(&v29, (_ThrowInfo *)&TI4_AVOutOfMemoryException_wmi__);
  }
  v16 = (User *)*((_QWORD *)v13 + 5);
  if ( v15 != v16 && v16 )
    User::`scalar deleting destructor'(v16);
  *((_QWORD *)v13 + 5) = v15;
  wmi::AutoRef<User::UserEntry>::Release(&v40);
  LeaveCriticalSection(v4);
  return v0;
}
// 18002A33C: could not find valid save-restore pair for rbp
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);
// 180073740: using guessed type void *wmi::OutOfMemoryException::`vftable';
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018002A5A8) ----------------------------------------------------
User::UserEntry **__fastcall User::CreateWellKnownUser(User::UserEntry **a1, WELL_KNOWN_SID_TYPE a2)
{
  int LastError; // ebx
  enum _SID_NAME_USE v5; // [rsp+38h] [rbp-69h] BYREF
  const wchar_t **v6; // [rsp+40h] [rbp-61h] BYREF
  DWORD cbSid; // [rsp+48h] [rbp-59h] BYREF
  __int64 *v8[2]; // [rsp+50h] [rbp-51h] BYREF
  char pExceptionObject[56]; // [rsp+60h] [rbp-41h] BYREF
  struct _RTL_CRITICAL_SECTION pSid[2]; // [rsp+98h] [rbp-9h] BYREF

  v8[1] = (__int64 *)-2LL;
  cbSid = 68;
  v5 = SidTypeUnknown;
  v6 = 0LL;
  v8[0] = 0LL;
  CreateWellKnownSid(a2, 0LL, pSid, &cbSid);
  if ( !(unsigned int)User::LookupUserSid((struct _bstr_t *)&v6, (struct _bstr_t *)v8, &v5, pSid) )
  {
    LastError = GetLastError();
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && *((char *)WPP_GLOBAL_Control + 28) < 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0xBu,
        (__int64)&WPP_0a02ad6f637a3dce55ae09b3fc909c99_Traceguids,
        LastError);
    }
    wmi::GenericException::GenericException((wmi::GenericException *)pExceptionObject, LastError);
    CxxThrowException_0(pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
  }
  User::CreateUser(a1, v8, &v6, v5, pSid);
  _bstr_t::_Free((_bstr_t *)v8);
  _bstr_t::_Free((_bstr_t *)&v6);
  return a1;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018002A6E0) ----------------------------------------------------
__int64 __fastcall User::FromSidToDomainAccount(struct _bstr_t *a1, void *a2)
{
  signed int LastError; // eax
  unsigned int v4; // ebx
  char **v6[3]; // [rsp+20h] [rbp-18h] BYREF
  int v7; // [rsp+50h] [rbp+18h] BYREF
  char **v8; // [rsp+58h] [rbp+20h] BYREF

  v6[1] = (char **)-2LL;
  v6[0] = 0LL;
  v8 = 0LL;
  if ( (unsigned int)User::LookupUserSid((struct _bstr_t *)&v8, (struct _bstr_t *)v6, (enum _SID_NAME_USE *)&v7, a2) )
  {
    User::AssembleFullUserName(a1, &v8, v6);
    v4 = 0;
  }
  else
  {
    LastError = GetLastError();
    v4 = LastError;
    if ( LastError > 0 )
      v4 = (unsigned __int16)LastError | 0x80070000;
  }
  _bstr_t::~_bstr_t((_bstr_t *)&v8);
  _bstr_t::~_bstr_t((_bstr_t *)v6);
  return v4;
}

//----- (000000018002A76C) ----------------------------------------------------
__int64 __fastcall User::AssembleFullUserName(struct _bstr_t *a1, char ***a2, char ***a3)
{
  char **v6; // rcx
  char *v7; // rdi
  UINT v8; // ebx
  char **v9; // rax
  UINT v10; // eax
  __int64 v11; // rsi
  unsigned __int64 v12; // rsi
  char *v13; // r8
  unsigned __int16 *v14; // rbx
  signed int v15; // eax
  unsigned __int64 v16; // rdx
  unsigned __int16 *v17; // rax
  unsigned __int64 v18; // rcx
  unsigned __int64 v19; // r8
  char *v20; // rdx
  __int64 v21; // r9
  signed __int64 v22; // rcx
  __int16 v23; // ax
  char *v24; // rax
  __int64 *v25; // rax
  unsigned __int16 *v27; // [rsp+68h] [rbp+10h] BYREF
  char v28; // [rsp+70h] [rbp+18h] BYREF

  v6 = *a3;
  v7 = 0LL;
  if ( *a3 && *v6 )
    v8 = SysStringLen((BSTR)*v6);
  else
    v8 = 0;
  v9 = *a2;
  if ( *a2 && *v9 )
    v10 = SysStringLen((BSTR)*v9);
  else
    v10 = 0;
  v11 = v8 + v10 + 1;
  ATL::CComBSTR::CComBSTR((ATL::CComBSTR *)&v27, v8 + v10 + 1);
  v12 = v11 + 1;
  if ( *a2 )
    v13 = **a2;
  else
    v13 = 0LL;
  v14 = v27;
  StringCchCopyW((char *)v27, v12, v13);
  v15 = v12 > 0x7FFFFFFF ? 0x80070057 : 0;
  if ( v12 > 0x7FFFFFFF )
    goto LABEL_18;
  v16 = v12;
  v17 = v14;
  do
  {
    if ( !*v17 )
      break;
    ++v17;
    --v16;
  }
  while ( v16 );
  v15 = v16 == 0 ? 0x80070057 : 0;
  if ( v16 )
    v18 = v12 - v16;
  else
LABEL_18:
    v18 = 0LL;
  if ( v15 >= 0 )
  {
    v19 = v12 - v18;
    v20 = (char *)&v14[v18];
    if ( v12 != v18 )
    {
      v21 = 2147483646LL;
      v22 = (char *)L"\\" - v20;
      do
      {
        if ( !v21 )
          break;
        v23 = *(_WORD *)&v20[v22];
        if ( !v23 )
          break;
        *(_WORD *)v20 = v23;
        v20 += 2;
        --v21;
        --v19;
      }
      while ( v19 );
    }
    v24 = v20 - 2;
    if ( v19 )
      v24 = v20;
    *(_WORD *)v24 = 0;
  }
  if ( *a3 )
    v7 = **a3;
  StringCchCatW(v14, v12, v7);
  v25 = (__int64 *)_bstr_t::_bstr_t((_bstr_t *)&v28, v14);
  _bstr_t::operator=((__int64 *)a1, v25);
  _bstr_t::_Free((_bstr_t *)&v28);
  SysFreeString(0LL);
  return 0LL;
}

//----- (000000018002A90C) ----------------------------------------------------
__int64 __fastcall User::LookupUserSid(struct _bstr_t *a1, struct _bstr_t *a2, enum _SID_NAME_USE *a3, void *a4)
{
  UINT v8; // edx
  UINT v9; // edx
  unsigned int v10; // esi
  __int64 *v11; // rax
  __int64 *v12; // rax
  DWORD cchReferencedDomainName; // [rsp+30h] [rbp-40h] BYREF
  DWORD cchName; // [rsp+34h] [rbp-3Ch] BYREF
  enum _SID_NAME_USE peUse; // [rsp+38h] [rbp-38h] BYREF
  LPWSTR ReferencedDomainName; // [rsp+40h] [rbp-30h] BYREF
  LPWSTR Name; // [rsp+48h] [rbp-28h] BYREF
  unsigned __int16 *v19; // [rsp+50h] [rbp-20h] BYREF
  unsigned __int16 *v20[3]; // [rsp+58h] [rbp-18h] BYREF

  v20[1] = (unsigned __int16 *)-2LL;
  cchName = 0;
  cchReferencedDomainName = 0;
  peUse = SidTypeUnknown;
  v20[0] = 0LL;
  v19 = 0LL;
  LookupAccountSidLocalW(a4, 0LL, &cchName, 0LL, &cchReferencedDomainName, &peUse);
  if ( GetLastError() == 122 )
  {
    v8 = cchName++;
    ATL::CComBSTR::CComBSTR((ATL::CComBSTR *)&Name, v8);
    v9 = cchReferencedDomainName++;
    ATL::CComBSTR::CComBSTR((ATL::CComBSTR *)&ReferencedDomainName, v9);
    v10 = LookupAccountSidLocalW(a4, Name, &cchName, ReferencedDomainName, &cchReferencedDomainName, &peUse);
    if ( v10 )
    {
      ATL::CComBSTR::operator=(v20, (LPCSTR *)&Name);
      ATL::CComBSTR::operator=(&v19, (LPCSTR *)&ReferencedDomainName);
      SysFreeString(ReferencedDomainName);
      SysFreeString(Name);
      v11 = (__int64 *)_bstr_t::_bstr_t((_bstr_t *)&Name, v19);
      _bstr_t::operator=((__int64 *)a1, v11);
      _bstr_t::_Free((_bstr_t *)&Name);
      v19 = 0LL;
      v12 = (__int64 *)_bstr_t::_bstr_t((_bstr_t *)&Name, v20[0]);
      _bstr_t::operator=((__int64 *)a2, v12);
      _bstr_t::_Free((_bstr_t *)&Name);
      *a3 = peUse;
      v10 = 1;
    }
    else
    {
      SysFreeString(ReferencedDomainName);
      SysFreeString(Name);
    }
  }
  else
  {
    v10 = 0;
  }
  SysFreeString(0LL);
  SysFreeString(0LL);
  return v10;
}

//----- (000000018002AAC0) ----------------------------------------------------
OLECHAR **__fastcall ATL::CComBSTR::operator=(OLECHAR **a1, LPCSTR *a2)
{
  OLECHAR *v4; // rcx
  BSTR v5; // rax

  v4 = *a1;
  if ( v4 != (OLECHAR *)*a2 )
  {
    SysFreeString(v4);
    v5 = ATL::CComBSTR::Copy(a2);
    *a1 = v5;
    if ( *a2 )
    {
      if ( !v5 )
        ATL::PrivateAtlThrow(-2147024882);
    }
  }
  return a1;
}

//----- (000000018002AB20) ----------------------------------------------------
void __fastcall ServiceMain(unsigned int a1, const unsigned __int16 *const *a2)
{
  __int64 v4[2]; // [rsp+58h] [rbp-128h] BYREF
  void *lpMem; // [rsp+68h] [rbp-118h]
  struct _RTL_CRITICAL_SECTION CriticalSection; // [rsp+A0h] [rbp-E0h] BYREF

  JobsService::JobsService((JobsService *)v4);
  CNtService::Run((CNtService *)v4, (char *)L"Schedule", a1, a2, v4);
  v4[0] = (__int64)&JobsService::`vftable';
  JobsService::FinalizeSCMEventLogNotifications((JobsService *)v4);
  v4[0] = (__int64)&CNtService::`vftable';
  if ( lpMem )
    operator delete(lpMem);
  DeleteCriticalSection(&CriticalSection);
}
// 18002AB20: could not find valid save-restore pair for rbp
// 180070520: using guessed type void *JobsService::`vftable';
// 180070568: using guessed type void *CNtService::`vftable';
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018002ABC0) ----------------------------------------------------
__int64 __fastcall CNtService::Run(
        CNtService *this,
        char *a2,
        unsigned int a3,
        const unsigned __int16 *const *a4,
        void *lpContext)
{
  __int64 v8; // rdi
  unsigned __int64 v10; // rdi
  char *v11; // rax
  SERVICE_STATUS_HANDLE v12; // rax
  __int64 v13; // r8
  CNtService *v14; // rcx
  int v15; // eax
  __int64 v16; // r8
  __int64 v17; // rax
  const wchar_t *v19; // rdx
  __int64 v20; // rax
  __int64 v21; // r8

  v8 = -1LL;
  do
    ++v8;
  while ( *(_WORD *)&a2[2 * v8] );
  v10 = v8 + 1;
  v11 = (char *)operator new(saturated_mul(v10, 2uLL));
  *((_QWORD *)this + 2) = v11;
  if ( !v11 )
    return 8LL;
  if ( (int)StringCchCopyW(v11, v10, a2) >= 0 )
  {
    v12 = RegisterServiceCtrlHandlerExW(
            *((LPCWSTR *)this + 2),
            (LPHANDLER_FUNCTION_EX)CNtService::_HandlerEx,
            lpContext);
    *((_QWORD *)this + 4) = v12;
    v14 = this;
    if ( !v12 )
    {
      v19 = L"Initial call to RegisterServiceCtrlHandler failed";
LABEL_13:
      (*(void (__fastcall **)(CNtService *, const wchar_t *))(*(_QWORD *)this + 56LL))(v14, v19);
      goto LABEL_14;
    }
    *((_DWORD *)this + 10) = 32;
    *((_DWORD *)this + 14) = 0;
    if ( (unsigned int)CNtService::ReportStatusToSCMgr(this, 2, v13, 1, 0x7530u) )
    {
      v15 = (*(__int64 (__fastcall **)(CNtService *, _QWORD, _QWORD, const unsigned __int16 *const *))(*(_QWORD *)this + 24LL))(
              this,
              *((_QWORD *)this + 4),
              a3,
              a4);
      v14 = this;
      if ( v15 )
      {
        if ( (unsigned int)CNtService::ReportStatusToSCMgr(this, 4, v16, 0, 0) )
        {
          v17 = *(_QWORD *)this;
          *((_DWORD *)this + 2) = 1;
          (*(void (__fastcall **)(CNtService *))(v17 + 8))(this);
        }
        goto LABEL_14;
      }
      v19 = L"Initialize call failed, bailing out";
      goto LABEL_13;
    }
  }
LABEL_14:
  v20 = *(_QWORD *)this;
  *((_DWORD *)this + 2) = 0;
  (*(void (__fastcall **)(CNtService *))(v20 + 32))(this);
  if ( *((_QWORD *)this + 4) )
    CNtService::ReportStatusToSCMgr(this, 1, v21, 0, 0);
  return 0LL;
}
// 18002AC7A: variable 'v13' is possibly undefined
// 18002ACB8: variable 'v16' is possibly undefined
// 18003FFF3: variable 'v21' is possibly undefined
// 18007F880: using guessed type wchar_t aInitialCallToR[50];
// 18007F8F0: using guessed type wchar_t aInitializeCall[36];

//----- (000000018002ACE8) ----------------------------------------------------
__int64 __fastcall CNtService::ReportStatusToSCMgr(CNtService *this, int a2, __int64 a3, int a4, unsigned int a5)
{
  int v8; // eax
  __int128 v9; // xmm0
  __int64 v10; // xmm1_8
  unsigned int v11; // ebx
  struct _SERVICE_STATUS ServiceStatus; // [rsp+20h] [rbp-38h] BYREF

  EnterCriticalSection((LPCRITICAL_SECTION)((char *)this + 72));
  if ( a2 == 2 || a2 == 1 )
    v8 = 0;
  else
    v8 = *((_DWORD *)this + 6);
  *((_DWORD *)this + 12) = v8;
  *((_DWORD *)this + 13) = 0;
  *((_DWORD *)this + 16) = a5;
  *((_DWORD *)this + 11) = a2;
  *((_DWORD *)this + 15) = a4;
  v9 = *(_OWORD *)((char *)this + 40);
  ServiceStatus.dwWaitHint = a5;
  v10 = *((_QWORD *)this + 7);
  *(_OWORD *)&ServiceStatus.dwServiceType = v9;
  *(_QWORD *)&ServiceStatus.dwServiceSpecificExitCode = v10;
  LeaveCriticalSection((LPCRITICAL_SECTION)((char *)this + 72));
  v11 = SetServiceStatus(*((SERVICE_STATUS_HANDLE *)this + 4), &ServiceStatus);
  if ( !v11 )
    (*(void (__fastcall **)(CNtService *, const wchar_t *))(*(_QWORD *)this + 56LL))(
      this,
      L"Could not SetServiceStatus");
  return v11;
}
// 18007F958: using guessed type wchar_t aCouldNotSetser[27];

//----- (000000018002ADC8) ----------------------------------------------------
JobsService *__fastcall JobsService::JobsService(JobsService *this)
{
  unsigned __int64 v3; // [rsp+28h] [rbp-20h]

  *(_QWORD *)this = &CNtService::`vftable';
  *((_DWORD *)this + 6) = 4805;
  *((_DWORD *)this + 2) = 0;
  *((_QWORD *)this + 2) = 0LL;
  *((_DWORD *)this + 11) = 2;
  InitializeCriticalSection((LPCRITICAL_SECTION)((char *)this + 72));
  *(_QWORD *)this = &JobsService::`vftable';
  *((_QWORD *)this + 14) = 0LL;
  *((_QWORD *)this + 15) = 0LL;
  *((_BYTE *)this + 128) = 0;
  *((_QWORD *)this + 17) = 0LL;
  *((_QWORD *)this + 18) = 0LL;
  TSTime::TSTime((JobsService *)((char *)this + 152));
  TSTime::TSTime((JobsService *)((char *)this + 168));
  *((_QWORD *)this + 32) = 0LL;
  InitializeSRWLock((PSRWLOCK)this + 33);
  *((_DWORD *)this + 46) = 3;
  *((_QWORD *)this + 24) = 0LL;
  *((_QWORD *)this + 25) = 0LL;
  *((_QWORD *)this + 26) = 0LL;
  *((_QWORD *)this + 27) = 0LL;
  *((_QWORD *)this + 28) = 0LL;
  *((_QWORD *)this + 29) = 0LL;
  *((_DWORD *)this + 60) = 0;
  *((_DWORD *)this + 61) = 1;
  *((_DWORD *)this + 62) = 72;
  *(_WORD *)((char *)this + 129) = 1;
  LOBYTE(v3) = 0;
  *(_OWORD *)((char *)this + 152) = v3;
  LOBYTE(v3) = 0;
  *(_OWORD *)((char *)this + 168) = v3;
  return this;
}
// 18002AEE2: variable 'v3' is possibly undefined
// 180070520: using guessed type void *JobsService::`vftable';
// 180070568: using guessed type void *CNtService::`vftable';

//----- (000000018002AF18) ----------------------------------------------------
void __fastcall PseudoEventTrap::DiscoverAutologons(PseudoEventTrap *this)
{
  struct _RTL_CRITICAL_SECTION *v1; // r14
  __int64 i; // rdi
  DWORD v3; // ebp
  int LastError; // eax
  DWORD v5; // [rsp+60h] [rbp+8h] BYREF
  int v6; // [rsp+64h] [rbp+Ch]
  PVOID pMemory; // [rsp+68h] [rbp+10h] BYREF
  PVOID *p_pMemory; // [rsp+70h] [rbp+18h]

  v6 = HIDWORD(this);
  v1 = (struct _RTL_CRITICAL_SECTION *)g_pPseudoEventTrap;
  v5 = 0;
  pMemory = 0LL;
  if ( WTSEnumerateSessionsW(0LL, 0, 1u, (PWTS_SESSION_INFOW *)&pMemory, &v5) )
  {
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
    {
      WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xBu, (__int64)&WPP_c0b0770bd08e382a040e2237764c2feb_Traceguids, v5);
    }
    p_pMemory = &pMemory;
    for ( i = 0LL; (unsigned int)i < v5; i = (unsigned int)(i + 1) )
    {
      v3 = *((_DWORD *)pMemory + 6 * i);
      if ( v3 )
      {
        if ( (*((_DWORD *)pMemory + 6 * i + 4) & 0xFFFFFFFB) == 0 )
        {
          PseudoEventTrap::QueueOrProcessSessionChange(v1, 5u, v3);
          if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
            && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0
            && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
          {
            WPP_SF_D(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              0xCu,
              (__int64)&WPP_c0b0770bd08e382a040e2237764c2feb_Traceguids,
              v3);
          }
        }
      }
    }
    if ( pMemory )
      WTSFreeMemory(pMemory);
  }
  else if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
         && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0
         && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
  {
    LastError = GetLastError();
    if ( LastError > 0 )
      LastError = (unsigned __int16)LastError | 0x80070000;
    WPP_SF_D(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0xDu,
      (__int64)&WPP_c0b0770bd08e382a040e2237764c2feb_Traceguids,
      LastError);
  }
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018002AFF0) ----------------------------------------------------
__int64 __fastcall _WorkerThread__QCNtService__JobsService__UEAAKXZ(
        __int64 a1,
        __int64 a2,
        void *a3,
        const struct _GUID *a4)
{
  JobStore *v5; // rdi
  EventManager *v6; // rcx
  PseudoEventTrap *v7; // rcx
  int Jobs; // eax
  PseudoEventTrap *v9; // rcx
  Scheduler *v10; // rdi
  JobStore *v11; // rbx
  int started; // eax
  int v13; // eax
  __int32 v15; // [rsp+80h] [rbp+10h] BYREF
  int v16; // [rsp+88h] [rbp+18h]

  v16 = 0;
  v5 = JobStore::m_pCommonStore;
  v15 = 0;
  _InterlockedExchange(&v15, 0);
  _InterlockedIncrement(&ShutdownMgr::s_sync);
  v6 = (EventManager *)(unsigned int)_InterlockedExchange(
                                       &v15,
                                       _InterlockedCompareExchange(&dword_1800B0A14, 0, 0) != 0);
  if ( _InterlockedCompareExchange(&v15, 0, 0) )
  {
    *(_BYTE *)(a1 + 128) = 1;
    EventManager::EvtReport(v6, &SCHEDULE_SERVICE_START, a3, a4);
    PseudoEventTrap::DiscoverAutologons(v7);
    Jobs = JobStore::LoadJobs(v5, *(unsigned __int8 *)(a1 + 129));
    v16 = Jobs;
    if ( Jobs < 0
      && WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x400) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0xDu,
        (__int64)&WPP_e3966bf9b81b3ab085a9dfdc4dace9ef_Traceguids,
        Jobs);
    }
    if ( dword_1800B0D60 )
      ReleaseSRWLockExclusive(&SRWLock);
    else
      ReleaseSRWLockShared(&SRWLock);
    PseudoEventTrap::ProcessSessionChanges(v9);
  }
  _InterlockedExchange(&v15, 0);
  if ( _InterlockedExchangeAdd(&ShutdownMgr::s_sync, 0xFFFFFFFF) == 1 )
    SetEvent((HANDLE)_InterlockedCompareExchange64((volatile signed __int64 *)&ShutdownMgr::s_hEvent, -1LL, -1LL));
  v10 = g_pScheduler;
  v11 = JobStore::m_pCommonStore;
  JobStore::WaitForConfiguration(JobStore::m_pCommonStore);
  started = Scheduler::StartFirstMissedRun(v10, *(_DWORD *)(*((_QWORD *)v11 + 10) + 88LL));
  v16 = started;
  if ( started < 0
    && WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x400) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
  {
    WPP_SF_D(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0xEu,
      (__int64)&WPP_e3966bf9b81b3ab085a9dfdc4dace9ef_Traceguids,
      started);
  }
  JobsService::SetServiceRestartOptions();
  v13 = Scheduler::TimerThreadFunction(g_pScheduler);
  v16 = v13;
  if ( v13 < 0
    && WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x400) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
  {
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xFu, (__int64)&WPP_e3966bf9b81b3ab085a9dfdc4dace9ef_Traceguids, v13);
  }
  return 0LL;
}
// 18002AFF0: could not find valid save-restore pair for rbp
// 18002B060: variable 'v7' is possibly undefined
// 18002B0A7: variable 'v9' is possibly undefined
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 1800B0A10: using guessed type int ShutdownMgr::s_sync;
// 1800B0A14: using guessed type int dword_1800B0A14;
// 1800B0D60: using guessed type int dword_1800B0D60;

//----- (000000018002B128) ----------------------------------------------------
__int64 __fastcall Scheduler::TimerThreadFunction(Scheduler *this)
{
  Scheduler *v1; // r14
  Scheduler *v2; // r12
  signed int LastError; // r15d
  HANDLE EventW; // rdi
  bool v5; // dl
  bool v6; // dl
  char v7; // al
  char v8; // di
  JobStore *v9; // rdi
  __int128 v10; // xmm6
  DWORD v11; // r12d
  DWORD v12; // edi
  unsigned int v13; // edi
  bool v14; // dl
  EventManager *v15; // rcx
  void **v16; // rcx
  EventManager *v17; // rcx
  void *v18; // r8
  const struct _GUID *v19; // r9
  EventManager *v20; // rcx
  unsigned int v21; // edi
  unsigned int v22; // eax
  int v23; // r8d
  char v24; // r12
  unsigned int v25; // ecx
  signed int v26; // ebx
  EventManager *v27; // rcx
  EventManager *v29; // rcx
  __int64 v30; // rdx
  __int64 v31; // rax
  __int64 v32; // rax
  int v33; // r8d
  void *v34; // [rsp+0h] [rbp-370h]
  const struct _GUID *v35; // [rsp+8h] [rbp-368h]
  struct _FILETIME v36[2]; // [rsp+20h] [rbp-350h] BYREF
  char v37[24]; // [rsp+38h] [rbp-338h] BYREF
  char v38[24]; // [rsp+50h] [rbp-320h] BYREF
  __int64 v39; // [rsp+70h] [rbp-300h]
  char v40[8]; // [rsp+80h] [rbp-2F0h] BYREF
  __int64 v41; // [rsp+88h] [rbp-2E8h]
  char v42[8]; // [rsp+A0h] [rbp-2D0h] BYREF
  __int64 v43; // [rsp+A8h] [rbp-2C8h]
  char v44[8]; // [rsp+B0h] [rbp-2C0h] BYREF
  __int64 v45; // [rsp+B8h] [rbp-2B8h]
  char v46[8]; // [rsp+C0h] [rbp-2B0h] BYREF
  __int64 v47; // [rsp+C8h] [rbp-2A8h]
  unsigned __int16 v48[28]; // [rsp+138h] [rbp-238h] BYREF
  char v49; // [rsp+1D8h] [rbp-198h]
  int v50; // [rsp+1DCh] [rbp-194h]
  DWORD TickCount; // [rsp+1E0h] [rbp-190h]
  struct _FILETIME v52[2]; // [rsp+1E8h] [rbp-188h]
  Scheduler *v53; // [rsp+1F8h] [rbp-178h]
  FILETIME FileTime1[2]; // [rsp+200h] [rbp-170h] BYREF
  __int128 v55; // [rsp+218h] [rbp-158h] BYREF
  struct _FILETIME SystemTimeAsFileTime; // [rsp+228h] [rbp-148h] BYREF
  Scheduler *v57; // [rsp+230h] [rbp-140h]
  __int128 v58; // [rsp+238h] [rbp-138h] BYREF
  __int128 v59[4]; // [rsp+258h] [rbp-118h] BYREF
  unsigned __int64 v60; // [rsp+298h] [rbp-D8h]
  __int64 v61; // [rsp+2A0h] [rbp-D0h]
  __int64 v62; // [rsp+2A8h] [rbp-C8h]
  __int128 v63; // [rsp+2B8h] [rbp-B8h] BYREF
  __int128 v64; // [rsp+2C8h] [rbp-A8h] BYREF
  __int128 v65; // [rsp+2D8h] [rbp-98h] BYREF
  HANDLE Handles[3]; // [rsp+2E8h] [rbp-88h] BYREF
  __int128 v67; // [rsp+300h] [rbp-70h]
  __int128 v68; // [rsp+310h] [rbp-60h]
  __int128 v69; // [rsp+320h] [rbp-50h]
  __int64 v70; // [rsp+330h] [rbp-40h]

  v62 = -2LL;
  v1 = g_pScheduler;
  v57 = g_pScheduler;
  v2 = g_pScheduler;
  v53 = g_pScheduler;
  LastError = 0;
  v50 = 0;
  EventW = CreateEventW(0LL, 0, 0, 0LL);
  wmi::AutoHandle::Close((Scheduler *)((char *)v1 + 24));
  *((_QWORD *)v1 + 3) = EventW;
  if ( EventW )
  {
    Handles[0] = *((HANDLE *)v1 + 1);
    Handles[1] = EventW;
    Handles[2] = *((HANDLE *)v1 + 2);
    TSTime::TSTime((TSTime *)&v55, v5);
    TickCount = GetTickCount();
    LOBYTE(v52[0].dwLowDateTime) = 0;
    v52[1] = 0LL;
    v7 = 0;
    v49 = 0;
    while ( 1 )
    {
      if ( v7 )
        return (unsigned int)LastError;
      TSTime::TSTime((TSTime *)FileTime1, v6);
      v8 = 0;
      *(_QWORD *)&v58 = (char *)v1 + 32;
      EnterCriticalSection((LPCRITICAL_SECTION)((char *)v1 + 32));
      FileTime1[1] = *(FILETIME *)((char *)v1 + 168);
      if ( !CompareFileTime((const FILETIME *)v1 + 21, &FileTime2)
        || (v40[0] = 0, v41 = *((_QWORD *)v1 + 21), (unsigned __int8)TSTime::operator<((char *)v2 + 304, v40)) )
      {
        v8 = 1;
      }
      LeaveCriticalSection((LPCRITICAL_SECTION)((char *)v1 + 32));
      if ( v8 )
      {
        v9 = JobStore::m_pCommonStore;
        JobStore::WaitForConfiguration(JobStore::m_pCommonStore);
        LODWORD(v9) = *(_DWORD *)(*((_QWORD *)v9 + 10) + 160LL);
        GetSystemTimeAsFileTime((LPFILETIME)v1 + 37);
        TSTime::operator+((char *)v1 + 288, v59, (unsigned int)v9);
        v10 = v59[0];
        if ( !*((_BYTE *)v1 + 472) )
        {
          v58 = v59[0];
          v63 = *((_OWORD *)v1 + 19);
          Scheduler::EvaluateScheduledJobs(v1, &v63, &v58);
        }
        *((_OWORD *)v1 + 19) = v10;
      }
      if ( !CompareFileTime(&FileTime1[1], &FileTime2) || (unsigned __int8)TSTime::operator<((char *)v2 + 304, v37) )
        *(_OWORD *)&FileTime1[0].dwLowDateTime = *((_OWORD *)v1 + 19);
      v65 = v55;
      v11 = TickCount;
      GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
      v12 = Scheduler::CalcWait(v1, &SystemTimeAsFileTime, &FileTime1[1]);
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x2000) != 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
      {
        WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 35LL, &WPP_5435fee58aaf3c352ed5cdc6abf88a31_Traceguids, v12);
      }
      v13 = WaitForMultipleObjectsEx(3u, Handles, 0, v12, 0);
      TSTime::TSTime((TSTime *)&v64, v14);
      v55 = v64;
      TickCount = GetTickCount();
      if ( v13 )
      {
        switch ( v13 )
        {
          case 2u:
            if ( *((_BYTE *)v1 + 473) )
              goto LABEL_17;
            v67 = 0LL;
            v68 = 0LL;
            v69 = 0LL;
            v70 = 0LL;
            if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x2000) != 0 )
              TSTime::ToString((TSTime *)v38, v48, 28);
            v21 = (TickCount - v11) / 0x3E8;
            v22 = TSTime::operator-(&v55, &v65);
            v24 = v22;
            if ( v21 < v22 )
              v25 = v22 - v21;
            else
              v25 = v21 - v22;
            if ( v25 >= 0x1A4 )
            {
              v39 = (__int64)v1 + 32;
              EnterCriticalSection((LPCRITICAL_SECTION)((char *)v1 + 32));
              v31 = *((_QWORD *)v1 + 10);
              if ( !*(_DWORD *)(v31 + 24) && !*(_DWORD *)(v31 + 28)
                || (v32 = *(_QWORD *)(v31 + 24),
                    v44[0] = 0,
                    v45 = v32,
                    (unsigned int)TSTime::operator-(v44, v38) >= 0x1A4) )
              {
                LeaveCriticalSection((LPCRITICAL_SECTION)((char *)v1 + 32));
                v16 = (void **)WPP_GLOBAL_Control;
                if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control )
                {
                  if ( (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x2000) != 0 && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
                  {
                    WPP_SF_ddS(*((_QWORD *)WPP_GLOBAL_Control + 2), 42, v33, v21, v24, (__int64)v48);
LABEL_17:
                    v16 = (void **)WPP_GLOBAL_Control;
                  }
                  if ( v16 != &WPP_GLOBAL_Control && (*((_DWORD *)v16 + 7) & 0x2000) != 0 && *((_BYTE *)v16 + 25) >= 4u )
                    WPP_SF_(v16[2], 43LL, &WPP_5435fee58aaf3c352ed5cdc6abf88a31_Traceguids);
                }
                EnterCriticalSection((LPCRITICAL_SECTION)((char *)v1 + 32));
                SortedRunList::FreeList((Scheduler *)((char *)v1 + 72));
                GetSystemTimeAsFileTime((LPFILETIME)v1 + 39);
                *((_QWORD *)v1 + 21) = -1LL;
                *((_OWORD *)v1 + 18) = *((_OWORD *)v1 + 19);
                LeaveCriticalSection((LPCRITICAL_SECTION)((char *)v1 + 32));
                *((_BYTE *)v1 + 473) = 0;
                Scheduler::EvaluateMissedRuns(v1);
                EventManager::EvtReport(v17, &SCHEDULE_SERVICE_TIME_CHANGE_SIGNALED, v18, v19);
                break;
              }
              goto LABEL_63;
            }
            v20 = (EventManager *)WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
              && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x2000) != 0
              && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
            {
              WPP_SF_ddS(*((_QWORD *)WPP_GLOBAL_Control + 2), 41, v23, v21, v22, (__int64)v48);
            }
            break;
          case 1u:
            v20 = (EventManager *)WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
              && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x2000) != 0
              && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
            {
              v30 = 40LL;
              goto LABEL_93;
            }
            break;
          case 0x102u:
            EnterCriticalSection((LPCRITICAL_SECTION)((char *)v1 + 32));
            if ( !CompareFileTime((const FILETIME *)v1 + 21, &FileTime2) )
            {
              if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
                && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x2000) != 0
                && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
              {
                WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 36LL, &WPP_5435fee58aaf3c352ed5cdc6abf88a31_Traceguids);
              }
LABEL_63:
              LeaveCriticalSection((LPCRITICAL_SECTION)((char *)v1 + 32));
              break;
            }
            LeaveCriticalSection((LPCRITICAL_SECTION)((char *)v1 + 32));
            if ( *((_BYTE *)v1 + 472) )
            {
              v20 = (EventManager *)WPP_GLOBAL_Control;
              if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
                && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x2000) != 0
                && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
              {
                v30 = 37LL;
LABEL_93:
                WPP_SF_(*((_QWORD *)v20 + 2), v30, &WPP_5435fee58aaf3c352ed5cdc6abf88a31_Traceguids);
              }
            }
            else
            {
              if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
                && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x2000) != 0
                && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
              {
                WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 38LL, &WPP_5435fee58aaf3c352ed5cdc6abf88a31_Traceguids);
              }
              Scheduler::StartJobs(v1);
            }
            break;
          case 0xFFFFFFFF:
            LastError = GetLastError();
            EventManager::EvtReport(
              v29,
              &SCHEDULE_SERVICE_ERROR,
              L"TimerThreadFunction:WAIT_FAILED",
              LastError,
              v34,
              v35);
            if ( LastError > 0 )
              LastError = (unsigned __int16)LastError | 0x80070000;
            if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
              && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x2000) != 0
              && *((unsigned __int8 *)WPP_GLOBAL_Control + 25) >= ((LastError >> 31) & 0xFFFFFFFE) + 4 )
            {
              WPP_SF_D(
                *((_QWORD *)WPP_GLOBAL_Control + 2),
                44LL,
                &WPP_5435fee58aaf3c352ed5cdc6abf88a31_Traceguids,
                (unsigned int)LastError);
            }
            v42[0] = 0;
            v43 = 0LL;
            if ( (unsigned __int8)TSTime::operator==(v36, v42) )
              GetSystemTimeAsFileTime(&v36[1]);
            break;
          default:
            EventManager::EvtReport(
              v15,
              &SCHEDULE_SERVICE_ERROR,
              L"TimerThreadFunction:WaitForMultipleObjects",
              v13,
              v34,
              v35);
            v20 = (EventManager *)WPP_GLOBAL_Control;
            if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
              && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x2000) != 0
              && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
            {
              WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 45LL, &WPP_5435fee58aaf3c352ed5cdc6abf88a31_Traceguids, v13);
            }
            break;
        }
      }
      else
      {
        v20 = (EventManager *)WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
          && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x2000) != 0
          && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
        {
          v30 = 39LL;
          goto LABEL_93;
        }
      }
      if ( LastError < 0 )
      {
        EventManager::EvtReport(
          v20,
          &SCHEDULE_SERVICE_ERROR,
          L"Scheduler::TimerThreadFunction exception",
          LastError,
          v34,
          v35);
        v46[0] = 0;
        v47 = 0LL;
        if ( (unsigned __int8)TSTime::operator==(v36, v46) )
          GetSystemTimeAsFileTime(&v36[1]);
        Sleep(0x1F4u);
        EnterCriticalSection((LPCRITICAL_SECTION)((char *)v1 + 32));
        SortedRunList::FreeList((Scheduler *)((char *)v1 + 72));
        *((_OWORD *)v1 + 19) = *(_OWORD *)&v36[0].dwLowDateTime;
        *((_QWORD *)v1 + 21) = -1LL;
        LastError = 0;
        LeaveCriticalSection((LPCRITICAL_SECTION)((char *)v1 + 32));
      }
      else
      {
        LOBYTE(v60) = 0;
        v61 = 0LL;
        *(_OWORD *)&v52[0].dwLowDateTime = v60;
      }
      v7 = v49;
      v2 = v53;
    }
  }
  v26 = GetLastError();
  EventManager::EvtReport(v27, &SCHEDULE_SERVICE_ERROR, L"TimerThreadFunction:CreateEvent", v26, v34, v35);
  if ( v26 > 0 )
    return (unsigned __int16)v26 | 0x80070000;
  return (unsigned int)v26;
}
// 18002B128: could not find valid save-restore pair for rbp
// 18002B1DD: variable 'v5' is possibly undefined
// 18002B216: variable 'v6' is possibly undefined
// 18002B3C3: variable 'v14' is possibly undefined
// 18002B490: variable 'v17' is possibly undefined
// 18002B490: variable 'v18' is possibly undefined
// 18002B490: variable 'v19' is possibly undefined
// 18004025B: variable 'v27' is possibly undefined
// 18004025B: variable 'v34' is possibly undefined
// 18004025B: variable 'v35' is possibly undefined
// 18004031F: variable 'v15' is possibly undefined
// 18004038D: variable 'v29' is possibly undefined
// 18004057B: variable 'v23' is possibly undefined
// 180040635: variable 'v33' is possibly undefined
// 18004070D: variable 'v20' is possibly undefined
// 180009014: using guessed type __int64 __fastcall TSTime::operator==(_QWORD, _QWORD);
// 180012E30: using guessed type __int64 __fastcall TSTime::operator<(_QWORD, _QWORD);
// 18001C7E0: using guessed type __int64 __fastcall TSTime::operator+(_QWORD, _QWORD, _QWORD);
// 180023A74: using guessed type __int64 __fastcall TSTime::operator-(_QWORD, _QWORD);
// 180025170: using guessed type __int64 __fastcall Scheduler::EvaluateScheduledJobs(_QWORD, _QWORD, _QWORD);
// 18004B234: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 18004B260: using guessed type __int64 __fastcall WPP_SF_D(_QWORD, _QWORD, _QWORD, _QWORD);
// 180054B0C: using guessed type __int64 __fastcall WPP_SF_ddS(_DWORD, _DWORD, _DWORD, _DWORD, char, __int64);
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 18002B128: using guessed type __int128 var_118[4];
// 18002B128: using guessed type char var_2F0[8];
// 18002B128: using guessed type char var_338[24];
// 18002B128: using guessed type char var_2D0[8];
// 18002B128: using guessed type char var_2C0[8];
// 18002B128: using guessed type char var_2B0[8];

//----- (000000018002B580) ----------------------------------------------------
__int64 JobsService::SetServiceRestartOptions(void)
{
  SC_HANDLE v0; // rax
  SC_HANDLE v1; // rsi
  SC_HANDLE v2; // rax
  SC_HANDLE v3; // rdi
  unsigned int v4; // ebx
  int v6; // eax
  signed int v7; // eax
  int v8; // eax
  signed int v9; // eax
  int LastError; // eax
  signed int v11; // eax
  int Info; // [rsp+20h] [rbp-50h] BYREF
  __int128 v13; // [rsp+28h] [rbp-48h]
  int v14; // [rsp+38h] [rbp-38h]
  int *v15; // [rsp+40h] [rbp-30h]
  int v16[6]; // [rsp+48h] [rbp-28h] BYREF

  v16[1] = 0;
  v16[4] = 0;
  v16[5] = 0;
  Info = 86400;
  v14 = 3;
  v15 = v16;
  v13 = 0LL;
  v16[0] = 4;
  v16[2] = 1;
  v16[3] = 60000;
  v0 = OpenSCManagerW(0LL, 0LL, 4u);
  v1 = v0;
  if ( v0 )
  {
    v2 = OpenServiceW(v0, L"Schedule", 0x12u);
    v3 = v2;
    if ( v2 )
    {
      if ( ChangeServiceConfig2W(v2, 2u, &Info) )
      {
        v4 = 0;
      }
      else
      {
        if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
          && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0
          && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
        {
          LastError = GetLastError();
          WPP_SF_D(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x21u,
            (__int64)&WPP_e3966bf9b81b3ab085a9dfdc4dace9ef_Traceguids,
            LastError);
        }
        v11 = GetLastError();
        v4 = v11;
        if ( v11 > 0 )
          v4 = (unsigned __int16)v11 | 0x80070000;
      }
      CloseServiceHandle(v3);
    }
    else
    {
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        v8 = GetLastError();
        WPP_SF_D(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x20u,
          (__int64)&WPP_e3966bf9b81b3ab085a9dfdc4dace9ef_Traceguids,
          v8);
      }
      v9 = GetLastError();
      v4 = v9;
      if ( v9 > 0 )
        v4 = (unsigned __int16)v9 | 0x80070000;
    }
    CloseServiceHandle(v1);
  }
  else
  {
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      v6 = GetLastError();
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x1Fu,
        (__int64)&WPP_e3966bf9b81b3ab085a9dfdc4dace9ef_Traceguids,
        v6);
    }
    v7 = GetLastError();
    v4 = v7;
    if ( v7 > 0 )
      return (unsigned __int16)v7 | 0x80070000;
  }
  return v4;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018002B694) ----------------------------------------------------
void __fastcall PseudoEventTrap::ProcessSessionChanges(PseudoEventTrap *this)
{
  PseudoEventTrap *v1; // rdi
  struct _RTL_CRITICAL_SECTION *v2; // rsi
  __int64 v3; // rax
  _QWORD **v4; // rdx
  __int64 v5; // rbx

  v1 = g_pPseudoEventTrap;
  v2 = (struct _RTL_CRITICAL_SECTION *)((char *)g_pPseudoEventTrap + 160);
  while ( 1 )
  {
    EnterCriticalSection(v2);
    if ( !*((_QWORD *)v1 + 28) )
      break;
    v3 = *((_QWORD *)v1 + 27);
    v4 = *(_QWORD ***)v3;
    v5 = *(_QWORD *)(*(_QWORD *)v3 + 16LL);
    if ( *(_QWORD *)v3 != v3 )
    {
      *v4[1] = *v4;
      (*v4)[1] = v4[1];
      operator delete(v4);
      --*((_QWORD *)v1 + 28);
    }
    LeaveCriticalSection(v2);
    PseudoEventTrap::ProcessSessionChange(v1, v5, HIDWORD(v5));
  }
  *((_BYTE *)v1 + 232) = 1;
  LeaveCriticalSection(v2);
}

//----- (000000018002B700) ----------------------------------------------------
__int64 __fastcall JobStore::ReloadMigratedTasks(JobStore *this)
{
  int v2; // ebx
  const wchar_t *Path; // rax
  int v5; // eax
  const wchar_t *v6[2]; // [rsp+28h] [rbp-40h] BYREF
  char v7[16]; // [rsp+38h] [rbp-30h] BYREF
  wmi::RefBase *v8; // [rsp+48h] [rbp-20h] BYREF

  v2 = 0;
  JobMoniker::JobMoniker((JobMoniker *)v6, 0LL, 0LL);
  while ( *((_QWORD *)this + 9) )
  {
    JobMoniker::operator=((__int64)v6, **((_QWORD **)this + 8) + 32LL);
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
    {
      Path = JobMoniker::GetPath((JobMoniker *)v6);
      WPP_SF_S(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x5Du,
        (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
        Path);
    }
    v5 = JobStore::InstantiateTaskEntry((HKEY *)this, v6, 0, 0LL);
    if ( v5 < 0 && v2 >= 0 )
      v2 = v5;
    std::_Tree<std::_Tset_traits<JobMoniker,std::less<JobMoniker>,std::allocator<JobMoniker>,0>>::erase(
      (_QWORD *)this + 8,
      (__int64)v6);
  }
  wmi::AutoRef<JobBucket>::Release(&v8);
  _bstr_t::_Free((_bstr_t *)v7);
  return (unsigned int)v2;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 18002B700: using guessed type char var_30[16];

//----- (000000018002B784) ----------------------------------------------------
__int64 __fastcall JobStore::IsMTRCompleted(JobStore *this)
{
  unsigned int v1; // ebx
  HKEY v3; // rcx
  LSTATUS ValueW; // eax
  int pvData; // [rsp+58h] [rbp+10h] BYREF
  DWORD pcbData; // [rsp+60h] [rbp+18h] BYREF

  v1 = 0;
  if ( dword_1800B0B6C )
    return (unsigned int)dword_1800B0B68;
  v3 = (HKEY)*((_QWORD *)this + 2);
  pvData = 0;
  pcbData = 4;
  ValueW = RegGetValueW(v3, 0LL, L"MTRCompleted", 0x10u, 0LL, &pvData, &pcbData);
  if ( ValueW == 2 )
  {
LABEL_7:
    dword_1800B0B68 = v1;
    dword_1800B0B6C = 1;
    return v1;
  }
  if ( !ValueW )
  {
    LOBYTE(v1) = pvData != 0;
    goto LABEL_7;
  }
  return (unsigned int)dword_1800B0B68;
}
// 1800B0B68: using guessed type int dword_1800B0B68;
// 1800B0B6C: using guessed type int dword_1800B0B6C;

//----- (000000018002B810) ----------------------------------------------------
char __fastcall tlgKeywordOn(__int64 a1, __int64 a2)
{
  char v2; // r8

  v2 = 0;
  if ( !a2 || (a2 & *(_QWORD *)(a1 + 16)) != 0 && (a2 & *(_QWORD *)(a1 + 24)) == *(_QWORD *)(a1 + 24) )
    return 1;
  return v2;
}

//----- (000000018002B834) ----------------------------------------------------
__int64 __fastcall JobStore::IsPermissionsRestoreCompleted(JobStore *this)
{
  unsigned int v1; // ebx
  HKEY v2; // rcx
  LSTATUS ValueW; // eax
  int v5; // [rsp+58h] [rbp+10h] BYREF
  DWORD v6; // [rsp+60h] [rbp+18h] BYREF

  v1 = 0;
  if ( dword_1800B0B64 )
    return (unsigned int)dword_1800B01F4;
  v2 = (HKEY)*((_QWORD *)this + 2);
  v5 = 0;
  v6 = 4;
  ValueW = RegGetValueW(v2, 0LL, L"OwnUpdateCompleted", 0x10u, 0LL, &v5, &v6);
  if ( ValueW != 2 )
  {
    if ( !ValueW )
    {
      LOBYTE(v1) = v5 != 0;
      goto LABEL_5;
    }
    return (unsigned int)dword_1800B01F4;
  }
LABEL_5:
  dword_1800B01F4 = v1;
  dword_1800B0B64 = 1;
  return v1;
}
// 1800B01F4: using guessed type int dword_1800B01F4;
// 1800B0B64: using guessed type int dword_1800B0B64;

//----- (000000018002B8BC) ----------------------------------------------------
__int64 __fastcall JobStore::LoadJobs(JobStore *this, int a2)
{
  unsigned int v4; // ebx
  bool v5; // si
  int Index; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  JobStore *v10; // rcx
  int v12; // eax
  int v13; // edx
  bool v14[4]; // [rsp+30h] [rbp-40h] BYREF
  unsigned int v15; // [rsp+34h] [rbp-3Ch] BYREF
  struct _EVENT_DATA_DESCRIPTOR v16; // [rsp+38h] [rbp-38h] BYREF
  int *v17; // [rsp+58h] [rbp-18h]
  __int64 v18; // [rsp+60h] [rbp-10h]

  v4 = 0;
  v14[0] = 0;
  if ( (unsigned int)dword_1800AFF68 > 4 && (qword_1800AFF78 & 2) != 0 && (qword_1800AFF80 & 2) == qword_1800AFF80 )
  {
    v15 = a2;
    v17 = (int *)&v15;
    v18 = 4LL;
    tlgWriteTransfer_EventWriteTransfer(
      (__int64)&dword_1800AFF68,
      (unsigned __int8 *)dword_18007F07A,
      0LL,
      0LL,
      3u,
      &v16);
  }
  if ( !(unsigned int)JobStore::IsMigrationCleanupCompleted(this)
    || !(unsigned int)JobStore::IsPermissionsRestoreCompleted(this) )
  {
    v12 = JobStore::MigrateSecurityInfoP(this, (unsigned __int16 *)&ChannelPath);
    v13 = 0;
    if ( v12 < 0 )
      v13 = v12;
    v4 = v13;
    if ( v13 >= 0 )
      v4 = 0;
    if ( (unsigned int)dword_1800AFF68 > 4 && (qword_1800AFF78 & 2) != 0 && (qword_1800AFF80 & 2) == qword_1800AFF80 )
    {
      v15 = v13;
      v17 = (int *)&v15;
      v18 = 4LL;
      tlgWriteTransfer_EventWriteTransfer(
        (__int64)&dword_1800AFF68,
        (unsigned __int8 *)dword_18007EEFE,
        0LL,
        0LL,
        3u,
        &v16);
    }
  }
  v5 = a2 != 0;
  Index = JobStore::LoadIndex((HKEY *)this, 1, v5, v14);
  if ( Index < 0 && !v4 )
    v4 = Index;
  v7 = JobStore::LoadIndex((HKEY *)this, 2, v5, v14);
  if ( v7 < 0 && !v4 )
    v4 = v7;
  v8 = JobStore::LoadIndex((HKEY *)this, 3, v5, v14);
  if ( v8 < 0 && !v4 )
    v4 = v8;
  v9 = JobStore::ReloadMigratedTasks(this);
  if ( v9 < 0 && !v4 )
    v4 = v9;
  if ( v14[0] )
    JobStore::DestroyMigratedUbpmStatsFiles(v10);
  if ( !(unsigned int)JobStore::IsPermissionsRestoreCompleted(this) )
    JobStore::MarkPermissionsRestoreCompletion(this);
  if ( !(unsigned int)JobStore::IsMigrationCleanupCompleted(this) )
    JobStore::MarkMigrationCleanupCompletion(this);
  if ( !(unsigned int)JobStore::IsHashingCompleted(this) )
    JobStore::MarkHashingCompletion(this);
  if ( !(unsigned int)JobStore::IsMTRCompleted(this) )
    JobStore::MarkMTRCompletion(this);
  if ( (unsigned int)dword_1800AFF68 > 4 && (qword_1800AFF78 & 2) != 0 && (qword_1800AFF80 & 2) == qword_1800AFF80 )
  {
    v15 = v4;
    v17 = (int *)&v15;
    v18 = 4LL;
    tlgWriteTransfer_EventWriteTransfer(
      (__int64)&dword_1800AFF68,
      (unsigned __int8 *)dword_18007EE52,
      0LL,
      0LL,
      3u,
      &v16);
  }
  return v4;
}
// 180040B4D: variable 'v10' is possibly undefined
// 18007EE52: using guessed type int dword_18007EE52[8];
// 18007EEFE: using guessed type int dword_18007EEFE[9];
// 18007F07A: using guessed type int dword_18007F07A[9];
// 1800AFF78: using guessed type __int64 qword_1800AFF78;
// 1800AFF80: using guessed type __int64 qword_1800AFF80;

//----- (000000018002BA18) ----------------------------------------------------
__int64 __fastcall JobStore::LoadIndex(HKEY *a1, int a2, bool a3, bool *a4)
{
  int v7; // esi
  int v8; // edi
  IndexEnumerator *v9; // rbx
  int Next; // eax
  JobMoniker *v11; // rax
  int Moniker; // edi
  __int64 v13; // r8
  __int64 v14; // r8
  void *v15; // r9
  bool v16; // sf
  const wchar_t *v18; // rax
  const unsigned __int16 *Path; // rax
  EventManager *v20; // rcx
  const wchar_t *v21; // rax
  const struct _EVENT_DESCRIPTOR *v22; // rdx
  int v23; // [rsp+30h] [rbp-220h]
  int v24; // [rsp+40h] [rbp-210h]
  char v25[40]; // [rsp+60h] [rbp-1F0h] BYREF
  char v26[120]; // [rsp+88h] [rbp-1C8h] BYREF
  bool v27; // [rsp+148h] [rbp-108h]
  int v28; // [rsp+14Ch] [rbp-104h]
  bool v29; // [rsp+150h] [rbp-100h]
  int v30; // [rsp+158h] [rbp-F8h]
  int v31; // [rsp+160h] [rbp-F0h]
  int v32; // [rsp+168h] [rbp-E8h]
  IndexEnumerator *v33; // [rsp+170h] [rbp-E0h] BYREF
  int v34; // [rsp+178h] [rbp-D8h]
  HKEY *v35; // [rsp+180h] [rbp-D0h]
  bool *v36; // [rsp+188h] [rbp-C8h]
  __int64 v37; // [rsp+190h] [rbp-C0h]
  const wchar_t *v38[2]; // [rsp+198h] [rbp-B8h] BYREF
  char v39[16]; // [rsp+1A8h] [rbp-A8h] BYREF
  wmi::RefBase *v40; // [rsp+1B8h] [rbp-98h] BYREF
  char v41[16]; // [rsp+1C0h] [rbp-90h] BYREF
  char v42[16]; // [rsp+1D0h] [rbp-80h] BYREF
  wmi::RefBase *v43; // [rsp+1E0h] [rbp-70h] BYREF
  char v44[16]; // [rsp+1E8h] [rbp-68h] BYREF
  char v45[16]; // [rsp+1F8h] [rbp-58h] BYREF
  wmi::RefBase *v46; // [rsp+208h] [rbp-48h] BYREF

  v37 = -2LL;
  v27 = a3;
  v35 = a1;
  v31 = a2;
  v34 = a2;
  v29 = a3;
  v36 = a4;
  v7 = 0;
  v30 = 0;
  v32 = 0;
  JobMoniker::JobMoniker((JobMoniker *)v41, 0LL, 0LL);
  JobMoniker::JobMoniker((JobMoniker *)v38, L"_Unavailable_Task_Path_", 0LL);
  v33 = 0LL;
  v8 = JobStore::EnumStoredTasks((__int64)a1, a2, &v33);
  v28 = v8;
  if ( v8 >= 0 )
  {
    v9 = v33;
    while ( 1 )
    {
      while ( 1 )
      {
        Next = IndexEnumerator::FindNext(v9);
        v8 = Next;
        v28 = Next;
        if ( Next < 0 || Next == 1 )
          goto LABEL_9;
        v11 = JobMoniker::JobMoniker((JobMoniker *)v44, L"_Loading_Task_Path_", 0LL);
        JobMoniker::operator=((__int64)v38, (__int64)v11);
        wmi::AutoRef<JobBucket>::Release(&v46);
        _bstr_t::_Free((_bstr_t *)v45);
        Moniker = IndexEnumerator::GetMoniker(v9, (struct JobMoniker *)v38);
        v28 = Moniker;
        if ( Moniker >= 0 )
          break;
        if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
          && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
          && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
        {
          WPP_SF_dD(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x5Fu, v13, a2);
        }
LABEL_7:
        if ( Moniker < 0 )
        {
          Path = JobMoniker::GetPath((JobMoniker *)v25);
          EventManager::EvtReport(v20, &TASK_LOAD_FAILED, Path, Moniker);
          v23 = 1;
          if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
            && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
            && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
          {
            v21 = JobMoniker::GetPath((JobMoniker *)v25);
            WPP_SF_SD(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              0x60u,
              (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
              v21);
          }
          if ( !v7 )
          {
            v7 = Moniker;
            JobMoniker::operator=((__int64)v26, (__int64)v25);
          }
        }
      }
      Moniker = JobStore::InstantiateTaskEntry(a1, v38, v27, a4);
      v28 = Moniker;
      if ( Moniker >= 0 )
        goto LABEL_7;
      if ( Moniker != -2147216626 )
      {
        if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
          && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
          && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
        {
          v18 = JobMoniker::GetPath((JobMoniker *)v25);
          WPP_SF_SD(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x5Eu,
            (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
            v18);
        }
        goto LABEL_7;
      }
      *a4 = 1;
    }
  }
LABEL_9:
  wmi::AutoRef<FolderEnumerator>::~AutoRef<FolderEnumerator>(&v33);
  if ( v8 >= 0 )
    goto LABEL_10;
  v16 = v7 < 0;
  if ( !v7 )
  {
    v7 = v8;
    JobMoniker::operator=((__int64)v26, (__int64)v25);
LABEL_10:
    v16 = v7 < 0;
  }
  if ( v16 )
  {
    if ( !v23 )
    {
      v22 = (const struct _EVENT_DESCRIPTOR *)&SCHEDULE_SERVICE_RUN_BOOT_JOBS_FAILED;
      if ( v24 != 1 )
        v22 = &SCHEDULE_SERVICE_LOAD_JOBS_FAILED;
      EventManager::EvtReport(g_pEventManager, v22, (unsigned int)v7, v15);
    }
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_dD(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x61u, v14, a2);
    }
  }
  wmi::AutoRef<JobBucket>::Release(&v40);
  _bstr_t::_Free((_bstr_t *)v39);
  wmi::AutoRef<JobBucket>::Release(&v43);
  _bstr_t::_Free((_bstr_t *)v42);
  return (unsigned int)v7;
}
// 18002BA18: could not find valid save-restore pair for rbp
// 180040CE5: variable 'v20' is possibly undefined
// 180040C90: variable 'v13' is possibly undefined
// 180040DA9: variable 'v23' is possibly undefined
// 180040DBE: variable 'v24' is possibly undefined
// 180040DCC: variable 'v15' is possibly undefined
// 180040E08: variable 'v14' is possibly undefined
// 1800090EC: using guessed type __int64 __fastcall wmi::AutoRef<FolderEnumerator>::~AutoRef<FolderEnumerator>(_QWORD);
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 18002BA18: using guessed type char var_90[16];
// 18002BA18: using guessed type char var_68[16];
// 18002BA18: using guessed type char var_58[16];
// 18002BA18: using guessed type char var_A8[16];
// 18002BA18: using guessed type char var_80[16];

//----- (000000018002BC04) ----------------------------------------------------
__int64 __fastcall IndexEnumerator::FindNext(IndexEnumerator *this)
{
  unsigned int v1; // edx
  unsigned int v2; // eax

  v1 = 1;
  v2 = *((_DWORD *)this + 5) + 1;
  if ( v2 < *((_DWORD *)this + 4) )
  {
    *((_DWORD *)this + 5) = v2;
    return 0;
  }
  return v1;
}

//----- (000000018002BC24) ----------------------------------------------------
__int64 __fastcall JobStore::InstantiateTaskEntry(HKEY *this, const wchar_t **a2, unsigned __int8 a3, bool *a4)
{
  unsigned __int8 v4; // si
  HKEY v7; // rbx
  unsigned __int16 *v8; // rdi
  const unsigned __int16 *Path; // rax
  signed int Bucket; // r14d
  int v11; // esi
  unsigned __int8 IsErrorNotFound; // bl
  char v13; // si
  const wchar_t *v14; // rcx
  int v15; // eax
  JobStore *v16; // rcx
  int v17; // eax
  char v18; // r12
  struct _FILETIME *v19; // r12
  const unsigned __int16 *v21; // rax
  __int64 v22; // rcx
  __int64 v23; // rax
  unsigned int v24; // edx
  unsigned __int64 v25; // r8
  const wchar_t *v26; // rax
  const unsigned __int16 *v27; // rax
  char *v28; // rbx
  wchar_t *v29; // rax
  int XmlFolder; // eax
  const unsigned __int16 *v31; // rax
  void *v32; // rcx
  void *v33; // rsi
  int v34; // eax
  const unsigned __int16 *v35; // rax
  const struct JobSecurity *v36; // r8
  const unsigned __int16 *v37; // rax
  int v38; // edx
  OLECHAR *v39; // rax
  volatile signed __int32 *v40; // rax
  WCHAR *v41; // rcx
  unsigned __int16 *Copy; // rax
  OLECHAR *v43; // rbx
  JobStore *v44; // rcx
  WCHAR *v45; // rsi
  const unsigned __int16 *v46; // rax
  EventManager *v47; // rcx
  const wchar_t *v48; // rax
  bool v50[7]; // [rsp+89h] [rbp-7Fh] BYREF
  __int64 v51; // [rsp+90h] [rbp-78h] BYREF
  unsigned __int16 v52; // [rsp+98h] [rbp-70h] BYREF
  unsigned __int16 *v53; // [rsp+A0h] [rbp-68h] BYREF
  volatile signed __int32 *v54; // [rsp+A8h] [rbp-60h] BYREF
  HKEY hKey; // [rsp+B0h] [rbp-58h] BYREF
  int v56; // [rsp+B8h] [rbp-50h] BYREF
  int v57; // [rsp+BCh] [rbp-4Ch] BYREF
  void *lpMem; // [rsp+C0h] [rbp-48h] BYREF
  LPCWSTR StringSecurityDescriptor; // [rsp+C8h] [rbp-40h] BYREF
  struct Actions::ActionCollection *v60; // [rsp+D0h] [rbp-38h]
  HKEY v61; // [rsp+D8h] [rbp-30h] BYREF
  BSTR bstrString; // [rsp+E0h] [rbp-28h] BYREF
  wchar_t *Str[2]; // [rsp+E8h] [rbp-20h] BYREF
  User::UserEntry *v64; // [rsp+F8h] [rbp-10h] BYREF
  PSECURITY_DESCRIPTOR v65[2]; // [rsp+100h] [rbp-8h] BYREF
  __int64 *v66[3]; // [rsp+110h] [rbp+8h] BYREF
  unsigned __int64 v67; // [rsp+128h] [rbp+20h] BYREF
  struct _FILETIME v68[7]; // [rsp+130h] [rbp+28h] BYREF
  char v69[24]; // [rsp+168h] [rbp+60h] BYREF
  __int64 v70; // [rsp+180h] [rbp+78h]
  __int128 v71; // [rsp+188h] [rbp+80h] BYREF
  __int128 v72; // [rsp+198h] [rbp+90h] BYREF
  struct _FILETIME v73[6]; // [rsp+1A8h] [rbp+A0h] BYREF
  wmi::RefBase *v74; // [rsp+1D8h] [rbp+D0h] BYREF
  __int128 v75; // [rsp+1E0h] [rbp+D8h] BYREF
  char v76[16]; // [rsp+1F0h] [rbp+E8h] BYREF
  wmi::RefBase *v77; // [rsp+200h] [rbp+F8h] BYREF
  char v78[1056]; // [rsp+208h] [rbp+100h] BYREF
  CBstrWriter *v79; // [rsp+628h] [rbp+520h]

  v70 = -2LL;
  v4 = a3;
  JobSecurity::JobSecurity((JobSecurity *)v65);
  hKey = 0LL;
  v7 = 0LL;
  v61 = 0LL;
  v8 = 0LL;
  v53 = 0LL;
  Triggers::Trigulator::Trigulator(v68);
  Actions::ActionCollection::ActionCollection((Actions::ActionCollection *)v66);
  Triggers::Trigulator::Trigulator(v73);
  Actions::ActionCollection::ActionCollection((Actions::ActionCollection *)v69);
  JobMoniker::JobMoniker((JobMoniker *)&v75, 0LL, 0LL);
  v50[0] = 0;
  v60 = (struct Actions::ActionCollection *)v66;
  Path = JobMoniker::GetPath((JobMoniker *)a2);
  JobStore::RegGetOverrideInfo(this, Path, (enum JobFlags::StatePersistanceFlags *)&v56);
  Bucket = JobStore::RegOpenTaskKeyP(this, 1u, (struct JobMoniker *)a2, &hKey, 0x2001Fu);
  if ( Bucket < 0 )
    goto LABEL_26;
  v11 = v56;
  if ( v56 )
  {
    v21 = JobMoniker::GetPath((JobMoniker *)a2);
    Bucket = JobStore::RegOpenTaskOverrideKey((JobStore *)this, v21, 0xF003Fu, 2, &v61);
    if ( Bucket < 0 )
      goto LABEL_92;
    v7 = v61;
  }
  Bucket = Triggers::Trigulator::StreamInWithOverrides(hKey, v7, 15, v11, (__int64)v68, &v67);
  if ( Bucket < 0 )
    goto LABEL_92;
  Bucket = Triggers::Trigulator::GetBucket((Triggers::Trigulator *)v68, (struct JobMoniker *)a2);
  if ( Bucket < 0 )
    goto LABEL_92;
  *((_DWORD *)a2[4] + 5) = v11;
  Bucket = Actions::ActionCollection::StreamIn((Actions::ActionCollection *)v66, hKey, &v52);
  IsErrorNotFound = tsched::IsErrorNotFound((tsched *)(unsigned int)Bucket);
  if ( IsErrorNotFound )
    Bucket = 0;
  if ( Bucket < 0 )
    goto LABEL_92;
  if ( !(unsigned int)JobStore::IsHashingCompleted((JobStore *)this)
    || (v13 = IsErrorNotFound, !(unsigned int)JobStore::IsMigrationCleanupCompleted((JobStore *)this)) )
  {
    v13 = 1;
  }
  if ( v67 < 0x16 || v52 < 2u )
  {
    IsErrorNotFound = 1;
    v13 = 1;
  }
  if ( a3 )
  {
    v14 = a2[4];
    v15 = *((_DWORD *)v14 + 4);
    if ( (v15 & 0x20000000) != 0 && (v15 & 0x400000) != 0 )
    {
      *((_DWORD *)v14 + 4) = v15 & 0xFFBFFFFF;
      IsErrorNotFound = 1;
      v13 = 1;
    }
  }
  if ( (unsigned int)Actions::ActionCollection::HasAction(v66, 34952)
    || (unsigned int)Actions::ActionCollection::HasAction(v66, 39321) )
  {
    Bucket = -2147216592;
    goto LABEL_92;
  }
  Bucket = JobStore::SetSchedulingEngineFlag(
             v16,
             (struct JobMoniker *)a2,
             (struct Triggers::Trigulator *)v68,
             (struct Actions::ActionCollection *)v66,
             v50,
             &v57);
  if ( Bucket < 0 )
  {
LABEL_92:
    v4 = a3;
    goto LABEL_26;
  }
  v17 = IsErrorNotFound;
  if ( v50[0] )
    v17 = 1;
  LODWORD(v51) = v17;
  v18 = IsErrorNotFound;
  if ( v13 == 1 )
  {
    Bucket = JobStore::XmlLoadRawTaskFile((char **)this, (JobMoniker *)a2, (void **)&v53);
    v8 = v53;
    if ( Bucket == -2147216607 )
    {
      if ( (unsigned int)JobStore::IsHashingCompleted((JobStore *)this) || !v8 )
        goto LABEL_47;
      v23 = -1LL;
      do
        ++v23;
      while ( v8[v23] );
      v22 = 0xFFFFFFFFLL;
      v24 = -1;
      if ( 2 * v23 )
      {
        v25 = 0LL;
        do
        {
          v22 = (v24 >> 8) ^ dword_18007D000[(unsigned __int8)v24 ^ (unsigned __int64)*((unsigned __int8 *)v8 + v25)];
          v24 = (v24 >> 8) ^ dword_18007D000[(unsigned __int8)v24 ^ (unsigned __int64)*((unsigned __int8 *)v8 + v25++)];
        }
        while ( v25 < 2 * v23 );
      }
      v26 = a2[4];
      if ( (_DWORD)v22 != *((_DWORD *)v26 + 6) )
      {
LABEL_47:
        if ( (int)JobStore::GenerateTaskXmlFromCollections(
                    v22,
                    (__int64)a2,
                    (Triggers::Trigulator *)v68,
                    (Actions::ActionCollection *)v66,
                    (char **)&v53) < 0 )
        {
          v8 = v53;
        }
        else
        {
          v27 = JobMoniker::GetPath((JobMoniker *)a2);
          ATL::CComBSTR::CComBSTR((ATL::CComBSTR *)Str, v27);
          v28 = (char *)Str[0];
          v29 = wcsrchr(Str[0], 0x5Cu);
          v18 = 0;
          if ( v29 && v29 != (wchar_t *)v28 )
          {
            *v29 = 0;
            XmlFolder = JobStore::CreateXmlFolder((JobStore *)this, v28, 0LL);
            if ( XmlFolder == -2147024713 )
              XmlFolder = 0;
            if ( XmlFolder < 0 )
            {
              SysFreeString((BSTR)v28);
              v8 = v53;
              goto LABEL_92;
            }
          }
          v8 = v53;
          if ( (int)JobStore::ComputeHash((struct JobMoniker *)a2, (unsigned __int8 *)v53) < 0
            || (v31 = JobMoniker::GetPath((JobMoniker *)a2), (int)JobStore::RegJobSecurityQuery(this, v31, v65) < 0) )
          {
LABEL_60:
            SysFreeString((BSTR)v28);
            goto LABEL_92;
          }
          lpMem = 0LL;
          if ( (int)JobSecurity::GetSddl(v65, 7u, (unsigned __int16 **)&lpMem) < 0 )
          {
            v32 = lpMem;
LABEL_59:
            operator delete(v32);
            goto LABEL_60;
          }
          v33 = lpMem;
          v34 = JobStore::XmlSaveTaskFile((JobStore *)this, (const struct JobMoniker *)a2, v8, (LPCWSTR)lpMem);
          if ( v34 < 0 )
          {
            v32 = v33;
            goto LABEL_59;
          }
          LOBYTE(v34) = 1;
          LODWORD(v51) = v34;
          Bucket = 0;
          operator delete(v33);
          SysFreeString((BSTR)v28);
        }
LABEL_64:
        if ( Bucket < 0 )
          goto LABEL_92;
        LOBYTE(v17) = v51;
        goto LABEL_20;
      }
      v22 = 1LL;
      LOBYTE(v26) = 1;
      LODWORD(v51) = (_DWORD)v26;
      v18 = 1;
      Bucket = 0;
    }
    if ( Bucket >= 0 && (unsigned int)JobStore::IsMigrationCleanupCompleted((JobStore *)this) )
      goto LABEL_64;
    goto LABEL_47;
  }
LABEL_20:
  if ( (_BYTE)v17 != 1 && v18 != 1 )
    goto LABEL_22;
  v35 = JobMoniker::GetPath((JobMoniker *)a2);
  Bucket = JobStore::RegJobSecurityQuery(this, v35, v65);
  if ( Bucket < 0 )
    goto LABEL_92;
  if ( v18 == 1 )
  {
    v51 = 0LL;
    if ( (int)StringReader::CreateStream((__int64)v8, &v51) < 0 )
    {
LABEL_75:
      _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::~_com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>(&v51);
LABEL_22:
      v19 = v68;
      goto LABEL_23;
    }
    v37 = JobMoniker::GetPath((JobMoniker *)a2);
    JobMoniker::_SetPath((_bstr_t::Data_t **)&v75, v37);
    v75 = *(_OWORD *)a2;
    v38 = *((_DWORD *)a2[4] + 4);
    v64 = 0LL;
    ServerXMLUpdateHandler::ServerXMLUpdateHandler(
      (ServerXMLUpdateHandler *)v78,
      (v38 & 0x20000000) != 0,
      0,
      0LL,
      0LL,
      0LL,
      0,
      (const struct JobMoniker *)&v75,
      &v64,
      (struct Triggers::Trigulator *)v73,
      (struct Actions::ActionCollection *)v69,
      1,
      0LL,
      0LL,
      0);
    wmi::AutoRef<User::UserEntry>::Release(&v64);
    v39 = (OLECHAR *)operator new(0x460uLL);
    bstrString = v39;
    if ( v39 )
      v40 = (volatile signed __int32 *)TaskXmlReader::TaskXmlReader((__int64)v39, &v51, 0LL, 0);
    else
      v40 = 0LL;
    v54 = v40;
    if ( v40 )
    {
      _InterlockedAdd(v40 + 2, 1u);
      v8 = v53;
    }
    if ( (int)TaskXmlReader::ProcessXml((TaskXmlReader *)v40, (struct ITaskXmlHandler *)v78) < 0 )
    {
LABEL_74:
      wmi::AutoRef<FolderEnumerator>::~AutoRef<FolderEnumerator>(&v54);
      ServerXMLUpdateHandler::~ServerXMLUpdateHandler((ServerXMLUpdateHandler *)v78);
      goto LABEL_75;
    }
    bstrString = 0LL;
    Copy = CBstrWriter::GetCopy(v79);
    ATL::CComBSTR::Attach(&bstrString, Copy);
    wmi::AutoRef<JobBucket>::operator=(&v74, (volatile signed __int32 *)v77);
    v43 = bstrString;
    if ( (int)JobStore::ComputeHash((struct JobMoniker *)&v75, (unsigned __int8 *)bstrString) < 0 )
    {
LABEL_73:
      SysFreeString(v43);
      goto LABEL_74;
    }
    Bucket = JobStore::SetSchedulingEngineFlag(
               v44,
               (struct JobMoniker *)&v75,
               (struct Triggers::Trigulator *)v73,
               (struct Actions::ActionCollection *)v69,
               v50,
               &v57);
    if ( Bucket < 0 )
    {
      SysFreeString(v43);
      wmi::AutoRef<FolderEnumerator>::~AutoRef<FolderEnumerator>(&v54);
      ServerXMLUpdateHandler::~ServerXMLUpdateHandler((ServerXMLUpdateHandler *)v78);
      _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::~_com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>(&v51);
      goto LABEL_92;
    }
    StringSecurityDescriptor = 0LL;
    if ( (int)JobSecurity::GetSddl(v65, 7u, (unsigned __int16 **)&StringSecurityDescriptor) < 0 )
    {
      v41 = (WCHAR *)StringSecurityDescriptor;
LABEL_72:
      operator delete(v41);
      goto LABEL_73;
    }
    v45 = (WCHAR *)StringSecurityDescriptor;
    if ( (int)JobStore::XmlSaveTaskFile(
                (JobStore *)this,
                (const struct JobMoniker *)&v75,
                v43,
                StringSecurityDescriptor) < 0 )
    {
      v41 = v45;
      goto LABEL_72;
    }
    v19 = v73;
    v60 = (struct Actions::ActionCollection *)v69;
    a2 = (const wchar_t **)&v75;
    operator delete(v45);
    SysFreeString(v43);
    wmi::AutoRef<FolderEnumerator>::~AutoRef<FolderEnumerator>(&v54);
    ServerXMLUpdateHandler::~ServerXMLUpdateHandler((ServerXMLUpdateHandler *)v78);
    _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::~_com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>(&v51);
  }
  else
  {
    v19 = v68;
  }
  Bucket = JobStore::UpdateTaskEntry(
             this,
             (const struct JobMoniker *)a2,
             v36,
             (const struct Triggers::Trigulator *)v19,
             v60,
             0LL);
  if ( Bucket < 0 )
    goto LABEL_92;
LABEL_23:
  v4 = a3;
  if ( (*((_DWORD *)a2[4] + 4) & 0x2000000) != 0 )
  {
    std::_Tree<std::_Tset_traits<JobMoniker,std::less<JobMoniker>,std::allocator<JobMoniker>,0>>::erase(
      this + 8,
      (__int64)a2);
    Bucket = (*(__int64 (__fastcall **)(void ***, _QWORD, const wchar_t **, _QWORD, struct _FILETIME *, struct Actions::ActionCollection *, unsigned int, int, _QWORD, _QWORD))UbpmProxySingleton::s_singleton[0])(
               UbpmProxySingleton::s_singleton,
               a3,
               a2,
               a3,
               v19,
               v60,
               2 * (unsigned int)a3,
               -1,
               0LL,
               0LL);
    if ( Bucket < 0 )
    {
      v46 = JobMoniker::GetPath((JobMoniker *)a2);
      EventManager::EvtReport(v47, &TASK_INSTANTIATE_FAILED, v46, L"Ubpm-RegisterConsumer", Bucket);
    }
  }
  else
  {
    LOBYTE(Str[0]) = 0;
    Str[1] = (wchar_t *)-1LL;
    v71 = *(_OWORD *)Str;
    LOBYTE(Str[0]) = 0;
    Str[1] = 0LL;
    v72 = (unsigned __int64)Str[0];
    Bucket = Triggers::Trigulator::RegisterAll(
               (Triggers::Trigulator *)v19,
               (struct JobMoniker *)a2,
               &v72,
               &v71,
               2 * (unsigned int)a3);
  }
LABEL_26:
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
    && *((unsigned __int8 *)WPP_GLOBAL_Control + 25) >= (int)(((Bucket >> 31) & 0xFFFFFFFE) + 4) )
  {
    v48 = L"boot";
    if ( !v4 )
      v48 = L"non-boot";
    WPP_SF_SSD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x5Au,
      (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
      a2[3],
      (__int64)v48);
  }
  wmi::AutoRef<JobBucket>::Release(&v77);
  _bstr_t::_Free((_bstr_t *)v76);
  Actions::ActionCollection::~ActionCollection((Actions::ActionCollection *)v69);
  Triggers::Trigulator::~Trigulator((Triggers::Trigulator *)v73);
  Actions::ActionCollection::~ActionCollection((Actions::ActionCollection *)v66);
  Triggers::Trigulator::~Trigulator((Triggers::Trigulator *)v68);
  operator delete(v8);
  wmi::AutoRegKey::Close(&v61);
  wmi::AutoRegKey::Close(&hKey);
  tsched::AutoLocalPtr<unsigned short>::~AutoLocalPtr<unsigned short>(v65);
  return (unsigned int)Bucket;
}
// 18002BE3E: variable 'v16' is possibly undefined
// 1800413C3: variable 'v47' is possibly undefined
// 180040F39: variable 'v22' is possibly undefined
// 180041252: variable 'v44' is possibly undefined
// 180041344: variable 'v36' is possibly undefined
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);
// 1800090EC: using guessed type __int64 __fastcall wmi::AutoRef<FolderEnumerator>::~AutoRef<FolderEnumerator>(_QWORD);
// 18007D000: using guessed type _DWORD dword_18007D000[256];
// 180080468: using guessed type wchar_t aBoot[5];
// 180080478: using guessed type wchar_t aNonBoot[9];
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 1800AFFB0: using guessed type void **UbpmProxySingleton::s_singleton[2];
// 18002BC24: using guessed type PSECURITY_DESCRIPTOR var_588[2];
// 18002BC24: using guessed type char var_498[16];

//----- (000000018002BFBC) ----------------------------------------------------
__int64 __fastcall std::_Tree<std::_Tset_traits<JobMoniker,std::less<JobMoniker>,std::allocator<JobMoniker>,0>>::erase(
        _QWORD *a1,
        __int64 a2)
{
  _QWORD *v2; // rsi
  _QWORD *v5; // rdi
  __int64 *v6; // rbx
  __int64 i; // rbx
  __int64 v8; // rbx
  _QWORD *v9; // rax
  __int64 v11; // rcx
  __int64 j; // rcx
  __int64 v13; // [rsp+50h] [rbp+8h] BYREF

  v2 = (_QWORD *)*a1;
  v5 = (_QWORD *)*a1;
  v6 = *(__int64 **)(*a1 + 8LL);
  while ( !*((_BYTE *)v6 + 25) )
  {
    if ( (int)_bstr_t::_Compare((BSTR **)v6 + 6, (BSTR **)(a2 + 16)) >= 0 )
    {
      if ( *((_BYTE *)v5 + 25) && (int)_bstr_t::_Compare((BSTR **)(a2 + 16), (BSTR **)v6 + 6) < 0 )
        v5 = v6;
      v2 = v6;
      v6 = (__int64 *)*v6;
    }
    else
    {
      v6 = (__int64 *)v6[2];
    }
  }
  if ( *((_BYTE *)v5 + 25) )
    i = *a1 + 8LL;
  else
    i = (__int64)v5;
LABEL_5:
  for ( i = *(_QWORD *)i; !*(_BYTE *)(i + 25); i = *(_QWORD *)(i + 16) )
  {
    if ( (int)_bstr_t::_Compare((BSTR **)(a2 + 16), (BSTR **)(i + 48)) < 0 )
    {
      v5 = (_QWORD *)i;
      goto LABEL_5;
    }
  }
  v8 = 0LL;
  v9 = v2;
  while ( v9 != v5 )
  {
    ++v8;
    if ( !*((_BYTE *)v9 + 25) )
    {
      v11 = v9[2];
      if ( *(_BYTE *)(v11 + 25) )
      {
        for ( j = v9[1]; !*(_BYTE *)(j + 25) && v9 == *(_QWORD **)(j + 16); j = *(_QWORD *)(j + 8) )
          v9 = (_QWORD *)j;
        v9 = (_QWORD *)j;
      }
      else
      {
        v9 = std::_Tree_val<std::_Tree_simple_types<std::pair<_bstr_t const,std::list<_FILETIME> *>>>::_Min((_QWORD *)v11);
      }
    }
  }
  std::_Tree<std::_Tset_traits<JobMoniker,std::less<JobMoniker>,std::allocator<JobMoniker>,0>>::erase(a1, &v13, v2, v5);
  return v8;
}

//----- (000000018002C050) ----------------------------------------------------
_QWORD *__fastcall std::_Tree<std::_Tset_traits<JobMoniker,std::less<JobMoniker>,std::allocator<JobMoniker>,0>>::erase(
        _QWORD *a1,
        _QWORD *a2,
        _QWORD *a3,
        _QWORD *a4)
{
  __int64 v6; // rdx
  _QWORD *v7; // rbx
  _QWORD *v9; // rax
  _QWORD *v11; // r8
  __int64 v12; // rcx
  _QWORD *i; // rax
  __int64 v14; // [rsp+30h] [rbp+8h] BYREF

  v6 = *a1;
  v7 = a3;
  if ( a3 == *(_QWORD **)*a1 && a4 == (_QWORD *)v6 )
  {
    std::_Tree<std::_Tset_traits<JobMoniker,std::less<JobMoniker>,std::allocator<JobMoniker>,0>>::_Erase(
      (__int64)a1,
      *(wmi::RefBase ***)(v6 + 8));
    *(_QWORD *)(*a1 + 8LL) = *a1;
    *(_QWORD *)*a1 = *a1;
    *(_QWORD *)(*a1 + 16LL) = *a1;
    v9 = (_QWORD *)*a1;
    a1[1] = 0LL;
    *a2 = *v9;
  }
  else
  {
    while ( v7 != a4 )
    {
      v11 = v7;
      if ( !*((_BYTE *)v7 + 25) )
      {
        v12 = v7[2];
        if ( *(_BYTE *)(v12 + 25) )
        {
          for ( i = (_QWORD *)v7[1]; !*((_BYTE *)i + 25) && v7 == (_QWORD *)i[2]; i = (_QWORD *)i[1] )
            v7 = i;
        }
        else
        {
          i = std::_Tree_val<std::_Tree_simple_types<std::pair<_bstr_t const,std::list<_FILETIME> *>>>::_Min((_QWORD *)v12);
        }
        v7 = i;
      }
      std::_Tree<std::_Tset_traits<JobMoniker,std::less<JobMoniker>,std::allocator<JobMoniker>,0>>::erase(a1, &v14, v11);
    }
    *a2 = v7;
  }
  return a2;
}
// 18004151B: variable 'v11' is possibly undefined

//----- (000000018002C0D4) ----------------------------------------------------
void __fastcall std::_Tree<std::_Tset_traits<JobMoniker,std::less<JobMoniker>,std::allocator<JobMoniker>,0>>::_Erase(
        __int64 a1,
        wmi::RefBase **a2)
{
  wmi::RefBase **v2; // rbx
  wmi::RefBase *v4; // rdi

  v2 = a2;
  v4 = (wmi::RefBase *)a2;
  if ( !*((_BYTE *)a2 + 25) )
  {
    do
    {
      std::_Tree<std::_Tset_traits<JobMoniker,std::less<JobMoniker>,std::allocator<JobMoniker>,0>>::_Erase(
        a1,
        *((_QWORD *)v4 + 2));
      v4 = *(wmi::RefBase **)v4;
      wmi::AutoRef<JobBucket>::Release(v2 + 8);
      _bstr_t::_Free((_bstr_t *)(v2 + 6));
      operator delete(v2);
      v2 = (wmi::RefBase **)v4;
    }
    while ( !*((_BYTE *)v4 + 25) );
  }
}

//----- (000000018002C110) ----------------------------------------------------
__int64 __fastcall Actions::ActionCollection::HasAction(__int64 **a1, __int16 a2)
{
  __int64 *v2; // rbx

  v2 = *a1;
  while ( 1 )
  {
    v2 = (__int64 *)*v2;
    if ( v2 == *a1 )
      break;
    if ( a2 == (*(unsigned __int16 (__fastcall **)(__int64))(*(_QWORD *)v2[2] + 24LL))(v2[2]) )
      return 1LL;
  }
  return 0LL;
}

//----- (000000018002C168) ----------------------------------------------------
__int64 __fastcall JobStore::IsMigrationCleanupCompleted(JobStore *this)
{
  unsigned int v1; // ebx
  HKEY v3; // rcx
  LSTATUS ValueW; // eax
  int pvData; // [rsp+58h] [rbp+10h] BYREF
  DWORD pcbData; // [rsp+60h] [rbp+18h] BYREF

  v1 = 0;
  if ( dword_1800B0B5C )
    return (unsigned int)dword_1800B01F8;
  v3 = (HKEY)*((_QWORD *)this + 2);
  pvData = 0;
  pcbData = 4;
  ValueW = RegGetValueW(v3, 0LL, L"MigrationCleanupCompleted", 0x10u, 0LL, &pvData, &pcbData);
  if ( ValueW == 2 )
  {
LABEL_7:
    dword_1800B01F8 = v1;
    dword_1800B0B5C = 1;
    return v1;
  }
  if ( !ValueW )
  {
    LOBYTE(v1) = pvData != 0;
    goto LABEL_7;
  }
  return (unsigned int)dword_1800B01F8;
}
// 1800B01F8: using guessed type int dword_1800B01F8;
// 1800B0B5C: using guessed type int dword_1800B0B5C;

//----- (000000018002C1F4) ----------------------------------------------------
__int64 __fastcall JobStore::IsHashingCompleted(JobStore *this)
{
  unsigned int v1; // ebx
  HKEY v3; // rcx
  LSTATUS ValueW; // eax
  int pvData; // [rsp+58h] [rbp+10h] BYREF
  DWORD pcbData; // [rsp+60h] [rbp+18h] BYREF

  v1 = 0;
  if ( dword_1800B0B60 )
    return (unsigned int)dword_1800B0B58;
  v3 = (HKEY)*((_QWORD *)this + 2);
  pvData = 0;
  pcbData = 4;
  ValueW = RegGetValueW(v3, 0LL, L"HashingCompleted", 0x10u, 0LL, &pvData, &pcbData);
  if ( ValueW == 2 )
  {
LABEL_7:
    dword_1800B0B58 = v1;
    dword_1800B0B60 = 1;
    return v1;
  }
  if ( !ValueW )
  {
    LOBYTE(v1) = pvData != 0;
    goto LABEL_7;
  }
  return (unsigned int)dword_1800B0B58;
}
// 1800B0B58: using guessed type int dword_1800B0B58;
// 1800B0B60: using guessed type int dword_1800B0B60;

//----- (000000018002C280) ----------------------------------------------------
__int64 __fastcall IndexEnumerator::GetMoniker(IndexEnumerator *this, struct JobMoniker *a2)
{
  JobMoniker::operator=((__int64)a2, *((_QWORD *)this + 3) + 40LL * *((unsigned int *)this + 5));
  return 0LL;
}

//----- (000000018002C2AC) ----------------------------------------------------
__int64 __fastcall JobStore::EnumStoredTasks(__int64 a1, int a2, _QWORD *a3)
{
  __int64 v6; // rcx
  OLECHAR *v7; // rbx
  LSTATUS v8; // eax
  __int64 v9; // r8
  int v10; // edi
  LSTATUS v11; // eax
  volatile signed __int32 *v12; // rax
  volatile signed __int32 *v13; // rsi
  void **v14; // r10
  unsigned __int16 v16; // dx
  const wchar_t *v17; // r9
  __int64 v18[2]; // [rsp+30h] [rbp-10h] BYREF
  LPCWSTR lpSubKey; // [rsp+70h] [rbp+30h] BYREF
  HKEY v20; // [rsp+80h] [rbp+40h] BYREF
  HKEY phkResult; // [rsp+88h] [rbp+48h] BYREF

  v18[1] = -2LL;
  lpSubKey = 0LL;
  wmi::AutoRef<FolderEnumerator>::~AutoRef<FolderEnumerator>(a3);
  *a3 = 0LL;
  JobStore::GetIndexKeyPath(v6, a2, (BSTR *)&lpSubKey);
  phkResult = 0LL;
  v20 = 0LL;
  v7 = (OLECHAR *)lpSubKey;
  v8 = RegOpenKeyExW(*(HKEY *)(a1 + 16), lpSubKey, 0, 0x20019u, &phkResult);
  v10 = v8;
  if ( v8 )
  {
    if ( v8 > 0 )
      v10 = (unsigned __int16)v8 | 0x80070000;
    v14 = (void **)WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control )
    {
      if ( (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0 && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        v16 = 98;
        v17 = v7;
LABEL_20:
        WPP_SF_SD((__int64)v14[2], v16, (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids, v17);
LABEL_10:
        v14 = (void **)WPP_GLOBAL_Control;
      }
LABEL_11:
      if ( v14 != &WPP_GLOBAL_Control
        && (*((_DWORD *)v14 + 7) & 0x40000) != 0
        && *((unsigned __int8 *)v14 + 25) >= (int)(((v10 >> 31) & 0xFFFFFFFE) + 4) )
      {
        WPP_SF_dD((__int64)v14[2], 0x64u, v9, a2);
      }
    }
  }
  else
  {
    v11 = RegOpenKeyExW(*(HKEY *)(a1 + 16), L"TaskCache\\Tasks", 0, 0x20019u, &v20);
    v10 = v11;
    if ( !v11 )
    {
      v12 = (volatile signed __int32 *)operator new(0x20uLL);
      v13 = v12;
      v18[0] = (__int64)v12;
      if ( v12 )
      {
        *(_QWORD *)v12 = &wmi::RefBase::`vftable';
        *((_DWORD *)v12 + 2) = 0;
        *(_QWORD *)v12 = &IndexEnumerator::`vftable';
        *((_DWORD *)v12 + 4) = 0;
        *((_DWORD *)v12 + 5) = -1;
        *((_QWORD *)v12 + 3) = 0LL;
      }
      else
      {
        v13 = 0LL;
      }
      v18[0] = (__int64)v13;
      if ( v13 )
      {
        _InterlockedIncrement(v13 + 2);
        v7 = (OLECHAR *)lpSubKey;
      }
      v10 = IndexEnumerator::Initialize((IndexEnumerator *)v13, phkResult, v20);
      if ( v10 >= 0 )
        wmi::AutoRef<TaskXmlReader>::operator=(a3, (__int64)v13);
      wmi::AutoRef<FolderEnumerator>::~AutoRef<FolderEnumerator>(v18);
      goto LABEL_10;
    }
    if ( v11 > 0 )
      v10 = (unsigned __int16)v11 | 0x80070000;
    v14 = (void **)WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control )
    {
      if ( (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0 && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        v16 = 99;
        v17 = L"TaskCache\\Tasks";
        goto LABEL_20;
      }
      goto LABEL_11;
    }
  }
  wmi::AutoRegKey::Close(&v20);
  wmi::AutoRegKey::Close(&phkResult);
  SysFreeString(v7);
  return (unsigned int)v10;
}
// 18002C2E9: variable 'v6' is possibly undefined
// 180041639: variable 'v9' is possibly undefined
// 1800090EC: using guessed type __int64 __fastcall wmi::AutoRef<FolderEnumerator>::~AutoRef<FolderEnumerator>(_QWORD);
// 1800705B0: using guessed type void *IndexEnumerator::`vftable';
// 180070980: using guessed type void *wmi::RefBase::`vftable';
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018002C440) ----------------------------------------------------
IndexEnumerator *__fastcall IndexEnumerator::`vector deleting destructor'(IndexEnumerator *this, char a2)
{
  JobMoniker *v4; // rcx

  *(_QWORD *)this = &IndexEnumerator::`vftable';
  v4 = (JobMoniker *)*((_QWORD *)this + 3);
  if ( v4 )
    JobMoniker::`vector deleting destructor'(v4);
  *(_QWORD *)this = &wmi::RefBase::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 1800705B0: using guessed type void *IndexEnumerator::`vftable';
// 180070980: using guessed type void *wmi::RefBase::`vftable';

//----- (000000018002C494) ----------------------------------------------------
char *__fastcall JobMoniker::`vector deleting destructor'(JobMoniker *this)
{
  char *v1; // rbx

  v1 = (char *)this - 8;
  `eh vector destructor iterator'(
    this,
    0x28uLL,
    *((_QWORD *)this - 1),
    (void (__stdcall *)(void *))JobMoniker::~JobMoniker);
  operator delete(v1);
  return v1;
}

//----- (000000018002C4D8) ----------------------------------------------------
__int64 __fastcall IndexEnumerator::Initialize(IndexEnumerator *this, HKEY a2, HKEY a3)
{
  int v5; // esi
  JobMoniker *v6; // rbx
  DWORD v7; // r14d
  unsigned int v8; // r15d
  int v9; // edi
  LSTATUS v10; // eax
  __int64 v11; // rdi
  __int64 v12; // rax
  bool v13; // cf
  SIZE_T v14; // rax
  char *v15; // rax
  JobMoniker *v16; // rbx
  HKEY v17; // rdi
  int Moniker; // eax
  JobMoniker *v19; // rdx
  _QWORD *v21; // rcx
  unsigned __int16 v22; // dx
  _QWORD *v23; // rcx
  unsigned __int16 v24; // dx
  DWORD cSubKeys; // [rsp+60h] [rbp-20h] BYREF
  JobMoniker *v26[3]; // [rsp+68h] [rbp-18h] BYREF
  DWORD cbMaxSubKeyLen; // [rsp+C0h] [rbp+40h] BYREF
  HKEY v28; // [rsp+D0h] [rbp+50h]
  DWORD lpcSubKeys; // [rsp+D8h] [rbp+58h] BYREF

  v28 = a3;
  v26[1] = (JobMoniker *)-2LL;
  v5 = 0;
  v6 = 0LL;
  v26[0] = 0LL;
  cbMaxSubKeyLen = 0;
  cSubKeys = 0;
  lpcSubKeys = 0;
  v7 = 0;
  v8 = 0;
  *((_DWORD *)this + 4) = 0;
  *((_DWORD *)this + 5) = -1;
  v9 = RegQueryInfoKeyW(a3, 0LL, 0LL, 0LL, &cSubKeys, &cbMaxSubKeyLen, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL);
  if ( v9 )
  {
    if ( v9 > 0 )
      v9 = (unsigned __int16)v9 | 0x80070000;
    v21 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
      || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) == 0
      || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
    {
      goto LABEL_20;
    }
    v22 = 10;
LABEL_40:
    WPP_SF_D(v21[2], v22, (__int64)&WPP_3a28f766f52e3b91612b0fe468777cfd_Traceguids, v9);
    goto LABEL_20;
  }
  if ( cbMaxSubKeyLen > 0x26 )
  {
    v23 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
      || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) == 0
      || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
    {
      goto LABEL_46;
    }
    v24 = 11;
    goto LABEL_45;
  }
  v10 = RegQueryInfoKeyW(a2, 0LL, 0LL, 0LL, &lpcSubKeys, &cbMaxSubKeyLen, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL);
  v9 = v10;
  if ( v10 )
  {
    if ( v10 > 0 )
      v9 = (unsigned __int16)v10 | 0x80070000;
    v21 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
      || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) == 0
      || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
    {
      goto LABEL_20;
    }
    v22 = 12;
    goto LABEL_40;
  }
  if ( cbMaxSubKeyLen > 0x26 )
  {
    v23 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
      || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) == 0
      || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
    {
      goto LABEL_46;
    }
    v24 = 13;
LABEL_45:
    WPP_SF_D(v23[2], v24, (__int64)&WPP_3a28f766f52e3b91612b0fe468777cfd_Traceguids, -2147024773);
LABEL_46:
    v9 = -2147024773;
    goto LABEL_20;
  }
  if ( lpcSubKeys )
  {
    v11 = lpcSubKeys;
    v12 = 40LL * lpcSubKeys;
    if ( !is_mul_ok(lpcSubKeys, 0x28uLL) )
      v12 = -1LL;
    v13 = __CFADD__(v12, 8LL);
    v14 = v12 + 8;
    if ( v13 )
      v14 = -1LL;
    v15 = (char *)operator new(v14);
    v26[2] = (JobMoniker *)v15;
    if ( v15 )
    {
      *(_QWORD *)v15 = v11;
      v16 = (JobMoniker *)(v15 + 8);
      `eh vector constructor iterator'(
        v15 + 8,
        0x28uLL,
        (unsigned int)v11,
        (void (__stdcall *)(void *))JobMoniker::`default constructor closure',
        (void (__stdcall *)(void *))JobMoniker::~JobMoniker);
    }
    else
    {
      v16 = 0LL;
    }
    wmi::AutoVectorPtr<JobMoniker>::operator=(v26, v16);
    v6 = v26[0];
    if ( lpcSubKeys )
    {
      v17 = v28;
      do
      {
        Moniker = IndexEnumerator::LoadMoniker(a2, v17, v7, (JobMoniker *)((char *)v6 + 40 * v8));
        v5 = Moniker;
        if ( (unsigned int)(Moniker + 2147216627) <= 1 )
        {
          v5 = 0;
        }
        else
        {
          if ( Moniker < 0 )
            goto LABEL_19;
          ++v8;
        }
        ++v7;
      }
      while ( v7 < lpcSubKeys );
    }
  }
  v19 = v6;
  v6 = 0LL;
  wmi::AutoVectorPtr<JobMoniker>::operator=((JobMoniker **)this + 3, v19);
  *((_DWORD *)this + 4) = v8;
LABEL_19:
  v9 = v5;
LABEL_20:
  if ( v6 )
    JobMoniker::`vector deleting destructor'(v6);
  return (unsigned int)v9;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018002C6D8) ----------------------------------------------------
__int64 __fastcall IndexEnumerator::LoadMoniker(HKEY hKey, HKEY a2, DWORD dwIndex, struct JobMoniker *a4)
{
  LSTATUS v8; // eax
  unsigned int v9; // ebx
  LSTATUS v10; // eax
  signed int LastError; // eax
  DWORD Type; // [rsp+40h] [rbp-C0h] BYREF
  DWORD cchName; // [rsp+44h] [rbp-BCh] BYREF
  DWORD cbData; // [rsp+48h] [rbp-B8h] BYREF
  HKEY hKeya[2]; // [rsp+50h] [rbp-B0h] BYREF
  char v17[16]; // [rsp+60h] [rbp-A0h] BYREF
  char v18[16]; // [rsp+70h] [rbp-90h] BYREF
  wmi::RefBase *v19; // [rsp+80h] [rbp-80h] BYREF
  WCHAR Name[40]; // [rsp+90h] [rbp-70h] BYREF
  unsigned __int16 Data[264]; // [rsp+E0h] [rbp-20h] BYREF

  hKeya[1] = HKEY_DYN_DATA|0x7FFFFFF8LL;
  hKeya[0] = 0LL;
  memset_0(Data, 0, 0x20AuLL);
  cbData = 522;
  Type = -1;
  cchName = 40;
  memset_0(Name, 0, sizeof(Name));
  if ( RegEnumKeyExW(hKey, dwIndex, Name, &cchName, 0LL, 0LL, 0LL, 0LL) )
  {
    LastError = GetLastError();
    v9 = LastError;
    if ( LastError > 0 )
      v9 = (unsigned __int16)LastError | 0x80070000;
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_SD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0xEu,
        (__int64)&WPP_3a28f766f52e3b91612b0fe468777cfd_Traceguids,
        Name);
    }
  }
  else
  {
    v8 = RegOpenKeyExW(a2, Name, 0, 0x20019u, hKeya);
    v9 = v8;
    if ( v8 )
    {
      if ( v8 > 0 )
        v9 = (unsigned __int16)v8 | 0x80070000;
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        WPP_SF_SD(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0xFu,
          (__int64)&WPP_3a28f766f52e3b91612b0fe468777cfd_Traceguids,
          Name);
      }
    }
    else
    {
      v10 = RegQueryValueExW(hKeya[0], L"Path", 0LL, &Type, (LPBYTE)Data, &cbData);
      v9 = v10;
      if ( !v10 )
      {
        if ( Type == 1 )
        {
          JobMoniker::JobMoniker((JobMoniker *)v17, Data, Name);
          JobMoniker::operator=((__int64)a4, (__int64)v17);
          wmi::AutoRef<JobBucket>::Release(&v19);
          _bstr_t::_Free((_bstr_t *)v18);
        }
        else
        {
          v9 = -2147216627;
          if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
            && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
            && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
          {
            WPP_SF_SSD(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              0x11u,
              (__int64)&WPP_3a28f766f52e3b91612b0fe468777cfd_Traceguids,
              L"Path",
              (__int64)Name);
          }
        }
        goto LABEL_6;
      }
      if ( v10 > 0 )
        v9 = (unsigned __int16)v10 | 0x80070000;
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        WPP_SF_SSD(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x10u,
          (__int64)&WPP_3a28f766f52e3b91612b0fe468777cfd_Traceguids,
          L"Path",
          (__int64)Name);
      }
    }
    if ( tsched::IsErrorNotFound((tsched *)v9) )
      v9 = -2147216626;
  }
LABEL_6:
  wmi::AutoRegKey::Close(hKeya);
  return v9;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 18002C6D8: using guessed type unsigned __int16 Data[264];
// 18002C6D8: using guessed type char var_2B0[16];

//----- (000000018002C868) ----------------------------------------------------
JobMoniker **__fastcall wmi::AutoVectorPtr<JobMoniker>::operator=(JobMoniker **a1, JobMoniker *a2)
{
  JobMoniker *v4; // rcx

  v4 = *a1;
  if ( v4 )
    JobMoniker::`vector deleting destructor'(v4);
  *a1 = a2;
  return a1;
}

//----- (000000018002C8A0) ----------------------------------------------------
__int64 __fastcall _Register__QEventTriggerRegistrar__EventTrapMap__UEAAJAEBVJobMoniker__PEAUEventTrigger_Triggers___Z(
        __int64 a1,
        JobMoniker *a2,
        struct Triggers::EventTrigger *a3)
{
  char v5; // r15
  __int64 v6; // rbp
  _QWORD *v7; // rax
  EventTrap *v8; // rax
  EventTrap *Context; // rsi
  const WCHAR **v10; // rcx
  const WCHAR *v11; // r9
  EVT_HANDLE v12; // rax
  const wchar_t *Path; // rax
  unsigned int v15; // edi
  signed int LastError; // eax
  int v17; // ecx
  const unsigned __int16 *v18; // rax
  EventManager *v19; // rcx

  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
  {
    Path = JobMoniker::GetPath(a2);
    WPP_SF_S(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xBu, (__int64)&WPP_16de8f11014e3cd60e9c758468ee516f_Traceguids, Path);
  }
  v5 = 1;
  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 8));
  v6 = 0LL;
  v7 = (_QWORD *)(a1 + 48);
  while ( *v7 )
  {
    v6 = (unsigned int)(v6 + 1);
    ++v7;
    if ( (unsigned int)v6 >= 0xFF )
    {
      v15 = -2147024882;
      goto LABEL_14;
    }
  }
  v8 = (EventTrap *)operator new(0x50uLL);
  if ( v8 )
    Context = EventTrap::EventTrap(v8, a2, a3);
  else
    Context = 0LL;
  v5 = 0;
  v10 = *(const WCHAR ***)(*((_QWORD *)Context + 6) + 88LL);
  if ( v10 )
    v11 = *v10;
  else
    v11 = 0LL;
  v12 = EvtSubscribe(
          0LL,
          0LL,
          &ChannelPath,
          v11,
          0LL,
          Context,
          (EVT_SUBSCRIBE_CALLBACK)EventTrapMap::ConsumerCallback,
          1u);
  if ( v12 )
  {
    *(_QWORD *)Context = v12;
    v15 = 0;
LABEL_13:
    *(_QWORD *)(a1 + 8 * v6 + 48) = Context;
    goto LABEL_14;
  }
  LastError = GetLastError();
  v15 = LastError;
  if ( LastError > 0 )
    v15 = (unsigned __int16)LastError | 0x80070000;
  if ( v15 + 2147023181 <= 7 && (v17 = 133, _bittest(&v17, v15 + 2147023181))
    || v15 + 2147024770 <= 1
    || v15 == -2147019873 )
  {
    *(_QWORD *)Context = 0LL;
    v15 = 1;
    goto LABEL_13;
  }
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
  {
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xCu, (__int64)&WPP_16de8f11014e3cd60e9c758468ee516f_Traceguids, v15);
  }
  v18 = JobMoniker::GetPath(a2);
  EventManager::EvtReport(v19, &TASK_EVENT_SUBSCRIPTION_FAILED, v18, v15);
  EventTrap::`scalar deleting destructor'(Context);
LABEL_14:
  LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 8));
  if ( v5 && a3 )
    (**(void (__fastcall ***)(struct Triggers::EventTrigger *, __int64))a3)(a3, 1LL);
  return v15;
}
// 18002C932: conditional instruction was optimized away because ebp.4<FFu
// 1800490F1: variable 'v19' is possibly undefined
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018002C9FC) ----------------------------------------------------
EventTrap *__fastcall EventTrap::EventTrap(
        EventTrap *this,
        const struct JobMoniker *a2,
        struct Triggers::EventTrigger *a3)
{
  _QWORD *v5; // r15
  _QWORD *v6; // r12
  WCHAR *v7; // rsi
  __int64 v8; // rax
  int v9; // edi
  int v10; // ebx
  OLECHAR **v11; // rcx
  UINT v12; // eax
  unsigned __int64 v13; // rcx
  OLECHAR *v15; // rcx
  unsigned __int64 v16; // rbx
  WCHAR *v17; // rax
  char **v18; // r8
  char *v19; // r8
  int v20; // eax
  EVT_HANDLE v21; // rbx
  signed int LastError; // eax
  LPCWSTR *v23; // rdi
  int v24; // r8d
  _QWORD *v25; // rax
  __int64 v26; // rcx
  const WCHAR **v27; // rcx
  const WCHAR *v28; // rdx
  __int64 v29; // rcx
  __int64 i; // rcx
  EVT_HANDLE RenderContext; // rbx
  signed int v32; // eax
  void **pExceptionObject; // [rsp+28h] [rbp-38h] BYREF
  char v34; // [rsp+30h] [rbp-30h]
  const unsigned __int16 *v35; // [rsp+38h] [rbp-28h]
  __int64 v36; // [rsp+40h] [rbp-20h]
  __int64 v37; // [rsp+48h] [rbp-18h]
  int v38; // [rsp+50h] [rbp-10h]
  int v39; // [rsp+54h] [rbp-Ch]
  int v40; // [rsp+58h] [rbp-8h]
  LPCWSTR ValuePaths; // [rsp+B0h] [rbp+50h] BYREF

  JobMoniker::JobMoniker((EventTrap *)((char *)this + 8), a2, (__int64)a3);
  *((_QWORD *)this + 6) = a3;
  v5 = (_QWORD *)((char *)this + 64);
  *((_QWORD *)this + 8) = -1LL;
  v6 = (_QWORD *)((char *)this + 72);
  *((_QWORD *)this + 9) = -1LL;
  v7 = (WCHAR *)operator new(0x18uLL);
  ValuePaths = v7;
  if ( v7 )
  {
    v8 = *((_QWORD *)this + 6);
    v9 = *(_DWORD *)(v8 + 96);
    v10 = *(_DWORD *)(v8 + 100);
    *(_QWORD *)v7 = 0LL;
    *((_QWORD *)v7 + 1) = 0LL;
    *(_QWORD *)v7 = std::_Tree_alloc<0,std::_Tree_base_types<std::pair<User const,LogonJob *>>>::_Buyheadnode();
    *((_DWORD *)v7 + 4) = v10;
    *((_DWORD *)v7 + 5) = v9;
  }
  else
  {
    v7 = 0LL;
  }
  *((_QWORD *)this + 7) = v7;
  AutoEvtHandle::Close((void **)this + 8);
  *v5 = -1LL;
  AutoEvtHandle::Close((void **)this + 9);
  *v6 = -1LL;
  v11 = *(OLECHAR ***)(*((_QWORD *)this + 6) + 104LL);
  if ( v11 && (v15 = *v11) != 0LL )
    v12 = SysStringLen(v15);
  else
    v12 = 0;
  if ( v12 )
  {
    v16 = v12 + 1;
    v17 = (WCHAR *)operator new(saturated_mul(v16, 2uLL));
    ValuePaths = v17;
    v18 = *(char ***)(*((_QWORD *)this + 6) + 104LL);
    if ( v18 )
      v19 = *v18;
    else
      v19 = 0LL;
    v20 = StringCchCopyW((char *)v17, v16, v19);
    if ( v20 < 0 )
    {
      v34 = 0;
      pExceptionObject = &wmi::GenericException::`vftable';
      v35 = &word_18007630E;
      v36 = 0LL;
      v37 = 0LL;
      v38 = v20;
      v39 = -1;
      v40 = -1;
      CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
    }
    v21 = EvtCreateRenderContext(1u, &ValuePaths, 0);
    AutoEvtHandle::Close((void **)this + 8);
    *v5 = v21;
    if ( !v21 )
    {
      LastError = GetLastError();
      if ( LastError > 0 )
        LastError = (unsigned __int16)LastError | 0x80070000;
      v34 = 0;
      pExceptionObject = &wmi::GenericException::`vftable';
      v35 = &word_18007630E;
      v36 = 0LL;
      v37 = 0LL;
      v38 = LastError;
      v39 = -1;
      v40 = -1;
      CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
    }
    operator delete((void *)ValuePaths);
  }
  v13 = *(_QWORD *)(*((_QWORD *)this + 6) + 120LL);
  if ( v13 )
  {
    v23 = (LPCWSTR *)operator new(saturated_mul(v13, 8uLL));
    v24 = 0;
    v25 = **(_QWORD ***)(*((_QWORD *)this + 6) + 112LL);
    while ( 1 )
    {
      v26 = *((_QWORD *)this + 6);
      if ( v25 == *(_QWORD **)(v26 + 112) )
        break;
      v27 = (const WCHAR **)v25[5];
      if ( v27 )
        v28 = *v27;
      else
        v28 = 0LL;
      v23[v24++] = v28;
      if ( !*((_BYTE *)v25 + 25) )
      {
        v29 = v25[2];
        if ( *(_BYTE *)(v29 + 25) )
        {
          for ( i = v25[1]; !*(_BYTE *)(i + 25) && v25 == *(_QWORD **)(i + 16); i = *(_QWORD *)(i + 8) )
            v25 = (_QWORD *)i;
          v25 = (_QWORD *)i;
        }
        else
        {
          v25 = std::_Tree_val<std::_Tree_simple_types<std::pair<_bstr_t const,std::list<_FILETIME> *>>>::_Min((_QWORD *)v29);
        }
      }
    }
    RenderContext = EvtCreateRenderContext(*(_DWORD *)(v26 + 120), v23, 0);
    AutoEvtHandle::Close((void **)this + 9);
    *v6 = RenderContext;
    operator delete(v23);
    if ( !RenderContext )
    {
      v32 = GetLastError();
      if ( v32 > 0 )
        v32 = (unsigned __int16)v32 | 0x80070000;
      v34 = 0;
      pExceptionObject = &wmi::GenericException::`vftable';
      v35 = &word_18007630E;
      v36 = 0LL;
      v37 = 0LL;
      v38 = v32;
      v39 = -1;
      v40 = -1;
      CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
    }
  }
  return this;
}
// 1800492A2: variable 'v24' is possibly undefined
// 1800716D8: using guessed type void *wmi::GenericException::`vftable';

//----- (000000018002CB00) ----------------------------------------------------
void __fastcall JobMoniker::~JobMoniker(wmi::RefBase **this)
{
  wmi::AutoRef<JobBucket>::Release(this + 4);
  _bstr_t::_Free((_bstr_t *)(this + 2));
}

//----- (000000018002CB28) ----------------------------------------------------
__int64 __fastcall Triggers::Trigulator::RegisterAllUbpmEmulatedTriggers(
        Triggers::Trigulator *this,
        const wchar_t **a2)
{
  int v4; // edi
  _QWORD *v5; // rbx
  __int64 v6; // r14
  int v8; // [rsp+50h] [rbp+8h] BYREF
  int v9; // [rsp+54h] [rbp+Ch]

  v8 = 0;
  v9 = 0;
  v4 = 1;
  if ( *((_QWORD *)this + 5) )
  {
    v5 = (_QWORD *)*((_QWORD *)this + 4);
    while ( 1 )
    {
      v5 = (_QWORD *)*v5;
      if ( v5 == *((_QWORD **)this + 4) || v4 < 0 )
        break;
      v6 = v5[2];
      if ( (*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v6 + 72LL))(v6) == 52428 )
      {
        v5[2] = 0LL;
        v4 = (*(__int64 (__fastcall **)(__int64, const wchar_t **, int *))(*(_QWORD *)v6 + 56LL))(v6, a2, &v8);
      }
    }
  }
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0
    && *((unsigned __int8 *)WPP_GLOBAL_Control + 25) >= (int)(((v4 >> 31) & 0xFFFFFFFE) + 4) )
  {
    WPP_SF_SD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x15u,
      (__int64)&WPP_9c6330531b9f37c0b720c7be8cd79119_Traceguids,
      a2[3]);
  }
  return (unsigned int)v4;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018002CBE0) ----------------------------------------------------
__int64 __fastcall Triggers::EventTrigger::EventTrigger(
        __int64 a1,
        const OLECHAR *a2,
        _bstr_t *a3,
        __int128 *a4,
        __int128 *a5,
        int a6,
        int a7,
        char a8,
        __int128 *a9,
        int a10,
        int a11,
        _bstr_t *a12,
        void **a13)
{
  __int64 v15; // rax
  __int64 v16; // rax
  __int128 v18; // [rsp+50h] [rbp-48h] BYREF
  __int128 v19; // [rsp+60h] [rbp-38h] BYREF
  __int128 v20; // [rsp+70h] [rbp-28h] BYREF

  v18 = *a9;
  v19 = *a5;
  v20 = *a4;
  Triggers::GenericTrigger::GenericTrigger(a1, a2, &v20, &v19, a6, a7, a8, &v18);
  *(_QWORD *)a1 = &Triggers::EventTrigger::`vftable';
  v15 = *(_QWORD *)a3;
  *(_QWORD *)(a1 + 88) = *(_QWORD *)a3;
  if ( v15 )
    _InterlockedIncrement((volatile signed __int32 *)(v15 + 16));
  *(_DWORD *)(a1 + 96) = a10;
  *(_DWORD *)(a1 + 100) = a11;
  v16 = *(_QWORD *)a12;
  *(_QWORD *)(a1 + 104) = *(_QWORD *)a12;
  if ( v16 )
    _InterlockedIncrement((volatile signed __int32 *)(v16 + 16));
  std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>(
    (_QWORD *)(a1 + 112),
    a13);
  _bstr_t::_Free(a3);
  _bstr_t::_Free(a12);
  std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::clear(a13);
  operator delete(*a13);
  return a1;
}
// 180070B78: using guessed type void *Triggers::EventTrigger::`vftable';

//----- (000000018002CD14) ----------------------------------------------------
Triggers::EventTrigger *__fastcall Triggers::EventTrigger::EventTrigger(Triggers::EventTrigger *this)
{
  Triggers::GenericTrigger::GenericTrigger(this);
  *(_QWORD *)this = &Triggers::EventTrigger::`vftable';
  *((_QWORD *)this + 11) = 0LL;
  *((_QWORD *)this + 13) = 0LL;
  *((_QWORD *)this + 14) = 0LL;
  *((_QWORD *)this + 15) = 0LL;
  *((_QWORD *)this + 14) = std::_Tree_alloc<0,std::_Tree_base_types<std::pair<User const,LogonJob *>>>::_Buyheadnode();
  return this;
}
// 180070B78: using guessed type void *Triggers::EventTrigger::`vftable';

//----- (000000018002CD78) ----------------------------------------------------
_QWORD *__fastcall std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>(
        _QWORD *a1,
        _QWORD *a2)
{
  _QWORD *v4; // rdi
  __int64 v5; // rcx
  _QWORD *v7; // rax
  _QWORD *v8; // r8
  __int64 v9; // rax
  __int64 v10; // rdx
  char v11; // [rsp+40h] [rbp+8h]

  v11 = (char)a1;
  *a1 = 0LL;
  a1[1] = 0LL;
  v4 = std::_Tree_alloc<0,std::_Tree_base_types<std::pair<User const,LogonJob *>>>::_Buyheadnode();
  *a1 = v4;
  v4[1] = std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::_Copy_nodes<std::integral_constant<bool,0>>(
            a1,
            *(_QWORD *)(*a2 + 8LL),
            (__int64)v4,
            v11);
  a1[1] = a2[1];
  v5 = *(_QWORD *)(*a1 + 8LL);
  if ( *(_BYTE *)(v5 + 25) )
  {
    *(_QWORD *)*a1 = *a1;
    *(_QWORD *)(*a1 + 16LL) = *a1;
  }
  else
  {
    v7 = std::_Tree_val<std::_Tree_simple_types<std::pair<_bstr_t const,std::list<_FILETIME> *>>>::_Min((_QWORD *)v5);
    *v8 = v7;
    v9 = std::_Tree_val<std::_Tree_simple_types<std::pair<_bstr_t const,_bstr_t>>>::_Max(*(_QWORD *)(*a1 + 8LL));
    *(_QWORD *)(v10 + 16) = v9;
  }
  return a1;
}
// 1800493AC: variable 'v8' is possibly undefined
// 1800493BB: variable 'v10' is possibly undefined

//----- (000000018002CE08) ----------------------------------------------------
_QWORD *__fastcall std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::_Copy_nodes<std::integral_constant<bool,0>>(
        _QWORD *a1,
        __int64 a2,
        __int64 a3,
        char a4)
{
  _QWORD *v8; // rsi
  _QWORD *v10; // rdi
  __int64 v11; // r9
  __int64 v12; // r9
  __int64 v13; // [rsp+20h] [rbp-38h]

  v8 = (_QWORD *)*a1;
  if ( !*(_BYTE *)(a2 + 25) )
  {
    v10 = std::_Tree_buy<std::pair<_bstr_t const,_bstr_t>>::_Buynode<std::pair<_bstr_t const,_bstr_t> &>(
            a1,
            (__int64 *)(a2 + 32));
    v10[1] = a3;
    *((_BYTE *)v10 + 24) = *(_BYTE *)(a2 + 24);
    if ( *((_BYTE *)v8 + 25) )
      v8 = v10;
    LOBYTE(v11) = a4;
    *v10 = std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::_Copy_nodes<std::integral_constant<bool,0>>(
             a1,
             *(_QWORD *)a2,
             v10,
             v11,
             -2LL);
    LOBYTE(v12) = a4;
    v10[2] = std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::_Copy_nodes<std::integral_constant<bool,0>>(
               a1,
               *(_QWORD *)(a2 + 16),
               v10,
               v12,
               v13);
  }
  return v8;
}
// 1800493F6: variable 'v11' is possibly undefined
// 18004940B: variable 'v12' is possibly undefined
// 18004940B: variable 'v13' is possibly undefined

//----- (000000018002CE60) ----------------------------------------------------
__int64 __fastcall Triggers::EventTrigger::StreamIn(
        Triggers::EventTrigger *this,
        unsigned __int64 a2,
        unsigned __int8 **a3,
        unsigned __int8 *a4)
{
  __int64 result; // rax
  unsigned __int8 *v8; // rcx
  __int64 v9; // r14
  __int64 v10; // rax
  unsigned __int8 *v11; // rdx
  unsigned __int8 *v12; // rsi
  int v13; // r14d
  unsigned __int8 *v14; // rdx
  __int64 v15; // r14
  unsigned __int8 *v16; // rdx
  unsigned __int8 *v17; // rsi
  unsigned int v18; // r12d
  int v19; // r13d
  int v20; // r14d
  unsigned __int8 *v21; // rcx
  __int64 v22; // r14
  unsigned __int8 *v23; // rcx
  unsigned __int8 *v24; // rsi
  int v25; // r14d
  __int64 v26; // r14
  __int64 v27; // rax
  unsigned __int8 *v28; // rdx
  unsigned __int8 *v29; // rsi
  __int64 *v30; // rax
  _bstr_t::Data_t *v31; // [rsp+20h] [rbp-40h] BYREF
  _bstr_t::Data_t *v32[2]; // [rsp+28h] [rbp-38h] BYREF
  __int64 v33; // [rsp+38h] [rbp-28h] BYREF
  char v34[8]; // [rsp+40h] [rbp-20h] BYREF
  char v35[24]; // [rsp+48h] [rbp-18h] BYREF

  v32[1] = (_bstr_t::Data_t *)-2LL;
  result = Triggers::GenericTrigger::StreamIn(this, a2, a3, a4);
  if ( (int)result >= 0 )
  {
    v8 = *a3;
    if ( (unsigned __int64)(a4 - *a3) >= 4 )
    {
      v9 = *(unsigned int *)v8;
      v10 = 2LL;
      do
      {
        v11 = v8 + 4;
        v8 += 4;
        --v10;
      }
      while ( v10 );
      *a3 = v11;
      if ( (_DWORD)v9 )
      {
        v12 = &v11[2 * v9 + 2];
        if ( v12 > a4 || *(_WORD *)&v11[2 * v9] )
          return 2147549183LL;
        _bstr_t::operator=((_bstr_t::Data_t **)this + 11, (const OLECHAR *)v11);
        *a3 = v12;
        v13 = (2 * (_BYTE)v9 + 2) & 7;
        v11 = v12;
        if ( v13 )
        {
          v11 = &v12[8 - v13];
          *a3 = v11;
        }
      }
      if ( a4 - v11 >= 8 )
      {
        *((_DWORD *)this + 24) = *(_DWORD *)v11;
        *a3 += 4;
        *((_DWORD *)this + 25) = *(_DWORD *)*a3;
        *a3 += 4;
        v14 = *a3;
        if ( (unsigned __int64)(a4 - *a3) >= 8 )
        {
          v15 = *(unsigned int *)v14;
          v16 = v14 + 8;
          *a3 = v16;
          v17 = v16;
          if ( (_DWORD)v15 )
          {
            v17 = &v16[2 * v15 + 2];
            if ( v17 > a4 || *(_WORD *)&v16[2 * v15] )
              return 2147549183LL;
            _bstr_t::operator=((_bstr_t::Data_t **)this + 13, (const OLECHAR *)v16);
            *a3 = v17;
            v20 = (2 * (_BYTE)v15 + 2) & 7;
            v16 = v17;
            if ( v20 )
            {
              v16 = &v17[8 - v20];
              *a3 = v16;
              v17 = v16;
            }
          }
          if ( (unsigned __int64)(a4 - v16) >= 8 )
          {
            v18 = *(_DWORD *)v16;
            *a3 = v17 + 8;
            v19 = 0;
            if ( !v18 )
              return 0LL;
            while ( 1 )
            {
              v32[0] = 0LL;
              v31 = 0LL;
              v21 = *a3;
              if ( (unsigned __int64)(a4 - *a3) < 8 )
                break;
              v22 = *(unsigned int *)v21;
              v23 = v21 + 8;
              *a3 = v23;
              v24 = v23;
              if ( (_DWORD)v22 )
              {
                v24 = &v23[2 * v22 + 2];
                if ( v24 > a4 || *(_WORD *)&v23[2 * v22] )
                  break;
                _bstr_t::operator=(v32, (const OLECHAR *)v23);
                *a3 = v24;
                v25 = (2 * (_BYTE)v22 + 2) & 7;
                v23 = v24;
                if ( v25 )
                {
                  v23 = &v24[8 - v25];
                  *a3 = v23;
                  v24 = v23;
                }
              }
              if ( (unsigned __int64)(a4 - v23) < 8 )
                break;
              v26 = *(unsigned int *)v23;
              v27 = 2LL;
              do
              {
                v28 = v24 + 4;
                v24 += 4;
                --v27;
              }
              while ( v27 );
              *a3 = v28;
              if ( (_DWORD)v26 )
              {
                v29 = &v28[2 * v26 + 2];
                if ( v29 > a4 || *(_WORD *)&v28[2 * v26] )
                  break;
                _bstr_t::operator=(&v31, (const OLECHAR *)v28);
                *a3 = v29;
                if ( ((2 * (_BYTE)v26 + 2) & 7) != 0 )
                  *a3 = &v29[8 - ((2 * (_BYTE)v26 + 2) & 7)];
              }
              v30 = std::pair<_bstr_t,_bstr_t>::pair<_bstr_t,_bstr_t>(&v33, (__int64 *)v32, (__int64 *)&v31);
              std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::insert<std::pair<_bstr_t,_bstr_t>>(
                (__int64 *)this + 14,
                (__int64)v35,
                v30);
              _bstr_t::_Free((_bstr_t *)v34);
              _bstr_t::_Free((_bstr_t *)&v33);
              _bstr_t::_Free((_bstr_t *)&v31);
              _bstr_t::_Free((_bstr_t *)v32);
              if ( ++v19 >= v18 )
                return 0LL;
            }
            _bstr_t::_Free((_bstr_t *)&v31);
            _bstr_t::_Free((_bstr_t *)v32);
          }
        }
      }
    }
    return 2147549183LL;
  }
  return result;
}
// 18002CE60: using guessed type char var_18[24];
// 18002CE60: using guessed type char var_20[8];

//----- (000000018002CFB0) ----------------------------------------------------
__int64 __fastcall UbpmParams::AddMaintenanceTrigger(UbpmParams *this)
{
  int v3; // [rsp+30h] [rbp-38h] BYREF
  __int128 v4; // [rsp+34h] [rbp-34h]
  int v5; // [rsp+44h] [rbp-24h]
  __int64 v6; // [rsp+48h] [rbp-20h]
  int v7; // [rsp+50h] [rbp-18h]
  int v8; // [rsp+54h] [rbp-14h]
  unsigned __int16 **ActionIdArray; // [rsp+58h] [rbp-10h]

  v6 = 0LL;
  v7 = 0;
  v5 = -1;
  v4 = 0LL;
  v3 = 3;
  v8 = (__int64)(*((_QWORD *)this + 44) - *((_QWORD *)this + 43)) >> 3;
  ActionIdArray = UbpmParams::GetActionIdArray(this);
  std::vector<_UBPM_TRIGGER_PARAMS>::push_back((__int64 *)this + 112, &v3);
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
  {
    WPP_SF_SD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x16u,
      (__int64)&WPP_f0f7296807f33a7e423f6d049324e537_Traceguids,
      *(const wchar_t **)(*((_QWORD *)this + 1) + 24LL));
  }
  return 0LL;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018002D060) ----------------------------------------------------
__int64 __fastcall SchRpcRun(
        __int64 a1,
        unsigned __int16 *a2,
        unsigned int a3,
        const unsigned __int16 **a4,
        unsigned int a5,
        unsigned int a6,
        unsigned __int16 *a7,
        struct _GUID *a8)
{
  return RpcServer::RunTask((RTL_SRWLOCK *)&RpcServer::s_singleton, a2, a3, a4, a5, a6, a7, a8);
}
// 18002D060: could not find valid save-restore pair for rbp
// 1800B0D48: using guessed type __int64 RpcServer::s_singleton;

//----- (000000018002D0C4) ----------------------------------------------------
__int64 __fastcall RpcServer::RunTask(
        RTL_SRWLOCK *this,
        unsigned __int16 *a2,
        unsigned int a3,
        const unsigned __int16 **a4,
        unsigned int a5,
        DWORD SessionId,
        const unsigned __int16 *StringSid,
        struct _GUID *a8)
{
  __int64 v11; // rcx
  int CallerToken; // ebx
  DWORD v13; // r15d
  const unsigned __int16 *v14; // r8
  const unsigned __int16 *v15; // rdx
  HKEY *v16; // rdi
  const unsigned __int16 *Path; // rax
  const unsigned __int16 *v18; // rax
  JobMoniker *v19; // rax
  unsigned int v20; // edi
  void *v21; // r8
  signed int LastError; // eax
  char v23; // r14
  User::UserEntry *v24; // rbx
  User *v25; // rax
  unsigned int v26; // ecx
  const OLECHAR **v27; // rdi
  const unsigned __int16 **v28; // rax
  unsigned int i; // ebx
  __int64 *v30; // rax
  __int64 v31; // r8
  PSID *p_Sid; // rcx
  struct _GUID *v33; // rdi
  unsigned __int16 *v34; // rax
  const struct _EVENT_DESCRIPTOR *v35; // rdx
  EventManager *v36; // rcx
  __int64 v37; // rcx
  __int64 v38; // r8
  struct _GUID *v39; // r9
  unsigned __int16 *v41; // [rsp+28h] [rbp-E0h]
  PSID Sid; // [rsp+60h] [rbp-A8h] BYREF
  RTL_SRWLOCK *v43; // [rsp+68h] [rbp-A0h] BYREF
  User::UserEntry *v44; // [rsp+70h] [rbp-98h] BYREF
  User::UserEntry *v45; // [rsp+78h] [rbp-90h] BYREF
  User::UserEntry *v46; // [rsp+80h] [rbp-88h] BYREF
  User::UserEntry *v47; // [rsp+88h] [rbp-80h] BYREF
  struct _GUID *v48; // [rsp+90h] [rbp-78h] BYREF
  HANDLE ClientToken; // [rsp+98h] [rbp-70h] BYREF
  User::UserEntry *v50; // [rsp+A0h] [rbp-68h] BYREF
  _bstr_t::Data_t *v51; // [rsp+A8h] [rbp-60h] BYREF
  _bstr_t::Data_t *v52; // [rsp+B0h] [rbp-58h] BYREF
  void *lpMem[2]; // [rsp+B8h] [rbp-50h] BYREF
  const unsigned __int16 **v54; // [rsp+C8h] [rbp-40h] BYREF
  char v55[8]; // [rsp+D0h] [rbp-38h] BYREF
  char v56[24]; // [rsp+D8h] [rbp-30h] BYREF
  __int64 v57; // [rsp+F0h] [rbp-18h]
  struct _FILETIME v58[7]; // [rsp+F8h] [rbp-10h] BYREF
  char v59[16]; // [rsp+130h] [rbp+28h] BYREF
  char v60[16]; // [rsp+140h] [rbp+38h] BYREF
  wmi::RefBase *v61; // [rsp+150h] [rbp+48h] BYREF
  struct _GUID v62; // [rsp+158h] [rbp+50h] BYREF
  char v63[16]; // [rsp+168h] [rbp+60h] BYREF
  char v64[16]; // [rsp+178h] [rbp+70h] BYREF
  wmi::RefBase *v65; // [rsp+188h] [rbp+80h] BYREF
  unsigned __int16 v66[12]; // [rsp+190h] [rbp+88h] BYREF
  unsigned __int16 v67[264]; // [rsp+1A8h] [rbp+A0h] BYREF

  v57 = -2LL;
  v54 = a4;
  v48 = a8;
  lpMem[1] = 0LL;
  lpMem[0] = std::_Tree_alloc<0,std::_Tree_base_types<std::pair<User const,LogonJob *>>>::_Buyheadnode();
  v52 = 0LL;
  v51 = 0LL;
  User::User((User *)&v50);
  User::User((User *)&v47);
  User::User((User *)&v46);
  User::User((User *)&v44);
  User::User((User *)&v45);
  Triggers::Trigulator::Trigulator(v58);
  Actions::ActionCollection::ActionCollection((Actions::ActionCollection *)v56);
  ClientToken = 0LL;
  JobMoniker::JobMoniker((JobMoniker *)v59, a2, 0LL);
  if ( (unsigned int)dword_1800AFF68 > 5 && tlgKeywordOn((__int64)&dword_1800AFF68, 0LL) )
    _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<>(
      v11,
      byte_18007F153);
  if ( (a5 & 0xFFFFFFF0) != 0 )
  {
    CallerToken = -2147024809;
    v13 = SessionId;
    goto LABEL_88;
  }
  if ( (a5 & 4) != 0 )
  {
    v13 = SessionId;
    if ( ((SessionId + 1) & 0xFFFFFFFE) == 0 )
    {
LABEL_8:
      CallerToken = -2147024809;
      goto LABEL_88;
    }
  }
  else
  {
    v13 = -1;
  }
  memset_0(v67, 0, 0x20AuLL);
  CallerToken = tsched::TaskPathCanonicalize((tsched *)v67, (char *)a2, v14);
  if ( CallerToken < 0 )
    goto LABEL_88;
  if ( tsched::IsRoot((tsched *)v67, v15) )
  {
    CallerToken = -2147024809;
    goto LABEL_88;
  }
  CallerToken = GetCallerToken(L"RunTask", &ClientToken);
  if ( CallerToken < 0 )
    goto LABEL_88;
  v43 = this + 2;
  AcquireSRWLockShared(this + 2);
  CallerToken = TaskAccessCheck(ClientToken, v67, 1u);
  if ( CallerToken < 0
    || (v16 = (HKEY *)JobStore::m_pCommonStore,
        Path = JobMoniker::GetPath((JobMoniker *)v59),
        CallerToken = JobStore::RegGetTreeInfo(v16, Path, &v62, 0LL),
        CallerToken < 0) )
  {
LABEL_15:
    tsched::SrwLockSharedScope::~SrwLockSharedScope(&v43);
    goto LABEL_88;
  }
  v18 = JobMoniker::GetPath((JobMoniker *)v59);
  v19 = JobMoniker::JobMoniker((JobMoniker *)v63, v18, &v62);
  JobMoniker::operator=((__int64)v59, (__int64)v19);
  wmi::AutoRef<JobBucket>::Release(&v65);
  _bstr_t::_Free((_bstr_t *)v64);
  Sid = 0LL;
  CallerToken = JobStore::RegOpenTaskKey(v16, (struct JobMoniker *)v59, (HKEY *)&Sid, 0x20019u);
  if ( CallerToken < 0
    || (CallerToken = Triggers::Trigulator::StreamIn((wmi::RefBase **)v58, (HKEY)Sid, 3, 0LL), CallerToken < 0)
    || (CallerToken = Triggers::Trigulator::GetBucket((Triggers::Trigulator *)v58, (struct JobMoniker *)v59),
        CallerToken < 0)
    || (CallerToken = Actions::ActionCollection::StreamIn((Actions::ActionCollection *)v56, (HKEY)Sid, 0LL),
        CallerToken < 0) )
  {
    wmi::AutoRegKey::~AutoRegKey((wmi::AutoRegKey *)&Sid);
    goto LABEL_15;
  }
  wmi::AutoRegKey::~AutoRegKey((wmi::AutoRegKey *)&Sid);
  tsched::SrwLockSharedScope::~SrwLockSharedScope(&v43);
  v20 = *((_DWORD *)v61 + 4);
  if ( (v20 & 0x100) == 0 )
  {
    CallerToken = -2147216600;
    goto LABEL_88;
  }
  if ( (v20 & 0x400000) == 0 )
  {
    CallerToken = -2147216602;
    goto LABEL_88;
  }
  User::operator=(&v47, (User::UserEntry **)v61 + 8);
  if ( (a5 & 2) != 0 )
    v20 = v20 & 0xFBFFC30D | 0x400;
  RpcAutoImpersonate::RpcAutoImpersonate((RpcAutoImpersonate *)&v43, L"RpcServer::RunTask", 1);
  CallerToken = User::FromImpersonationToken((struct User *)&v46, 0LL);
  if ( CallerToken < 0 )
  {
    if ( (_DWORD)v43 )
      RpcRevertToSelf();
    goto LABEL_88;
  }
  if ( (_DWORD)v43 )
    RpcRevertToSelf();
  if ( StringSid )
  {
    if ( (a5 & 8) != 0 )
    {
      Sid = 0LL;
      if ( !ConvertStringSidToSidW(StringSid, &Sid) )
      {
        LastError = GetLastError();
        CallerToken = LastError;
        if ( LastError > 0 )
          CallerToken = (unsigned __int16)LastError | 0x80070000;
        goto LABEL_38;
      }
      CallerToken = User::FromSid(&v45, Sid, SidTypeUnknown);
      if ( CallerToken < 0 )
      {
LABEL_38:
        tsched::AutoLocalPtr<unsigned short>::~AutoLocalPtr<unsigned short>(&Sid);
        goto LABEL_88;
      }
      tsched::AutoLocalPtr<unsigned short>::~AutoLocalPtr<unsigned short>(&Sid);
    }
    else
    {
      CallerToken = User::FromUsername(&v45, StringSid);
      if ( CallerToken < 0 )
        goto LABEL_88;
    }
  }
  if ( (a5 & 4) == 0 || (CallerToken = User::FromUserSession(&v50, v13, v21), CallerToken >= 0) )
  {
    User::operator=(&v44, &v47);
    v23 = 0;
    v24 = v45;
    if ( (a5 & 4) != 0 )
    {
      if ( v45 && !User::operator==((User *)&v50, (User *)&v45) )
        goto LABEL_8;
      v20 = v20 & 0xFFF03FFF | 0x10000;
      User::operator=(&v44, &v50);
      v23 = 1;
    }
    if ( (a5 & 1) != 0 )
    {
      if ( (a5 & 4) != 0 && !User::operator==((User *)&v50, (User *)&v46)
        || v24 && !User::operator==((User *)&v46, (User *)&v45) )
      {
        goto LABEL_8;
      }
      v20 = v20 & 0xFFF03FFF | 0x10000;
      User::operator=(&v44, &v46);
      v23 = 1;
    }
    if ( v24 )
    {
      v20 = v20 & 0xFFF03FFF | 0x10000;
      User::operator=(&v44, &v45);
      v23 = 1;
    }
    if ( !User::operator==((User *)&v46, (User *)&v44) )
    {
      v25 = User::User((User *)&Sid, &v44);
      CallerToken = IsPrincipalAllowed(v25, v20);
      if ( CallerToken < 0 )
      {
        if ( User::operator==((User *)&v44, (User *)&v47) )
        {
          CallerToken = TaskAccessCheck(ClientToken, v67, 0x20u);
          if ( CallerToken < 0 )
            goto LABEL_88;
        }
        else
        {
          if ( (a5 & 4) == 0 )
            goto LABEL_88;
          CallerToken = TaskAccessCheck(ClientToken, v67, 0x20u);
          if ( CallerToken < 0 )
            goto LABEL_88;
          CallerToken = User::LookupType((User *)&v47, (enum _SID_NAME_USE *)&v43);
          if ( CallerToken < 0 )
            goto LABEL_88;
          CallerToken = User::LookupType((User *)&v44, (enum _SID_NAME_USE *)&Sid);
          if ( CallerToken < 0 )
            goto LABEL_88;
          if ( (((_DWORD)v43 - 2) & 0xFFFFFFFC) != 0
            || (_DWORD)v43 == 3
            || (_DWORD)Sid != 1
            || !RpcServer::UserGroupCheck(v13, (const struct User *)&v44, (const struct User *)&v47) )
          {
            CallerToken = -2147024891;
            goto LABEL_88;
          }
        }
      }
    }
    if ( a3 > 0x20 )
      goto LABEL_8;
    v26 = 0;
    v27 = v54;
    if ( a3 )
    {
      v28 = v54;
      while ( *v28 )
      {
        ++v26;
        ++v28;
        if ( v26 >= a3 )
          goto LABEL_65;
      }
      goto LABEL_8;
    }
LABEL_65:
    for ( i = 0; i < a3; ++v27 )
    {
      if ( (int)StringCchPrintfW(v66, 0xAuLL, (size_t *)L"Arg%d", i, v41) >= 0 )
      {
        _bstr_t::operator=(&v52, v66);
        _bstr_t::operator=(&v51, *v27);
        v30 = std::pair<_bstr_t,_bstr_t>::pair<_bstr_t,_bstr_t>((__int64 *)&v54, (__int64 *)&v52, (__int64 *)&v51);
        LOBYTE(v41) = byte_1800B14D1;
        std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::_Insert_nohint<std::pair<_bstr_t const,_bstr_t>,std::_Nil>(
          (__int64 *)lpMem,
          (__int64)&v62,
          v31,
          (BSTR **)v30);
        _bstr_t::_Free((_bstr_t *)v55);
        _bstr_t::_Free((_bstr_t *)&v54);
      }
      ++i;
    }
    if ( (*((_DWORD *)v61 + 4) & 0x2000000) != 0 )
    {
      User::User((User *)&Sid);
      p_Sid = &Sid;
      if ( v23 )
        p_Sid = (PSID *)&v44;
      v33 = v48;
      CallerToken = (*((__int64 (__fastcall **)(void ***, char *, struct _FILETIME *, char *, unsigned int, PSID *, DWORD, void **, struct _GUID *))UbpmProxySingleton::s_singleton[0]
                     + 4))(
                      UbpmProxySingleton::s_singleton,
                      v59,
                      v58,
                      v56,
                      a5,
                      p_Sid,
                      v13,
                      lpMem,
                      v48);
      if ( CallerToken < 0 )
      {
        wmi::AutoRef<User::UserEntry>::Release(&Sid);
        goto LABEL_88;
      }
      wmi::AutoRef<User::UserEntry>::Release(&Sid);
    }
    else
    {
      CallerToken = -2147467263;
      v33 = v48;
    }
    v34 = (unsigned __int16 *)*User::GetAccount((__int64)&v44, (__int64 *)&v48);
    if ( v34 )
      v34 = *(unsigned __int16 **)v34;
    EventManager::EvtReport(v36, v35, v67, v33, v34);
    _bstr_t::_Free((_bstr_t *)&v48);
  }
LABEL_88:
  if ( (unsigned int)dword_1800AFF68 > 4 && tlgKeywordOn((__int64)&dword_1800AFF68, 0LL) )
  {
    LODWORD(Sid) = v13;
    LODWORD(v43) = CallerToken;
    v48 = v39;
    _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapSz<unsigned short>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>>(
      v37,
      byte_18007F1F1,
      v38,
      (__int64)v39,
      (const WCHAR **)&v48,
      (__int64)&v43,
      (__int64)&Sid);
  }
  wmi::AutoRef<JobBucket>::Release(&v61);
  _bstr_t::_Free((_bstr_t *)v60);
  wmi::AutoHandle::Close(&ClientToken);
  Actions::ActionCollection::~ActionCollection((Actions::ActionCollection *)v56);
  Triggers::Trigulator::~Trigulator((Triggers::Trigulator *)v58);
  wmi::AutoRef<User::UserEntry>::Release(&v45);
  wmi::AutoRef<User::UserEntry>::Release(&v44);
  wmi::AutoRef<User::UserEntry>::Release(&v46);
  wmi::AutoRef<User::UserEntry>::Release(&v47);
  wmi::AutoRef<User::UserEntry>::Release(&v50);
  _bstr_t::_Free((_bstr_t *)&v51);
  _bstr_t::_Free((_bstr_t *)&v52);
  std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::clear(lpMem);
  operator delete(lpMem[0]);
  return (unsigned int)CallerToken;
}
// 18002D1BE: variable 'v11' is possibly undefined
// 18002D22A: variable 'v14' is possibly undefined
// 18002D24C: variable 'v15' is possibly undefined
// 18002D4E5: variable 'v21' is possibly undefined
// 18002D673: variable 'v41' is possibly undefined
// 18002D6BF: variable 'v31' is possibly undefined
// 18002D83C: variable 'v36' is possibly undefined
// 18002D83C: variable 'v35' is possibly undefined
// 18002D873: variable 'v39' is possibly undefined
// 18002D89B: variable 'v37' is possibly undefined
// 18002D89B: variable 'v38' is possibly undefined
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);
// 18007F153: using guessed type unsigned __int8 byte_18007F153[27];
// 18007F1F1: using guessed type unsigned __int8 byte_18007F1F1[53];
// 1800AFFB0: using guessed type void **UbpmProxySingleton::s_singleton[2];
// 1800B14D1: using guessed type char byte_1800B14D1;
// 18002D0C4: using guessed type char var_290[16];
// 18002D0C4: using guessed type char var_280[16];
// 18002D0C4: using guessed type char var_328[8];
// 18002D0C4: using guessed type char var_2B8[16];

//----- (000000018002D960) ----------------------------------------------------
__int64 __fastcall std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::_Insert_nohint<std::pair<_bstr_t const,_bstr_t>,std::_Nil>(
        __int64 *a1,
        __int64 a2,
        __int64 a3,
        BSTR **a4)
{
  __int64 v7; // rsi
  __int64 v8; // rbx
  char v9; // r14
  __int64 v10; // rbx
  __int64 i; // rax
  __int64 v13; // [rsp+60h] [rbp+8h] BYREF

  v7 = *a1;
  v8 = *(_QWORD *)(*a1 + 8);
  v9 = 1;
  while ( !*(_BYTE *)(v8 + 25) )
  {
    v7 = v8;
    if ( (int)_bstr_t::_Compare(a4, (BSTR **)(v8 + 32)) >= 0 )
    {
      v9 = 0;
      v8 = *(_QWORD *)(v8 + 16);
    }
    else
    {
      v9 = 1;
      v8 = *(_QWORD *)v8;
    }
  }
  v10 = v7;
  if ( v9 )
  {
    if ( v7 == *(_QWORD *)*a1 )
    {
      *(_QWORD *)a2 = *std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::_Insert_at<std::pair<_bstr_t const,_bstr_t>,std::_Nil>(
                         a1,
                         &v13,
                         1,
                         (_QWORD *)v7,
                         (__int64 *)a4);
      *(_BYTE *)(a2 + 8) = 1;
      return a2;
    }
    if ( *(_BYTE *)(v7 + 25) )
    {
      v10 = *(_QWORD *)(v7 + 16);
    }
    else if ( *(_BYTE *)(*(_QWORD *)v7 + 25LL) )
    {
      for ( i = *(_QWORD *)(v7 + 8); !*(_BYTE *)(i + 25) && v10 == *(_QWORD *)i; i = *(_QWORD *)(i + 8) )
        v10 = i;
      if ( !*(_BYTE *)(v10 + 25) )
        v10 = i;
    }
    else
    {
      v10 = std::_Tree_val<std::_Tree_simple_types<std::pair<_bstr_t const,_bstr_t>>>::_Max(*(_QWORD *)v7);
    }
  }
  if ( (int)_bstr_t::_Compare((BSTR **)(v10 + 32), a4) >= 0 )
  {
    *(_QWORD *)a2 = v10;
    *(_BYTE *)(a2 + 8) = 0;
  }
  else
  {
    *(_QWORD *)a2 = *std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::_Insert_at<std::pair<_bstr_t const,_bstr_t>,std::_Nil>(
                       a1,
                       &v13,
                       v9,
                       (_QWORD *)v7,
                       (__int64 *)a4);
    *(_BYTE *)(a2 + 8) = 1;
  }
  return a2;
}

//----- (000000018002D9FC) ----------------------------------------------------
_QWORD *__fastcall std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::_Insert_at<std::pair<_bstr_t const,_bstr_t>,std::_Nil>(
        _QWORD *a1,
        _QWORD *a2,
        char a3,
        _QWORD *a4,
        __int64 *a5)
{
  _QWORD *v9; // rax
  _QWORD *v10; // r10
  char v11; // r11
  __int64 v12; // rax
  _QWORD *v13; // r9
  __int64 v14; // rcx
  _QWORD *result; // rax
  __int64 v16; // rax
  __int64 *v17; // rdx
  __int64 v18; // rcx

  if ( a1[1] >= 0x555555555555554uLL )
    std::_Xlength_error("map/set<T> too long");
  v9 = std::_Tree_buy<std::pair<_bstr_t const,_bstr_t>>::_Buynode<std::pair<_bstr_t const,_bstr_t>>(a1, a5);
  ++a1[1];
  v10 = v9;
  v11 = 0;
  v9[1] = a4;
  if ( a4 == (_QWORD *)*a1 )
  {
    *(_QWORD *)(*a1 + 8LL) = v9;
    *(_QWORD *)*a1 = v9;
    *(_QWORD *)(*a1 + 16LL) = v9;
  }
  else if ( a3 )
  {
    *a4 = v9;
    if ( a4 == *(_QWORD **)*a1 )
      *(_QWORD *)*a1 = v9;
  }
  else
  {
    a4[2] = v9;
    if ( a4 == *(_QWORD **)(*a1 + 16LL) )
      *(_QWORD *)(*a1 + 16LL) = v9;
  }
  v12 = v9[1];
  v13 = v10;
  while ( *(_BYTE *)(v12 + 24) == v11 )
  {
    v16 = v13[1];
    v17 = *(__int64 **)(v16 + 8);
    v18 = *v17;
    if ( v16 == *v17 )
    {
      v18 = v17[2];
      if ( *(_BYTE *)(v18 + 24) == v11 )
        goto LABEL_23;
      if ( v13 == *(_QWORD **)(v16 + 16) )
        std::_Tree<std::_Tmap_traits<User,LogonJob *,User::less,std::allocator<std::pair<User const,LogonJob *>>,1>>::_Lrotate(
          (__int64)a1,
          v13[1]);
      *(_BYTE *)(v13[1] + 24LL) = 1;
      *(_BYTE *)(*(_QWORD *)(v13[1] + 8LL) + 24LL) = v11;
      std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::_Rrotate(
        (__int64)a1,
        *(_QWORD **)(v13[1] + 8LL));
    }
    else
    {
      if ( *(_BYTE *)(v18 + 24) == v11 )
      {
LABEL_23:
        *(_BYTE *)(v16 + 24) = 1;
        *(_BYTE *)(v18 + 24) = 1;
        *(_BYTE *)(*(_QWORD *)(v13[1] + 8LL) + 24LL) = v11;
        v13 = *(_QWORD **)(v13[1] + 8LL);
        goto LABEL_22;
      }
      if ( v13 == *(_QWORD **)v16 )
        std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::_Rrotate(
          (__int64)a1,
          (_QWORD *)v13[1]);
      *(_BYTE *)(v13[1] + 24LL) = 1;
      *(_BYTE *)(*(_QWORD *)(v13[1] + 8LL) + 24LL) = v11;
      std::_Tree<std::_Tmap_traits<User,LogonJob *,User::less,std::allocator<std::pair<User const,LogonJob *>>,1>>::_Lrotate(
        (__int64)a1,
        *(_QWORD *)(v13[1] + 8LL));
    }
LABEL_22:
    v12 = v13[1];
  }
  v14 = *(_QWORD *)(*a1 + 8LL);
  result = a2;
  *a2 = v10;
  *(_BYTE *)(v14 + 24) = 1;
  return result;
}
// 18002DA71: variable 'v11' is possibly undefined
// 18002DA90: variable 'v10' is possibly undefined
// 1800496C9: variable 'v13' is possibly undefined

//----- (000000018002DAA8) ----------------------------------------------------
_QWORD *__fastcall std::_Tree_buy<std::pair<_bstr_t const,_bstr_t>>::_Buynode<std::pair<_bstr_t const,_bstr_t>>(
        _QWORD *a1,
        __int64 *a2)
{
  _QWORD *result; // rax
  __int64 v4; // rcx
  __int64 v5; // rcx

  result = std::_Tree_buy<std::pair<_bstr_t const,void *>>::_Buynode0(a1);
  *((_WORD *)result + 12) = 0;
  v4 = *a2;
  result[4] = *a2;
  if ( v4 )
    _InterlockedIncrement((volatile signed __int32 *)(v4 + 16));
  v5 = a2[1];
  result[5] = v5;
  if ( v5 )
    _InterlockedIncrement((volatile signed __int32 *)(v5 + 16));
  return result;
}

//----- (000000018002DAF8) ----------------------------------------------------
__int64 __fastcall EventManager::EvtReport(
        EventManager *this,
        const struct _EVENT_DESCRIPTOR *a2,
        const unsigned __int16 *a3,
        const struct _GUID *a4,
        unsigned __int16 *a5)
{
  EventManager *v5; // rdi
  struct _RTL_CRITICAL_SECTION *v9; // rbx
  int v10; // eax
  int v11; // edi
  EventManager *v12; // rcx
  __int64 v13[2]; // [rsp+20h] [rbp-50h] BYREF
  struct _EVENT_DATA_DESCRIPTOR v14; // [rsp+30h] [rbp-40h] BYREF
  const struct _GUID *v15; // [rsp+40h] [rbp-30h]
  __int64 v16; // [rsp+48h] [rbp-28h]
  struct _EVENT_DATA_DESCRIPTOR v17; // [rsp+50h] [rbp-20h] BYREF

  v5 = g_pEventManager;
  if ( !*(_QWORD *)g_pEventManager )
    return 1LL;
  if ( !(unsigned __int8)EtwEventEnabled(*(_QWORD *)g_pEventManager, "n", a3, a4) )
    return 0LL;
  CreateDataDescriptor(&v14, a3);
  v15 = a4;
  v16 = 16LL;
  CreateDataDescriptor(&v17, a5);
  v9 = (struct _RTL_CRITICAL_SECTION *)((char *)v5 + 8);
  EnterCriticalSection((LPCRITICAL_SECTION)((char *)v5 + 8));
  EtwEventActivityIdControl(2LL, a4);
  v10 = EtwEventWrite(*(_QWORD *)v5, "n", 3LL, &v14);
  v13[0] = 0LL;
  v13[1] = 0LL;
  v11 = v10;
  EtwEventActivityIdControl(2LL, v13);
  LeaveCriticalSection(v9);
  if ( !v11 )
    return 0LL;
  EventManager::LogIt(v12, L"EventWrite error", v11);
  if ( v11 > 0 )
    return (unsigned __int16)v11 | 0x80070000;
  return (unsigned int)v11;
}
// 18004982E: variable 'v12' is possibly undefined
// 1800746B8: using guessed type __int64 __fastcall EtwEventEnabled(_QWORD, _QWORD, _QWORD, _QWORD);
// 1800746C0: using guessed type __int64 __fastcall EtwEventActivityIdControl(_QWORD, _QWORD);
// 180074768: using guessed type __int64 __fastcall EtwEventWrite(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000018002DB80) ----------------------------------------------------
__int64 *__fastcall User::GetAccount(__int64 a1, __int64 *a2)
{
  struct _RTL_CRITICAL_SECTION *v2; // rbx

  v2 = User::s_cs;
  *a2 = 0LL;
  EnterCriticalSection(v2);
  _bstr_t::operator=(a2, (__int64 *)(*(_QWORD *)a1 + 16LL));
  LeaveCriticalSection(v2);
  return a2;
}

//----- (000000018002DBE8) ----------------------------------------------------
__int64 *__fastcall std::pair<_bstr_t,_bstr_t>::pair<_bstr_t,_bstr_t>(__int64 *a1, __int64 *a2, __int64 *a3)
{
  __int64 v3; // rax
  __int64 v4; // rax

  v3 = *a2;
  *a1 = *a2;
  if ( v3 )
    _InterlockedIncrement((volatile signed __int32 *)(v3 + 16));
  v4 = *a3;
  a1[1] = *a3;
  if ( v4 )
    _InterlockedIncrement((volatile signed __int32 *)(v4 + 16));
  return a1;
}

//----- (000000018002DC14) ----------------------------------------------------
HRESULT __fastcall ExeTask::ResolveDocRunAssociation(ExeTask *this, LPCWSTR pszAssoc)
{
  HRESULT result; // eax
  DWORD pcchOut[4]; // [rsp+30h] [rbp-238h] BYREF
  WCHAR pszOut[264]; // [rsp+40h] [rbp-228h] BYREF

  memset_0(pszOut, 0, 0x20AuLL);
  pcchOut[0] = 261;
  result = AssocQueryStringW(0, ASSOCSTR_COMMAND, pszAssoc, L"open", pszOut, pcchOut);
  if ( result >= 0 )
    return ExeTask::SetAssocLaunchCommand(this, (__int64)pszOut, pcchOut[0]);
  return result;
}
// 18002DC14: using guessed type DWORD var_238[4];

//----- (000000018002DCC4) ----------------------------------------------------
__int64 __fastcall ExeTask::SetAssocLaunchCommand(ExeTask *this, __int64 a2, unsigned int a3)
{
  const unsigned __int16 *v6; // rdi
  OLECHAR *v7; // rbx
  BOOL v8; // ecx
  __int64 v9; // r15
  const OLECHAR *v10; // rdx
  unsigned __int16 v11; // cx
  const unsigned __int16 *v12; // r8
  unsigned __int16 v13; // cx
  const unsigned __int16 *v14; // rdx
  unsigned __int16 v15; // dx
  unsigned __int16 v16; // cx
  BSTR **v17; // rdx
  BSTR *p_bstrString; // rdx
  OLECHAR *v20; // [rsp+20h] [rbp-30h] BYREF
  BSTR v21; // [rsp+28h] [rbp-28h] BYREF
  BSTR v22[2]; // [rsp+30h] [rbp-20h] BYREF
  BSTR bstrString; // [rsp+40h] [rbp-10h] BYREF

  v22[1] = (BSTR)-2LL;
  v6 = (const unsigned __int16 *)a2;
  v7 = 0LL;
  v21 = 0LL;
  v20 = 0LL;
  v8 = 0;
  if ( *(_WORD *)a2 )
  {
    v9 = -a2;
    while ( (unsigned int)(((__int64)v6 - a2) >> 1) <= a3 )
    {
      if ( v8 )
      {
        if ( *v6 == 34 )
          v8 = 0;
      }
      else
      {
        if ( *v6 == 32 || *v6 == 9 )
          break;
        v8 = *v6 == 34;
      }
      if ( !*++v6 )
        break;
    }
    if ( (unsigned __int64)v6 > a2 )
    {
      v10 = *(const OLECHAR **)ATL::CComBSTR::CComBSTR(
                                 (ATL::CComBSTR *)&bstrString,
                                 ((__int64)v6 - a2) >> 1,
                                 (const unsigned __int16 *)a2);
      ATL::CComBSTR::operator=(&v21, v10);
      SysFreeString(bstrString);
      v11 = *v6;
      if ( *v6 )
      {
        do
        {
          if ( (unsigned int)(((__int64)v6 + v9) >> 1) > a3 || v11 != 32 && v11 != 9 )
            break;
          v11 = *++v6;
        }
        while ( *v6 );
        if ( *v6 )
        {
          while ( 1 )
          {
            if ( (unsigned int)(((__int64)v6 - a2) >> 1) > a3 )
            {
LABEL_34:
              v7 = v20;
              goto LABEL_35;
            }
            v12 = v6;
            v13 = *v6;
            if ( *v6 )
            {
              do
              {
                if ( v13 == 37 )
                  break;
                if ( (unsigned int)(((__int64)v6 + v9) >> 1) > a3 )
                  break;
                v13 = *++v6;
              }
              while ( *v6 );
              if ( v6 > v12 )
              {
                v14 = *(const unsigned __int16 **)ATL::CComBSTR::CComBSTR((ATL::CComBSTR *)v22, v6 - v12, v12);
                ATL::CComBSTR::operator+=((const void **)&v20, v14);
                SysFreeString(v22[0]);
              }
            }
            v15 = *v6;
            if ( *v6 == 37 )
            {
              v16 = *++v6;
              v15 = *v6;
              if ( *v6 )
              {
                if ( (unsigned int)(((__int64)v6 - a2) >> 1) <= a3 )
                  break;
              }
            }
LABEL_33:
            if ( !v15 )
              goto LABEL_34;
          }
          if ( v16 == 42 )
          {
            v17 = (BSTR **)*((_QWORD *)this + 7);
          }
          else
          {
            if ( v16 <= 0x2Fu || v16 > 0x31u && v16 != 76 && v16 != 108 )
            {
              LOWORD(bstrString) = asc_18007F994[0];
              WORD2(bstrString) = asc_18007F994[2];
              WORD1(bstrString) = v16;
              p_bstrString = &bstrString;
LABEL_32:
              ATL::CComBSTR::operator+=((const void **)&v20, (const unsigned __int16 *)p_bstrString);
              v15 = *++v6;
              goto LABEL_33;
            }
            v17 = (BSTR **)*((_QWORD *)this + 6);
          }
          if ( v17 )
            p_bstrString = *v17;
          else
            p_bstrString = 0LL;
          goto LABEL_32;
        }
      }
    }
  }
LABEL_35:
  _bstr_t::operator=((_bstr_t::Data_t **)this + 6, v21);
  _bstr_t::operator=((_bstr_t::Data_t **)this + 7, v7);
  SysFreeString(v7);
  SysFreeString(v21);
  return 0LL;
}
// 18007F994: using guessed type wchar_t asc_18007F994[3];

//----- (000000018002DF50) ----------------------------------------------------
ATL::CComBSTR *__fastcall ATL::CComBSTR::CComBSTR(ATL::CComBSTR *this, UINT a2, const unsigned __int16 *a3)
{
  BSTR v4; // rax

  if ( a2 )
  {
    v4 = SysAllocStringLen(a3, a2);
    *(_QWORD *)this = v4;
    if ( !v4 )
      ATL::PrivateAtlThrow(-2147024882);
  }
  else
  {
    *(_QWORD *)this = 0LL;
  }
  return this;
}

//----- (000000018002DF90) ----------------------------------------------------
__int64 __fastcall Triggers::LogonTrigger::ToUbpmFormat(
        Triggers::LogonTrigger *this,
        const struct Triggers::TriggerExportOptions *a2,
        struct IUbpmRegistrationParams *a3)
{
  __int64 result; // rax
  __int64 v6; // rdi
  TSTime *v7; // rax
  struct _SYSTEMTIME *v8; // rbx
  TSTime *v9; // rax
  struct _SYSTEMTIME *v10; // rax
  __int128 v11; // [rsp+50h] [rbp-68h] BYREF
  __int128 v12; // [rsp+60h] [rbp-58h] BYREF
  struct _SYSTEMTIME v13; // [rsp+70h] [rbp-48h] BYREF
  struct _SYSTEMTIME v14; // [rsp+80h] [rbp-38h] BYREF

  result = Triggers::SessionBasedTrigger::ResolveUPN(this);
  if ( (int)result >= 0 )
  {
    v6 = *(_QWORD *)a3;
    v7 = (TSTime *)TSTime::ToGMT((__int128 *)((char *)this + 24), &v11);
    v8 = TSTime::ToSYSTEMTIME(v7, &v13);
    v9 = (TSTime *)TSTime::ToGMT((__int128 *)((char *)this + 8), &v12);
    v10 = TSTime::ToSYSTEMTIME(v9, &v14);
    return (*(__int64 (__fastcall **)(struct IUbpmRegistrationParams *, _QWORD, char *, _QWORD, _DWORD, char *, struct _SYSTEMTIME *, struct _SYSTEMTIME *))(v6 + 32))(
             a3,
             *((unsigned __int8 *)this + 64),
             (char *)this + 88,
             *((unsigned int *)this + 10),
             *((_DWORD *)this + 11),
             (char *)this + 48,
             v10,
             v8);
  }
  return result;
}

//----- (000000018002E060) ----------------------------------------------------
__int64 InitializeCmdlineProcessing(void)
{
  signed int v0; // ebx
  signed int LastError; // eax

  if ( ExpandEnvironmentStringsW(L"%SystemRoot%\\SYSTEM32\\cmd.exe", CmdExe::m_buffer, 0x105u) )
  {
    v0 = 0;
  }
  else
  {
    LastError = GetLastError();
    v0 = LastError;
    if ( LastError > 0 )
      v0 = (unsigned __int16)LastError | 0x80070000;
  }
  if ( v0 >= 0 )
    InitExtensions();
  return (unsigned int)v0;
}
// 1800B1270: using guessed type OLECHAR CmdExe::m_buffer[264];

//----- (000000018002E0A8) ----------------------------------------------------
void InitExtensions(void)
{
  wchar_t *v0; // rbx
  DWORD v1; // eax
  DWORD v2; // edi
  void *v3; // rax
  wchar_t *v4; // rsi
  wchar_t *v5; // rax
  __int64 v6; // rdi
  char *v7; // rax
  char *v8; // rbp
  unsigned int v9; // edx
  LPWSTR lpDst; // [rsp+60h] [rbp+8h] BYREF

  v0 = 0LL;
  lpDst = 0LL;
  v1 = ExpandEnvironmentStringsW(L"%pathext%", 0LL, 0);
  v2 = v1;
  if ( v1 )
  {
    v3 = operator new(saturated_mul(v1, 2uLL));
    wmi::AutoVectorPtr<unsigned char>::operator=((void **)&lpDst, v3);
    v0 = lpDst;
    if ( ExpandEnvironmentStringsW(L"%pathext%", lpDst, v2) )
    {
      if ( !wcschr(v0, 0x25u) && *v0 == 46 )
      {
        v4 = v0;
        ExtsFound = 0;
        do
        {
          v5 = wcschr(v4, 0x3Bu);
          if ( v5 )
          {
            v6 = v5 - v4;
          }
          else
          {
            v6 = -1LL;
            do
              ++v6;
            while ( v4[v6] );
          }
          if ( (int)v6 + 1 < (unsigned int)v6 )
            break;
          v7 = (char *)operator new(saturated_mul((unsigned int)(v6 + 1), 2uLL));
          v8 = v7;
          if ( !v7 )
            break;
          if ( (int)StringCchCopyNW(v7, (unsigned int)(v6 + 1), (char *)v4, (unsigned int)v6) < 0 )
          {
            operator delete(v8);
            break;
          }
          v9 = ExtsFound;
          (&PathExts)[ExtsFound] = (unsigned __int16 * near *)v8;
          ExtsFound = v9 + 1;
          v4 = wcschr(v4 + 1, 0x2Eu);
        }
        while ( v4 && ExtsFound < 0x64 );
      }
    }
  }
  operator delete(v0);
}
// 1800AF910: using guessed type unsigned __int16 * near *PathExts;
// 1800B01F0: using guessed type unsigned int ExtsFound;

//----- (000000018002E260) ----------------------------------------------------
DWORD __fastcall ItSpBatteryThesholdCallback(struct _ITSRV_GLOBAL_CONTEXT *a1, int a2, _DWORD *a3)
{
  int v4; // ebx
  struct _TP_WORK **v5; // rcx
  void (__stdcall *v6)(struct _TP_CALLBACK_INSTANCE *, void *, struct _TP_WORK *); // r8

  if ( a2 != 32787 || a3[4] != 4 )
    return 87;
  v4 = a3[5];
  EventManager::EvtReport(a1, &ItSpEvt_PowerNotificationReceived, L"BatteryThreshold", v4);
  if ( _InterlockedExchange((volatile __int32 *)a1 + 204, v4) == v4 )
    return 0;
  else
    return ItSpSubmitThreadpoolWork(v5, a1, v6);
}
// 18002E2A9: variable 'v5' is possibly undefined
// 18002E2A9: variable 'v6' is possibly undefined

//----- (000000018002E2D0) ----------------------------------------------------
DWORD __fastcall ItSpPowerSourceDetectionCallback(struct _ITSRV_GLOBAL_CONTEXT *a1, int a2, _DWORD *a3)
{
  int v4; // ebx
  struct _TP_WORK **v5; // rcx
  void (__stdcall *v6)(struct _TP_CALLBACK_INSTANCE *, void *, struct _TP_WORK *); // r8

  if ( a2 != 32787 || a3[4] != 4 )
    return 87;
  v4 = a3[5];
  EventManager::EvtReport(a1, &ItSpEvt_PowerNotificationReceived, L"PowerSource", v4);
  if ( _InterlockedExchange((volatile __int32 *)a1 + 200, v4) == v4 )
    return 0;
  else
    return ItSpSubmitThreadpoolWork(v5, a1, v6);
}
// 18002E319: variable 'v5' is possibly undefined
// 18002E319: variable 'v6' is possibly undefined

//----- (000000018002E340) ----------------------------------------------------
DWORD __fastcall ItSpLPEDetectionCallback(struct _ITSRV_GLOBAL_CONTEXT *a1, int a2, _DWORD *a3)
{
  int v4; // ebx
  struct _TP_WORK **v5; // rcx
  void (__stdcall *v6)(struct _TP_CALLBACK_INSTANCE *, void *, struct _TP_WORK *); // r8

  if ( a2 != 32787 || a3[4] != 4 )
    return 87;
  v4 = a3[5];
  EventManager::EvtReport(a1, &ItSpEvt_PowerNotificationReceived, L"LowPower", v4);
  if ( _InterlockedExchange((volatile __int32 *)a1 + 193, v4) == v4 )
    return 0;
  else
    return ItSpSubmitThreadpoolWork(v5, a1, v6);
}
// 1800498C9: variable 'v5' is possibly undefined
// 1800498C9: variable 'v6' is possibly undefined

//----- (000000018002E3B0) ----------------------------------------------------
void __fastcall JobMoniker::`default constructor closure'(JobMoniker *this)
{
  JobMoniker::JobMoniker(this, 0LL, 0LL);
}

//----- (000000018002E3C0) ----------------------------------------------------
__int64 __fastcall Triggers::SessionChangeTrigger::WriteXml(
        Triggers::SessionChangeTrigger *this,
        struct TaskXmlWriter *a2)
{
  BSTR *v2; // rax
  UINT v5; // eax
  __int64 *v6; // rax
  __int64 v7; // r9
  __int64 result; // rax

  v2 = (BSTR *)*((_QWORD *)this + 10);
  if ( v2 && *v2 )
    v5 = SysStringLen(*v2);
  else
    v5 = 0;
  if ( v5 )
  {
    v6 = (__int64 *)*((_QWORD *)this + 10);
    if ( v6 )
      v7 = *v6;
    else
      v7 = 0LL;
    result = TaskXmlWriter::StartElementWithAttribute((__int64)a2, 37, 109, v7);
  }
  else
  {
    result = TaskXmlWriter::StartElement((int *)a2, 37);
  }
  if ( (int)result >= 0 )
  {
    result = Triggers::SessionChangeTrigger::WriteInnerXml(this, a2);
    if ( (int)result >= 0 )
      return TaskXmlWriter::EndElement((__int64)a2);
  }
  return result;
}

//----- (000000018002E448) ----------------------------------------------------
__int64 __fastcall Triggers::SessionChangeTrigger::WriteInnerXml(
        Triggers::SessionChangeTrigger *this,
        struct TaskXmlWriter *a2)
{
  __int64 result; // rax
  unsigned int v5; // ebx
  _QWORD *v6; // r8
  __int64 v7; // [rsp+50h] [rbp+18h] BYREF

  result = Triggers::GenericTrigger::WriteInnerXml(this, a2);
  if ( (int)result >= 0 )
  {
    result = TaskXmlWriter::ElementSessionStateChange(a2, *((_DWORD *)this + 24));
    v5 = result;
    if ( (int)result >= 0 )
    {
      if ( *((_QWORD *)this + 11) )
      {
        v6 = (_QWORD *)*User::GetDomainAccount((Triggers::SessionChangeTrigger *)((char *)this + 88), &v7);
        if ( v6 )
          v6 = (_QWORD *)*v6;
        v5 = TaskXmlWriter::Element((__int64)a2, 36, (__int64)v6);
        _bstr_t::_Free((_bstr_t *)&v7);
      }
      return v5;
    }
  }
  return result;
}

//----- (000000018002E4A8) ----------------------------------------------------
__int64 __fastcall TaskXmlWriter::ElementSessionStateChange(TaskXmlWriter *this, int a2)
{
  int v2; // edx
  const unsigned __int16 *v3; // r8
  int v5; // edx
  int v6; // edx
  int v7; // edx
  int v8; // edx

  v2 = a2 - 1;
  if ( !v2 )
    goto LABEL_2;
  v5 = v2 - 1;
  if ( !v5 )
  {
    v3 = L"ConsoleDisconnect";
    return TaskXmlWriter::Element((__int64)this, 38, (__int64)v3);
  }
  v6 = v5 - 1;
  if ( !v6 )
  {
    v3 = L"RemoteConnect";
    return TaskXmlWriter::Element((__int64)this, 38, (__int64)v3);
  }
  v7 = v6 - 1;
  if ( !v7 )
  {
    v3 = L"RemoteDisconnect";
    return TaskXmlWriter::Element((__int64)this, 38, (__int64)v3);
  }
  v8 = v7 - 3;
  if ( !v8 )
  {
    v3 = L"SessionLock";
    return TaskXmlWriter::Element((__int64)this, 38, (__int64)v3);
  }
  if ( v8 == 1 )
    v3 = L"SessionUnlock";
  else
LABEL_2:
    v3 = L"ConsoleConnect";
  return TaskXmlWriter::Element((__int64)this, 38, (__int64)v3);
}

//----- (000000018002E4C8) ----------------------------------------------------
__int64 __fastcall Auditor::StartupAuditing(Auditor *this, const unsigned __int16 *a2, __int64 a3)
{
  AuthzAutoHandle *v3; // rdi
  __int64 result; // rax
  unsigned int LastError; // ebx
  DWORD v6; // [rsp+40h] [rbp+8h] BYREF
  int v7; // [rsp+44h] [rbp+Ch]

  v7 = HIDWORD(this);
  v3 = g_pAuditor;
  v6 = 1;
  result = Auditor::EnableNamedPrivilege(this, a2, a3, &v6);
  LastError = result;
  if ( !(_DWORD)result )
  {
    if ( !(unsigned int)AuthziInitializeAuditEventType(0LL, 3LL, 4698LL, 8LL, v3) )
      LastError = GetLastError();
    if ( !(unsigned int)AuthziInitializeAuditEventType(0LL, 3LL, 4699LL, 8LL, (char *)v3 + 8) )
      LastError = GetLastError();
    if ( !(unsigned int)AuthziInitializeAuditEventType(0LL, 3LL, 4700LL, 8LL, (char *)v3 + 16) )
      LastError = GetLastError();
    if ( !(unsigned int)AuthziInitializeAuditEventType(0LL, 3LL, 4701LL, 8LL, (char *)v3 + 24) )
      LastError = GetLastError();
    if ( !(unsigned int)AuthziInitializeAuditEventType(0LL, 3LL, 4702LL, 8LL, (char *)v3 + 32) )
      LastError = GetLastError();
    if ( LastError
      && WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x8000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x13u,
        (__int64)&WPP_0026520f6666348a6128473d4ed545c7_Traceguids,
        LastError);
    }
    return LastError;
  }
  return result;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 1800B9028: using guessed type __int64 __fastcall AuthziInitializeAuditEventType(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000018002E5FC) ----------------------------------------------------
__int64 __fastcall Auditor::EnableNamedPrivilege(Auditor *this, const unsigned __int16 *a2, __int64 a3, DWORD *a4)
{
  DWORD LastError; // ebx
  HANDLE CurrentProcess; // rax
  DWORD ReturnLength; // [rsp+30h] [rbp-40h] BYREF
  void *TokenHandle; // [rsp+38h] [rbp-38h] BYREF
  void **p_TokenHandle; // [rsp+40h] [rbp-30h] BYREF
  struct _TOKEN_PRIVILEGES NewState; // [rsp+48h] [rbp-28h] BYREF
  struct _TOKEN_PRIVILEGES PreviousState; // [rsp+58h] [rbp-18h] BYREF

  LastError = 0;
  ReturnLength = 0;
  TokenHandle = 0LL;
  p_TokenHandle = &TokenHandle;
  CurrentProcess = GetCurrentProcess();
  if ( OpenProcessToken(CurrentProcess, 0x28u, &TokenHandle)
    && (unsigned int)User::LookupPrivilege(L"SeAuditPrivilege", &NewState.Privileges[0].Luid)
    && (NewState.Privileges[0].Attributes = 2,
        NewState.PrivilegeCount = 1,
        AdjustTokenPrivileges(TokenHandle, 0, &NewState, 0x10u, &PreviousState, &ReturnLength)) )
  {
    if ( a4 )
    {
      if ( PreviousState.PrivilegeCount )
        *a4 = (PreviousState.Privileges[0].Attributes >> 1) & 1;
      else
        *a4 = 1;
    }
  }
  else
  {
    LastError = GetLastError();
  }
  tsched::HandleFree::~HandleFree(&p_TokenHandle);
  return LastError;
}

//----- (000000018002E6F8) ----------------------------------------------------
void __fastcall tsched::HandleFree::~HandleFree(void ***this)
{
  char *v2; // rcx

  v2 = (char *)**this;
  if ( (unsigned __int64)(v2 - 1) <= 0xFFFFFFFFFFFFFFFDuLL )
  {
    CloseHandle(v2);
    **this = 0LL;
  }
}

//----- (000000018002E734) ----------------------------------------------------
__int64 __fastcall User::LookupPrivilege(LPCWSTR lpName, PLUID lpLuid)
{
  unsigned int v2; // edi
  const wchar_t **v5; // r14
  unsigned int v6; // ebx
  wchar_t *v7; // rax
  char *v8; // rsi
  int v9; // edx
  int v10; // ecx

  v2 = 0;
  v5 = (const wchar_t **)&off_1800728D0;
  v6 = 1;
  while ( _wcsicmp(*v5, lpName) )
  {
    ++v2;
    v5 += 2;
    if ( v2 >= 0x23 )
      return LookupPrivilegeValueW(0LL, lpName, lpLuid);
  }
  v7 = (&off_1800728D0)[2 * v2];
  v8 = (char *)((char *)lpName - (char *)v7);
  do
  {
    v9 = *(unsigned __int16 *)&v8[(_QWORD)v7];
    v10 = *v7 - v9;
    if ( v10 )
      break;
    ++v7;
  }
  while ( v9 );
  if ( v10 )
  {
    v6 = 0;
    SetLastError(0x521u);
  }
  else
  {
    *lpLuid = (struct _LUID)*(&off_1800728D0 + 2 * v2 + 1);
  }
  return v6;
}
// 1800728D0: using guessed type wchar_t *off_1800728D0;

//----- (000000018002E7E0) ----------------------------------------------------
__int64 __fastcall Triggers::EventTrigger::ToUbpmFormat(
        Triggers::EventTrigger *this,
        const struct Triggers::TriggerExportOptions *a2,
        struct IUbpmRegistrationParams *a3)
{
  __int64 v3; // rdi
  TSTime *v6; // rax
  struct _SYSTEMTIME *v7; // rbx
  TSTime *v8; // rax
  struct _SYSTEMTIME *v9; // rax
  __int128 v11; // [rsp+40h] [rbp-68h] BYREF
  __int128 v12; // [rsp+50h] [rbp-58h] BYREF
  struct _SYSTEMTIME v13; // [rsp+60h] [rbp-48h] BYREF
  struct _SYSTEMTIME v14; // [rsp+70h] [rbp-38h] BYREF

  v3 = *(_QWORD *)a3;
  v6 = (TSTime *)TSTime::ToGMT((__int128 *)((char *)this + 24), &v11);
  v7 = TSTime::ToSYSTEMTIME(v6, &v13);
  v8 = (TSTime *)TSTime::ToGMT((__int128 *)((char *)this + 8), &v12);
  v9 = TSTime::ToSYSTEMTIME(v8, &v14);
  return (*(__int64 (__fastcall **)(struct IUbpmRegistrationParams *, _QWORD, _QWORD, _QWORD, char *, struct _SYSTEMTIME *, struct _SYSTEMTIME *))(v3 + 64))(
           a3,
           *((unsigned __int8 *)this + 64),
           *((unsigned int *)this + 10),
           *((unsigned int *)this + 11),
           (char *)this + 48,
           v9,
           v7);
}

//----- (000000018002E8A0) ----------------------------------------------------
__int64 __fastcall Triggers::BootTrigger::ToUbpmFormat(
        Triggers::BootTrigger *this,
        const struct Triggers::TriggerExportOptions *a2,
        struct IUbpmRegistrationParams *a3)
{
  BOOL v3; // esi
  __int64 v6; // rdi
  TSTime *v7; // rax
  struct _SYSTEMTIME *v8; // rbx
  TSTime *v9; // rax
  struct _SYSTEMTIME *v10; // rax
  __int128 v12; // [rsp+40h] [rbp-68h] BYREF
  __int128 v13; // [rsp+50h] [rbp-58h] BYREF
  struct _SYSTEMTIME v14; // [rsp+60h] [rbp-48h] BYREF
  struct _SYSTEMTIME v15; // [rsp+70h] [rbp-38h] BYREF

  v3 = 0;
  if ( *((_BYTE *)this + 64) )
    v3 = (*(_BYTE *)a2 & 2) != 0;
  v6 = *(_QWORD *)a3;
  v7 = (TSTime *)TSTime::ToGMT((__int128 *)((char *)this + 24), &v12);
  v8 = TSTime::ToSYSTEMTIME(v7, &v14);
  v9 = (TSTime *)TSTime::ToGMT((__int128 *)((char *)this + 8), &v13);
  v10 = TSTime::ToSYSTEMTIME(v9, &v15);
  return (*(__int64 (__fastcall **)(struct IUbpmRegistrationParams *, BOOL, _QWORD, _QWORD, char *, struct _SYSTEMTIME *, struct _SYSTEMTIME *))(v6 + 48))(
           a3,
           v3,
           *((unsigned int *)this + 10),
           *((unsigned int *)this + 11),
           (char *)this + 48,
           v10,
           v8);
}

//----- (000000018002E980) ----------------------------------------------------
__int64 __fastcall Triggers::RegistrationTrigger::ToUbpmFormat(
        Triggers::RegistrationTrigger *this,
        const struct Triggers::TriggerExportOptions *a2,
        struct IUbpmRegistrationParams *a3)
{
  unsigned int v6; // esi
  __int64 v7; // rdi
  TSTime *v8; // rax
  struct _SYSTEMTIME *v9; // rbx
  TSTime *v10; // rax
  struct _SYSTEMTIME *v11; // rax
  __int128 v13; // [rsp+50h] [rbp-78h] BYREF
  __int128 v14; // [rsp+60h] [rbp-68h] BYREF
  struct _SYSTEMTIME v15; // [rsp+70h] [rbp-58h] BYREF
  struct _SYSTEMTIME v16; // [rsp+80h] [rbp-48h] BYREF

  if ( !*((_BYTE *)this + 64) || (v6 = 1, (*(_BYTE *)a2 & 1) == 0) )
    v6 = 0;
  v7 = *(_QWORD *)a3;
  v8 = (TSTime *)TSTime::ToGMT((__int128 *)((char *)this + 24), &v13);
  v9 = TSTime::ToSYSTEMTIME(v8, &v15);
  v10 = (TSTime *)TSTime::ToGMT((__int128 *)((char *)this + 8), &v14);
  v11 = TSTime::ToSYSTEMTIME(v10, &v16);
  return (*(__int64 (__fastcall **)(struct IUbpmRegistrationParams *, _QWORD, _QWORD, _QWORD, char *, struct _SYSTEMTIME *, struct _SYSTEMTIME *, _DWORD, _QWORD))(v7 + 96))(
           a3,
           v6,
           *((unsigned int *)this + 10),
           *((unsigned int *)this + 11),
           (char *)this + 48,
           v11,
           v9,
           *((_DWORD *)a2 + 1),
           *((_QWORD *)a2 + 1));
}

//----- (000000018002EA70) ----------------------------------------------------
Triggers::EventTrigger *__fastcall Triggers::EventTrigger::`scalar deleting destructor'(
        Triggers::EventTrigger *this,
        char a2)
{
  std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::clear((_QWORD *)this + 14);
  operator delete(*((void **)this + 14));
  _bstr_t::_Free((Triggers::EventTrigger *)((char *)this + 104));
  _bstr_t::_Free((Triggers::EventTrigger *)((char *)this + 88));
  _bstr_t::_Free((Triggers::EventTrigger *)((char *)this + 80));
  *(_QWORD *)this = &Triggers::Trigger::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 180070988: using guessed type void *Triggers::Trigger::`vftable';

//----- (000000018002EAF4) ----------------------------------------------------
void __fastcall AutoEvtHandle::Close(void **this)
{
  char *v2; // rcx

  v2 = (char *)*this;
  if ( (unsigned __int64)(v2 - 1) <= 0xFFFFFFFFFFFFFFFDuLL )
  {
    EvtClose(v2);
    *this = (void *)-1LL;
  }
}

//----- (000000018002EB20) ----------------------------------------------------
__int64 __fastcall Triggers::IdleTrigger::ToUbpmFormat(
        Triggers::IdleTrigger *this,
        const struct Triggers::TriggerExportOptions *a2,
        struct IUbpmRegistrationParams *a3)
{
  int v3; // edi
  __int64 v4; // rsi
  TSTime *v7; // rax
  struct _SYSTEMTIME *v8; // rbx
  TSTime *v9; // rax
  struct _SYSTEMTIME *v10; // rax
  __int128 v12; // [rsp+50h] [rbp-68h] BYREF
  __int128 v13; // [rsp+60h] [rbp-58h] BYREF
  struct _SYSTEMTIME v14; // [rsp+70h] [rbp-48h] BYREF
  struct _SYSTEMTIME v15; // [rsp+80h] [rbp-38h] BYREF

  v3 = *((unsigned __int8 *)this + 88);
  v4 = *(_QWORD *)a3;
  v7 = (TSTime *)TSTime::ToGMT((__int128 *)((char *)this + 24), &v12);
  v8 = TSTime::ToSYSTEMTIME(v7, &v14);
  v9 = (TSTime *)TSTime::ToGMT((__int128 *)((char *)this + 8), &v13);
  v10 = TSTime::ToSYSTEMTIME(v9, &v15);
  return (*(__int64 (__fastcall **)(struct IUbpmRegistrationParams *, _QWORD, _QWORD, _QWORD, char *, struct _SYSTEMTIME *, struct _SYSTEMTIME *, int))(v4 + 56))(
           a3,
           *((unsigned __int8 *)this + 64),
           *((unsigned int *)this + 10),
           *((unsigned int *)this + 11),
           (char *)this + 48,
           v10,
           v8,
           v3);
}

//----- (000000018002EBF0) ----------------------------------------------------
__int64 __fastcall Triggers::MaintenanceTrigger::ToUbpmFormat(
        Triggers::MaintenanceTrigger *this,
        const struct Triggers::TriggerExportOptions *a2,
        struct IUbpmRegistrationParams *a3)
{
  return (*(__int64 (__fastcall **)(struct IUbpmRegistrationParams *, const struct Triggers::TriggerExportOptions *))(*(_QWORD *)a3 + 88LL))(
           a3,
           a2);
}

//----- (000000018002EC0C) ----------------------------------------------------
_QWORD *__fastcall User::CreateLocalAdmin(_QWORD *a1)
{
  int v2; // eax
  PVOID v3; // rbx
  int InformationPolicy; // eax
  PVOID v5; // r14
  int v6; // esi
  int v8; // ebx
  int v9; // ebx
  DWORD cbSid[2]; // [rsp+28h] [rbp-E0h] BYREF
  PVOID PolicyHandle; // [rsp+30h] [rbp-D8h] BYREF
  PVOID Buffer[3]; // [rsp+38h] [rbp-D0h] BYREF
  __int64 v13; // [rsp+50h] [rbp-B8h]
  NTSTATUS (__stdcall *v14)(LSA_HANDLE); // [rsp+58h] [rbp-B0h]
  PVOID v15; // [rsp+60h] [rbp-A8h]
  __int64 v16; // [rsp+68h] [rbp-A0h]
  NTSTATUS (__stdcall *v17)(PVOID); // [rsp+70h] [rbp-98h]
  PVOID v18; // [rsp+78h] [rbp-90h]
  char pExceptionObject[56]; // [rsp+80h] [rbp-88h] BYREF
  struct _LSA_OBJECT_ATTRIBUTES ObjectAttributes; // [rsp+B8h] [rbp-50h] BYREF
  char pSid[68]; // [rsp+E8h] [rbp-20h] BYREF

  Buffer[1] = (PVOID)-2LL;
  Buffer[2] = a1;
  cbSid[1] = 0;
  PolicyHandle = 0LL;
  ObjectAttributes.Length = 48;
  memset(&ObjectAttributes.RootDirectory, 0, 20);
  *(_OWORD *)&ObjectAttributes.SecurityDescriptor = 0LL;
  v2 = LsaOpenPolicy(0LL, &ObjectAttributes, 1u, &PolicyHandle);
  if ( v2 < 0 )
  {
    v8 = RtlNtStatusToDosError(v2);
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && *((char *)WPP_GLOBAL_Control + 28) < 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xCu, (__int64)&WPP_0a02ad6f637a3dce55ae09b3fc909c99_Traceguids, v8);
    }
    wmi::GenericException::GenericException((wmi::GenericException *)pExceptionObject, v8);
    CxxThrowException_0(pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
  }
  LOBYTE(v13) = 0;
  v14 = LsaClose;
  v3 = PolicyHandle;
  v15 = PolicyHandle;
  InformationPolicy = LsaQueryInformationPolicy(PolicyHandle, PolicyAccountDomainInformation, Buffer);
  if ( InformationPolicy < 0 )
  {
    v9 = RtlNtStatusToDosError(InformationPolicy);
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && *((char *)WPP_GLOBAL_Control + 28) < 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xDu, (__int64)&WPP_0a02ad6f637a3dce55ae09b3fc909c99_Traceguids, v9);
    }
    wmi::GenericException::GenericException((wmi::GenericException *)pExceptionObject, v9);
    CxxThrowException_0(pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
  }
  LOBYTE(v16) = 0;
  v17 = LsaFreeMemory;
  v5 = Buffer[0];
  v18 = Buffer[0];
  cbSid[0] = 68;
  CreateWellKnownSid(WinAccountAdministratorSid, *((PSID *)Buffer[0] + 2), pSid, cbSid);
  *a1 = 0LL;
  cbSid[1] = 1;
  v6 = User::FromSid((User::UserEntry **)a1, pSid, SidTypeUser);
  if ( v6 < 0 )
  {
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && *((char *)WPP_GLOBAL_Control + 28) < 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xEu, (__int64)&WPP_0a02ad6f637a3dce55ae09b3fc909c99_Traceguids, v6);
    }
    wmi::GenericException::GenericException((wmi::GenericException *)pExceptionObject, v6);
    CxxThrowException_0(pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
  }
  LsaFreeMemory(v5);
  LsaClose(v3);
  return a1;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018002EE94) ----------------------------------------------------
__int64 __fastcall Triggers::IdleTrigger::IdleTrigger(
        __int64 a1,
        const OLECHAR *a2,
        __int128 *a3,
        __int128 *a4,
        int a5,
        int a6,
        char a7,
        __int128 *a8,
        char a9)
{
  __int128 v11; // [rsp+40h] [rbp-38h] BYREF
  __int128 v12; // [rsp+50h] [rbp-28h] BYREF
  __int128 v13; // [rsp+60h] [rbp-18h] BYREF

  v12 = *a4;
  v11 = *a8;
  v13 = *a3;
  Triggers::GenericTrigger::GenericTrigger(a1, a2, &v13, &v12, a5, a6, a7, &v11);
  *(_QWORD *)a1 = &Triggers::IdleTrigger::`vftable';
  *(_BYTE *)(a1 + 88) = a9;
  return a1;
}
// 180070BF0: using guessed type void *Triggers::IdleTrigger::`vftable';
// 18002EE94: using guessed type __int128 var_18;

//----- (000000018002EF20) ----------------------------------------------------
__int64 __fastcall Triggers::EventTrigger::WriteXml(Triggers::EventTrigger *this, struct TaskXmlWriter *a2)
{
  BSTR *v2; // rax
  UINT v5; // eax
  __int64 result; // rax
  __int64 *v7; // rax
  __int64 v8; // r9

  v2 = (BSTR *)*((_QWORD *)this + 10);
  if ( v2 && *v2 )
    v5 = SysStringLen(*v2);
  else
    v5 = 0;
  if ( v5 )
  {
    v7 = (__int64 *)*((_QWORD *)this + 10);
    if ( v7 )
      v8 = *v7;
    else
      v8 = 0LL;
    result = TaskXmlWriter::StartElementWithAttribute((__int64)a2, 27, 109, v8);
  }
  else
  {
    result = TaskXmlWriter::StartElement((int *)a2, 27);
  }
  if ( (int)result >= 0 )
  {
    result = Triggers::EventTrigger::WriteInnerXml(this, a2);
    if ( (int)result >= 0 )
      return TaskXmlWriter::EndElement((__int64)a2);
  }
  return result;
}

//----- (000000018002EF88) ----------------------------------------------------
__int64 __fastcall Triggers::EventTrigger::WriteInnerXml(Triggers::EventTrigger *this, struct TaskXmlWriter *a2)
{
  __int64 result; // rax
  _QWORD *v5; // rax
  __int64 v6; // r8
  __int64 v7; // rdx
  __int64 v8; // r9
  _QWORD *v9; // rbx
  __int64 *v10; // rax
  __int64 v11; // rcx
  __int64 *v12; // rax
  __int64 v13; // r8
  __int64 v14; // rcx
  _QWORD *i; // rax

  result = Triggers::GenericTrigger::WriteInnerXml(this, a2);
  if ( (int)result >= 0 )
  {
    v5 = (_QWORD *)*((_QWORD *)this + 11);
    v6 = v5 ? *v5 : 0LL;
    result = TaskXmlWriter::Element((__int64)a2, 28, v6);
    if ( (int)result >= 0 )
    {
      if ( *((_QWORD *)this + 15) )
      {
        result = TaskXmlWriter::StartElement((int *)a2, 32);
        if ( (int)result >= 0 )
        {
          v9 = (_QWORD *)**((_QWORD **)this + 14);
          while ( v9 != *((_QWORD **)this + 14) )
          {
            v10 = (__int64 *)v9[4];
            if ( v10 )
              v11 = *v10;
            else
              v11 = 0LL;
            v12 = (__int64 *)v9[5];
            if ( v12 )
              v13 = *v12;
            else
              v13 = 0LL;
            result = TaskXmlWriter::ElementWithAttribute((__int64)a2, v7, v13, v8, v11);
            if ( (int)result < 0 )
              return result;
            if ( !*((_BYTE *)v9 + 25) )
            {
              v14 = v9[2];
              if ( *(_BYTE *)(v14 + 25) )
              {
                for ( i = (_QWORD *)v9[1]; !*((_BYTE *)i + 25) && v9 == (_QWORD *)i[2]; i = (_QWORD *)i[1] )
                  v9 = i;
              }
              else
              {
                i = std::_Tree_val<std::_Tree_simple_types<std::pair<_bstr_t const,std::list<_FILETIME> *>>>::_Min((_QWORD *)v14);
              }
              v9 = i;
            }
          }
          return TaskXmlWriter::EndElement((__int64)a2);
        }
      }
    }
  }
  return result;
}
// 180049C11: variable 'v7' is possibly undefined
// 180049C11: variable 'v8' is possibly undefined

//----- (000000018002EFF0) ----------------------------------------------------
__int64 __fastcall Triggers::EventTrigger::RegisterThyself(
        Triggers::EventTrigger *this,
        struct JobMoniker *a2,
        struct Triggers::TriggerOptions *a3)
{
  return (**(__int64 (__fastcall ***)(EventTrapMap *, struct JobMoniker *, Triggers::EventTrigger *))g_pEventTrapMap)(
           g_pEventTrapMap,
           a2,
           this);
}

//----- (000000018002F010) ----------------------------------------------------
void __fastcall JobsService::SCMEventLogNotificationCallback(char a1, char *a2)
{
  RTL_SRWLOCK *v3; // rbx
  struct _TP_WORK *ThreadpoolWork; // rax
  int LastError; // eax
  __int32 v6; // [rsp+30h] [rbp+8h] BYREF

  if ( (a1 & 9) != 0 )
  {
    _InterlockedExchange((volatile __int32 *)&JobsService::s_dwLastNotificationMaskReceived, a1);
    v6 = 0;
    _InterlockedExchange(&v6, 0);
    _InterlockedIncrement(&ShutdownMgr::s_sync);
    _InterlockedExchange(&v6, _InterlockedCompareExchange(&dword_1800B0A14, 0, 0) != 0);
    if ( _InterlockedCompareExchange(&v6, 0, 0) )
    {
      v3 = (RTL_SRWLOCK *)(a2 + 264);
      AcquireSRWLockExclusive((PSRWLOCK)a2 + 33);
      ThreadpoolWork = CreateThreadpoolWork(
                         (PTP_WORK_CALLBACK)JobsService::SCMEventLogNotificationWorker,
                         a2,
                         (PTP_CALLBACK_ENVIRON)(a2 + 184));
      if ( ThreadpoolWork )
      {
        SubmitThreadpoolWork(ThreadpoolWork);
      }
      else if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
             && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0
             && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        LastError = GetLastError();
        WPP_SF_D(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x1Du,
          (__int64)&WPP_e3966bf9b81b3ab085a9dfdc4dace9ef_Traceguids,
          LastError);
      }
      ReleaseSRWLockExclusive(v3);
    }
    _InterlockedExchange(&v6, 0);
    if ( _InterlockedExchangeAdd(&ShutdownMgr::s_sync, 0xFFFFFFFF) == 1 )
      SetEvent((HANDLE)_InterlockedCompareExchange64((volatile signed __int64 *)&ShutdownMgr::s_hEvent, -1LL, -1LL));
  }
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 1800B0A10: using guessed type int ShutdownMgr::s_sync;
// 1800B0A14: using guessed type int dword_1800B0A14;
// 1800B1260: using guessed type unsigned int JobsService::s_dwLastNotificationMaskReceived;

//----- (000000018002F0F0) ----------------------------------------------------
__int64 __fastcall Triggers::RegistrationTrigger::WriteXml(
        Triggers::RegistrationTrigger *this,
        struct TaskXmlWriter *a2)
{
  BSTR *v2; // rax
  UINT v5; // eax
  __int64 result; // rax
  __int64 *v7; // rax
  __int64 v8; // r9

  v2 = (BSTR *)*((_QWORD *)this + 10);
  if ( v2 && *v2 )
    v5 = SysStringLen(*v2);
  else
    v5 = 0;
  if ( v5 )
  {
    v7 = (__int64 *)*((_QWORD *)this + 10);
    if ( v7 )
      v8 = *v7;
    else
      v8 = 0LL;
    result = TaskXmlWriter::StartElementWithAttribute((__int64)a2, 23, 109, v8);
  }
  else
  {
    result = TaskXmlWriter::StartElement((int *)a2, 23);
  }
  if ( (int)result >= 0 )
  {
    result = Triggers::GenericTrigger::WriteInnerXml(this, a2);
    if ( (int)result >= 0 )
      return TaskXmlWriter::EndElement((__int64)a2);
  }
  return result;
}

//----- (000000018002F158) ----------------------------------------------------
_QWORD *__fastcall Triggers::RegistrationTrigger::RegistrationTrigger(
        _QWORD *a1,
        const OLECHAR *a2,
        __int128 *a3,
        __int128 *a4,
        int a5,
        int a6,
        char a7,
        __int128 *a8)
{
  __int128 v10; // [rsp+40h] [rbp-38h] BYREF
  __int128 v11; // [rsp+50h] [rbp-28h] BYREF
  __int128 v12; // [rsp+60h] [rbp-18h] BYREF

  v11 = *a4;
  v10 = *a8;
  v12 = *a3;
  Triggers::GenericTrigger::GenericTrigger((__int64)a1, a2, &v12, &v11, a5, a6, a7, &v10);
  *a1 = &Triggers::RegistrationTrigger::`vftable';
  return a1;
}
// 180070C68: using guessed type void *Triggers::RegistrationTrigger::`vftable';
// 18002F158: using guessed type __int128 var_18;

//----- (000000018002F1D8) ----------------------------------------------------
signed int ShutdownMgr::Initialize(void)
{
  HANDLE EventW; // rax
  __int64 v1; // rcx
  signed int result; // eax

  _InterlockedExchange(&ShutdownMgr::s_sync, 1);
  _InterlockedExchange(&dword_1800B0A14, 1);
  EventW = CreateEventW(0LL, 1, 0, 0LL);
  InterlockedAutoHandle::operator=(v1, (__int64)EventW);
  if ( _InterlockedCompareExchange64((volatile signed __int64 *)&ShutdownMgr::s_hEvent, -1LL, -1LL) )
    return 0;
  result = GetLastError();
  if ( result > 0 )
    return (unsigned __int16)result | 0x80070000;
  return result;
}
// 18002F208: variable 'v1' is possibly undefined
// 1800B0A10: using guessed type int ShutdownMgr::s_sync;
// 1800B0A14: using guessed type int dword_1800B0A14;

//----- (000000018002F234) ----------------------------------------------------
__int64 __fastcall JobsService::DetectBootStart(JobsService *this)
{
  unsigned int LastHrError; // ebx
  HANDLE v3; // rax
  tsched *v4; // rcx
  void *v6; // [rsp+30h] [rbp+8h] BYREF

  *(_WORD *)((char *)this + 129) = 257;
  LastHrError = 0;
  v3 = OpenEventW(0x100000u, 0, L"Global\\SC_AutoStartComplete");
  v6 = v3;
  if ( v3 )
    *((_BYTE *)this + 129) = WaitForSingleObject(v3, 0)
                          || (unsigned int)JobStore::IsOOBEInProgress()
                          || (unsigned int)JobStore::IsSystemSetupInProgress()
                          || (unsigned int)JobStore::IsWinPESetupInProgress()
                          || (unsigned int)IsSystemUpgradeInProgress();
  else
    LastHrError = tsched::GetLastHrError(v4);
  wmi::AutoHandle::Close(&v6);
  return LastHrError;
}
// 18002F2A8: variable 'v4' is possibly undefined

//----- (000000018002F2C0) ----------------------------------------------------
__int64 *__fastcall ATL::CAtlStringMgr::CAtlStringMgr(ATL::CAtlStringMgr *this, struct ATL::IAtlMemMgr *a2)
{
  __int64 *result; // rax

  dword_1800B0C10 = 2;
  ATL::g_strmgr = (__int64)&ATL::CAtlStringMgr::`vftable';
  qword_1800B0BF8 = (__int64)&ATL::g_strheap;
  qword_1800B0C08 = 0LL;
  dword_1800B0C18 = 0;
  result = &ATL::g_strmgr;
  qword_1800B0C00 = (__int64)&ATL::g_strmgr;
  return result;
}
// 180071800: using guessed type void *ATL::CAtlStringMgr::`vftable';
// 1800B0BD8: using guessed type __int64 ATL::g_strheap;
// 1800B0BF0: using guessed type __int64 ATL::g_strmgr;
// 1800B0BF8: using guessed type __int64 qword_1800B0BF8;
// 1800B0C00: using guessed type __int64 qword_1800B0C00;
// 1800B0C08: using guessed type __int64 qword_1800B0C08;
// 1800B0C10: using guessed type int dword_1800B0C10;
// 1800B0C18: using guessed type int dword_1800B0C18;

//----- (000000018002F30C) ----------------------------------------------------
void __fastcall ATL::CWin32Heap::~CWin32Heap(ATL::CWin32Heap *this)
{
  bool v1; // zf
  void *v2; // rcx

  v1 = *((_BYTE *)this + 16) == 0;
  *(_QWORD *)this = &ATL::CWin32Heap::`vftable';
  if ( !v1 )
  {
    v2 = (void *)*((_QWORD *)this + 1);
    if ( v2 )
      HeapDestroy(v2);
  }
}
// 180071830: using guessed type void *ATL::CWin32Heap::`vftable';

//----- (000000018002F344) ----------------------------------------------------
std::bad_alloc *__fastcall std::bad_alloc::bad_alloc(std::bad_alloc *this, const struct std::bad_alloc *a2)
{
  exception::exception(this, a2);
  *(_QWORD *)this = &std::bad_alloc::`vftable';
  return this;
}
// 180070CE0: using guessed type void *std::bad_alloc::`vftable';

//----- (000000018002F36C) ----------------------------------------------------
std::bad_alloc *__fastcall std::bad_alloc::bad_alloc(std::bad_alloc *this)
{
  char *v3; // [rsp+30h] [rbp+8h] BYREF

  v3 = "bad allocation";
  exception::exception(this, (const char *const *)&v3, 1);
  *(_QWORD *)this = &std::bad_alloc::`vftable';
  return this;
}
// 180070CE0: using guessed type void *std::bad_alloc::`vftable';

//----- (000000018002F3AC) ----------------------------------------------------
std::logic_error *__fastcall std::logic_error::logic_error(std::logic_error *this, const struct std::logic_error *a2)
{
  exception::exception(this, a2);
  *(_QWORD *)this = &std::length_error::`vftable';
  return this;
}
// 180070CF0: using guessed type void *std::length_error::`vftable';

//----- (000000018002F3D4) ----------------------------------------------------
std::length_error *__fastcall std::length_error::length_error(std::length_error *this, char *a2)
{
  char *v4; // [rsp+30h] [rbp+8h] BYREF

  v4 = a2;
  exception::exception(this, (const char *const *)&v4);
  *(_QWORD *)this = &std::length_error::`vftable';
  return this;
}
// 180070CF0: using guessed type void *std::length_error::`vftable';

//----- (000000018002F430) ----------------------------------------------------
std::bad_alloc *__fastcall std::bad_alloc::`vector deleting destructor'(std::bad_alloc *this, char a2)
{
  *(_QWORD *)this = &std::bad_alloc::`vftable';
  exception::~exception(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 180070CE0: using guessed type void *std::bad_alloc::`vftable';

//----- (000000018002F470) ----------------------------------------------------
std::length_error *__fastcall std::length_error::`scalar deleting destructor'(std::length_error *this, char a2)
{
  exception::~exception(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (000000018002F4D0) ----------------------------------------------------
void __fastcall __noreturn std::_Xlength_error(char *a1)
{
  char pExceptionObject[40]; // [rsp+20h] [rbp-28h] BYREF

  std::length_error::length_error((std::length_error *)pExceptionObject, a1);
  CxxThrowException_0(pExceptionObject, (_ThrowInfo *)&TI3_AVlength_error_std__);
}

//----- (000000018002F4FC) ----------------------------------------------------
void __fastcall __noreturn std::_Xout_of_range(char *a1)
{
  char pExceptionObject[40]; // [rsp+20h] [rbp-28h] BYREF

  std::length_error::length_error((std::length_error *)pExceptionObject, a1);
  CxxThrowException_0(pExceptionObject, (_ThrowInfo *)&TI3_AVout_of_range_std__);
}

//----- (000000018002F528) ----------------------------------------------------
const char *__fastcall std::_Syserror_map(int a1)
{
  _QWORD *v1; // rax

  v1 = &unk_1800711B0;
  if ( !"address family not supported" )
    return 0LL;
  while ( *(_DWORD *)v1 != a1 )
  {
    v1 += 2;
    if ( !v1[1] )
      return 0LL;
  }
  return (const char *)v1[1];
}

//----- (000000018002F558) ----------------------------------------------------
const char *__fastcall std::_Winerror_map(int a1)
{
  _QWORD *v1; // rax

  v1 = &unk_180070D00;
  if ( !"permission denied" )
    return 0LL;
  while ( *(_DWORD *)v1 != a1 )
  {
    v1 += 2;
    if ( !v1[1] )
      return 0LL;
  }
  return (const char *)v1[1];
}

//----- (000000018002F590) ----------------------------------------------------
__int64 pre_c_init()
{
  _QWORD *v0; // rax

  v0 = malloc(0x100uLL);
  _onexitbegin = v0;
  _onexitend = (__int64)v0;
  if ( !v0 )
    return 1LL;
  *v0 = 0LL;
  return 0LL;
}
// 1800B08C0: using guessed type __int64 _onexitend;

//----- (000000018002F5CC) ----------------------------------------------------
__int64 __fastcall CRT_INIT(__int64 a1, int a2, __int64 a3)
{
  int v5; // r14d
  PVOID StackBase; // rsi
  signed __int64 v7; // rax
  void (**v8)(void); // rbp
  void (**v9)(void); // rsi
  void *v10; // r12
  __int64 v11; // r15
  void (*v12)(void); // rax
  int v13; // ebp
  PVOID v14; // rsi
  signed __int64 v15; // rax
  __int64 (**v16)(void); // rsi
  int v17; // eax

  if ( !a2 )
  {
    if ( dword_1800B022C > 0 )
    {
      v5 = 0;
      --dword_1800B022C;
      StackBase = NtCurrentTeb()->NtTib.StackBase;
      while ( 1 )
      {
        v7 = _InterlockedCompareExchange64(&_native_startup_lock, (signed __int64)StackBase, 0LL);
        if ( !v7 )
          break;
        if ( (PVOID)v7 == StackBase )
        {
          v5 = 1;
          break;
        }
        Sleep(0x3E8u);
      }
      if ( _native_startup_state == 2 )
      {
        v8 = (void (**)(void))_onexitbegin;
        if ( _onexitbegin )
        {
          v9 = (void (**)(void))_onexitend;
          v10 = _onexitbegin;
          v11 = _onexitend;
          while ( --v9 >= v8 )
          {
            v12 = *v9;
            if ( *v9 )
            {
              *v9 = 0LL;
              v12();
              if ( v10 != _onexitbegin || v11 != _onexitend )
              {
                v10 = _onexitbegin;
                v8 = (void (**)(void))_onexitbegin;
                v11 = _onexitend;
                v9 = (void (**)(void))_onexitend;
              }
            }
          }
          free(v8);
          _onexitend = 0LL;
          _onexitbegin = 0LL;
        }
        _native_startup_state = 0;
        if ( !v5 )
          _InterlockedExchange64(&_native_startup_lock, 0LL);
      }
      else
      {
        amsg_exit_0(31LL);
      }
      return 1LL;
    }
    return 0LL;
  }
  if ( a2 == 1 )
  {
    v13 = 0;
    v14 = NtCurrentTeb()->NtTib.StackBase;
    while ( 1 )
    {
      v15 = _InterlockedCompareExchange64(&_native_startup_lock, (signed __int64)v14, 0LL);
      if ( !v15 )
        break;
      if ( (PVOID)v15 == v14 )
      {
        v13 = 1;
        break;
      }
      Sleep(0x3E8u);
    }
    if ( _native_startup_state )
    {
      amsg_exit_0(31LL);
    }
    else
    {
      v16 = (__int64 (**)(void))&_xi_a;
      _native_startup_state = 1;
      v17 = 0;
      if ( &_xi_a < (_UNKNOWN *)&_xi_z )
      {
        while ( !v17 )
        {
          if ( *v16 )
            v17 = (*v16)();
          if ( ++v16 >= &_xi_z )
          {
            if ( !v17 )
              goto LABEL_37;
            return 0LL;
          }
        }
        return 0LL;
      }
LABEL_37:
      initterm_0((_PVFV *)&_xc_a, (_PVFV *)&_xc_z);
      _native_startup_state = 2;
    }
    if ( !v13 )
      _InterlockedExchange64(&_native_startup_lock, 0LL);
    if ( _dyn_tls_init_callback && (unsigned int)IsNonwritableInCurrentImage(&_dyn_tls_init_callback) )
      ((void (__fastcall *)(__int64, __int64, __int64))_dyn_tls_init_callback)(a1, 2LL, a3);
    ++dword_1800B022C;
  }
  return 1LL;
}
// 18002FC95: using guessed type __int64 __fastcall amsg_exit_0(_QWORD);
// 18002FD00: using guessed type __int64 __fastcall IsNonwritableInCurrentImage(_QWORD);
// 180074898: using guessed type __int64 (*_xi_z)(void);
// 1800B022C: using guessed type int dword_1800B022C;
// 1800B08B0: using guessed type __int64 _native_startup_lock;
// 1800B08B8: using guessed type int _native_startup_state;
// 1800B08C0: using guessed type __int64 _onexitend;
// 1800B08D0: using guessed type __int64 _dyn_tls_init_callback;

//----- (000000018002F854) ----------------------------------------------------
__int64 __fastcall _DllMainCRTStartup(HINSTANCE hinstDLL, __int64 fdwReason, void *a3)
{
  DWORD v3; // edi
  unsigned int v5; // ebx
  int v6; // eax

  v3 = fdwReason;
  v5 = 1;
  if ( (unsigned int)fdwReason <= 1 )
    _native_dllmain_reason = fdwReason;
  if ( (_DWORD)fdwReason || dword_1800B022C )
  {
    if ( (unsigned int)(fdwReason - 1) > 1 )
      goto LABEL_13;
    if ( pRawDllMain )
    {
      v6 = dword_1800B0230;
      if ( (_DWORD)fdwReason == 1 )
        v6 = 1;
      dword_1800B0230 = v6;
      v5 = pRawDllMain(hinstDLL, fdwReason, a3);
    }
    if ( v5 )
    {
      v5 = CRT_INIT((__int64)hinstDLL, v3, (__int64)a3);
      if ( v5 )
      {
LABEL_13:
        v5 = DllMain(hinstDLL, v3, a3);
        if ( v3 == 1 && !v5 )
        {
          DllMain(hinstDLL, 0, 0LL);
          CRT_INIT((__int64)hinstDLL, 0, 0LL);
          if ( pRawDllMain )
            pRawDllMain(hinstDLL, 0LL, 0LL);
        }
        if ( !v3 || v3 == 3 )
        {
          v5 = CRT_INIT((__int64)hinstDLL, v3, (__int64)a3);
          if ( pRawDllMain )
          {
            if ( dword_1800B0230 )
              v5 = pRawDllMain(hinstDLL, v3, a3);
          }
        }
      }
    }
  }
  else
  {
    v5 = 0;
  }
  if ( v3 <= 1 )
    _native_dllmain_reason = -1;
  return v5;
}
// 1800B01B0: using guessed type int _native_dllmain_reason;
// 1800B022C: using guessed type int dword_1800B022C;
// 1800B0230: using guessed type int dword_1800B0230;
// 1800B08D8: using guessed type __int64 (__fastcall *pRawDllMain)(_QWORD, _QWORD, _QWORD);

//----- (000000018002FB00) ----------------------------------------------------
type_info *__fastcall type_info::`scalar deleting destructor'(type_info *this, char a2)
{
  type_info::~type_info(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 180074460: using guessed type void type_info::~type_info(type_info *__hidden this);

//----- (000000018002FB5C) ----------------------------------------------------
_onexit_t __cdecl onexit_0(_onexit_t Func)
{
  int (__cdecl *v3)(); // rbx
  void *v4; // [rsp+38h] [rbp+10h] BYREF
  __int64 v5; // [rsp+40h] [rbp+18h] BYREF

  v4 = _onexitbegin;
  if ( _onexitbegin == (void *)-1LL )
    return (_onexit_t)((__int64 (*)(void))_onexit)();
  lock_0(8LL);
  v4 = _onexitbegin;
  v5 = _onexitend;
  v3 = (int (__cdecl *)())_dllonexit_0(Func, &v4, &v5);
  _onexitbegin = v4;
  _onexitend = v5;
  unlock_0(8LL);
  return v3;
}
// 180030047: using guessed type __int64 __fastcall lock_0(_QWORD);
// 180030053: using guessed type __int64 __fastcall unlock_0(_QWORD);
// 18003005F: using guessed type __int64 __fastcall _dllonexit_0(_QWORD, _QWORD, _QWORD);
// 1800B08C0: using guessed type __int64 _onexitend;

//----- (000000018002FCB0) ----------------------------------------------------
__int64 __fastcall FindPESection(__int64 a1, unsigned __int64 a2)
{
  unsigned int v2; // r9d
  __int64 v3; // r8
  __int64 result; // rax
  unsigned __int64 v6; // rdx

  v2 = 0;
  v3 = a1 + *(int *)(a1 + 60);
  result = v3 + *(unsigned __int16 *)(v3 + 20) + 24LL;
  if ( !*(_WORD *)(v3 + 6) )
    return 0LL;
  while ( 1 )
  {
    v6 = *(unsigned int *)(result + 12);
    if ( a2 >= v6 && a2 < (unsigned int)(v6 + *(_DWORD *)(result + 8)) )
      break;
    ++v2;
    result += 40LL;
    if ( v2 >= *(unsigned __int16 *)(v3 + 6) )
      return 0LL;
  }
  return result;
}

//----- (000000018002FD60) ----------------------------------------------------
_BOOL8 __fastcall ValidateImageBase(__int64 a1)
{
  __int64 v1; // rax
  _BOOL8 result; // rax

  result = 0;
  if ( *(_WORD *)a1 == 23117 )
  {
    v1 = a1 + *(int *)(a1 + 60);
    if ( *(_DWORD *)v1 == 17744 && *(_WORD *)(v1 + 24) == 523 )
      return 1;
  }
  return result;
}

//----- (000000018002FDA0) ----------------------------------------------------
void __cdecl _security_init_cookie()
{
  uintptr_t v0; // rax
  uintptr_t v1; // rcx
  unsigned __int64 v2; // [rsp+30h] [rbp+10h] BYREF
  struct _FILETIME SystemTimeAsFileTime; // [rsp+38h] [rbp+18h] BYREF
  LARGE_INTEGER PerformanceCount; // [rsp+40h] [rbp+20h] BYREF

  SystemTimeAsFileTime = 0LL;
  v0 = _security_cookie;
  if ( _security_cookie == 0x2B992DDFA232LL )
  {
    GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
    v2 = (unsigned __int64)SystemTimeAsFileTime;
    v2 ^= GetCurrentProcessId();
    v2 ^= GetCurrentThreadId();
    v2 ^= (unsigned __int64)GetTickCount() << 24;
    v2 ^= (unsigned __int64)&v2 ^ GetTickCount();
    QueryPerformanceCounter(&PerformanceCount);
    v0 = (v2 ^ PerformanceCount.QuadPart ^ ((unsigned __int64)PerformanceCount.LowPart << 32)) & 0xFFFFFFFFFFFFLL;
    v1 = v0;
    if ( v0 == 0x2B992DDFA232LL )
    {
      v0 = 0x2B992DDFA233LL;
      v1 = 0x2B992DDFA233LL;
    }
    _security_cookie = v1;
  }
  _security_cookie_complement = ~v0;
}
// 1800B01C0: using guessed type __int64 _security_cookie_complement;

//----- (000000018003008E) ----------------------------------------------------
__int64 __fastcall load_CoInitializeEx(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_core_com_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (000000018003009A) ----------------------------------------------------
__int64 __fastcall _tailMerge_api_ms_win_core_com_l1_1_0_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 (__fastcall *Helper2)(__int64, __int64, __int64, __int64); // rax

  Helper2 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))_delayLoadHelper2(
                                                                          (__int64)&_DELAY_IMPORT_DESCRIPTOR_api_ms_win_core_com_l1_1_0_dll,
                                                                          v4);
  return Helper2(a1, a2, a3, a4);
}
// 1800300D4: variable 'v4' is possibly undefined
// 180091230: using guessed type int _DELAY_IMPORT_DESCRIPTOR_api_ms_win_core_com_l1_1_0_dll;

//----- (0000000180030119) ----------------------------------------------------
__int64 __fastcall load_GetServiceRegistryStateKey(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_service_core_l1_1_3_dll(a1, a2, a3, a4);
}

//----- (0000000180030125) ----------------------------------------------------
__int64 __fastcall _tailMerge_api_ms_win_service_core_l1_1_3_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 (__fastcall *Helper2)(__int64, __int64, __int64, __int64); // rax

  Helper2 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))_delayLoadHelper2(
                                                                          (__int64)&_DELAY_IMPORT_DESCRIPTOR_api_ms_win_service_core_l1_1_3_dll,
                                                                          v4);
  return Helper2(a1, a2, a3, a4);
}
// 18003015F: variable 'v4' is possibly undefined
// 180091250: using guessed type int _DELAY_IMPORT_DESCRIPTOR_api_ms_win_service_core_l1_1_3_dll;

//----- (00000001800301A4) ----------------------------------------------------
__int64 __fastcall load_CoUninitialize(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_core_com_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (00000001800301B6) ----------------------------------------------------
__int64 __fastcall load_OpenSCManagerW(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_service_management_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (00000001800301C2) ----------------------------------------------------
__int64 __fastcall _tailMerge_api_ms_win_service_management_l1_1_0_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 (__fastcall *Helper2)(__int64, __int64, __int64, __int64); // rax

  Helper2 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))_delayLoadHelper2(
                                                                          (__int64)&_DELAY_IMPORT_DESCRIPTOR_api_ms_win_service_management_l1_1_0_dll,
                                                                          v4);
  return Helper2(a1, a2, a3, a4);
}
// 1800301FC: variable 'v4' is possibly undefined
// 180091270: using guessed type int _DELAY_IMPORT_DESCRIPTOR_api_ms_win_service_management_l1_1_0_dll;

//----- (0000000180030241) ----------------------------------------------------
__int64 __fastcall load_OpenServiceW(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_service_management_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (0000000180030253) ----------------------------------------------------
__int64 __fastcall load_SubscribeServiceChangeNotifications(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_service_private_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (000000018003025F) ----------------------------------------------------
__int64 __fastcall _tailMerge_api_ms_win_service_private_l1_1_0_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 (__fastcall *Helper2)(__int64, __int64, __int64, __int64); // rax

  Helper2 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))_delayLoadHelper2(
                                                                          (__int64)&_DELAY_IMPORT_DESCRIPTOR_api_ms_win_service_private_l1_1_0_dll,
                                                                          v4);
  return Helper2(a1, a2, a3, a4);
}
// 180030299: variable 'v4' is possibly undefined
// 180091290: using guessed type int _DELAY_IMPORT_DESCRIPTOR_api_ms_win_service_private_l1_1_0_dll;

//----- (00000001800302DE) ----------------------------------------------------
__int64 __fastcall load_UnsubscribeServiceChangeNotifications(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_service_private_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (00000001800302F0) ----------------------------------------------------
__int64 __fastcall load_CloseServiceHandle(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_service_management_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (0000000180030302) ----------------------------------------------------
__int64 __fastcall load_NetGetJoinInformation(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_wkscli_dll(a1, a2, a3, a4);
}

//----- (000000018003030E) ----------------------------------------------------
__int64 __fastcall _tailMerge_wkscli_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 (__fastcall *Helper2)(__int64, __int64, __int64, __int64); // rax

  Helper2 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))_delayLoadHelper2(
                                                                          (__int64)&_DELAY_IMPORT_DESCRIPTOR_wkscli_dll,
                                                                          v4);
  return Helper2(a1, a2, a3, a4);
}
// 180030348: variable 'v4' is possibly undefined
// 1800912B0: using guessed type int _DELAY_IMPORT_DESCRIPTOR_wkscli_dll;

//----- (000000018003038D) ----------------------------------------------------
__int64 __fastcall load_NetApiBufferFree(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_netutils_dll(a1, a2, a3, a4);
}

//----- (0000000180030399) ----------------------------------------------------
__int64 __fastcall _tailMerge_netutils_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 (__fastcall *Helper2)(__int64, __int64, __int64, __int64); // rax

  Helper2 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))_delayLoadHelper2(
                                                                          (__int64)&_DELAY_IMPORT_DESCRIPTOR_netutils_dll,
                                                                          v4);
  return Helper2(a1, a2, a3, a4);
}
// 1800303D3: variable 'v4' is possibly undefined
// 1800912D0: using guessed type int _DELAY_IMPORT_DESCRIPTOR_netutils_dll;

//----- (0000000180030418) ----------------------------------------------------
__int64 __fastcall load_RegisterServiceCtrlHandlerExW(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_service_core_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (0000000180030424) ----------------------------------------------------
__int64 __fastcall _tailMerge_api_ms_win_service_core_l1_1_0_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 (__fastcall *Helper2)(__int64, __int64, __int64, __int64); // rax

  Helper2 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))_delayLoadHelper2(
                                                                          (__int64)&_DELAY_IMPORT_DESCRIPTOR_api_ms_win_service_core_l1_1_0_dll,
                                                                          v4);
  return Helper2(a1, a2, a3, a4);
}
// 18003045E: variable 'v4' is possibly undefined
// 1800912F0: using guessed type int _DELAY_IMPORT_DESCRIPTOR_api_ms_win_service_core_l1_1_0_dll;

//----- (00000001800304A3) ----------------------------------------------------
__int64 __fastcall load_SetServiceStatus(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_service_core_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (00000001800304B5) ----------------------------------------------------
__int64 __fastcall load_CoCreateInstance(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_core_com_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (00000001800304C7) ----------------------------------------------------
__int64 __fastcall load_ConvertSidToStringSidW(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_security_sddl_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (00000001800304D3) ----------------------------------------------------
__int64 __fastcall _tailMerge_api_ms_win_security_sddl_l1_1_0_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 (__fastcall *Helper2)(__int64, __int64, __int64, __int64); // rax

  Helper2 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))_delayLoadHelper2(
                                                                          (__int64)&_DELAY_IMPORT_DESCRIPTOR_api_ms_win_security_sddl_l1_1_0_dll,
                                                                          v4);
  return Helper2(a1, a2, a3, a4);
}
// 18003050D: variable 'v4' is possibly undefined
// 180091310: using guessed type int _DELAY_IMPORT_DESCRIPTOR_api_ms_win_security_sddl_l1_1_0_dll;

//----- (0000000180030552) ----------------------------------------------------
__int64 __fastcall load_IIDFromString(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_core_com_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (0000000180030564) ----------------------------------------------------
__int64 __fastcall load_LsaOpenPolicy(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_security_lsapolicy_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (0000000180030570) ----------------------------------------------------
__int64 __fastcall _tailMerge_api_ms_win_security_lsapolicy_l1_1_0_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 (__fastcall *Helper2)(__int64, __int64, __int64, __int64); // rax

  Helper2 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))_delayLoadHelper2(
                                                                          (__int64)&_DELAY_IMPORT_DESCRIPTOR_api_ms_win_security_lsapolicy_l1_1_0_dll,
                                                                          v4);
  return Helper2(a1, a2, a3, a4);
}
// 1800305AA: variable 'v4' is possibly undefined
// 180091330: using guessed type int _DELAY_IMPORT_DESCRIPTOR_api_ms_win_security_lsapolicy_l1_1_0_dll;

//----- (00000001800305F0) ----------------------------------------------------
__int64 __fastcall load_LsaClose(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_security_lsapolicy_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (0000000180030602) ----------------------------------------------------
__int64 __fastcall load_LsaQueryInformationPolicy(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_security_lsapolicy_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (0000000180030620) ----------------------------------------------------
__int64 __fastcall load_LsaFreeMemory(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_security_lsapolicy_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (0000000180030632) ----------------------------------------------------
__int64 __fastcall load_LookupAccountNameW(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_security_lsalookup_l2_1_0_dll(a1, a2, a3, a4);
}

//----- (000000018003063E) ----------------------------------------------------
__int64 __fastcall _tailMerge_api_ms_win_security_lsalookup_l2_1_0_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 (__fastcall *Helper2)(__int64, __int64, __int64, __int64); // rax

  Helper2 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))_delayLoadHelper2(
                                                                          (__int64)&_DELAY_IMPORT_DESCRIPTOR_api_ms_win_security_lsalookup_l2_1_0_dll,
                                                                          v4);
  return Helper2(a1, a2, a3, a4);
}
// 180030678: variable 'v4' is possibly undefined
// 180091350: using guessed type int _DELAY_IMPORT_DESCRIPTOR_api_ms_win_security_lsalookup_l2_1_0_dll;

//----- (00000001800306BD) ----------------------------------------------------
__int64 __fastcall load_GetUserNameExW(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_sspicli_dll(a1, a2, a3, a4);
}

//----- (00000001800306C9) ----------------------------------------------------
__int64 __fastcall _tailMerge_sspicli_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 (__fastcall *Helper2)(__int64, __int64, __int64, __int64); // rax

  Helper2 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))_delayLoadHelper2(
                                                                          (__int64)&_DELAY_IMPORT_DESCRIPTOR_SspiCli_dll,
                                                                          v4);
  return Helper2(a1, a2, a3, a4);
}
// 180030703: variable 'v4' is possibly undefined
// 180091370: using guessed type int _DELAY_IMPORT_DESCRIPTOR_SspiCli_dll;

//----- (0000000180030748) ----------------------------------------------------
__int64 __fastcall load_ConvertStringSidToSidW(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_security_sddl_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (000000018003075A) ----------------------------------------------------
__int64 __fastcall load_LookupAccountNameLocalW(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_security_lsalookup_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (0000000180030766) ----------------------------------------------------
__int64 __fastcall _tailMerge_api_ms_win_security_lsalookup_l1_1_0_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 (__fastcall *Helper2)(__int64, __int64, __int64, __int64); // rax

  Helper2 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))_delayLoadHelper2(
                                                                          (__int64)&_DELAY_IMPORT_DESCRIPTOR_api_ms_win_security_lsalookup_l1_1_0_dll,
                                                                          v4);
  return Helper2(a1, a2, a3, a4);
}
// 1800307A0: variable 'v4' is possibly undefined
// 180091390: using guessed type int _DELAY_IMPORT_DESCRIPTOR_api_ms_win_security_lsalookup_l1_1_0_dll;

//----- (00000001800307E5) ----------------------------------------------------
__int64 __fastcall load_LookupAccountSidLocalW(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_security_lsalookup_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (00000001800307F7) ----------------------------------------------------
__int64 __fastcall load_LookupPrivilegeValueW(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_security_lsalookup_l2_1_0_dll(a1, a2, a3, a4);
}

//----- (0000000180030809) ----------------------------------------------------
__int64 __fastcall load_AuthzFreeAuditEvent(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_authz_dll(a1, a2, a3, a4);
}

//----- (0000000180030815) ----------------------------------------------------
__int64 __fastcall _tailMerge_authz_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 (__fastcall *Helper2)(__int64, __int64, __int64, __int64); // rax

  Helper2 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))_delayLoadHelper2(
                                                                          (__int64)&_DELAY_IMPORT_DESCRIPTOR_AUTHZ_dll,
                                                                          v4);
  return Helper2(a1, a2, a3, a4);
}
// 18003084F: variable 'v4' is possibly undefined
// 1800913B0: using guessed type int _DELAY_IMPORT_DESCRIPTOR_AUTHZ_dll;

//----- (0000000180030894) ----------------------------------------------------
__int64 __fastcall load_AuthziLogAuditEvent(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_authz_dll(a1, a2, a3, a4);
}

//----- (00000001800308A6) ----------------------------------------------------
__int64 __fastcall load_GetSecurityInfo(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_security_provider_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (00000001800308B2) ----------------------------------------------------
__int64 __fastcall _tailMerge_api_ms_win_security_provider_l1_1_0_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 (__fastcall *Helper2)(__int64, __int64, __int64, __int64); // rax

  Helper2 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))_delayLoadHelper2(
                                                                          (__int64)&_DELAY_IMPORT_DESCRIPTOR_api_ms_win_security_provider_l1_1_0_dll,
                                                                          v4);
  return Helper2(a1, a2, a3, a4);
}
// 1800308EC: variable 'v4' is possibly undefined
// 1800913D0: using guessed type int _DELAY_IMPORT_DESCRIPTOR_api_ms_win_security_provider_l1_1_0_dll;

//----- (0000000180030931) ----------------------------------------------------
__int64 __fastcall load_ConvertStringSecurityDescriptorToSecurityDescriptorW(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4)
{
  return _tailMerge_api_ms_win_security_sddl_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (0000000180030943) ----------------------------------------------------
__int64 __fastcall load_StringFromGUID2(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_core_com_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (0000000180030955) ----------------------------------------------------
__int64 __fastcall load_SetSecurityInfo(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_security_provider_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (0000000180030967) ----------------------------------------------------
__int64 __fastcall load_GetNamedSecurityInfoW(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_security_provider_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (0000000180030979) ----------------------------------------------------
__int64 __fastcall load_LsaConnectUntrusted(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_sspicli_dll(a1, a2, a3, a4);
}

//----- (000000018003098B) ----------------------------------------------------
__int64 __fastcall load_CredDeleteW(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_security_credentials_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (0000000180030997) ----------------------------------------------------
__int64 __fastcall _tailMerge_api_ms_win_security_credentials_l1_1_0_dll(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4)
{
  __int64 v4; // rax
  __int64 (__fastcall *Helper2)(__int64, __int64, __int64, __int64); // rax

  Helper2 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))_delayLoadHelper2(
                                                                          (__int64)&_DELAY_IMPORT_DESCRIPTOR_api_ms_win_security_credentials_l1_1_0_dll,
                                                                          v4);
  return Helper2(a1, a2, a3, a4);
}
// 1800309D1: variable 'v4' is possibly undefined
// 1800913F0: using guessed type int _DELAY_IMPORT_DESCRIPTOR_api_ms_win_security_credentials_l1_1_0_dll;

//----- (0000000180030A16) ----------------------------------------------------
__int64 __fastcall load_CoCreateGuid(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_core_com_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (0000000180030A28) ----------------------------------------------------
__int64 __fastcall load_LsaDeregisterLogonProcess(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_sspicli_dll(a1, a2, a3, a4);
}

//----- (0000000180030A40) ----------------------------------------------------
__int64 __fastcall load_CredFree(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_security_credentials_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (0000000180030A52) ----------------------------------------------------
__int64 __fastcall load_LogonUserExExW(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_sspicli_dll(a1, a2, a3, a4);
}

//----- (0000000180030A64) ----------------------------------------------------
__int64 __fastcall load_LsaCallAuthenticationPackage(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_sspicli_dll(a1, a2, a3, a4);
}

//----- (0000000180030A76) ----------------------------------------------------
__int64 __fastcall load_CredEnumerateW(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_security_credentials_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (0000000180030A88) ----------------------------------------------------
__int64 __fastcall load_LsaLookupAuthenticationPackage(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_sspicli_dll(a1, a2, a3, a4);
}

//----- (0000000180030A9A) ----------------------------------------------------
__int64 __fastcall load_LsaFreeReturnBuffer(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_sspicli_dll(a1, a2, a3, a4);
}

//----- (0000000180030AAC) ----------------------------------------------------
__int64 __fastcall load_CredWriteW(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_security_credentials_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (0000000180030ABE) ----------------------------------------------------
__int64 __fastcall load_BCryptGetProperty(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_bcrypt_dll(a1, a2, a3, a4);
}

//----- (0000000180030ACA) ----------------------------------------------------
__int64 __fastcall _tailMerge_bcrypt_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 (__fastcall *Helper2)(__int64, __int64, __int64, __int64); // rax

  Helper2 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))_delayLoadHelper2(
                                                                          (__int64)&_DELAY_IMPORT_DESCRIPTOR_bcrypt_dll,
                                                                          v4);
  return Helper2(a1, a2, a3, a4);
}
// 180030B04: variable 'v4' is possibly undefined
// 180091410: using guessed type int _DELAY_IMPORT_DESCRIPTOR_bcrypt_dll;

//----- (0000000180030B49) ----------------------------------------------------
__int64 __fastcall load_BCryptOpenAlgorithmProvider(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_bcrypt_dll(a1, a2, a3, a4);
}

//----- (0000000180030B5B) ----------------------------------------------------
__int64 __fastcall load_BCryptFinishHash(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_bcrypt_dll(a1, a2, a3, a4);
}

//----- (0000000180030B6D) ----------------------------------------------------
__int64 __fastcall load_BCryptCloseAlgorithmProvider(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_bcrypt_dll(a1, a2, a3, a4);
}

//----- (0000000180030B7F) ----------------------------------------------------
__int64 __fastcall load_BCryptDestroyHash(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_bcrypt_dll(a1, a2, a3, a4);
}

//----- (0000000180030B91) ----------------------------------------------------
__int64 __fastcall load_BCryptHashData(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_bcrypt_dll(a1, a2, a3, a4);
}

//----- (0000000180030BA3) ----------------------------------------------------
__int64 __fastcall load_BCryptCreateHash(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_bcrypt_dll(a1, a2, a3, a4);
}

//----- (0000000180030BB5) ----------------------------------------------------
__int64 __fastcall load_PowerSettingRegisterNotification(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_power_setting_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (0000000180030BC1) ----------------------------------------------------
__int64 __fastcall _tailMerge_api_ms_win_power_setting_l1_1_0_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 (__fastcall *Helper2)(__int64, __int64, __int64, __int64); // rax

  Helper2 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))_delayLoadHelper2(
                                                                          (__int64)&_DELAY_IMPORT_DESCRIPTOR_api_ms_win_power_setting_l1_1_0_dll,
                                                                          v4);
  return Helper2(a1, a2, a3, a4);
}
// 180030BFB: variable 'v4' is possibly undefined
// 180091430: using guessed type int _DELAY_IMPORT_DESCRIPTOR_api_ms_win_power_setting_l1_1_0_dll;

//----- (0000000180030C40) ----------------------------------------------------
__int64 __fastcall load_PowerDeterminePlatformRole(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_powrprof_dll(a1, a2, a3, a4);
}

//----- (0000000180030C4C) ----------------------------------------------------
__int64 __fastcall _tailMerge_powrprof_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 (__fastcall *Helper2)(__int64, __int64, __int64, __int64); // rax

  Helper2 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))_delayLoadHelper2(
                                                                          (__int64)&_DELAY_IMPORT_DESCRIPTOR_POWRPROF_dll,
                                                                          v4);
  return Helper2(a1, a2, a3, a4);
}
// 180030C86: variable 'v4' is possibly undefined
// 180091450: using guessed type int _DELAY_IMPORT_DESCRIPTOR_POWRPROF_dll;

//----- (0000000180030CCB) ----------------------------------------------------
__int64 __fastcall load_PowerSettingUnregisterNotification(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_power_setting_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (0000000180030CFC) ----------------------------------------------------
__int64 __fastcall load_CoFreeUnusedLibraries(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_core_com_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (0000000180030D0E) ----------------------------------------------------
__int64 __fastcall load_NetIsServiceAccount(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_logoncli_dll(a1, a2, a3, a4);
}

//----- (0000000180030D1A) ----------------------------------------------------
__int64 __fastcall _tailMerge_logoncli_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 (__fastcall *Helper2)(__int64, __int64, __int64, __int64); // rax

  Helper2 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))_delayLoadHelper2(
                                                                          (__int64)&_DELAY_IMPORT_DESCRIPTOR_logoncli_dll,
                                                                          v4);
  return Helper2(a1, a2, a3, a4);
}
// 180030D54: variable 'v4' is possibly undefined
// 180091470: using guessed type int _DELAY_IMPORT_DESCRIPTOR_logoncli_dll;

//----- (0000000180030D99) ----------------------------------------------------
__int64 __fastcall load_DeriveAppContainerSidFromAppContainerName(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_userenv_dll(a1, a2, a3, a4);
}

//----- (0000000180030DA5) ----------------------------------------------------
__int64 __fastcall _tailMerge_userenv_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 (__fastcall *Helper2)(__int64, __int64, __int64, __int64); // rax

  Helper2 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))_delayLoadHelper2(
                                                                          (__int64)&_DELAY_IMPORT_DESCRIPTOR_USERENV_dll,
                                                                          v4);
  return Helper2(a1, a2, a3, a4);
}
// 180030DDF: variable 'v4' is possibly undefined
// 180091490: using guessed type int _DELAY_IMPORT_DESCRIPTOR_USERENV_dll;

//----- (0000000180030E24) ----------------------------------------------------
__int64 __fastcall load_AuthziFreeAuditEventType(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_authz_dll(a1, a2, a3, a4);
}

//----- (0000000180030E36) ----------------------------------------------------
__int64 __fastcall load_AuthziInitializeAuditParams(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_authz_dll(a1, a2, a3, a4);
}

//----- (0000000180030E48) ----------------------------------------------------
__int64 __fastcall load_AuthziInitializeAuditEvent(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_authz_dll(a1, a2, a3, a4);
}

//----- (0000000180030E5A) ----------------------------------------------------
__int64 __fastcall load_AuthziInitializeAuditEventType(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_authz_dll(a1, a2, a3, a4);
}

//----- (0000000180030E6C) ----------------------------------------------------
__int64 __fastcall load_WmiCloseBlock(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_wmiclnt_dll(a1, a2, a3, a4);
}

//----- (0000000180030E78) ----------------------------------------------------
__int64 __fastcall _tailMerge_wmiclnt_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 (__fastcall *Helper2)(__int64, __int64, __int64, __int64); // rax

  Helper2 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))_delayLoadHelper2(
                                                                          (__int64)&_DELAY_IMPORT_DESCRIPTOR_WMICLNT_dll,
                                                                          v4);
  return Helper2(a1, a2, a3, a4);
}
// 180030EB2: variable 'v4' is possibly undefined
// 1800914B0: using guessed type int _DELAY_IMPORT_DESCRIPTOR_WMICLNT_dll;

//----- (0000000180030EF7) ----------------------------------------------------
__int64 __fastcall load_WmiQueryAllDataW(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_wmiclnt_dll(a1, a2, a3, a4);
}

//----- (0000000180030F09) ----------------------------------------------------
__int64 __fastcall load_WmiOpenBlock(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_wmiclnt_dll(a1, a2, a3, a4);
}

//----- (0000000180030F1C) ----------------------------------------------------
char IsUMgrQueryUserContextPresent()
{
  char result; // al
  char v1; // [rsp+30h] [rbp+8h] BYREF

  if ( dword_1800B0858 == 1 )
    return 1;
  if ( dword_1800B0858 == 2 )
    return 0;
  v1 = 0;
  if ( (int)ApiSetQueryApiSetPresence_0(L"BD", &v1) < 0 )
    return 0;
  result = v1;
  dword_1800B0858 = 2 - (v1 != 0);
  return result;
}
// 1800315A0: using guessed type __int64 __fastcall ApiSetQueryApiSetPresence_0(_QWORD, _QWORD);
// 1800716B8: using guessed type wchar_t aBd[3];
// 1800B0858: using guessed type int dword_1800B0858;

//----- (0000000180030F70) ----------------------------------------------------
__int64 __fastcall load_UMgrQueryUserContext(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ext_ms_win_session_usermgr_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (0000000180030F7C) ----------------------------------------------------
__int64 __fastcall _tailMerge_ext_ms_win_session_usermgr_l1_1_0_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 (__fastcall *Helper2)(__int64, __int64, __int64, __int64); // rax

  Helper2 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))_delayLoadHelper2(
                                                                          (__int64)&_DELAY_IMPORT_DESCRIPTOR_ext_ms_win_session_usermgr_l1_1_0_dll,
                                                                          v4);
  return Helper2(a1, a2, a3, a4);
}
// 180030FB6: variable 'v4' is possibly undefined
// 1800914D0: using guessed type int _DELAY_IMPORT_DESCRIPTOR_ext_ms_win_session_usermgr_l1_1_0_dll;

//----- (0000000180030FFB) ----------------------------------------------------
__int64 __fastcall load_EvtClose(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ext_ms_win_wevtapi_eventlog_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (0000000180031007) ----------------------------------------------------
__int64 __fastcall _tailMerge_ext_ms_win_wevtapi_eventlog_l1_1_0_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 (__fastcall *Helper2)(__int64, __int64, __int64, __int64); // rax

  Helper2 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))_delayLoadHelper2(
                                                                          (__int64)&_DELAY_IMPORT_DESCRIPTOR_ext_ms_win_wevtapi_eventlog_l1_1_0_dll,
                                                                          v4);
  return Helper2(a1, a2, a3, a4);
}
// 180031041: variable 'v4' is possibly undefined
// 1800914F0: using guessed type int _DELAY_IMPORT_DESCRIPTOR_ext_ms_win_wevtapi_eventlog_l1_1_0_dll;

//----- (0000000180031086) ----------------------------------------------------
__int64 __fastcall load_EvtOpenChannelConfig(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ext_ms_win_wevtapi_eventlog_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (0000000180031098) ----------------------------------------------------
__int64 __fastcall load_EvtGetChannelConfigProperty(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ext_ms_win_wevtapi_eventlog_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (00000001800310AA) ----------------------------------------------------
__int64 __fastcall load_EvtSetChannelConfigProperty(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ext_ms_win_wevtapi_eventlog_l1_1_2_dll(a1, a2, a3, a4);
}

//----- (00000001800310B6) ----------------------------------------------------
__int64 __fastcall _tailMerge_ext_ms_win_wevtapi_eventlog_l1_1_2_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 (__fastcall *Helper2)(__int64, __int64, __int64, __int64); // rax

  Helper2 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))_delayLoadHelper2(
                                                                          (__int64)&_DELAY_IMPORT_DESCRIPTOR_ext_ms_win_wevtapi_eventlog_l1_1_2_dll,
                                                                          v4);
  return Helper2(a1, a2, a3, a4);
}
// 1800310F0: variable 'v4' is possibly undefined
// 180091510: using guessed type int _DELAY_IMPORT_DESCRIPTOR_ext_ms_win_wevtapi_eventlog_l1_1_2_dll;

//----- (0000000180031135) ----------------------------------------------------
__int64 __fastcall load_EvtSaveChannelConfig(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ext_ms_win_wevtapi_eventlog_l1_1_2_dll(a1, a2, a3, a4);
}

//----- (0000000180031147) ----------------------------------------------------
__int64 __fastcall load_EvtSubscribe(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ext_ms_win_wevtapi_eventlog_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (0000000180031159) ----------------------------------------------------
__int64 __fastcall load_EvtCreateRenderContext(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ext_ms_win_wevtapi_eventlog_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (000000018003116B) ----------------------------------------------------
__int64 __fastcall load_EvtRender(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ext_ms_win_wevtapi_eventlog_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (000000018003117D) ----------------------------------------------------
__int64 __fastcall load_WTSQuerySessionInformationW(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ext_ms_win_session_wtsapi32_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (0000000180031189) ----------------------------------------------------
__int64 __fastcall _tailMerge_ext_ms_win_session_wtsapi32_l1_1_0_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 (__fastcall *Helper2)(__int64, __int64, __int64, __int64); // rax

  Helper2 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))_delayLoadHelper2(
                                                                          (__int64)&_DELAY_IMPORT_DESCRIPTOR_ext_ms_win_session_wtsapi32_l1_1_0_dll,
                                                                          v4);
  return Helper2(a1, a2, a3, a4);
}
// 1800311C3: variable 'v4' is possibly undefined
// 180091530: using guessed type int _DELAY_IMPORT_DESCRIPTOR_ext_ms_win_session_wtsapi32_l1_1_0_dll;

//----- (0000000180031208) ----------------------------------------------------
__int64 __fastcall load_WTSFreeMemory(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ext_ms_win_session_wtsapi32_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (000000018003121A) ----------------------------------------------------
__int64 __fastcall load_WTSEnumerateSessionsW(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ext_ms_win_session_wtsapi32_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (000000018003122C) ----------------------------------------------------
__int64 __fastcall load_WTSQueryUserToken(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ext_ms_win_session_wtsapi32_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (000000018003123E) ----------------------------------------------------
__int64 __fastcall load_AssocQueryStringW(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_ext_ms_win_shell_shlwapi_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (000000018003124A) ----------------------------------------------------
__int64 __fastcall _tailMerge_ext_ms_win_shell_shlwapi_l1_1_0_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 (__fastcall *Helper2)(__int64, __int64, __int64, __int64); // rax

  Helper2 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))_delayLoadHelper2(
                                                                          (__int64)&_DELAY_IMPORT_DESCRIPTOR_ext_ms_win_shell_shlwapi_l1_1_0_dll,
                                                                          v4);
  return Helper2(a1, a2, a3, a4);
}
// 180031284: variable 'v4' is possibly undefined
// 180091550: using guessed type int _DELAY_IMPORT_DESCRIPTOR_ext_ms_win_shell_shlwapi_l1_1_0_dll;

//----- (00000001800312D8) ----------------------------------------------------
void __fastcall `eh vector constructor iterator'(char *a1, __int64 a2, int a3, void (__fastcall *a4)(char *))
{
  int i; // ebx

  for ( i = 0; i < a3; ++i )
  {
    a4(a1);
    a1 += a2;
  }
}

//----- (0000000180031358) ----------------------------------------------------
void __fastcall `eh vector destructor iterator'(char *a1, __int64 a2, int a3, void (__stdcall *a4)(void *))
{
  int v4; // ebx
  char *v6; // rdi

  v4 = a3;
  v6 = &a1[a2 * a3];
  while ( --v4 >= 0 )
  {
    v6 -= a2;
    _guard_dispatch_icall_fptr();
  }
}
// 180035730: using guessed type __int64 __fastcall guard_dispatch_icall_nop();
// 1800747C8: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();

//----- (00000001800313C8) ----------------------------------------------------
void __fastcall __ArrayUnwind(char *a1, __int64 a2, int a3, void (__fastcall *a4)(char *))
{
  while ( --a3 >= 0 )
  {
    a1 -= a2;
    a4(a1);
  }
}

//----- (0000000180031420) ----------------------------------------------------
void __fastcall Init_thread_footer(_DWORD *a1)
{
  __int64 v2; // rdx

  AcquireSRWLockExclusive(&stru_1800B0888);
  v2 = (unsigned int)tls_index;
  *a1 = ++Init_global_epoch;
  *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + v2) + 4LL) = Init_global_epoch;
  ReleaseSRWLockExclusive(&stru_1800B0888);
  WakeAllConditionVariable(&ConditionVariable);
}
// 1800B01D0: using guessed type int Init_global_epoch;
// 1800B0898: using guessed type int tls_index;

//----- (0000000180031490) ----------------------------------------------------
void __fastcall Init_thread_header(_DWORD *a1)
{
  AcquireSRWLockExclusive(&stru_1800B0888);
  while ( 1 )
  {
    if ( !*a1 )
    {
      *a1 = -1;
      goto LABEL_7;
    }
    if ( *a1 != -1 )
      break;
    SleepConditionVariableSRW(&ConditionVariable, &stru_1800B0888, 0xFFFFFFFF, 0);
  }
  *(_DWORD *)(*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer + (unsigned int)tls_index) + 4LL) = Init_global_epoch;
LABEL_7:
  ReleaseSRWLockExclusive(&stru_1800B0888);
}
// 1800B01D0: using guessed type int Init_global_epoch;
// 1800B0898: using guessed type int tls_index;

//----- (00000001800315AC) ----------------------------------------------------
__int64 __fastcall load_CreateXmlWriter(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_xmllite_dll(a1, a2, a3, a4);
}

//----- (00000001800315B8) ----------------------------------------------------
__int64 __fastcall _tailMerge_xmllite_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 (__fastcall *Helper2)(__int64, __int64, __int64, __int64); // rax

  Helper2 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))_delayLoadHelper2(
                                                                          (__int64)&_DELAY_IMPORT_DESCRIPTOR_XmlLite_dll,
                                                                          v4);
  return Helper2(a1, a2, a3, a4);
}
// 1800315F2: variable 'v4' is possibly undefined
// 180091570: using guessed type int _DELAY_IMPORT_DESCRIPTOR_XmlLite_dll;

//----- (0000000180031637) ----------------------------------------------------
__int64 __fastcall load_CreateXmlWriterOutputWithEncodingName(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_xmllite_dll(a1, a2, a3, a4);
}

//----- (0000000180031649) ----------------------------------------------------
__int64 __fastcall load_StringFromCLSID(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_core_com_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (000000018003165B) ----------------------------------------------------
__int64 __fastcall load_CoTaskMemFree(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_core_com_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (000000018003166D) ----------------------------------------------------
__int64 __fastcall load_CLSIDFromString(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_core_com_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (000000018003167F) ----------------------------------------------------
__int64 __fastcall load_CreateXmlReader(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_xmllite_dll(a1, a2, a3, a4);
}

//----- (0000000180031691) ----------------------------------------------------
__int64 __fastcall load_CredMarshalCredentialW(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_security_credentials_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (00000001800316A3) ----------------------------------------------------
__int64 __fastcall load_QueryServiceStatus(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return _tailMerge_api_ms_win_service_winsvc_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (00000001800316AF) ----------------------------------------------------
__int64 __fastcall _tailMerge_api_ms_win_service_winsvc_l1_1_0_dll(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 (__fastcall *Helper2)(__int64, __int64, __int64, __int64); // rax

  Helper2 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))_delayLoadHelper2(
                                                                          (__int64)&_DELAY_IMPORT_DESCRIPTOR_api_ms_win_service_winsvc_l1_1_0_dll,
                                                                          v4);
  return Helper2(a1, a2, a3, a4);
}
// 1800316E9: variable 'v4' is possibly undefined
// 180091590: using guessed type int _DELAY_IMPORT_DESCRIPTOR_api_ms_win_service_winsvc_l1_1_0_dll;

//----- (000000018003172E) ----------------------------------------------------
__int64 __fastcall load_ConvertSecurityDescriptorToStringSecurityDescriptorW(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4)
{
  return _tailMerge_api_ms_win_security_sddl_l1_1_0_dll(a1, a2, a3, a4);
}

//----- (0000000180031740) ----------------------------------------------------
BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
  REGHANDLE v4; // rcx

  if ( fdwReason )
  {
    if ( fdwReason == 1 )
    {
      TraceLoggingRegisterEx_EventRegister_EventSetInformation((ULONGLONG *)&dword_1800AFF68);
      WPP_INIT_CONTROL_ARRAY();
      WPP_GLOBAL_Control = &WPP_MAIN_CB;
      WPP_REGISTRATION_GUIDS = (__int64)&WPP_ThisDir_CTLGUID_JobCtlGuid;
      WppInitUm();
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x400) != 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xAu, (__int64)&WPP_e3966bf9b81b3ab085a9dfdc4dace9ef_Traceguids);
      }
      g_hInstance = hinstDLL;
      DisableThreadLibraryCalls(hinstDLL);
    }
  }
  else
  {
    v4 = RegHandle;
    RegHandle = 0LL;
    dword_1800AFF68 = 0;
    EventUnregister(v4);
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x400) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xBu, (__int64)&WPP_e3966bf9b81b3ab085a9dfdc4dace9ef_Traceguids);
    }
    WppCleanupUm();
  }
  return 1;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 1800B0960: using guessed type HINSTANCE g_hInstance;
// 1800B0C20: using guessed type __int64 WPP_MAIN_CB;
// 1800B0C48: using guessed type __int64 WPP_REGISTRATION_GUIDS;

//----- (000000018003184C) ----------------------------------------------------
__int64 __fastcall ExeTask::SetBatchLaunchCommand(BSTR **this)
{
  BSTR **v1; // r15
  BSTR **v2; // r14
  UINT v3; // ebx
  UINT v4; // eax
  unsigned int v5; // ecx
  UINT v6; // ebx
  char *v7; // rdi
  unsigned int v8; // ebx
  UINT v9; // eax
  __int64 v10; // rbx
  BSTR *v11; // rsi
  char *v12; // r8
  char *v13; // r8
  char *v14; // r8

  v1 = this + 7;
  v2 = this + 6;
  v3 = _bstr_t::length(this + 7);
  v4 = _bstr_t::length(v2);
  v5 = v4 + v3;
  if ( v4 + v3 < v4 )
    return (unsigned int)-805306219;
  if ( v5 + 2 < v5 )
    return (unsigned int)-805306219;
  v6 = v5 + 8;
  if ( v5 + 8 < v5 + 2 )
  {
    return (unsigned int)-805306219;
  }
  else
  {
    v7 = (char *)SysAllocStringLen(0LL, v6);
    if ( v7 )
    {
      v9 = v6 + 1;
      if ( v6 + 1 < v6 )
      {
        v8 = -805306219;
      }
      else
      {
        v10 = v9;
        StringCchCopyW(v7, v9, (char *)L"/c");
        v11 = *v2;
        if ( *v2 )
          v11 = (BSTR *)*v11;
        if ( *(_WORD *)v11 == 34 && *((_WORD *)v11 + _bstr_t::length(v2) - 1) == 34 )
        {
          StringCchCatW((unsigned __int16 *)v7, v10, (char *)L" \"");
          v12 = (char *)*v2;
          if ( *v2 )
            v12 = *(char **)v12;
        }
        else
        {
          StringCchCatW((unsigned __int16 *)v7, v10, (char *)L" \"\"");
          v13 = (char *)*v2;
          if ( *v2 )
            v13 = *(char **)v13;
          StringCchCatW((unsigned __int16 *)v7, v10, v13);
          v12 = (char *)L"\"";
        }
        StringCchCatW((unsigned __int16 *)v7, v10, v12);
        if ( _bstr_t::length(v1) )
        {
          StringCchCatW((unsigned __int16 *)v7, v10, (char *)L" ");
          v14 = (char *)*v1;
          if ( *v1 )
            v14 = *(char **)v14;
          StringCchCatW((unsigned __int16 *)v7, v10, v14);
        }
        StringCchCatW((unsigned __int16 *)v7, v10, (char *)L"\"");
        _bstr_t::operator=((_bstr_t::Data_t **)v2, CmdExe::m_buffer);
        _bstr_t::operator=((_bstr_t::Data_t **)v1, (const OLECHAR *)v7);
        v7 = 0LL;
        v8 = 0;
      }
      if ( v7 )
        SysFreeString((BSTR)v7);
    }
    else
    {
      return (unsigned int)-2147024882;
    }
  }
  return v8;
}
// 1800B1270: using guessed type OLECHAR CmdExe::m_buffer[264];

//----- (0000000180031A08) ----------------------------------------------------
bool __fastcall User::IsLocalSystem(PSID pSid2)
{
  User::UserEntry *LocalSystem; // rax
  char v4; // [rsp+38h] [rbp+10h] BYREF

  LocalSystem = User::GetLocalSystem((User::UserEntry *)&v4);
  LOBYTE(pSid2) = EqualSid(*(PSID *)(*(_QWORD *)LocalSystem + 32LL), pSid2);
  wmi::AutoRef<User::UserEntry>::Release(&v4);
  return (char)pSid2;
}
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);

//----- (0000000180031A50) ----------------------------------------------------
__int64 __fastcall Auditor::GetCallerProcessInfo(
        Auditor *this,
        unsigned int *a2,
        unsigned __int64 *a3,
        unsigned int *a4,
        unsigned int *a5)
{
  DWORD v8; // r12d
  void *v9; // rdi
  signed int LastError; // ebx
  HANDLE v11; // rax
  unsigned __int64 v12; // rax
  unsigned int v14; // [rsp+30h] [rbp-B1h]
  unsigned int v15; // [rsp+34h] [rbp-ADh]
  unsigned __int64 ProcessInformation; // [rsp+38h] [rbp-A9h] BYREF
  char v17[40]; // [rsp+40h] [rbp-A1h] BYREF
  unsigned int v18; // [rsp+68h] [rbp-79h]
  int RpcCallAttributes[2]; // [rsp+70h] [rbp-71h] BYREF
  char v20[52]; // [rsp+78h] [rbp-69h] BYREF
  unsigned int v21; // [rsp+ACh] [rbp-35h]
  DWORD dwProcessId; // [rsp+B0h] [rbp-31h]

  v14 = 0;
  v15 = 0;
  ProcessInformation = 0LL;
  v8 = 0;
  v9 = 0LL;
  if ( !a2 || !a3 || !a4 || !a5 )
  {
    LastError = -1073741811;
LABEL_19:
    if ( v9 )
      CloseHandle(v9);
    goto LABEL_21;
  }
  *a2 = 0;
  *a3 = 0LL;
  *a4 = 0;
  *a5 = 0;
  memset_0(v20, 0, 0x70uLL);
  RpcCallAttributes[0] = 3;
  RpcCallAttributes[1] = 16;
  if ( RpcServerInqCallAttributesW(0LL, RpcCallAttributes) )
    return (unsigned int)-1073741244;
  v8 = dwProcessId;
  v15 = v21;
  v11 = OpenProcess(0x1000u, 0, dwProcessId);
  v9 = v11;
  if ( v11 )
  {
    LastError = NtQueryInformationProcess(v11, ProcessLUIDDeviceMapsEnabled|0x40, &ProcessInformation, 8u, 0LL);
    if ( LastError >= 0 )
    {
      ProcessInformation |= (unsigned __int64)MEMORY[0x7FFE02C4] << 48;
      if ( !NtQueryInformationProcess(v9, ProcessBasicInformation, v17, 0x30u, 0LL) )
      {
        LastError = (int)GetLastError() > 0 ? (unsigned __int16)GetLastError() | 0xC0070000 : GetLastError();
        if ( LastError >= 0 )
          v14 = v18;
      }
    }
    goto LABEL_19;
  }
  if ( (int)GetLastError() > 0 )
    LastError = (unsigned __int16)GetLastError() | 0xC0070000;
  else
    LastError = GetLastError();
LABEL_21:
  if ( LastError >= 0 )
  {
    v12 = ProcessInformation;
    *a2 = v8;
    *a3 = v12;
    *a4 = v14;
    *a5 = v15;
  }
  return (unsigned int)LastError;
}
// 180031A50: using guessed type char var_B8[52];
// 180031A50: using guessed type char var_F0[40];

//----- (0000000180031C78) ----------------------------------------------------
unsigned __int16 *__fastcall Auditor::GetComputerNameDnsFullyQualified(Auditor *this)
{
  WCHAR *v1; // rax
  WCHAR *v2; // rbx
  WCHAR *v3; // rax
  DWORD nSize; // [rsp+30h] [rbp+8h] BYREF
  int v6; // [rsp+34h] [rbp+Ch]

  v6 = HIDWORD(this);
  nSize = 256;
  v1 = (WCHAR *)malloc(0x200uLL);
  v2 = v1;
  if ( !v1 )
    return 0LL;
  if ( !GetComputerNameExW(ComputerNameDnsFullyQualified, v1, &nSize) )
  {
    if ( GetLastError() != 234 )
      goto LABEL_6;
    v3 = (WCHAR *)realloc(v2, 2LL * nSize);
    v2 = v3;
    if ( !v3 )
      return 0LL;
    if ( !GetComputerNameExW(ComputerNameDnsFullyQualified, v3, &nSize) )
    {
LABEL_6:
      free(v2);
      return 0LL;
    }
  }
  return v2;
}

//----- (0000000180031D40) ----------------------------------------------------
void __fastcall lambda_0374aa0a5d1201b2358c6bce99369c58_::_lambda_invoker_cdecl_(
        PTP_CALLBACK_INSTANCE Instance,
        RTL_SRWLOCK *Context,
        PTP_TIMER Timer)
{
  wil::details::EnabledStateManager::OnTimer(Context);
}

//----- (0000000180031D50) ----------------------------------------------------
__int64 __fastcall _lambda_0ae89f7ca77040da3af7dd229dfecfb4_::_lambda_invoker_cdecl_(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        wil::details::FeatureStateManager *a4)
{
  wil::details::FeatureStateManager::OnStateChange(a4);
  return 0LL;
}

//----- (0000000180031D80) ----------------------------------------------------
void __fastcall lambda_5035b992506f4af81a770c5842624510_::_lambda_invoker_cdecl_(
        PTP_CALLBACK_INSTANCE Instance,
        PVOID Context,
        PTP_TIMER Timer)
{
  __int64 v4; // rdx
  __int64 v5; // r8
  RTL_SRWLOCK *v6; // [rsp+38h] [rbp+10h] BYREF

  if ( *(_BYTE *)Context )
  {
    wil::srwlock::lock_exclusive((RTL_SRWLOCK *)Context + 5, &v6);
    if ( *((_QWORD *)Context + 32) - *((_QWORD *)Context + 31) >= 0xCuLL )
    {
      wil_details_WriteSRUMWnfUsageBuffer((__int64 *)Context + 31, v4, v5);
      *((_QWORD *)Context + 32) = *((_QWORD *)Context + 31);
    }
    *((_BYTE *)Context + 64) = 0;
    wil::unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_SRWLOCK *,void (*)(_RTL_SRWLOCK *),&void ReleaseSRWLockExclusive(_RTL_SRWLOCK *),wistd::integral_constant<unsigned __int64,1>,_RTL_SRWLOCK *,_RTL_SRWLOCK *,0,std::nullptr_t>>>::~unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_SRWLOCK *,void (*)(_RTL_SRWLOCK *),&void ReleaseSRWLockExclusive(_RTL_SRWLOCK *),wistd::integral_constant<unsigned __int64,1>,_RTL_SRWLOCK *,_RTL_SRWLOCK *,0,std::nullptr_t>>>((__int64 *)&v6);
  }
}
// 180031DB7: variable 'v4' is possibly undefined
// 180031DB7: variable 'v5' is possibly undefined

//----- (0000000180031DF0) ----------------------------------------------------
void __fastcall _lambda_aa194dc0bf891154933407eb98fb868a_::_lambda_invoker_cdecl_(void *a1)
{
  wil::details::EnabledStateManager::OnTimer((RTL_SRWLOCK *)&wil::details::g_enabledStateManager);
}

//----- (0000000180031E10) ----------------------------------------------------
void __fastcall lambda_d51448ba32f8ef42e59400edd4566183_::_lambda_invoker_cdecl_(
        PTP_CALLBACK_INSTANCE Instance,
        RTL_SRWLOCK *Context,
        PTP_TIMER Timer)
{
  RTL_SRWLOCK *v4; // [rsp+38h] [rbp+10h] BYREF

  if ( LOBYTE(Context->Ptr) )
  {
    wil::srwlock::lock_exclusive(Context + 4, &v4);
    BYTE1(Context[8].Ptr) = 0;
    wil::unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_SRWLOCK *,void (*)(_RTL_SRWLOCK *),&void ReleaseSRWLockExclusive(_RTL_SRWLOCK *),wistd::integral_constant<unsigned __int64,1>,_RTL_SRWLOCK *,_RTL_SRWLOCK *,0,std::nullptr_t>>>::~unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_SRWLOCK *,void (*)(_RTL_SRWLOCK *),&void ReleaseSRWLockExclusive(_RTL_SRWLOCK *),wistd::integral_constant<unsigned __int64,1>,_RTL_SRWLOCK *,_RTL_SRWLOCK *,0,std::nullptr_t>>>((__int64 *)&v4);
    wil::details::FeatureStateManager::FlushUsage((wil::details::FeatureStateManager *)Context);
  }
}

//----- (0000000180031E5C) ----------------------------------------------------
void __fastcall wil::assign_null_to_opt_param<unsigned short const *>(_QWORD *a1)
{
  if ( a1 )
    *a1 = 0LL;
}

//----- (0000000180031E70) ----------------------------------------------------
void __fastcall wil::assign_to_opt_param<unsigned int>(_DWORD *a1)
{
  if ( a1 )
    *a1 = 0;
}

//----- (0000000180031E80) ----------------------------------------------------
__int64 __fastcall wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>(
        __int64 (__fastcall **a1)(_QWORD),
        _QWORD *a2)
{
  return (*a1)(*a2);
}

//----- (0000000180031E94) ----------------------------------------------------
__int64 __fastcall wil::unique_any_t<wil::details::unique_storage<wil::details::resource_policy<void *,void (*)(void *),&void wil::details::UnregisterWilFeatureConfigurationChange(void *),wistd::integral_constant<unsigned __int64,0>,void *,void *,0,std::nullptr_t>>>::~unique_any_t<wil::details::unique_storage<wil::details::resource_policy<void *,void (*)(void *),&void wil::details::UnregisterWilFeatureConfigurationChange(void *),wistd::integral_constant<unsigned __int64,0>,void *,void *,0,std::nullptr_t>>>(
        __int64 *a1)
{
  __int64 result; // rax
  __int64 v2; // [rsp+40h] [rbp+8h] BYREF
  void (__fastcall *v3)(wil::details *, void *); // [rsp+48h] [rbp+10h] BYREF

  result = *a1;
  if ( *a1 )
  {
    v2 = *a1;
    v3 = wil::details::UnregisterWilFeatureConfigurationChange;
    return wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>((__int64 (__fastcall **)(_QWORD))&v3, &v2);
  }
  return result;
}

//----- (0000000180031ED4) ----------------------------------------------------
bool __fastcall wil::details_abi::operator!=(_QWORD *a1, _QWORD *a2)
{
  return *a1 != *a2;
}

//----- (0000000180031EE8) ----------------------------------------------------
__int64 __fastcall wil::details::EnsureSubscribedToFeatureConfigurationChanges(wil::details *this)
{
  __int64 result; // rax

  result = (unsigned int)dword_1800B0A8C;
  if ( !dword_1800B0A8C )
    return wil::details::EnabledStateManager::EnsureSubscribedToFeatureConfigurationChangesImpl((RTL_SRWLOCK *)&wil::details::g_enabledStateManager);
  return result;
}
// 1800B0A8C: using guessed type int dword_1800B0A8C;

//----- (0000000180031F10) ----------------------------------------------------
__int64 __fastcall wil::details::EnabledStateManager::EnsureSubscribedToFeatureConfigurationChangesImpl(
        RTL_SRWLOCK *this)
{
  unsigned int Ptr_high; // ebx
  void *v3; // r9
  RTL_SRWLOCK *v4; // rsi
  RTL_SRWLOCK *v6; // [rsp+30h] [rbp+8h] BYREF

  Ptr_high = 0;
  if ( !LOBYTE(this->Ptr) )
    return 0LL;
  wil::srwlock::lock_exclusive(this + 1, &v6);
  v4 = this + 4;
  if ( this[4].Ptr )
  {
    Ptr_high = HIDWORD(this[3].Ptr);
  }
  else
  {
    v4->Ptr = 0LL;
    wil::details::WilApi_SubscribeFeatureStateChangeNotification(
      (wil::details *)&this[4],
      (struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ **)_lambda_fee8cea507d2413a58be13acfb66740a_::_lambda_invoker_cdecl_,
      (void (__stdcall *)(void *))this,
      v3);
    if ( v4->Ptr )
    {
      HIDWORD(this[3].Ptr) = 1;
      Ptr_high = 1;
    }
  }
  wil::unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_SRWLOCK *,void (*)(_RTL_SRWLOCK *),&void ReleaseSRWLockExclusive(_RTL_SRWLOCK *),wistd::integral_constant<unsigned __int64,1>,_RTL_SRWLOCK *,_RTL_SRWLOCK *,0,std::nullptr_t>>>::~unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_SRWLOCK *,void (*)(_RTL_SRWLOCK *),&void ReleaseSRWLockExclusive(_RTL_SRWLOCK *),wistd::integral_constant<unsigned __int64,1>,_RTL_SRWLOCK *,_RTL_SRWLOCK *,0,std::nullptr_t>>>((__int64 *)&v6);
  return Ptr_high;
}
// 180031F54: variable 'v3' is possibly undefined

//----- (0000000180031F90) ----------------------------------------------------
char __fastcall wil::details::FeatureStateManager::EnsureSubscribedToStateChangesUnderLock(
        wil::details::FeatureStateManager *this,
        __int64 a2,
        __int64 a3)
{
  _QWORD *v3; // r9
  char v4; // bl
  int v6; // eax

  v3 = (_QWORD *)((char *)this + 160);
  v4 = 0;
  if ( *((_QWORD *)this + 20) )
  {
    v6 = 0;
  }
  else
  {
    *v3 = 0LL;
    v6 = wil_details_RtlRegisterFeatureConfigurationChangeNotification(
           (__int64)_lambda_1ad7ecfab602a777ecf020873216a663_::_lambda_invoker_cdecl_,
           (__int64)this,
           a3,
           (__int64)v3);
  }
  if ( !v6
    && !(unsigned int)wil::details::FeatureStateManager::EnsureSubscribedToStateChangesUnderLock(
                        (wil::details **)this + 18,
                        0x418A073AA3BC7C75LL,
                        (__int64)this)
    && !(unsigned int)wil::details::FeatureStateManager::EnsureSubscribedToStateChangesUnderLock(
                        (wil::details **)this + 19,
                        0x418A073AA3BC88F5LL,
                        (__int64)this) )
  {
    return 1;
  }
  return v4;
}

//----- (0000000180032010) ----------------------------------------------------
__int64 __fastcall wil::details::FeatureStateManager::EnsureSubscribedToStateChangesUnderLock(
        wil::details **a1,
        __int64 a2,
        __int64 a3)
{
  bool v3; // zf
  wil::details *v6; // rdi
  struct __WIL__WNF_USER_SUBSCRIPTION *v7; // rdx
  unsigned int v9; // [rsp+40h] [rbp-20h] BYREF
  int v10; // [rsp+44h] [rbp-1Ch] BYREF
  char v11[4]; // [rsp+48h] [rbp-18h] BYREF
  DWORD LastError; // [rsp+4Ch] [rbp-14h]
  __int64 v13; // [rsp+50h] [rbp-10h] BYREF

  v3 = *a1 == 0LL;
  v13 = a2;
  if ( !v3 )
    return 0LL;
  v9 = 0;
  v10 = 0;
  wil_details_NtQueryWnfStateData((__int64)&v13, a2, a3, (__int64)&v9, 0LL, (__int64)&v10);
  v6 = *a1;
  if ( *a1 )
  {
    v11[0] = 0;
    LastError = GetLastError();
    wil::details::UnsubscribeWilWnf(v6, v7);
    wil::last_error_context::~last_error_context((wil::last_error_context *)v11);
  }
  *a1 = 0LL;
  return wil_details_RtlSubscribeWnfStateChangeNotification(
           (__int64)a1,
           v13,
           v9,
           (__int64)_lambda_0ae89f7ca77040da3af7dd229dfecfb4_::_lambda_invoker_cdecl_,
           a3);
}
// 18003207F: variable 'v7' is possibly undefined
// 180032010: using guessed type char var_18[4];

//----- (00000001800320D4) ----------------------------------------------------
__int64 __fastcall JobStore::GenerateTaskXmlFromCollections(
        __int64 a1,
        __int64 a2,
        Triggers::Trigulator *a3,
        Actions::ActionCollection *a4,
        char **a5)
{
  int v8; // esi
  int v9; // eax
  char *v10; // rdi
  BSTR *v11; // rax
  BSTR *v12; // rax
  CBstrWriter *v13; // rbx
  int v14; // eax
  int started; // esi
  struct Schema *v16; // r8
  struct Schema *v17; // r8
  _QWORD *v18; // r8
  __int64 v19; // r8
  unsigned __int16 *Copy; // rax
  char **v21; // rbx
  char *v22; // rax
  unsigned __int64 v23; // rsi
  void *v24; // rax
  BSTR *v26; // [rsp+28h] [rbp-B1h] BYREF
  __int64 v27; // [rsp+30h] [rbp-A9h] BYREF
  __int64 v28[2]; // [rsp+38h] [rbp-A1h] BYREF
  char v29[160]; // [rsp+48h] [rbp-91h] BYREF

  v28[1] = -2LL;
  v8 = *(_DWORD *)(*(_QWORD *)(a2 + 32) + 96LL);
  v9 = v8;
  v10 = 0LL;
  if ( !v8 )
    v9 = 65542;
  LODWORD(v27) = v9;
  v11 = (BSTR *)operator new(0x28uLL);
  v26 = v11;
  if ( v11 )
    v12 = (BSTR *)CBstrWriter::CBstrWriter((CBstrWriter *)v11);
  else
    v12 = 0LL;
  v26 = v12;
  v13 = 0LL;
  v28[0] = 0LL;
  if ( v12 )
  {
    v14 = _com_ptr_t<_com_IIID<IStream,&__s_GUID const _GUID_0000000c_0000_0000_c000_000000000046>>::_QueryInterface<ATL::CComPtr<IStream>>(
            v28,
            &v26);
    if ( (int)(v14 + 0x80000000) >= 0 && v14 != -2147467262 )
      _com_issue_error(v14);
    v13 = (CBstrWriter *)v28[0];
  }
  TaskXmlWriter::TaskXmlWriter((__int64)v29, v28, &v27);
  if ( *((_QWORD *)a4 + 1) )
  {
    started = TaskXmlWriter::StartDocument((__int64)v29, v8);
    if ( started >= 0 )
    {
      started = JobBucket::WriteRegistrationXml(*(JobBucket **)(a2 + 32), (struct TaskXmlWriter *)v29, v16);
      if ( started >= 0 )
      {
        started = JobBucket::WritePrincipalXml(*(JobBucket **)(a2 + 32), (struct TaskXmlWriter *)v29, v17);
        if ( started >= 0 )
        {
          started = JobBucket::WriteSettingsXml(
                      *(JobBucket **)(a2 + 32),
                      (struct TaskXmlWriter *)v29,
                      (struct Schema *)&v27);
          if ( started >= 0 )
          {
            v18 = *(_QWORD **)(*(_QWORD *)(a2 + 32) + 168LL);
            v19 = v18 ? *v18 : 0LL;
            if ( !v19 || (started = TaskXmlWriter::ElementCData((__int64)v29, 96, v19), started >= 0) )
            {
              started = Triggers::Trigulator::WriteXml(a3, (struct TaskXmlWriter *)v29);
              if ( started >= 0 )
              {
                started = Actions::ActionCollection::WriteXml(a4, (struct TaskXmlWriter *)v29);
                if ( started >= 0 )
                {
                  started = TaskXmlWriter::EndDocument((TaskXmlWriter *)v29);
                  if ( started >= 0 )
                  {
                    Copy = CBstrWriter::GetCopy(v13);
                    _bstr_t::_bstr_t((_bstr_t *)&v26, Copy);
                    v21 = (char **)v26;
                    if ( v26 )
                      v22 = (char *)*v26;
                    else
                      v22 = 0LL;
                    if ( v22
                      && (v23 = _bstr_t::length(&v26) + 1,
                          v24 = operator new(saturated_mul(v23, 2uLL)),
                          wmi::AutoVectorPtr<unsigned char>::operator=((void **)a5, v24),
                          *a5) )
                    {
                      if ( v21 )
                        v10 = *v21;
                      started = StringCchCopyW(*a5, v23, v10);
                    }
                    else
                    {
                      started = -2147024882;
                    }
                    _bstr_t::_Free((_bstr_t *)&v26);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  else
  {
    started = -2147418113;
  }
  TaskXmlWriter::~TaskXmlWriter((TaskXmlWriter *)v29);
  _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::~_com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>(v28);
  return (unsigned int)started;
}
// 1800321CE: variable 'v16' is possibly undefined
// 1800321E6: variable 'v17' is possibly undefined

//----- (0000000180032398) ----------------------------------------------------
__int64 __fastcall JobStore::GenerateTaskXmlFromRegistry(
        HKEY *a1,
        struct JobMoniker *a2,
        __int64 a3,
        unsigned int *a4,
        char **a5)
{
  int Bucket; // esi
  __int64 v9; // rcx
  __int64 v10; // rdi
  unsigned __int64 v11; // rdi
  unsigned __int16 *v12; // rbx
  unsigned __int64 i; // rcx
  unsigned __int16 v14; // ax
  LPVOID v15; // rax
  __int64 v16; // rdi
  CBstrWriter *v17; // rcx
  unsigned __int16 *Copy; // rax
  char *v19; // rdi
  UINT v20; // esi
  __int64 v21; // r14
  void *v22; // rax
  const wchar_t *Path; // rax
  __int64 v24; // rdx
  __int64 v25; // r8
  __int64 v27; // [rsp+38h] [rbp-61h] BYREF
  HKEY hKey; // [rsp+40h] [rbp-59h] BYREF
  __int64 v29; // [rsp+48h] [rbp-51h] BYREF
  BSTR pbstr; // [rsp+50h] [rbp-49h] BYREF
  WCHAR *v31; // [rsp+58h] [rbp-41h] BYREF
  unsigned __int16 *v32; // [rsp+60h] [rbp-39h]
  char v33[24]; // [rsp+68h] [rbp-31h] BYREF
  __int64 v34; // [rsp+80h] [rbp-19h]
  struct _FILETIME v35[8]; // [rsp+88h] [rbp-11h] BYREF

  v34 = -2LL;
  hKey = 0LL;
  Bucket = JobStore::RegOpenTaskKey(a1, a2, &hKey, 0x20019u);
  if ( Bucket >= 0 )
  {
    Triggers::Trigulator::Trigulator(v35);
    Bucket = Triggers::Trigulator::StreamIn((wmi::RefBase **)v35, hKey, 15, 0LL);
    if ( Bucket < 0 )
    {
LABEL_34:
      Triggers::Trigulator::~Trigulator((Triggers::Trigulator *)v35);
      goto LABEL_35;
    }
    Actions::ActionCollection::ActionCollection((Actions::ActionCollection *)v33);
    Bucket = Actions::ActionCollection::StreamIn((Actions::ActionCollection *)v33, hKey, 0LL);
    if ( Bucket < 0
      || (Bucket = Triggers::Trigulator::GetBucket((Triggers::Trigulator *)v35, a2), Bucket < 0)
      || (Bucket = JobStore::GenerateTaskXmlFromCollections(
                     v9,
                     (__int64)a2,
                     (Triggers::Trigulator *)v35,
                     (Actions::ActionCollection *)v33,
                     a5),
          Bucket < 0) )
    {
LABEL_33:
      Actions::ActionCollection::~ActionCollection((Actions::ActionCollection *)v33);
      goto LABEL_34;
    }
    if ( a4 && *a4 )
    {
      v10 = -1LL;
      do
        ++v10;
      while ( *(_WORD *)(a3 + 2 * v10) );
      v11 = v10 + 1;
      v12 = (unsigned __int16 *)operator new(saturated_mul(v11 + 1, 2uLL));
      v32 = v12;
      for ( i = 0LL; i < v11; ++i )
      {
        v14 = 0;
        if ( *(_WORD *)(a3 + 2 * i) != 92 )
          v14 = *(_WORD *)(a3 + 2 * i);
        v12[i] = v14;
      }
      v12[v11] = 0;
      AutoThreadUIPreferredLanguages::AutoThreadUIPreferredLanguages((AutoThreadUIPreferredLanguages *)&v31, v12, a4);
      v27 = 0LL;
      Bucket = StringReader::CreateStream((__int64)*a5, &v27);
      if ( Bucket < 0 )
        goto LABEL_27;
      v15 = operator new(0x460uLL);
      v29 = (__int64)v15;
      if ( v15 )
        v16 = TaskXmlReader::TaskXmlReader((__int64)v15, &v27, 0LL, 1);
      else
        v16 = 0LL;
      v29 = v16;
      if ( v16 )
      {
        _InterlockedIncrement((volatile signed __int32 *)(v16 + 8));
        v12 = v32;
      }
      Bucket = TaskXmlReader::ProcessXml((TaskXmlReader *)v16, 0LL);
      if ( Bucket < 0 )
      {
LABEL_26:
        wmi::AutoRef<FolderEnumerator>::~AutoRef<FolderEnumerator>(&v29);
LABEL_27:
        _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::~_com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>(&v27);
        AutoThreadUIPreferredLanguages::~AutoThreadUIPreferredLanguages(&v31);
        operator delete(v12);
        goto LABEL_33;
      }
      if ( *a5 )
        operator delete(*a5);
      *a5 = 0LL;
      pbstr = 0LL;
      v17 = *(CBstrWriter **)(v16 + 24);
      if ( !v17 )
        ATL::PrivateAtlThrow(-2147467259);
      Copy = CBstrWriter::GetCopy(v17);
      ATL::CComBSTR::Attach(&pbstr, Copy);
      v19 = (char *)pbstr;
      v20 = SysStringLen(pbstr);
      v21 = v20 + 1LL;
      v22 = operator new(saturated_mul(v21, 2uLL));
      wmi::AutoVectorPtr<unsigned char>::operator=((void **)a5, v22);
      Bucket = StringCchCopyNW(*a5, v21, v19, v20);
      if ( Bucket < 0 )
      {
        SysFreeString((BSTR)v19);
        goto LABEL_26;
      }
      SysFreeString((BSTR)v19);
      wmi::AutoRef<FolderEnumerator>::~AutoRef<FolderEnumerator>(&v29);
      _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::~_com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>(&v27);
      AutoThreadUIPreferredLanguages::~AutoThreadUIPreferredLanguages(&v31);
      operator delete(v12);
    }
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
    {
      Path = JobMoniker::GetPath(a2);
      WPP_SF_S_guid_(*((_QWORD *)WPP_GLOBAL_Control + 2), v24, v25, Path);
    }
    goto LABEL_33;
  }
LABEL_35:
  wmi::AutoRegKey::Close(&hKey);
  return (unsigned int)Bucket;
}
// 180032461: variable 'v9' is possibly undefined
// 180032691: variable 'v24' is possibly undefined
// 180032691: variable 'v25' is possibly undefined
// 1800090EC: using guessed type __int64 __fastcall wmi::AutoRef<FolderEnumerator>::~AutoRef<FolderEnumerator>(_QWORD);
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018003274C) ----------------------------------------------------
signed __int32 *__fastcall wil::details::FeatureImpl<__WilFeatureTraits_Feature_2510298426>::GetCachedFeatureEnabledState(
        wil::details *a1,
        signed __int32 *a2)
{
  signed __int32 v2; // eax
  int v5; // esi
  __int64 v6; // rcx
  signed __int32 v7; // eax
  signed __int32 v8; // r9d
  int v9; // edx
  int v11; // [rsp+30h] [rbp+8h]
  __int64 v12; // [rsp+38h] [rbp+10h] BYREF

  v2 = *(_DWORD *)a1;
  *a2 = *(_DWORD *)a1;
  if ( (v2 & 6) != 6 )
  {
    v5 = wil::details::EnsureSubscribedToFeatureConfigurationChanges(a1);
    wil::details::FeatureImpl<__WilFeatureTraits_Feature_2510298426>::GetCurrentFeatureEnabledState(v6, &v12);
    v7 = *a2;
    do
    {
      v8 = v7;
      *a2 = v7;
      v9 = v7;
      if ( v11 && (v7 & 2) == 0 )
      {
        v9 = v7 ^ ((unsigned __int16)v12 ^ (unsigned __int16)v7) & 0x9C1 | 2;
        *a2 = v9;
      }
      if ( (v7 & 4) == 0 )
      {
        v9 = ((unsigned __int16)v12 ^ (unsigned __int16)v9) & 0x400 ^ v9 | 4;
        *a2 = v9;
      }
      v7 = _InterlockedCompareExchange((volatile signed __int32 *)a1, v9, v7);
    }
    while ( v8 != v7 );
    if ( (v8 & 4) == 0 )
      wil::details::SubscribeFeatureStateCacheToConfigurationChanges((volatile signed __int32 *)a1, 3, v5);
    if ( (*(_BYTE *)a2 & 2) == 0 )
      *a2 ^= ((unsigned __int16)v12 ^ (unsigned __int16)*a2) & 0x9C1;
  }
  return a2;
}
// 180032781: variable 'v6' is possibly undefined

//----- (0000000180032814) ----------------------------------------------------
_QWORD *__fastcall wil::details::FeatureImpl<__WilFeatureTraits_Feature_2510298426>::GetCurrentFeatureEnabledState(
        __int64 a1,
        _QWORD *a2)
{
  __int64 (__fastcall *v2)(__int64, __int64); // rax
  int v3; // ebx
  int v5; // edx
  int v6; // r8d
  int v7; // ecx

  v2 = (__int64 (__fastcall *)(__int64, __int64))g_wil_details_internalGetFeatureEnabledState;
  v3 = 0;
  if ( g_wil_details_internalGetFeatureEnabledState
    || (v2 = (__int64 (__fastcall *)(__int64, __int64))g_wil_details_apiGetFeatureEnabledState) != 0LL )
  {
    v5 = v2(56309499LL, 3LL);
  }
  else
  {
    v5 = 0;
  }
  *a2 = 0LL;
  v6 = 64;
  if ( (v5 & 0xFFFFFF3F) != 0 )
  {
    if ( (v5 & 0xFFFFFF3F) == 2 )
      v3 = 64;
    v6 = v3;
  }
  v7 = 8 * (v5 & 0x80 | (4 * (v5 & 0x40 | (4 * (v5 & 3)))));
  *(_DWORD *)a2 = v6 | v7 | ((v6 | (unsigned int)v7) >> 6) & 1;
  return a2;
}
// 1800B14C8: using guessed type __int64 g_wil_details_internalGetFeatureEnabledState;
// 1800B15D0: using guessed type __int64 g_wil_details_apiGetFeatureEnabledState;

//----- (00000001800328B8) ----------------------------------------------------
__int64 __fastcall wil::details::EnabledStateManager::InvalidateFeatureStateCache(
        __int64 a1,
        volatile signed __int32 *a2,
        int a3)
{
  __int64 result; // rax

  result = a3 != 0 ? -5 : -2111;
  _InterlockedAnd(a2, result);
  return result;
}

//----- (00000001800328D4) ----------------------------------------------------
bool __fastcall wil::details::IsFeatureConfigured(
        wil::details *a1,
        unsigned int a2,
        unsigned __int8 a3,
        int a4,
        _DWORD *a5)
{
  int v5; // esi
  volatile __int32 *v7; // rbx
  int v11; // r15d
  bool v12; // di
  char v13; // dl
  int v14; // [rsp+68h] [rbp+20h] BYREF

  v5 = a3;
  v7 = (volatile __int32 *)&`wil::details::IsFeatureConfigured'::`2'::machineStoreProbe;
  if ( a4 )
    v7 = (volatile __int32 *)&`wil::details::IsFeatureConfigured'::`2'::userStoreProbe;
  if ( (*v7 & 2) != 0 && (*v7 & 1) == 0 )
    return 0;
  if ( (*v7 & 2) != 0 )
    return (unsigned int)wil_QueryFeatureState((__int64)a1, a2, a3, a4, 0LL, a5) != 0;
  v14 = 1;
  v11 = wil::details::EnsureSubscribedToFeatureConfigurationChanges(a1);
  v12 = (unsigned int)wil_QueryFeatureState((__int64)a1, a2, v5, a4, &v14, a5) != 0;
  v13 = _InterlockedExchange(v7, (v14 != 0) + 6);
  if ( !v14 && (v13 & 4) == 0 )
    wil::details::SubscribeFeatureStateCacheToConfigurationChanges(v7, 0, v11);
  return v12;
}

//----- (00000001800329D0) ----------------------------------------------------
LPVOID __fastcall wil::details::ProcessHeapAlloc(DWORD dwFlags, SIZE_T dwBytes)
{
  HANDLE ProcessHeap; // rax
  LPVOID v5; // rbx
  HANDLE v6; // rax

  ProcessHeap = GetProcessHeap();
  v5 = HeapAlloc(ProcessHeap, dwFlags, dwBytes);
  if ( wil::details::g_pfnRtlDisownModuleHeapAllocation )
  {
    v6 = GetProcessHeap();
    ((void (__fastcall *)(HANDLE, LPVOID))wil::details::g_pfnRtlDisownModuleHeapAllocation)(v6, v5);
  }
  return v5;
}
// 1800B1490: using guessed type int (__stdcall *wil::details::g_pfnRtlDisownModuleHeapAllocation)(void *, void *);

//----- (0000000180032A40) ----------------------------------------------------
void __fastcall wil::details::EnabledStateManager::QueueBackgroundUsageReporting(
        PVOID pv,
        __int64 a2,
        struct wil_details_FeatureReportingCache *a3)
{
  struct _TP_TIMER *ThreadpoolTimer; // rax
  int v6; // [rsp+20h] [rbp-18h] BYREF
  struct wil_details_FeatureReportingCache *v7; // [rsp+28h] [rbp-10h]
  char v8; // [rsp+40h] [rbp+8h] BYREF
  DWORD LastError; // [rsp+44h] [rbp+Ch]
  RTL_SRWLOCK *v10; // [rsp+58h] [rbp+20h] BYREF

  if ( *(_BYTE *)pv && !wil::ProcessShutdownInProgress((wil *)pv) )
  {
    wil::srwlock::lock_exclusive((RTL_SRWLOCK *)pv + 1, &v10);
    v6 = 56309499;
    v7 = a3;
    wil::details_abi::heap_buffer::push_back((void **)pv + 6, &v6, 0x10uLL);
    if ( !*((_BYTE *)pv + 24) )
    {
      if ( !*((_QWORD *)pv + 2) )
      {
        v8 = 0;
        LastError = GetLastError();
        ThreadpoolTimer = CreateThreadpoolTimer(
                            (PTP_TIMER_CALLBACK)lambda_0374aa0a5d1201b2358c6bce99369c58_::_lambda_invoker_cdecl_,
                            pv,
                            0LL);
        wil::details::unique_storage<wil::details::resource_policy<_TP_TIMER *,void (*)(_TP_TIMER *),&public: static void wil::details::DestroyThreadPoolTimer<wil::details::SystemThreadPoolMethods,0>::Destroy(_TP_TIMER *),wistd::integral_constant<unsigned __int64,0>,_TP_TIMER *,_TP_TIMER *,0,std::nullptr_t>>::reset(
          (struct _TP_TIMER **)pv + 2,
          ThreadpoolTimer);
        wil::last_error_context::~last_error_context((wil::last_error_context *)&v8);
      }
      wil::details::EnsureCoalescedTimer_SetTimer((struct _TP_TIMER **)pv + 2, (_BYTE *)pv + 24, 300000LL);
    }
    wil::unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_SRWLOCK *,void (*)(_RTL_SRWLOCK *),&void ReleaseSRWLockExclusive(_RTL_SRWLOCK *),wistd::integral_constant<unsigned __int64,1>,_RTL_SRWLOCK *,_RTL_SRWLOCK *,0,std::nullptr_t>>>::~unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_SRWLOCK *,void (*)(_RTL_SRWLOCK *),&void ReleaseSRWLockExclusive(_RTL_SRWLOCK *),wistd::integral_constant<unsigned __int64,1>,_RTL_SRWLOCK *,_RTL_SRWLOCK *,0,std::nullptr_t>>>((__int64 *)&v10);
  }
}

//----- (0000000180032B20) ----------------------------------------------------
__int64 (__fastcall *wil::details::FeatureImpl<__WilFeatureTraits_Feature_2510298426>::ReportUsage(
        volatile signed __int32 *a1,
        unsigned __int8 a2,
        char a3,
        ...))(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD)
{
  unsigned int v4; // edi
  unsigned int v5; // eax
  unsigned int v6; // r10d
  __int64 v7; // rdx
  __int64 (__fastcall *result)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD); // rax
  int v9; // [rsp+70h] [rbp+20h] BYREF
  __int16 v10; // [rsp+74h] [rbp+24h]
  int v11; // [rsp+80h] [rbp+30h] BYREF
  __int64 v12; // [rsp+88h] [rbp+38h] BYREF
  va_list va; // [rsp+88h] [rbp+38h]
  va_list va1; // [rsp+90h] [rbp+40h] BYREF

  va_start(va1, a3);
  va_start(va, a3);
  v12 = va_arg(va1, _QWORD);
  LOBYTE(v11) = a3;
  v4 = a2;
  if ( (*a1 & 4) == 0 )
    v12 = *(_QWORD *)wil::details::FeatureImpl<__WilFeatureTraits_Feature_2510298426>::GetCachedFeatureEnabledState(
                       (wil::details *)a1,
                       (signed __int32 *)va);
  BYTE4(v12) = 2;
  LODWORD(v12) = 0;
  v9 = 0;
  v10 = WORD2(v12);
  v11 = 3;
  v5 = wil_details_MapReportingKind(3, v4);
  result = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD))wil::details::ReportUsageToServiceDirect(
                                                                                                     a1 + 2,
                                                                                                     v7,
                                                                                                     (v6 >> 10) & 1,
                                                                                                     (v6 >> 11) & 1,
                                                                                                     v5);
  if ( (_DWORD)result )
  {
    result = g_wil_details_pfnFeatureLoggingHook;
    if ( g_wil_details_pfnFeatureLoggingHook )
      return (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD))g_wil_details_pfnFeatureLoggingHook(56309499LL, &v9, 0LL, v4, &v11, 0LL, 0, 1LL);
  }
  return result;
}
// 180032B9C: variable 'v7' is possibly undefined
// 180032B85: variable 'v6' is possibly undefined
// 1800B15E8: using guessed type __int64 (__fastcall *g_wil_details_pfnFeatureLoggingHook)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD);

//----- (0000000180032BF8) ----------------------------------------------------
__int64 __fastcall wil::details::ReportUsageToServiceDirect(
        volatile signed __int32 *a1,
        __int64 a2,
        int a3,
        __int64 a4,
        unsigned int a5)
{
  int *v7; // rax
  __int64 v8; // rdx
  unsigned int v9; // ebx
  __int128 v10; // xmm1
  __int64 v11; // xmm0_8
  __int64 v13; // [rsp+48h] [rbp-20h] BYREF

  v7 = wil_details_FeatureReporting_RecordUsageInCache((__int64)&v13, a1, a5);
  v9 = 0;
  v10 = *(_OWORD *)v7;
  v11 = *((_QWORD *)v7 + 2);
  if ( g_wil_details_RecordSRUMFeatureUsage && (!a5 || a5 - 100 <= 0x31) )
    g_wil_details_RecordSRUMFeatureUsage(56309499LL, a5, 1LL);
  if ( (_DWORD)v10 )
    wil::details::EnabledStateManager::QueueBackgroundUsageReporting(
      &wil::details::g_enabledStateManager,
      v8,
      (struct wil_details_FeatureReportingCache *)a1);
  if ( DWORD1(v10) )
    wil::details::WilApi_RecordFeatureUsage((wil::details *)0x35B36FB);
  if ( !(_DWORD)v11 )
    wil::details::EnabledStateManager::EnsureSubscribedToUsageFlush(
      (wil::details::EnabledStateManager *)&wil::details::g_enabledStateManager,
      (struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ **)_lambda_aa194dc0bf891154933407eb98fb868a_::_lambda_invoker_cdecl_);
  if ( a3 )
    wil::details::WilApi_RecordFeatureUsage((wil::details *)0x35B36FB);
  LOBYTE(v9) = (_DWORD)v11 == 0;
  return v9;
}
// 1800B14C0: invalid function type '?' has been ignored
// 180032C80: variable 'v8' is possibly undefined
// 1800B14C0: using guessed type __int64 (__fastcall *g_wil_details_RecordSRUMFeatureUsage)(_QWORD, _QWORD, _QWORD);

//----- (0000000180032D10) ----------------------------------------------------
__int64 __fastcall wil::details::RtlDisownModuleHeapAllocation(wil::details *this, void *a2, void *a3)
{
  FARPROC ProcAddress; // rax
  unsigned int v4; // ebx
  HMODULE NtDllModuleHandle; // rax

  ProcAddress = (FARPROC)`wil::details::RtlDisownModuleHeapAllocation'::`2'::s_pfnRtlDisownModuleHeapAllocation;
  v4 = 0;
  if ( `wil::details::RtlDisownModuleHeapAllocation'::`2'::s_pfnRtlDisownModuleHeapAllocation )
    return ((unsigned int (__fastcall *)(wil::details *, void *, void *))ProcAddress)(this, a2, a3);
  NtDllModuleHandle = wil_details_GetNtDllModuleHandle();
  ProcAddress = GetProcAddress(NtDllModuleHandle, "RtlDisownModuleHeapAllocation");
  `wil::details::RtlDisownModuleHeapAllocation'::`2'::s_pfnRtlDisownModuleHeapAllocation = (__int64)ProcAddress;
  if ( ProcAddress )
    return ((unsigned int (__fastcall *)(wil::details *, void *, void *))ProcAddress)(this, a2, a3);
  return v4;
}
// 180032D60: variable 'a3' is possibly undefined
// 1800747C8: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 1800B09C8: using guessed type __int64 `wil::details::RtlDisownModuleHeapAllocation'::`2'::s_pfnRtlDisownModuleHeapAllocation;

//----- (0000000180032D84) ----------------------------------------------------
HRESULT __stdcall StringCopyWorkerA(
        STRSAFE_LPSTR pszDest,
        size_t cchDest,
        size_t *pcchNewDestLength,
        STRSAFE_PCNZCH pszSrc,
        size_t cchToCopy)
{
  STRSAFE_LPSTR v5; // r8
  __int64 v6; // rax
  signed __int64 v7; // r9
  char v8; // cl
  STRSAFE_LPSTR v9; // rcx
  HRESULT result; // eax

  v5 = pszDest;
  if ( cchDest )
  {
    v6 = 2147483646LL;
    v7 = pszSrc - pszDest;
    do
    {
      if ( !v6 )
        break;
      v8 = v5[v7];
      if ( !v8 )
        break;
      *v5 = v8;
      --v6;
      ++v5;
      --cchDest;
    }
    while ( cchDest );
  }
  v9 = v5 - 1;
  result = cchDest == 0 ? 0x8007007A : 0;
  if ( cchDest )
    v9 = v5;
  *v9 = 0;
  return result;
}

//----- (0000000180032DD8) ----------------------------------------------------
HRESULT __stdcall StringVPrintfWorkerW_0(
        STRSAFE_LPWSTR pszDest,
        size_t cchDest,
        size_t *pcchNewDestLength,
        STRSAFE_LPCWSTR pszFormat,
        va_list argList)
{
  size_t v5; // rdi
  HRESULT v7; // ebx
  int v8; // eax

  v5 = cchDest - 1;
  v7 = 0;
  v8 = _vsnwprintf(pszDest, cchDest - 1, pszFormat, argList);
  if ( v8 < 0 || v8 > v5 )
  {
    pszDest[v5] = 0;
    return -2147024774;
  }
  else if ( v8 == v5 )
  {
    pszDest[v5] = 0;
  }
  return v7;
}

//----- (0000000180032E3C) ----------------------------------------------------
HRESULT __stdcall StringValidateDestA(STRSAFE_PCNZCH pszDest, size_t cchDest, const size_t cchMax)
{
  HRESULT result; // eax

  result = 0;
  if ( cchDest - 1 > 0x7FFFFFFE )
    return -2147024809;
  return result;
}

//----- (0000000180032E5C) ----------------------------------------------------
void __fastcall wil::details::SubscribeFeatureStateCacheToConfigurationChanges(
        volatile signed __int32 *a1,
        int a2,
        int a3)
{
  int v6; // [rsp+20h] [rbp-18h] BYREF
  volatile signed __int32 *v7; // [rsp+28h] [rbp-10h]
  RTL_SRWLOCK *v8; // [rsp+58h] [rbp+20h] BYREF

  if ( wil::details::g_enabledStateManager )
  {
    wil::srwlock::lock_exclusive((RTL_SRWLOCK *)&qword_1800B0A78, &v8);
    if ( !a3
      || a3 != dword_1800B0A8C
      || (v6 = a2, v7 = a1, !wil::details_abi::heap_buffer::push_back((void **)&xmmword_1800B0AC0, &v6, 0x10uLL)) )
    {
      _InterlockedAnd(a1, a2 != 0 ? -5 : -2111);
    }
    wil::unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_SRWLOCK *,void (*)(_RTL_SRWLOCK *),&void ReleaseSRWLockExclusive(_RTL_SRWLOCK *),wistd::integral_constant<unsigned __int64,1>,_RTL_SRWLOCK *,_RTL_SRWLOCK *,0,std::nullptr_t>>>::~unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_SRWLOCK *,void (*)(_RTL_SRWLOCK *),&void ReleaseSRWLockExclusive(_RTL_SRWLOCK *),wistd::integral_constant<unsigned __int64,1>,_RTL_SRWLOCK *,_RTL_SRWLOCK *,0,std::nullptr_t>>>((__int64 *)&v8);
  }
}
// 1800B0A78: using guessed type __int64 qword_1800B0A78;
// 1800B0A8C: using guessed type int dword_1800B0A8C;

//----- (0000000180032F00) ----------------------------------------------------
void __fastcall wil::details::UnregisterWilFeatureConfigurationChange(wil::details *this, void *a2)
{
  FARPROC ProcAddress; // rax
  HMODULE NtDllModuleHandle; // rax

  ProcAddress = (FARPROC)g_wil_details_pfnRtlUnregisterFeatureConfigurationChangeNotification;
  if ( g_wil_details_pfnRtlUnregisterFeatureConfigurationChangeNotification
    || (NtDllModuleHandle = wil_details_GetNtDllModuleHandle(),
        ProcAddress = GetProcAddress(NtDllModuleHandle, "RtlUnregisterFeatureConfigurationChangeNotification"),
        (g_wil_details_pfnRtlUnregisterFeatureConfigurationChangeNotification = (__int64)ProcAddress) != 0) )
  {
    ((void (__fastcall *)(wil::details *, void *))ProcAddress)(this, a2);
  }
}
// 180032F3F: variable 'a2' is possibly undefined
// 1800B0980: using guessed type __int64 g_wil_details_pfnRtlUnregisterFeatureConfigurationChangeNotification;

//----- (0000000180032F60) ----------------------------------------------------
__int64 __fastcall wil::details::WilApiImpl_GetFeatureEnabledState(
        wil::details *this,
        unsigned int a2,
        _DWORD *a3,
        int *a4)
{
  bool IsFeatureConfigured; // al
  unsigned int v5; // ecx
  unsigned int v6; // edx
  __int64 result; // rax
  __int128 v8; // [rsp+30h] [rbp-28h] BYREF
  __int64 v9; // [rsp+40h] [rbp-18h]

  v8 = 0LL;
  v9 = 0LL;
  IsFeatureConfigured = wil::details::IsFeatureConfigured(
                          (wil::details *)&v8,
                          (unsigned int)this,
                          (a2 & 0xFFFFFF7F) - 2 <= 1,
                          (a2 >> 7) & 1,
                          a3);
  v5 = 0;
  if ( IsFeatureConfigured )
    v5 = v8;
  v6 = v5 | 0x80;
  if ( !(_DWORD)v9 )
    v6 = v5;
  result = v6 | 0x40;
  if ( !HIDWORD(v9) )
    return v6;
  return result;
}

//----- (0000000180032FDC) ----------------------------------------------------
__int64 __fastcall wil::details::WilStringVPrintfWorkerA(
        char *a1,
        size_t a2,
        __int64 a3,
        const char *a4,
        va_list ArgList)
{
  unsigned __int64 v5; // rdi
  unsigned int v7; // ebx
  int v8; // eax

  v5 = a2 - 1;
  v7 = 0;
  v8 = _vsnprintf_s(a1, a2, a2 - 1, a4, ArgList);
  if ( v8 < 0 || v8 > v5 )
  {
    a1[v5] = 0;
    return (unsigned int)-2147024774;
  }
  else if ( v8 == v5 )
  {
    a1[v5] = 0;
  }
  return v7;
}

//----- (0000000180033040) ----------------------------------------------------
__int64 __fastcall JobStore::XmlLoadRawTaskFile(char **a1, JobMoniker *a2, void **a3)
{
  signed int XmlTaskPath; // edi
  WCHAR *v6; // rbx
  HANDLE FileW; // rax
  tsched *v8; // rcx
  __int64 v9; // rbp
  const wchar_t *Path; // rax
  const unsigned __int16 *v11; // rax
  EventManager *v12; // rcx
  const unsigned __int16 *v13; // r9
  HashCompute *v14; // rcx
  unsigned __int8 *v15; // rdx
  int v16; // eax
  unsigned int v17; // edi
  const wchar_t *v18; // rax
  const unsigned __int16 *v19; // rax
  EventManager *v20; // rcx
  const unsigned __int16 *v21; // r9
  __int64 v22; // rdx
  const wchar_t *v23; // rax
  const wchar_t *v24; // rax
  LPCWSTR lpFileName; // [rsp+40h] [rbp-78h] BYREF
  __int64 v27[3]; // [rsp+48h] [rbp-70h] BYREF
  unsigned __int8 Buf1[32]; // [rsp+60h] [rbp-58h] BYREF

  v27[2] = -2LL;
  lpFileName = 0LL;
  XmlTaskPath = JobStore::GetXmlTaskPath(a1, a2, (void **)&lpFileName);
  v6 = (WCHAR *)lpFileName;
  if ( XmlTaskPath >= 0 )
  {
    FileW = CreateFileW(lpFileName, 0x80000000, 5u, 0LL, 3u, 0x8000080u, 0LL);
    v27[0] = (__int64)FileW;
    v27[1] = (__int64)v6;
    v9 = -1LL;
    if ( FileW == (HANDLE)-1LL )
    {
      XmlTaskPath = tsched::GetLastHrError(v8);
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        Path = JobMoniker::GetPath(a2);
        WPP_SF_SD(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x65u,
          (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
          Path);
      }
      v11 = JobMoniker::GetPath(a2);
      v13 = L"Load-CreateFile";
    }
    else
    {
      XmlTaskPath = JobStore::LoadFileToBuffer(FileW, a3);
      if ( XmlTaskPath >= 0 )
      {
        LODWORD(lpFileName) = 32;
        v15 = (unsigned __int8 *)*a3;
        do
          ++v9;
        while ( *(_WORD *)&v15[2 * v9] );
        v16 = HashCompute::ComputeHash(v14, v15, 2 * (int)v9, Buf1, (unsigned int *)&lpFileName);
        v17 = v16;
        if ( v16 )
        {
          if ( v16 > 0 )
            v17 = (unsigned __int16)v16 | 0x80070000;
          if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
            && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
            && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
          {
            v18 = JobMoniker::GetPath(a2);
            WPP_SF_SD(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              0x66u,
              (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
              v18);
          }
          v19 = JobMoniker::GetPath(a2);
          v21 = L"Load-ComputeHash";
        }
        else
        {
          v22 = *((_QWORD *)a2 + 4);
          if ( (-(__int64)(*(_DWORD *)(v22 + 60) != 0) & (v22 + 28)) != 0 )
          {
            if ( !memcmp_0(Buf1, (const void *)((v22 + 28) & -(__int64)(*(_DWORD *)(v22 + 60) != 0)), 0x20uLL) )
            {
              XmlTaskPath = 0;
              goto LABEL_35;
            }
            v17 = -2147216607;
            if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
              && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
              && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
            {
              v24 = JobMoniker::GetPath(a2);
              WPP_SF_SD(
                *((_QWORD *)WPP_GLOBAL_Control + 2),
                0x68u,
                (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
                v24);
            }
            v19 = JobMoniker::GetPath(a2);
            v21 = L"Load-CompareHash";
          }
          else
          {
            v17 = -2147216607;
            if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
              && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
              && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
            {
              v23 = JobMoniker::GetPath(a2);
              WPP_SF_SD(
                *((_QWORD *)WPP_GLOBAL_Control + 2),
                0x67u,
                (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
                v23);
            }
            v19 = JobMoniker::GetPath(a2);
            v21 = L"Load-NoHash";
          }
        }
        EventManager::EvtReport(v20, &TASK_INSTANTIATE_FAILED, v19, v21, v17);
        XmlTaskPath = -2147216607;
LABEL_35:
        tsched::JobsAutoHandle::Close((tsched::JobsAutoHandle *)v27);
        goto LABEL_36;
      }
      v11 = JobMoniker::GetPath(a2);
      v13 = L"Load-FileToBuffer";
    }
    EventManager::EvtReport(v12, &TASK_INSTANTIATE_FAILED, v11, v13, XmlTaskPath);
    goto LABEL_35;
  }
LABEL_36:
  operator delete(v6);
  return (unsigned int)XmlTaskPath;
}
// 1800330D7: variable 'v8' is possibly undefined
// 180033168: variable 'v12' is possibly undefined
// 18003319E: variable 'v14' is possibly undefined
// 180033324: variable 'v20' is possibly undefined
// 180078030: using guessed type wchar_t aLoadCreatefile[16];
// 180078078: using guessed type wchar_t aLoadComputehas[17];
// 1800780A0: using guessed type wchar_t aLoadNohash[12];
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180033390) ----------------------------------------------------
__int64 __fastcall JobStore::XmlSaveTaskFile(
        JobStore *this,
        const struct JobMoniker *a2,
        const unsigned __int16 *a3,
        LPCWSTR StringSecurityDescriptor)
{
  int XmlTaskPath; // ebx
  unsigned __int64 v10; // rax
  const wchar_t *Path; // rax
  ULONG v12; // [rsp+20h] [rbp-38h]
  void *lpMem[5]; // [rsp+30h] [rbp-28h] BYREF

  lpMem[1] = (void *)-2LL;
  if ( !JobStore::GetUseXmlStore(this) )
    return 0LL;
  lpMem[0] = 0LL;
  XmlTaskPath = JobStore::GetXmlTaskPath((char **)this, a2, lpMem);
  if ( XmlTaskPath >= 0 )
  {
    v10 = -1LL;
    do
      ++v10;
    while ( a3[v10] );
    if ( v10 > 0xFFFFFFFF )
    {
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        Path = JobMoniker::GetPath(a2);
        WPP_SF_SD(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x23u,
          (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
          Path);
      }
      XmlTaskPath = -2147024362;
    }
    else
    {
      XmlTaskPath = JobStore::SaveJobFile(this, (wchar_t *)lpMem[0], a3, v10, v12, StringSecurityDescriptor);
    }
  }
  operator delete(lpMem[0]);
  return (unsigned int)XmlTaskPath;
}
// 18003341A: variable 'v12' is possibly undefined
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (00000001800334B4) ----------------------------------------------------
void __fastcall __noreturn wil::details::in1diag3::_FailFastImmediate_Unexpected(wil::details::in1diag3 *this)
{
  __fastfail(7u);
}

//----- (00000001800334C4) ----------------------------------------------------
char __fastcall wil::details::FeatureImpl<__WilFeatureTraits_Feature_2510298426>::__private_IsEnabled(__int64 a1)
{
  char v2; // bl
  __int64 v3; // rdx
  char v5; // [rsp+38h] [rbp+10h] BYREF

  wil::details::FeatureImpl<__WilFeatureTraits_Feature_2510298426>::GetCachedFeatureEnabledState(a1, &v5);
  v2 = v5 & 1;
  LOBYTE(v3) = v5 & 1;
  wil::details::FeatureImpl<__WilFeatureTraits_Feature_2510298426>::ReportUsage(a1, v3);
  return v2;
}
// 1800334E7: variable 'v3' is possibly undefined
// 18003274C: using guessed type __int64 __fastcall wil::details::FeatureImpl<__WilFeatureTraits_Feature_2510298426>::GetCachedFeatureEnabledState(_QWORD, _QWORD);
// 180032B20: using guessed type __int64 __fastcall wil::details::FeatureImpl<__WilFeatureTraits_Feature_2510298426>::ReportUsage(_QWORD, _QWORD);

//----- (0000000180033500) ----------------------------------------------------
struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ **__fastcall wil::unique_any_t<wil::details::unique_storage<wil::details::resource_policy<FEATURE_STATE_CHANGE_SUBSCRIPTION__ *,void (*)(FEATURE_STATE_CHANGE_SUBSCRIPTION__ *),&void wil::details::UnsubscribeProcessWideUsageFlush(FEATURE_STATE_CHANGE_SUBSCRIPTION__ *),wistd::integral_constant<unsigned __int64,0>,FEATURE_STATE_CHANGE_SUBSCRIPTION__ *,FEATURE_STATE_CHANGE_SUBSCRIPTION__ *,0,std::nullptr_t>>>::put(
        struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ **a1)
{
  struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ *v1; // rdi
  struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ *v3; // rdx
  char v5; // [rsp+30h] [rbp+8h] BYREF
  DWORD LastError; // [rsp+34h] [rbp+Ch]

  v1 = *a1;
  if ( *a1 )
  {
    v5 = 0;
    LastError = GetLastError();
    wil::details::UnsubscribeProcessWideUsageFlush(v1, v3);
    wil::last_error_context::~last_error_context((wil::last_error_context *)&v5);
  }
  *a1 = 0LL;
  return a1;
}
// 18003352D: variable 'v3' is possibly undefined

//----- (0000000180033558) ----------------------------------------------------
wil::details **__fastcall wil::unique_any_t<wil::details::unique_storage<wil::details::resource_policy<FEATURE_STATE_CHANGE_SUBSCRIPTION__ *,void (*)(FEATURE_STATE_CHANGE_SUBSCRIPTION__ *),&void wil::details::WilApi_UnsubscribeFeatureStateChangeNotification(FEATURE_STATE_CHANGE_SUBSCRIPTION__ *),wistd::integral_constant<unsigned __int64,0>,FEATURE_STATE_CHANGE_SUBSCRIPTION__ *,FEATURE_STATE_CHANGE_SUBSCRIPTION__ *,0,std::nullptr_t>>>::put(
        wil::details **a1)
{
  wil::details *v1; // rdi
  struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ *v3; // rdx
  char v5; // [rsp+30h] [rbp+8h] BYREF
  DWORD LastError; // [rsp+34h] [rbp+Ch]

  v1 = *a1;
  if ( *a1 )
  {
    v5 = 0;
    LastError = GetLastError();
    wil::details::WilApi_UnsubscribeFeatureStateChangeNotification(v1, v3);
    wil::last_error_context::~last_error_context((wil::last_error_context *)&v5);
  }
  *a1 = 0LL;
  return a1;
}
// 180033585: variable 'v3' is possibly undefined

//----- (00000001800335B0) ----------------------------------------------------
__int64 __fastcall wil_QueryFeatureState(__int64 a1, unsigned int a2, int a3, int a4, _DWORD *a5, _DWORD *a6)
{
  __int64 result; // rax

  if ( a5 )
    *a5 = 0;
  *a6 = 1;
  result = wil_RtlStagingConfig_QueryFeatureState(a1, a2, a3, a5);
  if ( !(_DWORD)result )
    return wil_StagingConfig_QueryFeatureState(a4, a1, a2, a3, a5);
  return result;
}

//----- (0000000180033630) ----------------------------------------------------
__int64 __fastcall wil_RtlStagingConfig_QueryFeatureState(__int64 a1, unsigned int a2, int a3, _DWORD *a4)
{
  int v4; // ebx
  BOOL v8; // r14d
  unsigned int v9; // ebp
  FARPROC ProcAddress; // rax
  HMODULE NtDllModuleHandle; // rax
  int v12; // edx
  unsigned int v13; // ecx
  char v15[8]; // [rsp+30h] [rbp-48h] BYREF
  __int64 v16; // [rsp+38h] [rbp-40h] BYREF
  int v17; // [rsp+40h] [rbp-38h]

  v4 = 0;
  v8 = a3 == 0;
  v9 = 0;
  v16 = 0LL;
  v17 = 0;
  ProcAddress = (FARPROC)g_wil_details_pfnRtlQueryFeatureConfiguration;
  if ( g_wil_details_pfnRtlQueryFeatureConfiguration
    || (NtDllModuleHandle = wil_details_GetNtDllModuleHandle(),
        ProcAddress = GetProcAddress(NtDllModuleHandle, "RtlQueryFeatureConfiguration"),
        (g_wil_details_pfnRtlQueryFeatureConfiguration = (__int64)ProcAddress) != 0) )
  {
    v12 = ((__int64 (__fastcall *)(_QWORD, BOOL, char *, __int64 *))ProcAddress)(a2, v8, v15, &v16);
  }
  else
  {
    v12 = -1073741511;
  }
  if ( v12 )
  {
    if ( v12 != 279 )
      goto LABEL_10;
    v13 = HIDWORD(v16);
  }
  else
  {
    v13 = HIDWORD(v16);
    v9 = 1;
    *(_DWORD *)a1 = (HIDWORD(v16) >> 4) & 3;
    *(_BYTE *)(a1 + 4) = BYTE1(v13) & 0x3F;
    *(_DWORD *)(a1 + 12) = v17;
    *(_DWORD *)(a1 + 8) = (unsigned __int16)v13 >> 14;
    *(_DWORD *)(a1 + 20) = (v13 >> 6) & 1;
  }
  *(_DWORD *)(a1 + 16) = (v13 >> 7) & 1;
LABEL_10:
  if ( a4 )
  {
    LOBYTE(v4) = v12 != -2147483614;
    *a4 = v4;
  }
  return v9;
}
// 1800B0970: using guessed type __int64 g_wil_details_pfnRtlQueryFeatureConfiguration;
// 180033630: using guessed type char var_48[8];

//----- (0000000180033750) ----------------------------------------------------
__int64 __fastcall wil_RtlStagingConfig_RecordFeatureUsage(int a1, __int16 a2, int a3)
{
  FARPROC ProcAddress; // rax
  HMODULE NtDllModuleHandle; // rax
  int v6; // [rsp+48h] [rbp+20h] BYREF
  __int16 v7; // [rsp+4Ch] [rbp+24h]
  __int16 v8; // [rsp+4Eh] [rbp+26h]

  v8 = 0;
  v6 = a1;
  v7 = a2;
  if ( a3 )
    v8 |= 1u;
  ProcAddress = (FARPROC)g_wil_details_pfnRtlNotifyFeatureUsage;
  if ( g_wil_details_pfnRtlNotifyFeatureUsage )
    return ((__int64 (__fastcall *)(int *))ProcAddress)(&v6);
  NtDllModuleHandle = wil_details_GetNtDllModuleHandle();
  ProcAddress = GetProcAddress(NtDllModuleHandle, "RtlNotifyFeatureUsage");
  g_wil_details_pfnRtlNotifyFeatureUsage = (__int64)ProcAddress;
  if ( ProcAddress )
    return ((__int64 (__fastcall *)(int *))ProcAddress)(&v6);
  else
    return 3221225785LL;
}
// 1800B0968: using guessed type __int64 g_wil_details_pfnRtlNotifyFeatureUsage;

//----- (00000001800337C0) ----------------------------------------------------
__int64 __fastcall wil_StagingConfig_QueryFeatureState(int a1, __int64 a2, __int64 a3, int a4, _DWORD *a5)
{
  int v7; // ebp
  unsigned int FeatureState; // edi
  char v10[96]; // [rsp+30h] [rbp-158h] BYREF
  char v11[208]; // [rsp+90h] [rbp-F8h] BYREF

  v7 = a3;
  FeatureState = 0;
  if ( !(unsigned int)wil_details_StagingConfig_Load((__int64)v10, a1, a3, (__int64)v11) )
  {
    FeatureState = wil_details_StagingConfig_QueryFeatureState((__int64)v10, a2, v7, a4);
    if ( a5 )
      *a5 |= wil_details_StagingConfig_AreAnyFeaturesConfigured((__int64)v10);
    wil_details_StagingConfig_Free((__int64)v10);
  }
  return FeatureState;
}
// 1800337C0: using guessed type char var_F8[208];

//----- (0000000180033874) ----------------------------------------------------
__int64 __fastcall wil_StagingConfig_RecordFeatureUsage(unsigned int a1, unsigned __int16 a2, __int64 a3)
{
  int v5; // edi
  unsigned int v6; // ebx
  char v8[96]; // [rsp+30h] [rbp-158h] BYREF
  char v9[208]; // [rsp+90h] [rbp-F8h] BYREF

  v5 = a3;
  v6 = wil_details_StagingConfig_Load((__int64)v8, 0, a3, (__int64)v9);
  if ( !v6 )
  {
    v6 = wil_details_StagingConfig_FireNotification((__int64)v8, a1, a2, v5);
    wil_details_StagingConfig_Free((__int64)v8);
  }
  return v6;
}
// 180033874: using guessed type char var_F8[208];

//----- (0000000180033904) ----------------------------------------------------
__int64 __fastcall wil_details_FeatureReporting_IncrementOpportunityInCache(
        volatile signed __int32 *a1,
        int a2,
        __int64 a3,
        _DWORD *a4)
{
  signed __int32 v4; // r8d
  BOOL v7; // ebx
  unsigned int v8; // ecx
  int v9; // eax
  int v10; // edx
  int v11; // r10d
  unsigned __int64 v12; // rdx
  __int64 result; // rax

  v4 = *a1;
  v7 = a2 == 5;
  while ( 1 )
  {
    a4[1] = 0;
    v8 = v4 | 1;
    if ( (((v4 | 1u) >> 22) & 1) != v7 )
    {
      if ( ((v8 >> 15) & 0x7F) != 0 )
      {
        a4[1] = (v8 >> 15) & 0x7F;
        v9 = 5;
        if ( a2 != 1 )
          v9 = 1;
        v8 = v4 & 0xFFC07FFE | 1;
        a4[2] = v9;
      }
      v10 = 0;
      if ( a2 == 5 )
        v10 = 0x400000;
      v8 = v8 & 0xFFBFFFFF | v10;
    }
    v11 = (v8 >> 15) & 0x7F;
    v12 = (unsigned int)(v11 + 1);
    if ( v12 > 0x7F || v12 < ((v8 >> 15) & 0x7F) )
    {
      LODWORD(v12) = 1;
      a4[2] = a2;
      a4[1] = v11;
    }
    result = (unsigned int)_InterlockedCompareExchange(a1, (v8 ^ ((_DWORD)v12 << 15)) & 0x3F8000 ^ v8, v4);
    if ( v4 == (_DWORD)result )
      break;
    v4 = result;
  }
  a4[4] = 0;
  *a4 = (v4 & 1) == 0;
  return result;
}

//----- (00000001800339EC) ----------------------------------------------------
__int64 __fastcall wil_details_FeatureReporting_IncrementUsageInCache(
        volatile signed __int32 *a1,
        int a2,
        __int64 a3,
        _DWORD *a4)
{
  signed __int32 v4; // r8d
  BOOL v7; // ebx
  unsigned int v8; // ecx
  int v9; // edx
  int v10; // r10d
  unsigned __int64 v11; // rdx
  __int64 result; // rax

  v4 = *a1;
  v7 = a2 == 4;
  while ( 1 )
  {
    a4[1] = 0;
    v8 = v4 | 1;
    if ( (((v4 | 1u) >> 14) & 1) != v7 )
    {
      if ( ((v8 >> 5) & 0x1FF) != 0 )
      {
        a4[1] = (v8 >> 5) & 0x1FF;
        a4[2] = a2 == 0 ? 4 : 0;
        v8 = v4 & 0xFFFFC01E | 1;
      }
      v9 = 0;
      if ( a2 == 4 )
        v9 = 0x4000;
      v8 = v8 & 0xFFFFBFFF | v9;
    }
    v10 = (v8 >> 5) & 0x1FF;
    v11 = (unsigned int)(v10 + 1);
    if ( v11 > 0x1FF || v11 < (((unsigned __int64)v8 >> 5) & 0x1FF) )
    {
      LOWORD(v11) = 1;
      a4[2] = a2;
      a4[1] = v10;
    }
    result = (unsigned int)_InterlockedCompareExchange(
                             a1,
                             ((unsigned __int16)v8 ^ (unsigned __int16)(32 * v11)) & 0x3FE0 ^ v8,
                             v4);
    if ( v4 == (_DWORD)result )
      break;
    v4 = result;
  }
  a4[4] = 0;
  *a4 = (v4 & 1) == 0;
  return result;
}

//----- (0000000180033AD8) ----------------------------------------------------
int *__fastcall wil_details_FeatureReporting_RecordUsageInCache(__int64 a1, volatile signed __int32 *a2, __int64 a3)
{
  int *v4; // r9
  int v5; // r10d
  int v6; // edx
  int v7; // r8d
  int v8; // r8d
  int v9; // r8d
  signed __int32 i; // ecx
  int v11; // ebx
  signed __int32 v12; // eax
  int v13; // ebx
  unsigned __int32 v14; // eax
  BOOL v15; // ecx
  unsigned __int32 v16; // ett

  v4 = (int *)a1;
  *(_OWORD *)a1 = 0LL;
  *(_QWORD *)(a1 + 16) = 0LL;
  if ( !(_DWORD)a3 )
    goto LABEL_35;
  v5 = 1;
  if ( (_DWORD)a3 == 1 )
  {
LABEL_34:
    wil_details_FeatureReporting_IncrementOpportunityInCache(a2, a3, a3, (_DWORD *)a1);
    return v4;
  }
  if ( (int)a3 <= 1 )
    goto LABEL_25;
  if ( (int)a3 <= 3 )
  {
LABEL_8:
    v6 = 0;
    v7 = a3 - 2;
    if ( v7 )
    {
      v8 = v7 - 1;
      if ( v8 )
      {
        v9 = v8 - 3;
        if ( v9 )
        {
          if ( v9 == 1 )
            v6 = 16;
        }
        else
        {
          v6 = 4;
        }
      }
      else
      {
        v6 = 8;
      }
    }
    else
    {
      v6 = 2;
    }
    for ( i = *a2; ; i = v12 )
    {
      v11 = i | v6 | 1;
      v4[4] = (i | v6) == i;
      if ( (i | v6) == i )
        v11 = i | v6;
      v12 = _InterlockedCompareExchange(a2, v11, i);
      if ( i == v12 )
        break;
    }
    if ( (v11 & 1) == 0 || (i & 1) != 0 )
      v5 = 0;
    *v4 = v5;
    return v4;
  }
  if ( (_DWORD)a3 == 4 )
  {
LABEL_35:
    wil_details_FeatureReporting_IncrementUsageInCache(a2, a3, a3, (_DWORD *)a1);
    return v4;
  }
  if ( (_DWORD)a3 == 5 )
    goto LABEL_34;
  if ( (unsigned int)(a3 - 6) <= 1 )
    goto LABEL_8;
LABEL_25:
  v13 = a3 - 320;
  if ( (unsigned int)(a3 - 320) >= 0x40 )
    goto LABEL_33;
  v14 = *((_DWORD *)a2 + 1);
  do
  {
    v15 = (v14 & 0x10) != 0 && ((v14 >> 5) & 0x3F) == v13;
    v4[4] = v15;
    v16 = v14;
    v14 = _InterlockedCompareExchange(a2 + 1, (32 * (v13 & 0x3F)) | v14 & 0xFFFFF81F | 0x10, v14);
  }
  while ( v16 != v14 );
  if ( !v4[4] )
  {
LABEL_33:
    v4[3] = 0;
    v4[2] = a3;
    v4[1] = 1;
  }
  return v4;
}
// 180033C24: variable 'v4' is possibly undefined

//----- (0000000180033C34) ----------------------------------------------------
__int64 __fastcall wil_details_MapReportingKind(int a1, int a2)
{
  unsigned __int8 v2; // cl

  if ( a1 )
  {
    switch ( a1 )
    {
      case 1:
        return a2 == 0 ? 4 : 0;
      case 2:
        return a2 != 0 ? 1 : 5;
      case 3:
        return a2 != 0 ? 2 : 6;
      case 4:
        return a2 != 0 ? 3 : 7;
      case 5:
        return a2 != 0 ? 8 : 10;
      case 6:
        return a2 != 0 ? 9 : 11;
    }
    v2 = a1 - 100;
    if ( v2 <= 0x31u )
      return v2 + (a2 != 0 ? 100 : 150);
  }
  return 255LL;
}

//----- (0000000180033CD4) ----------------------------------------------------
__int64 __fastcall wil_details_NtQueryWnfStateData(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 (__fastcall *v6)(__int64, _QWORD, _QWORD, __int64, __int64, __int64); // r10
  HMODULE NtDllModuleHandle; // rax

  v6 = (__int64 (__fastcall *)(__int64, _QWORD, _QWORD, __int64, __int64, __int64))g_wil_details_pfnNtQueryWnfStateData;
  if ( g_wil_details_pfnNtQueryWnfStateData )
    return v6(a1, 0LL, 0LL, a4, a5, a6);
  NtDllModuleHandle = wil_details_GetNtDllModuleHandle();
  g_wil_details_pfnNtQueryWnfStateData = (__int64)GetProcAddress(NtDllModuleHandle, "NtQueryWnfStateData");
  v6 = (__int64 (__fastcall *)(__int64, _QWORD, _QWORD, __int64, __int64, __int64))g_wil_details_pfnNtQueryWnfStateData;
  if ( g_wil_details_pfnNtQueryWnfStateData )
    return v6(a1, 0LL, 0LL, a4, a5, a6);
  else
    return 3221225785LL;
}
// 1800B09C0: using guessed type __int64 g_wil_details_pfnNtQueryWnfStateData;

//----- (0000000180033D5C) ----------------------------------------------------
__int64 __fastcall wil_details_NtUpdateWnfStateData(
        __int64 a1,
        __int64 a2,
        unsigned int a3,
        __int64 a4,
        int a5,
        int a6,
        int a7)
{
  __int64 (__fastcall *v7)(__int64, __int64, _QWORD, _QWORD, _QWORD, int, int); // r10
  HMODULE NtDllModuleHandle; // rax

  v7 = (__int64 (__fastcall *)(__int64, __int64, _QWORD, _QWORD, _QWORD, int, int))g_wil_details_pfnNtUpdateWnfStateData;
  if ( g_wil_details_pfnNtUpdateWnfStateData )
    return v7(a1, a2, a3, 0LL, 0LL, a6, a7);
  NtDllModuleHandle = wil_details_GetNtDllModuleHandle();
  g_wil_details_pfnNtUpdateWnfStateData = (__int64)GetProcAddress(NtDllModuleHandle, "NtUpdateWnfStateData");
  v7 = (__int64 (__fastcall *)(__int64, __int64, _QWORD, _QWORD, _QWORD, int, int))g_wil_details_pfnNtUpdateWnfStateData;
  if ( g_wil_details_pfnNtUpdateWnfStateData )
    return v7(a1, a2, a3, 0LL, 0LL, a6, a7);
  else
    return 3221225785LL;
}
// 1800B09D8: using guessed type __int64 g_wil_details_pfnNtUpdateWnfStateData;

//----- (0000000180033DF8) ----------------------------------------------------
__int64 __fastcall wil_details_RecordCachedUsage(unsigned int a1, __int64 a2)
{
  unsigned __int32 v4; // ecx
  unsigned int v5; // edx
  __int64 result; // rax
  unsigned __int32 v7; // edx
  int v8; // edx
  unsigned __int32 v9; // ecx
  unsigned int v10; // ebx
  int *v11; // rdi
  __int64 v12; // r8
  __int64 v13; // [rsp+30h] [rbp-19h]
  int v14[9]; // [rsp+40h] [rbp-9h] BYREF
  unsigned __int32 v15; // [rsp+64h] [rbp+1Bh]
  int v16; // [rsp+68h] [rbp+1Fh]
  unsigned __int32 v17; // [rsp+6Ch] [rbp+23h]
  int v18; // [rsp+70h] [rbp+27h]
  unsigned __int32 v19; // [rsp+74h] [rbp+2Bh]
  int v20; // [rsp+78h] [rbp+2Fh]
  unsigned __int32 v21; // [rsp+7Ch] [rbp+33h]

  _m_prefetchw((const void *)a2);
  v4 = _InterlockedAnd((volatile signed __int32 *)a2, 0xFFC0401E);
  v5 = (v4 >> 1) & 0xF;
  if ( v5 )
  {
    _m_prefetchw((const void *)(a2 + 4));
    v5 &= ~_InterlockedOr((volatile signed __int32 *)(a2 + 4), v5);
  }
  v14[0] = 2;
  v14[1] = v5 & 1;
  v14[2] = 6;
  v14[3] = ((unsigned __int8)v5 >> 1) & 1;
  v14[4] = 3;
  v14[5] = ((unsigned __int8)v5 >> 2) & 1;
  v14[6] = 7;
  result = v5 >= 8;
  v14[8] = 0;
  v14[7] = v5 >= 8;
  if ( (v4 & 0x4000) != 0 )
  {
    v15 = 0;
    v7 = v4 >> 5;
  }
  else
  {
    v7 = v4 >> 5;
    result = (v4 >> 5) & 0x1FF;
    v15 = (v4 >> 5) & 0x1FF;
  }
  v16 = 4;
  if ( (v4 & 0x4000) != 0 )
    v17 = v7 & 0x1FF;
  else
    v17 = 0;
  v18 = 1;
  v8 = v4 & 0x400000;
  if ( (v4 & 0x400000) != 0 )
  {
    v19 = 0;
    v9 = v4 >> 15;
  }
  else
  {
    v9 = v4 >> 15;
    result = v9 & 0x7F;
    v19 = v9 & 0x7F;
  }
  v20 = 5;
  if ( v8 )
    v21 = v9 & 0x7F;
  else
    v21 = 0;
  v10 = 0;
  v11 = v14;
  do
  {
    v13 = *(_QWORD *)v11;
    if ( !HIDWORD(*(_QWORD *)v11) )
      goto LABEL_22;
    result = g_wil_details_internalRecordFeatureUsage;
    if ( g_wil_details_internalRecordFeatureUsage )
    {
      v12 = (unsigned int)HIDWORD(*(_QWORD *)v11);
    }
    else
    {
      result = g_wil_details_apiRecordFeatureUsage;
      if ( !g_wil_details_apiRecordFeatureUsage )
        goto LABEL_22;
      v12 = HIDWORD(v13);
    }
    result = ((__int64 (__fastcall *)(_QWORD, _QWORD, __int64, _QWORD))result)(a1, (unsigned int)v13, v12, 0LL);
LABEL_22:
    ++v10;
    v11 += 2;
  }
  while ( v10 < 8 );
  return result;
}
// 1800B14B8: using guessed type __int64 g_wil_details_internalRecordFeatureUsage;
// 1800B1578: using guessed type __int64 g_wil_details_apiRecordFeatureUsage;

//----- (0000000180033F9C) ----------------------------------------------------
__int64 __fastcall wil_details_RtlRegisterFeatureConfigurationChangeNotification(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4)
{
  FARPROC ProcAddress; // rax
  HMODULE NtDllModuleHandle; // rax

  ProcAddress = (FARPROC)g_wil_details_pfnRtlRegisterFeatureConfigurationChangeNotification;
  if ( g_wil_details_pfnRtlRegisterFeatureConfigurationChangeNotification )
    return ((__int64 (__fastcall *)(__int64, __int64, _QWORD, __int64))ProcAddress)(a1, a2, 0LL, a4);
  NtDllModuleHandle = wil_details_GetNtDllModuleHandle();
  ProcAddress = GetProcAddress(NtDllModuleHandle, "RtlRegisterFeatureConfigurationChangeNotification");
  g_wil_details_pfnRtlRegisterFeatureConfigurationChangeNotification = (__int64)ProcAddress;
  if ( ProcAddress )
    return ((__int64 (__fastcall *)(__int64, __int64, _QWORD, __int64))ProcAddress)(a1, a2, 0LL, a4);
  else
    return 3221225785LL;
}
// 1800B0978: using guessed type __int64 g_wil_details_pfnRtlRegisterFeatureConfigurationChangeNotification;

//----- (0000000180034018) ----------------------------------------------------
__int64 __fastcall wil_details_RtlSubscribeWnfStateChangeNotification(
        __int64 a1,
        __int64 a2,
        unsigned int a3,
        __int64 a4,
        __int64 a5)
{
  __int64 (__fastcall *v5)(__int64, __int64, _QWORD, __int64, __int64, _QWORD, _DWORD, _DWORD); // r10
  HMODULE NtDllModuleHandle; // rax

  v5 = (__int64 (__fastcall *)(__int64, __int64, _QWORD, __int64, __int64, _QWORD, _DWORD, _DWORD))g_wil_details_pfnRtlSubscribeWnfStateChangeNotification;
  if ( g_wil_details_pfnRtlSubscribeWnfStateChangeNotification )
    return v5(a1, a2, a3, a4, a5, 0LL, 0, 0);
  NtDllModuleHandle = wil_details_GetNtDllModuleHandle();
  g_wil_details_pfnRtlSubscribeWnfStateChangeNotification = (__int64)GetProcAddress(
                                                                       NtDllModuleHandle,
                                                                       "RtlSubscribeWnfStateChangeNotification");
  v5 = (__int64 (__fastcall *)(__int64, __int64, _QWORD, __int64, __int64, _QWORD, _DWORD, _DWORD))g_wil_details_pfnRtlSubscribeWnfStateChangeNotification;
  if ( g_wil_details_pfnRtlSubscribeWnfStateChangeNotification )
    return v5(a1, a2, a3, a4, a5, 0LL, 0, 0);
  else
    return 3221225785LL;
}
// 1800B09B8: using guessed type __int64 g_wil_details_pfnRtlSubscribeWnfStateChangeNotification;

//----- (00000001800340C4) ----------------------------------------------------
_BOOL8 __fastcall wil_details_StagingConfigFeature_HasUniqueState(_DWORD *a1)
{
  int v1; // eax
  _BOOL8 result; // rax

  result = 0;
  if ( *a1 )
  {
    v1 = a1[1];
    if ( (v1 & 0x300) != 0 || (v1 & 0xC00) != 0 || (v1 & 0x3000) != 0 || (v1 & 0x3F000000) != 0 || (v1 & 2) != 0 )
      return 1;
  }
  return result;
}

//----- (0000000180034100) ----------------------------------------------------
__int64 __fastcall wil_details_StagingConfig_AreAnyFeaturesConfigured(__int64 a1)
{
  __int64 v1; // rdi
  unsigned int v2; // edx
  __int64 v3; // rbx
  unsigned int v4; // r9d
  int v5; // r9d
  __int64 v6; // r10
  unsigned int v7; // r11d
  unsigned int v8; // r8d

  v1 = *(_QWORD *)(a1 + 24);
  v2 = 0;
  v3 = *(_QWORD *)(a1 + 32);
  v4 = 0;
  if ( *(_WORD *)(v1 + 4) )
  {
    do
    {
      if ( wil_details_StagingConfigFeature_HasUniqueState((_DWORD *)(v3 + 12LL * v4)) )
      {
        if ( (*(_BYTE *)(v6 + 4) & 1) != 0 )
          return 1;
        v8 = v2;
        while ( v8 == v5 || *(_DWORD *)v6 != *(_DWORD *)(v3 + 12LL * v8) )
        {
          if ( ++v8 >= v7 )
            return 1;
        }
      }
      v4 = v5 + 1;
    }
    while ( v4 < v7 );
  }
  if ( *(_WORD *)(v1 + 6) > (unsigned __int16)v2 )
    return 1;
  return v2;
}
// 180034138: variable 'v6' is possibly undefined
// 18003413F: variable 'v2' is possibly undefined
// 180034145: variable 'v5' is possibly undefined
// 18003415C: variable 'v7' is possibly undefined

//----- (000000018003418C) ----------------------------------------------------
__int64 __fastcall wil_details_StagingConfig_FireNotification(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  __int64 v4; // rdi
  __int16 v6; // r14
  int v7; // esi
  unsigned int WnfStateData; // r10d
  unsigned int i; // ebx
  __int64 v11; // r9
  unsigned int v12; // r8d
  unsigned int v13; // edx
  __int64 v14; // rcx
  _WORD *v15; // rax
  int v17; // [rsp+20h] [rbp-E0h]
  unsigned int v18; // [rsp+40h] [rbp-C0h] BYREF
  int v19; // [rsp+44h] [rbp-BCh] BYREF
  int v20[2]; // [rsp+48h] [rbp-B8h] BYREF
  int v21; // [rsp+50h] [rbp-B0h] BYREF
  _WORD v22[2046]; // [rsp+54h] [rbp-ACh] BYREF

  v4 = *(_QWORD *)(a1 + 40);
  v6 = a3;
  v7 = a2;
  WnfStateData = 0;
  for ( i = 0; i < *(unsigned __int16 *)(*(_QWORD *)(a1 + 24) + 6LL); ++i )
  {
    if ( *(_DWORD *)(v4 + 16LL * i) == v7
      && *(_WORD *)(v4 + 16LL * i + 12) == v6
      && ((*(_DWORD *)(v4 + 16LL * i + 12) & 0x10000) == 0 || a4) )
    {
      v20[0] = *(_DWORD *)(v4 + 16LL * i + 4);
      v20[1] = *(_DWORD *)(v4 + 16LL * i + 8);
      do
      {
        v18 = 4096;
        WnfStateData = wil_details_NtQueryWnfStateData(
                         (__int64)v20,
                         a2,
                         a3,
                         (__int64)&v19,
                         (__int64)&v21,
                         (__int64)&v18);
        if ( !WnfStateData )
        {
          v12 = v18;
          v13 = 0;
          if ( (v18 & 7) != 0 )
            v12 = 0;
          v18 = v12;
          v14 = v12 >> 3;
          if ( (_DWORD)v14 )
          {
            v15 = v22;
            while ( *((_DWORD *)v15 - 1) != v7 || *v15 != v6 )
            {
              ++v13;
              v15 += 4;
              if ( v13 >= (unsigned int)v14 )
                goto LABEL_15;
            }
          }
          else
          {
LABEL_15:
            if ( (unsigned __int64)v12 + 8 <= 0x1000 )
            {
              v12 += 8;
              *(_DWORD *)&v22[4 * v14 - 2] = v7;
              v18 = v12;
              v22[4 * v14] = v6;
            }
          }
          WnfStateData = wil_details_NtUpdateWnfStateData((__int64)v20, (__int64)&v21, v12, v11, v17, v19, 1);
        }
      }
      while ( WnfStateData == -1073741823 );
    }
  }
  return WnfStateData;
}
// 180034254: variable 'a2' is possibly undefined
// 180034254: variable 'a3' is possibly undefined
// 1800342D5: variable 'v11' is possibly undefined
// 1800342D5: variable 'v17' is possibly undefined
// 18003418C: using guessed type _WORD var_102C[2046];

//----- (0000000180034338) ----------------------------------------------------
void __fastcall wil_details_StagingConfig_Free(__int64 a1)
{
  HANDLE ProcessHeap; // rax

  if ( *(_DWORD *)(a1 + 80) )
  {
    ProcessHeap = GetProcessHeap();
    HeapFree(ProcessHeap, 0, *(LPVOID *)(a1 + 56));
    *(_QWORD *)(a1 + 56) = 0LL;
    *(_QWORD *)(a1 + 24) = 0LL;
  }
}

//----- (0000000180034380) ----------------------------------------------------
__int64 __fastcall wil_details_StagingConfig_Load(__int64 a1, int a2, __int64 a3, __int64 a4)
{
  __int64 v7; // rdx
  __int64 v8; // r8
  int v9; // edi
  __int64 v10; // r13
  void *v11; // r15
  __int64 v12; // rax
  __int64 v13; // rbx
  unsigned __int64 v14; // r14
  unsigned int WnfStateData; // eax
  unsigned int v16; // r12d
  unsigned __int64 v17; // rax
  HANDLE ProcessHeap; // rax
  HANDLE v19; // rax
  __int64 v20; // rdx
  __int64 v21; // r8
  unsigned __int64 v22; // r8
  __int64 v23; // r10
  unsigned __int64 v24; // rdx
  int v25; // r9d
  __int64 v26; // rax
  int v27; // edx
  int v28; // ecx
  int v29; // eax
  __int64 result; // rax
  __int64 v31; // rdx
  HANDLE v32; // rax
  unsigned int v33; // [rsp+30h] [rbp-30h] BYREF
  int v34; // [rsp+34h] [rbp-2Ch] BYREF
  __int64 v35; // [rsp+38h] [rbp-28h] BYREF
  __int64 v36; // [rsp+40h] [rbp-20h] BYREF
  __int64 v37; // [rsp+48h] [rbp-18h] BYREF

  LODWORD(v36) = a2;
  v35 = a4;
  memset_0((void *)(a1 + 8), 0, 0x50uLL);
  v9 = 0;
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = 0;
  v10 = 200LL;
  v11 = 0LL;
  v12 = 0x418A073AA3BC88F5LL;
  v13 = 0LL;
  v14 = -(__int64)(a4 != 0) & 0xC8;
  if ( !(_DWORD)v36 )
    v12 = 0x418A073AA3BC7C75LL;
  v37 = v12;
  v33 = a4 != 0 ? 0xC8 : 0;
  WnfStateData = wil_details_NtQueryWnfStateData((__int64)&v37, v7, v8, a1 + 8, a4, (__int64)&v33);
  v16 = WnfStateData;
  if ( WnfStateData )
    goto LABEL_15;
  v13 = v35;
  if ( v35 )
    goto LABEL_15;
  do
  {
    if ( v14 < 0xC8 )
      v14 = 200LL;
    v17 = v14;
    v14 = v33;
    if ( v17 >= v33 )
      v14 = v17;
    if ( v14 < 0x10 )
      v14 = 16LL;
    if ( v11 )
    {
      ProcessHeap = GetProcessHeap();
      HeapFree(ProcessHeap, 0, v11);
    }
    v19 = GetProcessHeap();
    v11 = HeapAlloc(v19, 0, v14);
    if ( !v11 )
      return 3221225626LL;
    v33 = v14;
    WnfStateData = wil_details_NtQueryWnfStateData((__int64)&v37, v20, v21, a1 + 8, (__int64)v11, (__int64)&v33);
    v16 = WnfStateData;
    v13 = (__int64)v11;
LABEL_15:
    ;
  }
  while ( WnfStateData == -1073741789 );
  if ( v16 || !v13 )
  {
    if ( v11 )
    {
      v32 = GetProcessHeap();
      HeapFree(v32, 0, v11);
    }
    return v16;
  }
  else
  {
    v22 = v33;
    if ( v33 > 4 )
      *(_BYTE *)(a1 + 12) = *(_BYTE *)v13;
    if ( (unsigned int)v22 >= 0x10
      && *(_BYTE *)(a1 + 12) == 2
      && *(_WORD *)(v13 + 2) >= 0x10u
      && (v23 = *(unsigned __int16 *)(v13 + 4),
          v24 = *(unsigned __int16 *)(v13 + 2) + 16LL * *(unsigned __int16 *)(v13 + 6) + 12 * v23,
          v22 >= v24) )
    {
      v34 = 0;
      v25 = 0;
      if ( (_WORD)v23 )
      {
        v26 = 0x418A073AA3BC90F5LL;
        if ( !(_DWORD)v36 )
          v26 = 0x418A073AA3BC8075LL;
        v36 = v26;
        LODWORD(v35) = 0;
        wil_details_NtQueryWnfStateData((__int64)&v36, v24, v22, (__int64)&v34, 0LL, (__int64)&v35);
        LODWORD(v22) = v33;
        v25 = v34;
      }
      *(_QWORD *)(a1 + 24) = v13;
      *(_QWORD *)(a1 + 32) = v13 + 16;
      *(_QWORD *)(a1 + 40) = v13 + 16 + 12LL * *(unsigned __int16 *)(v13 + 4);
      *(_DWORD *)(a1 + 48) = v25 != 0;
      if ( *(_BYTE *)v13 == 2 && *(_BYTE *)(v13 + 1) < 2u )
      {
        v27 = 16 * *(unsigned __int16 *)(v13 + 6);
        v28 = 3 * *(unsigned __int16 *)(v13 + 4);
        v29 = *(unsigned __int16 *)(v13 + 2);
        *(_DWORD *)(a1 + 16) = 1;
        LODWORD(v22) = v29 + v27 + 4 * v28;
      }
    }
    else
    {
      v33 = 16;
      *(_OWORD *)v13 = 0LL;
      *(_DWORD *)v13 = 1049090;
      LODWORD(v22) = v33;
      *(_QWORD *)(a1 + 24) = v13;
      v31 = v13 + *(unsigned __int16 *)(v13 + 2);
      *(_QWORD *)(a1 + 32) = v31;
      *(_QWORD *)(a1 + 40) = v31 + 12LL * *(unsigned __int16 *)(v13 + 4);
    }
    *(_QWORD *)(a1 + 64) = (unsigned int)v22;
    if ( v11 )
      v10 = v14;
    *(_QWORD *)(a1 + 56) = v13;
    *(_QWORD *)(a1 + 72) = v10;
    LOBYTE(v9) = v13 == (_QWORD)v11;
    result = 0LL;
    *(_DWORD *)(a1 + 80) = v9;
  }
  return result;
}
// 18003441B: variable 'v7' is possibly undefined
// 18003441B: variable 'v8' is possibly undefined
// 1800344C3: variable 'v20' is possibly undefined
// 1800344C3: variable 'v21' is possibly undefined

//----- (0000000180034694) ----------------------------------------------------
__int64 __fastcall wil_details_StagingConfig_QueryFeatureState(__int64 a1, __int64 a2, int a3, int a4)
{
  __int64 v4; // r15
  int v5; // r10d
  __int64 v6; // r11
  int v10; // edi
  unsigned int v11; // edx
  unsigned int v12; // r14d
  int v13; // eax
  bool v14; // zf
  int v15; // eax
  unsigned int v16; // r8d
  __int64 v17; // rax
  int v18; // eax
  unsigned int v19; // edx
  unsigned int v20; // edx
  int v21; // eax
  int v22; // edx
  unsigned int v23; // ecx
  _DWORD *v24; // rax
  __int64 result; // rax
  __int64 v26; // [rsp+20h] [rbp-10h] BYREF
  int v27; // [rsp+28h] [rbp-8h]

  v4 = *(_QWORD *)(a1 + 24);
  v5 = 0;
  v6 = *(_QWORD *)(a1 + 32);
  v10 = 0;
  v11 = 0;
  v12 = *(unsigned __int16 *)(v4 + 4);
  if ( !*(_WORD *)(v4 + 4) )
  {
LABEL_9:
    v16 = 0;
    if ( v10 )
      goto LABEL_10;
    goto LABEL_29;
  }
  while ( 1 )
  {
    if ( *(_DWORD *)(v6 + 12LL * v11) == a3 )
    {
      if ( !a4 || !*(_DWORD *)(a1 + 48) )
      {
        v10 = 1;
        v14 = (*(_BYTE *)(v6 + 12LL * v11 + 4) & 1) == 0;
        v15 = *(_DWORD *)(v6 + 12LL * v11 + 8);
        v26 = *(_QWORD *)(v6 + 12LL * v11);
        v27 = v15;
        if ( !v14 )
          goto LABEL_9;
        goto LABEL_8;
      }
      if ( (*(_BYTE *)(v6 + 12LL * v11 + 4) & 1) == 0 )
        break;
    }
LABEL_8:
    if ( ++v11 >= v12 )
      goto LABEL_9;
  }
  v13 = *(_DWORD *)(v6 + 12LL * v11 + 8);
  v26 = *(_QWORD *)(v6 + 12LL * v11);
  v27 = v13;
LABEL_10:
  if ( !a4 || (v17 = 12LL, !*(_DWORD *)(a1 + 48)) )
    v17 = 8LL;
  v18 = *(_DWORD *)(v17 + v4);
  if ( (v18 & 4) != 0 )
  {
    v19 = HIDWORD(v26) & 0xFFFFCFFF;
    HIDWORD(v26) &= 0xFFFFCFFF;
  }
  else
  {
    v19 = HIDWORD(v26);
  }
  if ( (v18 & 2) != 0 )
  {
    v19 &= 0xFFFFF3FF;
    HIDWORD(v26) = v19;
  }
  if ( (v18 & 1) != 0 )
  {
    v19 &= 0xFFFFFCFF;
    HIDWORD(v26) = v19;
  }
  if ( (v18 & 8) != 0 )
  {
    v27 = 0;
    HIDWORD(v26) = v19 & 0xC0FFFFFF;
  }
  if ( wil_details_StagingConfigFeature_HasUniqueState(&v26) )
  {
    *(_DWORD *)(a2 + 12) = v27;
    *(_DWORD *)(a2 + 8) = v20 >> 30;
    *(_BYTE *)(a2 + 4) = HIBYTE(v20) & 0x3F;
    *(_DWORD *)(a2 + 20) = (v20 >> 1) & 1;
    v21 = (v20 >> 12) & 3;
    if ( v21 || (v21 = (v20 >> 10) & 3) != 0 )
    {
      *(_DWORD *)a2 = v21;
    }
    else
    {
      v22 = (v20 >> 8) & 3;
      if ( v22 )
        *(_DWORD *)a2 = v22;
    }
    v16 = 1;
  }
LABEL_29:
  v23 = v5;
  v24 = *(_DWORD **)(a1 + 40);
  if ( *(_WORD *)(v4 + 6) )
  {
    while ( *v24 != a3 )
    {
      ++v23;
      v24 += 4;
      if ( v23 >= *(unsigned __int16 *)(v4 + 6) )
        goto LABEL_34;
    }
    v5 = 1;
  }
LABEL_34:
  result = v16;
  *(_DWORD *)(a2 + 16) = v5;
  return result;
}
// 1800347B9: variable 'v20' is possibly undefined
// 1800347FD: variable 'v5' is possibly undefined
// 180034822: variable 'v16' is possibly undefined

//----- (000000018003485C) ----------------------------------------------------
signed int __fastcall CredStore::OpenCredManagerKey(CredStore *this, HKEY *a2)
{
  signed int result; // eax
  struct _SECURITY_ATTRIBUTES v3; // [rsp+50h] [rbp-28h] BYREF

  v3.nLength = 24;
  v3.lpSecurityDescriptor = tsched::StoreSecurity::g_pRestrictedKeySecurity;
  v3.bInheritHandle = 0;
  result = RegCreateKeyExW(
             HKEY_LOCAL_MACHINE,
             L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Schedule\\CredWom",
             0,
             0LL,
             0,
             0xF003Fu,
             &v3,
             a2,
             0LL);
  if ( result > 0 )
    return (unsigned __int16)result | 0x80070000;
  return result;
}

//----- (00000001800348D4) ----------------------------------------------------
__int64 __fastcall CredStore::ReleaseRefUserRecord(LPCRITICAL_SECTION lpCriticalSection, User *this, void **a3)
{
  int SidString; // ebx
  const WCHAR **v8; // rbx
  const WCHAR *v9; // rdx
  LSTATUS v10; // eax
  unsigned int v11; // edi
  int v12; // eax
  int v13; // eax
  const WCHAR *v14; // rdx
  LSTATUS v15; // eax
  void *v16; // rax
  char *v17; // rcx
  __int64 v18; // r8
  signed __int64 v19; // rdx
  __int16 v20; // ax
  char *v21; // rax
  BYTE v22[4]; // [rsp+30h] [rbp-A9h] BYREF
  DWORD cbData; // [rsp+34h] [rbp-A5h] BYREF
  HKEY hKey; // [rsp+38h] [rbp-A1h] BYREF
  BSTR *Type; // [rsp+40h] [rbp-99h] BYREF
  const WCHAR **v26; // [rsp+48h] [rbp-91h] BYREF
  BSTR *v27[2]; // [rsp+50h] [rbp-89h] BYREF
  char pExceptionObject[64]; // [rsp+60h] [rbp-79h] BYREF
  BYTE Data[80]; // [rsp+A0h] [rbp-39h] BYREF

  v27[1] = (BSTR *)-2LL;
  v27[0] = 0LL;
  memset_0(Data, 0, sizeof(Data));
  *(_DWORD *)v22 = 0;
  SidString = User::GetSidString(this, (struct _bstr_t *)v27);
  if ( SidString < 0 )
  {
    _bstr_t::_Free((_bstr_t *)v27);
    return (unsigned int)SidString;
  }
  hKey = 0LL;
  _bstr_t::_bstr_t((_bstr_t *)&v26, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Schedule\\CredWom");
  _bstr_t::_bstr_t((_bstr_t *)&Type, L"\\");
  _bstr_t::operator+=((OLECHAR ***)&v26, &Type);
  _bstr_t::_Free((_bstr_t *)&Type);
  _bstr_t::operator+=((OLECHAR ***)&v26, v27);
  EnterCriticalSection(lpCriticalSection);
  v8 = v26;
  if ( v26 )
    v9 = *v26;
  else
    v9 = 0LL;
  v10 = RegOpenKeyExW(HKEY_LOCAL_MACHINE, v9, 0, 0xF003Fu, &hKey);
  if ( v10 > 0 )
    v11 = (unsigned __int16)v10 | 0x80070000;
  else
    v11 = v10;
  if ( v10 )
    goto LABEL_24;
  cbData = 78;
  v12 = RegQueryValueExW(hKey, L"Index", 0LL, (LPDWORD)&Type, Data, &cbData);
  if ( !v12 )
  {
    cbData = 4;
    if ( RegQueryValueExW(hKey, L"Count", 0LL, (LPDWORD)&Type, v22, &cbData) )
      goto LABEL_24;
    if ( (_DWORD)Type != 4 )
    {
      v11 = -2147216623;
      goto LABEL_35;
    }
    v13 = *(_DWORD *)v22;
    if ( *(_DWORD *)v22 && (--*(_DWORD *)v22, v13 != 1) )
    {
      v15 = RegSetValueExW(hKey, L"Count", 0, 4u, v22, 4u);
      if ( !v15 )
      {
        v11 = 1;
        goto LABEL_35;
      }
      if ( v15 > 0 )
      {
LABEL_23:
        v11 = (unsigned __int16)v15 | 0x80070000;
        goto LABEL_24;
      }
      v11 = v15;
    }
    else
    {
      wmi::AutoRegKey::Close(&hKey);
      if ( v8 )
        v14 = *v8;
      else
        v14 = 0LL;
      v15 = RegDeleteTreeW(HKEY_LOCAL_MACHINE, v14);
      v11 = v15;
      if ( !v15 )
      {
LABEL_25:
        v16 = operator new(0x74uLL);
        wmi::AutoVectorPtr<unsigned char>::operator=(a3, v16);
        v17 = (char *)*a3;
        if ( !*a3 )
        {
          wmi::OutOfMemoryException::OutOfMemoryException((wmi::OutOfMemoryException *)pExceptionObject);
          CxxThrowException_0(pExceptionObject, (_ThrowInfo *)&TI4_AVOutOfMemoryException_wmi__);
        }
        v18 = 58LL;
        v19 = (char *)L"TaskScheduler:Task:" - v17;
        do
        {
          if ( v18 == -2147483588 )
            break;
          v20 = *(_WORD *)&v17[v19];
          if ( !v20 )
            break;
          *(_WORD *)v17 = v20;
          v17 += 2;
          --v18;
        }
        while ( v18 );
        v21 = v17 - 2;
        if ( v18 )
          v21 = v17;
        *(_WORD *)v21 = 0;
        v11 = v18 == 0 ? 0x8007007A : 0;
        if ( !v18 )
          goto LABEL_35;
        v12 = StringCchCopyW((char *)*a3 + 38, 39LL, (char *)Data);
        goto LABEL_34;
      }
      if ( v15 > 0 )
        goto LABEL_23;
    }
LABEL_24:
    if ( v11 )
      goto LABEL_35;
    goto LABEL_25;
  }
  if ( v12 <= 0 )
  {
LABEL_34:
    v11 = v12;
    goto LABEL_35;
  }
  v11 = (unsigned __int16)v12 | 0x80070000;
LABEL_35:
  LeaveCriticalSection(lpCriticalSection);
  _bstr_t::_Free((_bstr_t *)&v26);
  wmi::AutoRegKey::Close(&hKey);
  _bstr_t::_Free((_bstr_t *)v27);
  return v11;
}

//----- (0000000180034C8C) ----------------------------------------------------
signed int __fastcall JobStore::LoadFileToBuffer(HANDLE hFile, void **a2)
{
  signed int result; // eax
  DWORD v5; // esi
  char *v6; // rbx
  signed int LastError; // eax
  unsigned int v8; // edi
  __int64 v9; // rcx
  void *v10; // rdx
  union _LARGE_INTEGER FileSize; // [rsp+30h] [rbp-10h] BYREF
  __int16 Buffer; // [rsp+80h] [rbp+40h] BYREF
  DWORD NumberOfBytesRead; // [rsp+88h] [rbp+48h] BYREF

  FileSize.QuadPart = 0LL;
  if ( !GetFileSizeEx(hFile, &FileSize) )
    goto LABEL_2;
  if ( FileSize.HighPart )
    return -2147024882;
  if ( !FileSize.LowPart || (FileSize.LowPart & 1) != 0 )
    return -2147024809;
  NumberOfBytesRead = 0;
  Buffer = 0;
  if ( !ReadFile(hFile, &Buffer, 2u, &NumberOfBytesRead, 0LL) )
  {
LABEL_2:
    result = GetLastError();
    if ( result > 0 )
      return (unsigned __int16)result | 0x80070000;
    return result;
  }
  if ( NumberOfBytesRead != 2 || Buffer != -257 )
    return -2147024809;
  v5 = FileSize.LowPart >> 1;
  v6 = (char *)operator new(saturated_mul(FileSize.LowPart >> 1, 2uLL));
  if ( ReadFile(hFile, v6, 2 * v5, &NumberOfBytesRead, 0LL) )
  {
    v9 = 2LL * (v5 - 1);
    if ( NumberOfBytesRead == v9 )
    {
      *(_WORD *)&v6[v9] = 0;
      v10 = v6;
      v6 = 0LL;
      wmi::AutoVectorPtr<unsigned char>::operator=(a2, v10);
      v8 = 0;
    }
    else
    {
      v8 = -2147467259;
    }
  }
  else
  {
    LastError = GetLastError();
    v8 = LastError;
    if ( LastError > 0 )
      v8 = (unsigned __int16)LastError | 0x80070000;
  }
  operator delete(v6);
  return v8;
}

//----- (0000000180034E04) ----------------------------------------------------
__int64 __fastcall UbpmParams::AddBasicTrigger(
        __int64 *a1,
        int a2,
        int a3,
        int a4,
        int a5,
        __int64 a6,
        __int128 *a7,
        __int128 *a8,
        unsigned int a9,
        __int64 a10,
        int a11,
        int a12,
        _QWORD *a13,
        __int64 a14)
{
  __int64 v18; // r8
  __int64 v19; // r9
  int v20; // ecx
  int v21; // ebx
  __int64 v22; // rax
  __int64 v23; // rcx
  __int64 v24; // rax
  const wchar_t *v25; // rax
  __int64 v26; // r8
  __int64 v27; // r9
  unsigned __int16 **ActionIdArray; // rax
  unsigned int v29; // edx
  UbpmParams *v30; // rcx
  unsigned int v31; // eax
  bool v32; // zf
  __int64 v34; // [rsp+28h] [rbp-C9h]
  __int64 v35; // [rsp+28h] [rbp-C9h]
  __int64 v36; // [rsp+30h] [rbp-C1h]
  _BYTE v37[24]; // [rsp+38h] [rbp-B9h] BYREF
  void *v38; // [rsp+50h] [rbp-A1h] BYREF
  __int128 v39; // [rsp+58h] [rbp-99h]
  __int64 v40; // [rsp+68h] [rbp-89h]
  __int128 v41; // [rsp+70h] [rbp-81h] BYREF
  int v42; // [rsp+80h] [rbp-71h]
  int v43; // [rsp+84h] [rbp-6Dh]
  int v44; // [rsp+88h] [rbp-69h]
  int v45; // [rsp+8Ch] [rbp-65h]
  char v46; // [rsp+90h] [rbp-61h]
  bool v47; // [rsp+91h] [rbp-60h]
  __int16 v48; // [rsp+92h] [rbp-5Fh]
  int v49; // [rsp+94h] [rbp-5Dh]
  unsigned __int16 **v50; // [rsp+98h] [rbp-59h]
  char *NewTriggerId; // [rsp+A8h] [rbp-49h] BYREF
  int v52; // [rsp+B0h] [rbp-41h]
  __int64 v53; // [rsp+B4h] [rbp-3Dh]
  int v54; // [rsp+BCh] [rbp-35h]
  __int128 v55; // [rsp+C0h] [rbp-31h]
  __int128 v56; // [rsp+D0h] [rbp-21h]
  int v57; // [rsp+E0h] [rbp-11h]
  __int64 v58[2]; // [rsp+E4h] [rbp-Dh] BYREF

  v53 = 0LL;
  v54 = 0;
  memset(v58, 0, 12);
  DWORD1(v41) = 0;
  v48 = 0;
  NewTriggerId = UbpmParams::GetNewTriggerId((UbpmParams *)a1);
  v20 = (a2 == 0) | 2;
  if ( !*(_BYTE *)(a6 + 12) )
    v20 = a2 == 0;
  v52 = v20;
  if ( a12 )
    v52 = v20 | 8;
  v21 = -1;
  v57 = a3;
  v55 = *a7;
  v56 = *a8;
  if ( a3 != 3 )
  {
    if ( a3 != 1 )
    {
      if ( a3 == 6 )
      {
        memset(&v37[4], 0, 20);
        *(_QWORD *)v37 = *a13;
        if ( *(_QWORD *)(a14 + 8) )
        {
          *(_DWORD *)&v37[8] = 1;
          *(_QWORD *)&v37[16] = a14;
        }
        else
        {
          *(_DWORD *)&v37[8] = 0;
          *(_QWORD *)&v37[16] = 0LL;
        }
        v22 = UbpmParams::NewHostedObject<std::vector<_DAB_WNF_STATE_CHANGE_TRIGGER_PARAMS *>,_DAB_WNF_STATE_CHANGE_TRIGGER_PARAMS>(
                a1 + 105,
                (__int64)v37,
                v18,
                v19,
                v34,
                v36,
                *(__int64 *)v37,
                *(__int64 *)&v37[8],
                *(__int64 *)&v37[16],
                (__int64)v38);
        goto LABEL_22;
      }
      goto LABEL_23;
    }
    v38 = 0LL;
    *(_OWORD *)v37 = 0LL;
    v39 = 0LL;
    if ( a11 == 1 )
    {
      *(_QWORD *)v37 = 0x1000000001LL;
      *(_QWORD *)&v37[8] = &MACHINE_IDLE_GUID;
      v38 = &IDLE_TRIGGER_PROVIDER_GUID;
      v25 = L"Microsoft-Windows-IdleTriggerProvider";
    }
    else
    {
      if ( a11 != 2 )
      {
LABEL_16:
        v40 = UbpmParams::NewHostedObject<std::vector<_DAB_ETW_EVENT_TRIGGER_DATA_ITEM *>,_DAB_ETW_EVENT_TRIGGER_DATA_ITEM>(
                a1 + 99,
                v37,
                v18,
                v19,
                v34,
                v36,
                *(__int64 *)v37,
                *(__int64 *)&v37[8],
                *(__int64 *)&v37[16],
                (__int64)v38);
        v22 = UbpmParams::NewHostedObject<std::vector<_DAB_ETW_EVENT_TRIGGER_PARAMS *>,_DAB_ETW_EVENT_TRIGGER_PARAMS>(
                a1 + 102,
                &v38,
                v26,
                v27,
                v35,
                v36,
                *(__int64 *)v37,
                *(__int64 *)&v37[8],
                *(__int64 *)&v37[16],
                (__int64)v38);
        goto LABEL_22;
      }
      v23 = a1[3];
      v24 = -1LL;
      *(_DWORD *)v37 = 1;
      do
        ++v24;
      while ( *(_WORD *)(v23 + 2 * v24) );
      *(_QWORD *)&v37[8] = v23;
      *(_DWORD *)&v37[4] = 2 * v24 + 2;
      v38 = &TRIGGER_EMULATOR_PROVIDER_GUID;
      v25 = L"Microsoft-Windows-TriggerEmulatorProvider";
    }
    DWORD2(v39) = 1;
    *(_QWORD *)&v39 = v25;
    goto LABEL_16;
  }
  if ( a9 != -1 )
  {
    *(_QWORD *)v37 = a9;
    *(_QWORD *)&v37[8] = a10;
    v22 = UbpmParams::NewHostedObject<std::vector<_DAB_REGISTRATION_TRIGGER_PARAMS *>,_DAB_REGISTRATION_TRIGGER_PARAMS>(
            a1 + 96,
            v37);
LABEL_22:
    *(__int64 *)((char *)v58 + 4) = v22;
  }
LABEL_23:
  LODWORD(v41) = 1;
  *((_QWORD *)&v41 + 1) = UbpmParams::NewHostedObject<std::vector<_DAB_TRIGGER_PARAMS *>,_DAB_TRIGGER_PARAMS>(
                            a1 + 72,
                            (__int64)&NewTriggerId);
  v49 = (a1[44] - a1[43]) >> 3;
  ActionIdArray = UbpmParams::GetActionIdArray((UbpmParams *)a1);
  v29 = *(_DWORD *)a6;
  v50 = ActionIdArray;
  v43 = a5;
  v42 = a4;
  v44 = UbpmParams::ConvertToUbpmRepetitionInterval(v30, v29);
  v31 = *(_DWORD *)(a6 + 4);
  if ( v31 )
  {
    v21 = *(_DWORD *)(a6 + 4);
    if ( v31 < 0x3C )
      v21 = 60;
  }
  v32 = *(_BYTE *)(a6 + 12) == 0;
  v45 = v21;
  v47 = !v32;
  v46 = 0;
  std::vector<_UBPM_TRIGGER_PARAMS>::push_back(a1 + 112, &v41);
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
  {
    WPP_SF_SdD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x18u,
      (__int64)&WPP_f0f7296807f33a7e423f6d049324e537_Traceguids,
      *(const wchar_t **)(a1[1] + 24));
  }
  return 0LL;
}
// 180034F8A: variable 'v18' is possibly undefined
// 180034F8A: variable 'v19' is possibly undefined
// 180034F8A: variable 'v34' is possibly undefined
// 180034FA0: variable 'v26' is possibly undefined
// 180034FA0: variable 'v27' is possibly undefined
// 180034FA0: variable 'v35' is possibly undefined
// 180035048: variable 'v30' is possibly undefined
// 180078320: using guessed type wchar_t aMicrosoftWindo_2[38];
// 180078370: using guessed type wchar_t aMicrosoftWindo[42];
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180035100) ----------------------------------------------------
__int64 __fastcall UbpmParams::AddBootTrigger(
        UbpmParams *this,
        int a2,
        int a3,
        int a4,
        const struct Repetition *a5,
        struct _SYSTEMTIME *a6,
        struct _SYSTEMTIME *a7)
{
  return UbpmParams::AddBasicTrigger(
           (__int64 *)this,
           a2,
           2,
           a3,
           a4,
           (__int64)a5,
           (__int128 *)a6,
           (__int128 *)a7,
           0xFFFFFFFF,
           0LL,
           0,
           0,
           0LL,
           0LL);
}

//----- (0000000180035170) ----------------------------------------------------
__int64 __fastcall UbpmParams::AddEventTrigger(
        UbpmParams *this,
        int a2,
        int a3,
        int a4,
        const struct Repetition *a5,
        struct _SYSTEMTIME *a6,
        struct _SYSTEMTIME *a7)
{
  return UbpmParams::AddBasicTrigger(
           (__int64 *)this,
           a2,
           1,
           a3,
           a4,
           (__int64)a5,
           (__int128 *)a6,
           (__int128 *)a7,
           0xFFFFFFFF,
           0LL,
           2,
           0,
           0LL,
           0LL);
}

//----- (00000001800351E0) ----------------------------------------------------
__int64 __fastcall UbpmParams::AddIdleTrigger(
        UbpmParams *this,
        int a2,
        int a3,
        int a4,
        const struct Repetition *a5,
        struct _SYSTEMTIME *a6,
        struct _SYSTEMTIME *a7,
        int a8)
{
  return UbpmParams::AddBasicTrigger(
           (__int64 *)this,
           a2,
           1,
           a3,
           a4,
           (__int64)a5,
           (__int128 *)a6,
           (__int128 *)a7,
           0xFFFFFFFF,
           0LL,
           1,
           a8,
           0LL,
           0LL);
}

//----- (0000000180035260) ----------------------------------------------------
__int64 __fastcall UbpmParams::AddLogonTrigger(
        UbpmParams *this,
        __int64 a2,
        const struct User *a3,
        int a4,
        unsigned int a5,
        const struct Repetition *a6,
        const struct _SYSTEMTIME *a7,
        const struct _SYSTEMTIME *a8)
{
  return (*(__int64 (__fastcall **)(UbpmParams *, __int64, __int64, const struct User *, int, unsigned int, const struct Repetition *, const struct _SYSTEMTIME *, const struct _SYSTEMTIME *))(*(_QWORD *)this + 40LL))(
           this,
           a2,
           5LL,
           a3,
           a4,
           a5,
           a6,
           a7,
           a8);
}

//----- (00000001800352C0) ----------------------------------------------------
__int64 __fastcall UbpmParams::AddRegistrationTrigger(
        UbpmParams *this,
        int a2,
        int a3,
        int a4,
        const struct Repetition *a5,
        struct _SYSTEMTIME *a6,
        struct _SYSTEMTIME *a7,
        unsigned int a8,
        __int64 a9)
{
  return UbpmParams::AddBasicTrigger(
           (__int64 *)this,
           a2,
           3,
           a3,
           a4,
           (__int64)a5,
           (__int128 *)a6,
           (__int128 *)a7,
           a8,
           a9,
           0,
           0,
           0LL,
           0LL);
}

//----- (0000000180035340) ----------------------------------------------------
__int64 __fastcall UbpmParams::AddSessionBasedTrigger(
        UbpmParams *this,
        int a2,
        int a3,
        const struct User *a4,
        unsigned int a5,
        unsigned int a6,
        const struct Repetition *a7,
        const struct _SYSTEMTIME *a8,
        const struct _SYSTEMTIME *a9)
{
  int v12; // ebx
  void *v13; // rax
  __int64 v14; // r8
  __int64 v15; // r9
  BOOL v16; // eax
  const struct Repetition *v17; // r14
  int v18; // edx
  UbpmParams *v19; // rcx
  unsigned int v20; // eax
  _QWORD *v21; // rcx
  unsigned __int16 v22; // dx
  __int64 v24; // [rsp+28h] [rbp-B1h]
  __int64 v25; // [rsp+30h] [rbp-A9h]
  __int128 v26; // [rsp+38h] [rbp-A1h] BYREF
  __int128 v27; // [rsp+48h] [rbp-91h] BYREF
  unsigned int v28; // [rsp+58h] [rbp-81h]
  unsigned int v29; // [rsp+5Ch] [rbp-7Dh]
  int v30; // [rsp+60h] [rbp-79h]
  unsigned int v31; // [rsp+64h] [rbp-75h]
  char v32; // [rsp+68h] [rbp-71h]
  bool v33; // [rsp+69h] [rbp-70h]
  __int16 v34; // [rsp+6Ah] [rbp-6Fh]
  int v35; // [rsp+6Ch] [rbp-6Dh]
  unsigned __int16 **ActionIdArray; // [rsp+70h] [rbp-69h]
  void *lpMem[2]; // [rsp+78h] [rbp-61h] BYREF
  __int64 v38; // [rsp+88h] [rbp-51h]
  char *NewTriggerId; // [rsp+98h] [rbp-41h] BYREF
  int v40; // [rsp+A0h] [rbp-39h]
  __int64 v41; // [rsp+A4h] [rbp-35h]
  int v42; // [rsp+ACh] [rbp-2Dh]
  __int128 v43; // [rsp+B0h] [rbp-29h]
  __int128 v44; // [rsp+C0h] [rbp-19h]
  int v45; // [rsp+D0h] [rbp-9h]
  int v46; // [rsp+D4h] [rbp-5h]
  __int64 v47; // [rsp+D8h] [rbp-1h]
  __int64 v48; // [rsp+E8h] [rbp+Fh]
  void *v49; // [rsp+130h] [rbp+57h] BYREF

  v48 = -2LL;
  v12 = 0;
  v41 = 0LL;
  v42 = 0;
  v46 = 0;
  v26 = 0LL;
  v13 = 0LL;
  v49 = 0LL;
  DWORD1(v27) = 0;
  v34 = 0;
  if ( !*(_QWORD *)a4 )
  {
LABEL_4:
    LODWORD(v26) = a3;
    if ( v13 )
    {
      *(_OWORD *)lpMem = 0LL;
      v38 = 0LL;
      std::vector<void *>::push_back((__int64 *)lpMem, (__int64 *)&v49);
      DWORD1(v26) = 1;
      *((_QWORD *)&v26 + 1) = UbpmParams::CreateHostedSidInfoArray(this, (void *const **)lpMem);
      if ( lpMem[0] )
        operator delete(lpMem[0]);
    }
    NewTriggerId = UbpmParams::GetNewTriggerId(this);
    v16 = a2 == 0;
    v17 = a7;
    v18 = v16 | 2;
    if ( !*((_BYTE *)a7 + 12) )
      v18 = v16;
    v40 = v18;
    if ( (*(_DWORD *)(*(_QWORD *)(*((_QWORD *)this + 1) + 32LL) + 16LL) & 0xFC000) == 0x8000 )
      v40 = v18 | 4;
    v43 = (__int128)*a8;
    v44 = (__int128)*a9;
    v45 = 5;
    v47 = UbpmParams::NewHostedObject<std::vector<_DAB_ETW_EVENT_TRIGGER_DATA_ITEM *>,_DAB_ETW_EVENT_TRIGGER_DATA_ITEM>(
            (__int64 *)this + 78,
            &v26,
            v14,
            v15,
            v24,
            v25,
            v26,
            *((__int64 *)&v26 + 1),
            v27,
            *((__int64 *)&v27 + 1));
    LODWORD(v27) = 1;
    *((_QWORD *)&v27 + 1) = UbpmParams::NewHostedObject<std::vector<_DAB_TRIGGER_PARAMS *>,_DAB_TRIGGER_PARAMS>(
                              (__int64 *)this + 72,
                              (__int64)&NewTriggerId);
    v35 = (__int64)(*((_QWORD *)this + 44) - *((_QWORD *)this + 43)) >> 3;
    ActionIdArray = UbpmParams::GetActionIdArray(this);
    v28 = a5;
    v29 = a6;
    v30 = UbpmParams::ConvertToUbpmRepetitionInterval(v19, *(_DWORD *)v17);
    v20 = *((_DWORD *)v17 + 1);
    if ( v20 )
    {
      if ( v20 < 0x3C )
        v20 = 60;
    }
    else
    {
      v20 = -1;
    }
    v31 = v20;
    v33 = *((_BYTE *)v17 + 12) != 0;
    v32 = 0;
    std::vector<_UBPM_TRIGGER_PARAMS>::push_back((__int64 *)this + 112, &v27);
    v21 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
    {
      v22 = 18;
      goto LABEL_24;
    }
    return (unsigned int)v12;
  }
  v12 = User::LookupSid(a4, &v49);
  if ( v12 >= 0 )
  {
    v13 = v49;
    goto LABEL_4;
  }
  v21 = WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
  {
    v22 = 17;
LABEL_24:
    WPP_SF_SdD(
      v21[2],
      v22,
      (__int64)&WPP_f0f7296807f33a7e423f6d049324e537_Traceguids,
      *(const wchar_t **)(*((_QWORD *)this + 1) + 24LL));
  }
  return (unsigned int)v12;
}
// 18003550B: conditional instruction was optimized away because ebx.4>=0
// 180035473: variable 'v14' is possibly undefined
// 180035473: variable 'v15' is possibly undefined
// 180035473: variable 'v24' is possibly undefined
// 1800354CA: variable 'v19' is possibly undefined
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (00000001800355B0) ----------------------------------------------------
__int64 __fastcall UbpmParams::AddWnfStateChangeTrigger(
        UbpmParams *this,
        int a2,
        int a3,
        int a4,
        const struct Repetition *a5,
        struct _SYSTEMTIME *a6,
        struct _SYSTEMTIME *a7,
        struct _WNF_STATE_NAME a8,
        void *a9)
{
  struct _WNF_STATE_NAME v10; // [rsp+70h] [rbp-18h] BYREF

  v10 = a8;
  return UbpmParams::AddBasicTrigger(
           (__int64 *)this,
           a2,
           6,
           a3,
           a4,
           (__int64)a5,
           (__int128 *)a6,
           (__int128 *)a7,
           0xFFFFFFFF,
           0LL,
           0,
           0,
           &v10,
           (__int64)a9);
}

//----- (0000000180035658) ----------------------------------------------------
__int64 __fastcall _GSHandlerCheck_EH(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rbx
  __int64 result; // rax

  v4 = *(_QWORD *)(a4 + 56);
  _GSHandlerCheckCommon(a2, a4, v4 + 4);
  result = 1LL;
  if ( ((((*(_DWORD *)(a1 + 4) & 0x66) != 0) + 1) & *(_DWORD *)(v4 + 4)) != 0 )
    return _CxxFrameHandler3_0(a1, a2, a3, a4);
  return result;
}
// 18002FAD4: using guessed type __int64 __fastcall _CxxFrameHandler3_0(_QWORD, _QWORD, _QWORD, _QWORD);
// 180031534: using guessed type __int64 __fastcall _GSHandlerCheckCommon(_QWORD, _QWORD, _QWORD);

//----- (0000000180038760) ----------------------------------------------------
void *__fastcall dynamic_atexit_destructor_for__ShutdownMgr::s_hEvent__(__int64 a1)
{
  return InterlockedAutoHandle::operator=(a1, 0LL);
}

//----- (0000000180038790) ----------------------------------------------------
void **dynamic_atexit_destructor_for__std::_Error_objects_int_::_Generic_object__()
{
  void **result; // rax

  result = &std::error_category::`vftable';
  std::_Error_objects<int>::_Generic_object = &std::error_category::`vftable';
  return result;
}
// 180070460: using guessed type void *std::error_category::`vftable';
// 1800AFF60: using guessed type void **std::_Error_objects<int>::_Generic_object;

//----- (00000001800387A0) ----------------------------------------------------
void **dynamic_atexit_destructor_for__std::_Error_objects_int_::_Iostream_object__()
{
  void **result; // rax

  result = &std::error_category::`vftable';
  std::_Error_objects<int>::_Iostream_object[0] = &std::error_category::`vftable';
  return result;
}
// 180070460: using guessed type void *std::error_category::`vftable';
// 1800AFF58: using guessed type void **std::_Error_objects<int>::_Iostream_object[2];

//----- (00000001800387B0) ----------------------------------------------------
void **dynamic_atexit_destructor_for__std::_Error_objects_int_::_System_object__()
{
  void **result; // rax

  result = &std::error_category::`vftable';
  std::_Error_objects<int>::_System_object[0] = &std::error_category::`vftable';
  return result;
}
// 180070460: using guessed type void *std::error_category::`vftable';
// 1800AFF50: using guessed type void **std::_Error_objects<int>::_System_object[3];

//----- (00000001800387C0) ----------------------------------------------------
void __fastcall wil::details::_dynamic_atexit_destructor_for__g_enabledStateManager__(wil *a1)
{
  wil::manually_managed_shutdown_aware_object<wil::details::EnabledStateManager>::destroy(a1);
}

//----- (00000001800387E0) ----------------------------------------------------
void __fastcall wil::details::_dynamic_atexit_destructor_for__g_featureStateManager__(wil *a1)
{
  wil::manually_managed_shutdown_aware_object<wil::details::FeatureStateManager>::destroy(a1);
}

//----- (0000000180038820) ----------------------------------------------------
void dynamic_atexit_destructor_for__JobStore::m_hashObject__()
{
  HashCompute::~HashCompute((struct _RTL_CRITICAL_SECTION *)&JobStore::m_hashObject);
}

//----- (0000000180038840) ----------------------------------------------------
void ATL::_dynamic_atexit_destructor_for__g_strheap__()
{
  ATL::CWin32Heap::~CWin32Heap((ATL::CWin32Heap *)&ATL::g_strheap);
}
// 1800B0BD8: using guessed type __int64 ATL::g_strheap;

//----- (0000000180038850) ----------------------------------------------------
void **ATL::_dynamic_atexit_destructor_for__g_strmgr__()
{
  void **result; // rax

  result = &ATL::CAtlStringMgr::`vftable';
  ATL::g_strmgr = (__int64)&ATL::CAtlStringMgr::`vftable';
  return result;
}
// 180071800: using guessed type void *ATL::CAtlStringMgr::`vftable';
// 1800B0BF0: using guessed type __int64 ATL::g_strmgr;

//----- (0000000180049D84) ----------------------------------------------------
void __fastcall tsched::SrwLockExclusiveScope::~SrwLockExclusiveScope(PSRWLOCK *this)
{
  ReleaseSRWLockExclusive(*this);
}

//----- (0000000180049DA8) ----------------------------------------------------
wmi::GenericException *__fastcall wmi::GenericException::GenericException(wmi::GenericException *this, int a2)
{
  wmi::GenericException *result; // rax

  *((_DWORD *)this + 11) = -1;
  *((_DWORD *)this + 12) = -1;
  *(_QWORD *)this = &wmi::GenericException::`vftable';
  *((_QWORD *)this + 2) = &word_18007630E;
  result = this;
  *((_BYTE *)this + 8) = 0;
  *((_QWORD *)this + 3) = 0LL;
  *((_QWORD *)this + 4) = 0LL;
  *((_DWORD *)this + 10) = a2;
  return result;
}
// 1800716D8: using guessed type void *wmi::GenericException::`vftable';

//----- (0000000180049DF0) ----------------------------------------------------
void __fastcall tsched::WTSFreeMe<_WTS_SESSION_INFOW>::~WTSFreeMe<_WTS_SESSION_INFOW>(void ***a1)
{
  void *v1; // rcx

  v1 = **a1;
  if ( v1 )
    WTSFreeMemory(v1);
}

//----- (0000000180049E18) ----------------------------------------------------
void __fastcall std::map<JobMoniker,_FILETIME,Scheduler::JobMonikerLess,std::allocator<std::pair<JobMoniker const,_FILETIME>>>::~map<JobMoniker,_FILETIME,Scheduler::JobMonikerLess,std::allocator<std::pair<JobMoniker const,_FILETIME>>>(
        _QWORD *a1)
{
  __int64 v2; // [rsp+40h] [rbp+8h] BYREF

  std::_Tree<std::_Tmap_traits<JobMoniker,_FILETIME,Scheduler::JobMonikerLess,std::allocator<std::pair<JobMoniker const,_FILETIME>>,0>>::erase(
    a1,
    &v2,
    *(_QWORD **)*a1,
    (_QWORD *)*a1);
  operator delete((void *)*a1);
}

//----- (0000000180049E54) ----------------------------------------------------
void __fastcall AuthzAutoHandle::~AuthzAutoHandle(AuthzAutoHandle *this)
{
  if ( *(_QWORD *)this )
  {
    AuthziFreeAuditEventType();
    *(_QWORD *)this = 0LL;
  }
}
// 1800B9000: using guessed type __int64 AuthziFreeAuditEventType(void);

//----- (0000000180049EB0) ----------------------------------------------------
void __fastcall wmi::GenericException::~GenericException(void **this)
{
  *this = &wmi::GenericException::`vftable';
  free(this[3]);
}
// 1800716D8: using guessed type void *wmi::GenericException::`vftable';

//----- (0000000180049ED0) ----------------------------------------------------
void __fastcall JobsService::~JobsService(JobsService *this)
{
  void *v2; // rcx

  *(_QWORD *)this = &JobsService::`vftable';
  JobsService::FinalizeSCMEventLogNotifications(this);
  v2 = (void *)*((_QWORD *)this + 2);
  *(_QWORD *)this = &CNtService::`vftable';
  if ( v2 )
    operator delete(v2);
  DeleteCriticalSection((LPCRITICAL_SECTION)((char *)this + 72));
}
// 180070520: using guessed type void *JobsService::`vftable';
// 180070568: using guessed type void *CNtService::`vftable';

//----- (0000000180049F1C) ----------------------------------------------------
void __fastcall Scheduler::~Scheduler(Scheduler *this)
{
  ScheduleListItem *v2; // rdi
  ScheduleListItem *v3; // rcx
  ScheduleListItem *v4; // rbx
  __int64 v5; // [rsp+40h] [rbp+8h] BYREF

  v2 = (Scheduler *)((char *)this + 320);
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x2000) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x12u, (__int64)&WPP_5435fee58aaf3c352ed5cdc6abf88a31_Traceguids);
  }
  v3 = (ScheduleListItem *)*((_QWORD *)v2 + 1);
  if ( v3 )
  {
    do
    {
      if ( v3 == v2 )
        break;
      v4 = (ScheduleListItem *)*((_QWORD *)v3 + 1);
      ScheduleListItem::Delete(v3);
      v3 = v4;
    }
    while ( v4 );
  }
  ScheduleListItem::~ScheduleListItem((wmi::RefBase **)v2);
  std::_Tree<std::_Tmap_traits<JobMoniker,_FILETIME,Scheduler::JobMonikerLess,std::allocator<std::pair<JobMoniker const,_FILETIME>>,0>>::erase(
    (_QWORD *)this + 34,
    &v5,
    **((_QWORD ***)this + 34),
    *((_QWORD **)this + 34));
  operator delete(*((void **)this + 34));
  SortedRunList::FreeList((Scheduler *)((char *)this + 176));
  wmi::AutoRef<JobBucket>::Release((wmi::RefBase **)this + 31);
  _bstr_t::_Free((Scheduler *)((char *)this + 232));
  *((_QWORD *)this + 22) = &RunListItem::`vftable';
  *((_QWORD *)this + 23) = 0LL;
  *((_QWORD *)this + 24) = 0LL;
  SortedRunList::FreeList((Scheduler *)((char *)this + 72));
  wmi::AutoRef<JobBucket>::Release((wmi::RefBase **)this + 18);
  _bstr_t::_Free((Scheduler *)((char *)this + 128));
  *((_QWORD *)this + 9) = &RunListItem::`vftable';
  *((_QWORD *)this + 10) = 0LL;
  *((_QWORD *)this + 11) = 0LL;
  DeleteCriticalSection((LPCRITICAL_SECTION)((char *)this + 32));
  wmi::AutoHandle::Close((void **)this + 3);
}
// 180070228: using guessed type void *RunListItem::`vftable';
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018004A060) ----------------------------------------------------
void __fastcall ShutdownGuard::~ShutdownGuard(ShutdownGuard *this)
{
  _InterlockedExchange((volatile __int32 *)this, 0);
  if ( _InterlockedExchangeAdd(&ShutdownMgr::s_sync, 0xFFFFFFFF) == 1 )
    SetEvent((HANDLE)_InterlockedCompareExchange64((volatile signed __int64 *)&ShutdownMgr::s_hEvent, -1LL, -1LL));
}
// 1800B0A10: using guessed type int ShutdownMgr::s_sync;

//----- (000000018004A0A4) ----------------------------------------------------
void __fastcall SortedRunList::~SortedRunList(wmi::RefBase **this)
{
  SortedRunList::FreeList((SortedRunList *)this);
  wmi::AutoRef<JobBucket>::Release(this + 9);
  _bstr_t::_Free((_bstr_t *)(this + 7));
  this[1] = 0LL;
  this[2] = 0LL;
  *this = (wmi::RefBase *)&RunListItem::`vftable';
}
// 180070228: using guessed type void *RunListItem::`vftable';

//----- (000000018004A0E8) ----------------------------------------------------
bool __fastcall TSTime::operator>=(__int64 a1, __int128 *a2)
{
  __int128 v4; // [rsp+20h] [rbp-18h] BYREF

  TSTime::EqualizeLocality((char *)a1, &v4, a2);
  return *(_QWORD *)(a1 + 8) >= *((_QWORD *)&v4 + 1);
}

//----- (000000018004A120) ----------------------------------------------------
void **__fastcall wmi::GenericException::`vector deleting destructor'(void **this, char a2)
{
  *this = &wmi::GenericException::`vftable';
  free(this[3]);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 1800716D8: using guessed type void *wmi::GenericException::`vftable';

//----- (000000018004A16C) ----------------------------------------------------
void ModuleTracker::Dump(void)
{
  unsigned __int64 v0; // rbx
  unsigned __int64 i; // rdi
  __int64 v2; // [rsp+20h] [rbp-E0h]
  unsigned __int16 v3[128]; // [rsp+30h] [rbp-D0h] BYREF
  unsigned __int16 v4[8]; // [rsp+130h] [rbp+30h] BYREF
  __int128 v5; // [rsp+140h] [rbp+40h]
  __int128 v6; // [rsp+150h] [rbp+50h]
  int v7; // [rsp+160h] [rbp+60h] BYREF
  wchar_t v8; // [rsp+164h] [rbp+64h]
  char v9[4042]; // [rsp+166h] [rbp+66h] BYREF

  *(_OWORD *)v4 = *(_OWORD *)L"Initialization sequence:";
  LOWORD(v7) = aInitialization[24];
  v5 = *(_OWORD *)L"zation sequence:";
  v6 = *(_OWORD *)L"equence:";
  memset_0((char *)&v7 + 2, 0, 0xFCEuLL);
  v0 = 0LL;
  for ( i = 0LL; i < 0x140; i += 16LL )
  {
    memset_0(v3, 0, sizeof(v3));
    LODWORD(v2) = *(unsigned int *)((char *)&dword_1800AFC38 + i);
    StringCchPrintfW(v3, 0x80uLL, (size_t *)L" %s(0x%x)", *(_QWORD *)((char *)&ModuleTracker::init + i), v2);
    StringCchCatW(v4, 2048LL, (char *)v3);
  }
  v7 = *(_DWORD *)L"e:";
  *(_OWORD *)v4 = *(_OWORD *)L"Uninitialization sequence:";
  v5 = *(_OWORD *)L"lization sequence:";
  v6 = *(_OWORD *)L" sequence:";
  v8 = aUninitializati[26];
  memset_0(v9, 0, sizeof(v9));
  do
  {
    memset_0(v3, 0, sizeof(v3));
    LODWORD(v2) = dword_1800AFE18[v0];
    StringCchPrintfW(v3, 0x80uLL, (size_t *)L" %s(0x%x)", *(_QWORD *)((char *)&ModuleTracker::uninit + v0 * 4), v2);
    StringCchCatW(v4, 2048LL, (char *)v3);
    v0 += 4LL;
  }
  while ( v0 < 80 );
}
// 18004A21F: variable 'v2' is possibly undefined
// 18007F5C8: using guessed type wchar_t aInitialization[25];
// 18007F618: using guessed type wchar_t aUninitializati[27];
// 1800AFE18: using guessed type int dword_1800AFE18[];
// 18004A16C: using guessed type char var_FDA[4042];

//----- (000000018004A314) ----------------------------------------------------
__int64 __fastcall JobsService::EnableOperationalLog(BOOL a1)
{
  unsigned int LastHrError; // ebx
  tsched *v3; // rcx
  EVT_HANDLE v4; // rdi
  EventManager *v5; // rcx
  void *v6; // r8
  const struct _GUID *v7; // r9
  struct _EVT_VARIANT PropertyValue; // [rsp+30h] [rbp-18h] BYREF
  DWORD PropertyValueBufferUsed; // [rsp+58h] [rbp+10h] BYREF

  LastHrError = 0;
  PropertyValue = 0LL;
  v4 = EvtOpenChannelConfig(0LL, L"Microsoft-Windows-TaskScheduler/Operational", 0);
  if ( v4 )
  {
    if ( EvtGetChannelConfigProperty(v4, EvtChannelConfigEnabled, 0, 0x10u, &PropertyValue, &PropertyValueBufferUsed) )
    {
      if ( PropertyValue.Type == 13 && PropertyValue.BooleanVal == a1 )
        goto LABEL_11;
      PropertyValue.Type = 13;
      PropertyValue.BooleanVal = a1;
      if ( EvtSetChannelConfigProperty(v4, EvtChannelConfigEnabled, 0, &PropertyValue) && EvtSaveChannelConfig(v4, 0) )
      {
        if ( !a1 )
          EventManager::EvtReport(v5, &SCHEDULE_OPERATIONAL_LOG_DISABLED, v6, v7);
        goto LABEL_11;
      }
    }
    LastHrError = tsched::GetLastHrError(v5);
LABEL_11:
    EvtClose(v4);
    return LastHrError;
  }
  return (unsigned int)tsched::GetLastHrError(v3);
}
// 18004A34F: variable 'v3' is possibly undefined
// 18004A38D: variable 'v5' is possibly undefined
// 18004A3EC: variable 'v6' is possibly undefined
// 18004A3EC: variable 'v7' is possibly undefined

//----- (000000018004A420) ----------------------------------------------------
void __fastcall JobsService::FinalCleanup(JobsService *this, __int64 a2, void *a3, const struct _GUID *a4)
{
  unsigned __int64 i; // rax
  JobsService *v6; // rcx
  void *started; // rsi
  void *v8; // rbx
  signed int v9; // eax
  Idolater *v10; // rcx
  Scheduler *v11; // rbx
  EventTrapMap *v12; // rbx
  PseudoEventTrap *v13; // rbx
  signed int v14; // eax
  AuthzAutoHandle *v15; // rbx
  EventManager *v16; // rbx
  void *v17; // rcx
  void *v18; // rcx
  void *v19; // rcx
  int v20; // eax

  for ( i = 0LL; i < 80; i += 4LL )
  {
    v6 = (JobsService *)dword_1800AFE18;
    dword_1800AFE18[i] = -1;
  }
  if ( g_pEventManager )
    EventManager::EvtReport((EventManager *)dword_1800AFE18, &SCHEDULE_SERVICE_STOP, a3, a4);
  if ( dword_1800AFD28 != -1 )
  {
    RpcServer::StopServer((RPC_BINDING_VECTOR **)&RpcServer::s_singleton);
    dword_1800AFF08 = 0;
  }
  if ( dword_1800AFCF8 >= 0 )
  {
    byte_1800B0CC8 = 0;
    SetEvent(*(&WaitHandle + 1));
  }
  if ( dword_1800AFD48 >= 0 )
  {
    JobsService::UninitializeWPTS(v6);
    dword_1800AFF28 = 0;
  }
  if ( dword_1800AFD38 >= 0 )
  {
    UbpmTerminate();
    dword_1800AFF18 = 0;
  }
  started = 0LL;
  if ( dword_1800AFD18 >= 0 )
    started = (void *)PlugIn::StartCleanUp(&PlugIn::s_singleton);
  v8 = 0LL;
  if ( dword_1800AFC78 >= 0 )
    v8 = (void *)ShutdownMgr::Shutdown();
  if ( g_hShutdownEvent )
    SetEvent(g_hShutdownEvent);
  if ( v8 )
  {
    v9 = WaitForSingleObject(v8, 0xFFFFFFFF);
    if ( v9 )
    {
      if ( v9 > 0 )
        v9 = (unsigned __int16)v9 | 0x80070000;
      dword_1800AFE58 = v9;
    }
    else
    {
      dword_1800AFE58 = 0;
    }
  }
  JobsService::FinalizeSCMEventLogNotifications(this);
  if ( *((_QWORD *)this + 32) )
  {
    AcquireSRWLockExclusive((PSRWLOCK)this + 33);
    CloseThreadpoolCleanupGroupMembers(*((PTP_CLEANUP_GROUP *)this + 32), 1, 0LL);
    CloseThreadpoolCleanupGroup(*((PTP_CLEANUP_GROUP *)this + 32));
    *((_QWORD *)this + 32) = 0LL;
    ReleaseSRWLockExclusive((PSRWLOCK)this + 33);
  }
  if ( dword_1800AFCF8 >= 0 )
  {
    Idolater::Uninit(v10);
    dword_1800AFED8 = 0;
  }
  if ( (dword_1800AFC38 & 0x80000000) == 0 )
  {
    ItSrvUninitialize();
    dword_1800AFE18[0] = 0;
  }
  if ( dword_1800AFCB8 != -1 )
  {
    v11 = g_pScheduler;
    if ( g_pScheduler )
    {
      Scheduler::~Scheduler(g_pScheduler);
      operator delete(v11);
    }
    g_pScheduler = 0LL;
    dword_1800AFE98 = 0;
  }
  if ( dword_1800AFCC8 != -1 )
  {
    v12 = g_pEventTrapMap;
    if ( g_pEventTrapMap )
    {
      EventTrapMap::~EventTrapMap(g_pEventTrapMap);
      operator delete(v12);
    }
    g_pEventTrapMap = 0LL;
    dword_1800AFEA8 = 0;
  }
  if ( dword_1800AFCD8 != -1 )
  {
    v13 = g_pPseudoEventTrap;
    if ( g_pPseudoEventTrap )
    {
      PseudoEventTrap::~PseudoEventTrap(g_pPseudoEventTrap);
      operator delete(v13);
    }
    g_pPseudoEventTrap = 0LL;
    dword_1800AFEB8 = 0;
  }
  if ( dword_1800AFCE8 != -1 )
  {
    User::UninitializeUserTable();
    dword_1800AFEC8 = 0;
  }
  if ( dword_1800AFC88 != -1 )
  {
    JobStore::DeleteCommonJobStore();
    dword_1800AFE68 = 0;
  }
  if ( dword_1800AFC68 != -1 )
  {
    CredStore::Uninit();
    dword_1800AFE48 = 0;
  }
  if ( started )
  {
    v14 = WaitForSingleObject(started, 0xFFFFFFFF);
    if ( v14 )
    {
      if ( v14 > 0 )
        v14 = (unsigned __int16)v14 | 0x80070000;
      dword_1800AFEE8 = v14;
    }
    else
    {
      dword_1800AFEE8 = 0;
    }
  }
  if ( dword_1800AFC58 >= 0 )
  {
    CoUninitialize();
    dword_1800AFE38 = 0;
  }
  ModuleTracker::Dump();
  v15 = g_pAuditor;
  if ( g_pAuditor )
  {
    AuthzAutoHandle::~AuthzAutoHandle((AuthzAutoHandle *)((char *)g_pAuditor + 32));
    AuthzAutoHandle::~AuthzAutoHandle((AuthzAutoHandle *)((char *)v15 + 24));
    AuthzAutoHandle::~AuthzAutoHandle((AuthzAutoHandle *)((char *)v15 + 16));
    AuthzAutoHandle::~AuthzAutoHandle((AuthzAutoHandle *)((char *)v15 + 8));
    AuthzAutoHandle::~AuthzAutoHandle(v15);
    operator delete(v15);
  }
  v16 = g_pEventManager;
  g_pAuditor = 0LL;
  if ( g_pEventManager )
  {
    if ( *(_QWORD *)g_pEventManager )
    {
      EtwEventUnregister();
      *(_QWORD *)v16 = 0LL;
    }
    DeleteCriticalSection((LPCRITICAL_SECTION)((char *)v16 + 8));
    operator delete(v16);
  }
  v17 = (void *)*((_QWORD *)this + 14);
  g_pEventManager = 0LL;
  if ( v17 )
  {
    CloseHandle(v17);
    *((_QWORD *)this + 14) = 0LL;
  }
  v18 = (void *)*((_QWORD *)this + 15);
  if ( v18 )
  {
    CloseHandle(v18);
    *((_QWORD *)this + 15) = 0LL;
  }
  v19 = (void *)*((_QWORD *)this + 18);
  if ( v19 )
  {
    CloseHandle(v19);
    *((_QWORD *)this + 18) = 0LL;
  }
  if ( g_hShutdownEvent )
  {
    CloseHandle(g_hShutdownEvent);
    g_hShutdownEvent = 0LL;
  }
  if ( dword_1800AFD18 >= 0 )
  {
    EnterCriticalSection(&PlugIn::s_singleton);
    PlugIn::Internal_Unload((PlugIn *)&PlugIn::s_singleton);
    LeaveCriticalSection(&PlugIn::s_singleton);
  }
  if ( dword_1800AFD08 >= 0 )
    DeleteCriticalSection(&PlugIn::s_singleton);
  v20 = dword_1800AFF48;
  if ( dword_1800AFD68 != -1 )
    v20 = 0;
  dword_1800AFF48 = v20;
}
// 18004A4B1: variable 'v6' is possibly undefined
// 18004A5C3: variable 'v10' is possibly undefined
// 180073D30: using guessed type __int64 UbpmTerminate(void);
// 180074770: using guessed type __int64 EtwEventUnregister(void);
// 1800AFC58: using guessed type int dword_1800AFC58;
// 1800AFC68: using guessed type int dword_1800AFC68;
// 1800AFC78: using guessed type int dword_1800AFC78;
// 1800AFC88: using guessed type int dword_1800AFC88;
// 1800AFCB8: using guessed type int dword_1800AFCB8;
// 1800AFCC8: using guessed type int dword_1800AFCC8;
// 1800AFCD8: using guessed type int dword_1800AFCD8;
// 1800AFCE8: using guessed type int dword_1800AFCE8;
// 1800AFCF8: using guessed type int dword_1800AFCF8;
// 1800AFD08: using guessed type int dword_1800AFD08;
// 1800AFD18: using guessed type int dword_1800AFD18;
// 1800AFD28: using guessed type int dword_1800AFD28;
// 1800AFD38: using guessed type int dword_1800AFD38;
// 1800AFD48: using guessed type int dword_1800AFD48;
// 1800AFD68: using guessed type int dword_1800AFD68;
// 1800AFE18: using guessed type int dword_1800AFE18[];
// 1800AFE38: using guessed type int dword_1800AFE38;
// 1800AFE48: using guessed type int dword_1800AFE48;
// 1800AFE58: using guessed type int dword_1800AFE58;
// 1800AFE68: using guessed type int dword_1800AFE68;
// 1800AFE98: using guessed type int dword_1800AFE98;
// 1800AFEA8: using guessed type int dword_1800AFEA8;
// 1800AFEB8: using guessed type int dword_1800AFEB8;
// 1800AFEC8: using guessed type int dword_1800AFEC8;
// 1800AFED8: using guessed type int dword_1800AFED8;
// 1800AFEE8: using guessed type int dword_1800AFEE8;
// 1800AFF08: using guessed type int dword_1800AFF08;
// 1800AFF18: using guessed type int dword_1800AFF18;
// 1800AFF28: using guessed type int dword_1800AFF28;
// 1800AFF48: using guessed type int dword_1800AFF48;
// 1800B0CC8: using guessed type char byte_1800B0CC8;
// 1800B0CE0: using guessed type _RTL_CRITICAL_SECTION PlugIn::s_singleton;
// 1800B0D48: using guessed type __int64 RpcServer::s_singleton;

//----- (000000018004A87C) ----------------------------------------------------
void __fastcall JobsService::FinalizeSCMEventLogNotifications(JobsService *this)
{
  if ( *((_QWORD *)this + 17) )
  {
    UnsubscribeServiceChangeNotifications();
    *((_QWORD *)this + 17) = 0LL;
  }
}
// 1800B9260: using guessed type __int64 UnsubscribeServiceChangeNotifications(void);

//----- (000000018004A8B4) ----------------------------------------------------
signed int __fastcall tsched::GetLastHrError(tsched *this)
{
  signed int result; // eax

  result = GetLastError();
  if ( result > 0 )
    result = (unsigned __int16)result | 0x80070000;
  if ( result >= 0 )
    return -2147467259;
  return result;
}

//----- (000000018004A8F0) ----------------------------------------------------
void __fastcall JobsService::Log(JobsService *this, const unsigned __int16 *a2)
{
  CNtService::Log(this, a2);
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x400) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
  {
    GetLastError();
    WPP_SF_SD(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x15u, (__int64)&WPP_e3966bf9b81b3ab085a9dfdc4dace9ef_Traceguids, a2);
  }
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018004A95C) ----------------------------------------------------
__int64 __fastcall JobsService::SetMachineDomainJoinPrevDetected(int a1)
{
  unsigned int v1; // ebx
  LSTATUS v2; // eax
  bool v3; // zf
  bool v4; // sf
  int Data; // [rsp+60h] [rbp+8h] BYREF
  HKEY hKey; // [rsp+68h] [rbp+10h] BYREF

  v1 = 0;
  Data = a1;
  hKey = 0LL;
  v2 = RegCreateKeyExW(
         HKEY_LOCAL_MACHINE,
         L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Schedule",
         0,
         0LL,
         0,
         0x2001Fu,
         0LL,
         &hKey,
         0LL);
  v3 = v2 == 0;
  v4 = v2 < 0;
  if ( v2
    || (v2 = RegSetValueExW(hKey, L"DomainJoinDetected", 0, 4u, (const BYTE *)&Data, 4u), v3 = v2 == 0, v4 = v2 < 0, v2) )
  {
    if ( v4 || v3 )
      v1 = v2;
    else
      v1 = (unsigned __int16)v2 | 0x80070000;
  }
  wmi::AutoRegKey::Close(&hKey);
  return v1;
}

//----- (000000018004AA08) ----------------------------------------------------
int __fastcall JobsService::SetWakeupTimer(__int64 a1, __int64 a2, JobMoniker *a3)
{
  __int128 v5; // xmm0
  void *v6; // rcx
  unsigned int LastError; // ebx
  void *v8; // r9
  int result; // eax
  _QWORD *v10; // rcx
  unsigned __int16 v11; // dx
  void *v12; // r9
  struct _REASON_CONTEXT WakeContext; // [rsp+40h] [rbp-20h] BYREF
  const unsigned __int16 *Path; // [rsp+70h] [rbp+10h] BYREF
  LARGE_INTEGER DueTime; // [rsp+78h] [rbp+18h] BYREF

  WakeContext.Version = 0;
  WakeContext.Reason.Detailed.LocalizedReasonModule = g_hInstance;
  WakeContext.Flags = 2;
  *((_QWORD *)&WakeContext.Reason.SimpleReasonString + 1) = 0x100000066LL;
  Path = JobMoniker::GetPath(a3);
  DueTime.QuadPart = -300000000LL;
  WakeContext.Reason.Detailed.ReasonStrings = (LPWSTR *)&Path;
  TSTime::operator+=(a2, (__int64 *)&DueTime);
  v5 = *(_OWORD *)a2;
  v6 = *(void **)(a1 + 144);
  DueTime = *(LARGE_INTEGER *)(a2 + 8);
  *(_OWORD *)(a1 + 152) = v5;
  if ( SetWaitableTimerEx(v6, &DueTime, 0, (PTIMERAPCROUTINE)JobsService::WakeUpProc, 0LL, &WakeContext, 0) )
  {
    result = GetLastError();
    LastError = 50;
    if ( result == 50 )
    {
      result = EventManager::EvtReport(g_pEventManager, &SCHEDULE_SERVICE_SET_WAKEUP_TIMER_ERROR, 50LL, v12);
      v10 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x400) != 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        v11 = 25;
        return WPP_SF_D(v10[2], v11, (__int64)&WPP_e3966bf9b81b3ab085a9dfdc4dace9ef_Traceguids, LastError);
      }
    }
  }
  else
  {
    LastError = GetLastError();
    result = EventManager::EvtReport(g_pEventManager, &SCHEDULE_SERVICE_SET_WAKEUP_TIMER_ERROR, LastError, v8);
    v10 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x400) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      v11 = 24;
      return WPP_SF_D(v10[2], v11, (__int64)&WPP_e3966bf9b81b3ab085a9dfdc4dace9ef_Traceguids, LastError);
    }
  }
  return result;
}
// 18004AAD7: variable 'v8' is possibly undefined
// 18004AB2B: variable 'v12' is possibly undefined
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 1800B0960: using guessed type HINSTANCE g_hInstance;

//----- (000000018004AB84) ----------------------------------------------------
signed __int64 ShutdownMgr::Shutdown(void)
{
  if ( _InterlockedCompareExchange(&dword_1800B0A14, 0, 1)
    && _InterlockedExchangeAdd(&ShutdownMgr::s_sync, 0xFFFFFFFF) == 1 )
  {
    SetEvent((HANDLE)_InterlockedCompareExchange64((volatile signed __int64 *)&ShutdownMgr::s_hEvent, -1LL, -1LL));
  }
  return _InterlockedCompareExchange64((volatile signed __int64 *)&ShutdownMgr::s_hEvent, -1LL, -1LL);
}
// 1800B0A10: using guessed type int ShutdownMgr::s_sync;
// 1800B0A14: using guessed type int dword_1800B0A14;

//----- (000000018004ABF0) ----------------------------------------------------
void __fastcall _Stop__QCNtService__JobsService__UEAAXH_Z(__int64 a1, int a2)
{
  void **v3; // rcx
  void *v4; // rax

  v3 = (void **)WPP_GLOBAL_Control;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x2000) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
  {
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x10u, (__int64)&WPP_e3966bf9b81b3ab085a9dfdc4dace9ef_Traceguids, a2);
    v3 = (void **)WPP_GLOBAL_Control;
  }
  if ( *(_QWORD *)(a1 + 112) )
  {
    v4 = *(void **)(a1 + 112);
    if ( v3 != &WPP_GLOBAL_Control && (*((_DWORD *)v3 + 7) & 0x2000) != 0 && *((_BYTE *)v3 + 25) >= 4u )
    {
      WPP_SF_q((__int64)v3[2], 0x11u, (__int64)&WPP_e3966bf9b81b3ab085a9dfdc4dace9ef_Traceguids);
      v4 = *(void **)(a1 + 112);
    }
    SetEvent(v4);
  }
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018004AC98) ----------------------------------------------------
__int64 __fastcall JobsService::UninitializeWPTS(JobsService *this)
{
  unsigned int v1; // ebx
  void (*ProcAddress)(void); // rax
  signed int LastError; // eax

  v1 = 0;
  if ( !g_hModuleWpts )
    return 0LL;
  ProcAddress = (void (*)(void))GetProcAddress(g_hModuleWpts, "WptsTerminate");
  if ( ProcAddress )
  {
    ProcAddress();
  }
  else
  {
    LastError = GetLastError();
    v1 = LastError;
    if ( LastError > 0 )
      v1 = (unsigned __int16)LastError | 0x80070000;
  }
  FreeLibrary(g_hModuleWpts);
  g_hModuleWpts = 0LL;
  return v1;
}

//----- (000000018004AD20) ----------------------------------------------------
void __fastcall JobsService::WakeUpProc(
        EventManager *lpArgToCompletionRoutine,
        DWORD dwTimerLowValue,
        void *dwTimerHighValue,
        const struct _GUID *a4)
{
  EventManager::EvtReport(lpArgToCompletionRoutine, &TASK_STARTED_ON_COMPUTER_WAKEUP, dwTimerHighValue, a4);
}

//----- (000000018004AD34) ----------------------------------------------------
void __fastcall std::_Tree<std::_Tmap_traits<JobMoniker,_FILETIME,Scheduler::JobMonikerLess,std::allocator<std::pair<JobMoniker const,_FILETIME>>,0>>::_Erase(
        __int64 a1,
        wmi::RefBase **a2)
{
  wmi::RefBase **v2; // rbx
  wmi::RefBase *v4; // rdi

  v2 = a2;
  v4 = (wmi::RefBase *)a2;
  if ( !*((_BYTE *)a2 + 25) )
  {
    do
    {
      std::_Tree<std::_Tmap_traits<JobMoniker,_FILETIME,Scheduler::JobMonikerLess,std::allocator<std::pair<JobMoniker const,_FILETIME>>,0>>::_Erase(
        a1,
        *((_QWORD *)v4 + 2));
      v4 = *(wmi::RefBase **)v4;
      wmi::AutoRef<JobBucket>::Release(v2 + 8);
      _bstr_t::_Free((_bstr_t *)(v2 + 6));
      operator delete(v2);
      v2 = (wmi::RefBase **)v4;
    }
    while ( !*((_BYTE *)v4 + 25) );
  }
}

//----- (000000018004AD9C) ----------------------------------------------------
_QWORD *__fastcall std::_Tree<std::_Tmap_traits<User,LogonJob *,User::less,std::allocator<std::pair<User const,LogonJob *>>,1>>::_Lrotate(
        __int64 a1,
        __int64 a2)
{
  _QWORD *v2; // r8
  _QWORD *result; // rax

  v2 = *(_QWORD **)(a2 + 16);
  *(_QWORD *)(a2 + 16) = *v2;
  if ( !*(_BYTE *)(*v2 + 25LL) )
    *(_QWORD *)(*v2 + 8LL) = a2;
  v2[1] = *(_QWORD *)(a2 + 8);
  result = *(_QWORD **)a1;
  if ( a2 == *(_QWORD *)(*(_QWORD *)a1 + 8LL) )
  {
    result[1] = v2;
  }
  else
  {
    result = *(_QWORD **)(a2 + 8);
    if ( a2 == *result )
      *result = v2;
    else
      result[2] = v2;
  }
  *v2 = a2;
  *(_QWORD *)(a2 + 8) = v2;
  return result;
}

//----- (000000018004ADEC) ----------------------------------------------------
_QWORD *__fastcall std::_Tree_val<std::_Tree_simple_types<std::pair<_bstr_t const,std::list<_FILETIME> *>>>::_Min(
        _QWORD *a1)
{
  __int64 *v1; // rdx

  v1 = (__int64 *)*a1;
  if ( !*(_BYTE *)(*a1 + 25LL) )
  {
    do
    {
      a1 = v1;
      v1 = (__int64 *)*v1;
    }
    while ( !*((_BYTE *)v1 + 25) );
  }
  return a1;
}

//----- (000000018004AE10) ----------------------------------------------------
_QWORD *__fastcall std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::_Rrotate(
        __int64 a1,
        _QWORD *a2)
{
  __int64 v2; // r8
  __int64 v3; // rax
  _QWORD *result; // rax

  v2 = *a2;
  *a2 = *(_QWORD *)(*a2 + 16LL);
  v3 = *(_QWORD *)(v2 + 16);
  if ( !*(_BYTE *)(v3 + 25) )
    *(_QWORD *)(v3 + 8) = a2;
  *(_QWORD *)(v2 + 8) = a2[1];
  result = *(_QWORD **)a1;
  if ( a2 == *(_QWORD **)(*(_QWORD *)a1 + 8LL) )
  {
    result[1] = v2;
  }
  else
  {
    result = (_QWORD *)a2[1];
    if ( a2 == (_QWORD *)result[2] )
      result[2] = v2;
    else
      *result = v2;
  }
  *(_QWORD *)(v2 + 16) = a2;
  a2[1] = v2;
  return result;
}

//----- (000000018004AE64) ----------------------------------------------------
_QWORD *__fastcall std::_Tree<std::_Tmap_traits<JobMoniker,_FILETIME,Scheduler::JobMonikerLess,std::allocator<std::pair<JobMoniker const,_FILETIME>>,0>>::erase(
        _QWORD *a1,
        _QWORD *a2,
        _QWORD *a3,
        _QWORD *a4)
{
  __int64 v6; // rdx
  _QWORD *v7; // rbx
  _QWORD *v9; // rax
  _QWORD *v10; // r8
  __int64 v11; // rcx
  _QWORD *i; // rax
  __int64 v14; // [rsp+30h] [rbp+8h] BYREF

  v6 = *a1;
  v7 = a3;
  if ( a3 == *(_QWORD **)*a1 && a4 == (_QWORD *)v6 )
  {
    std::_Tree<std::_Tmap_traits<JobMoniker,_FILETIME,Scheduler::JobMonikerLess,std::allocator<std::pair<JobMoniker const,_FILETIME>>,0>>::_Erase(
      (__int64)a1,
      *(wmi::RefBase ***)(v6 + 8));
    *(_QWORD *)(*a1 + 8LL) = *a1;
    *(_QWORD *)*a1 = *a1;
    *(_QWORD *)(*a1 + 16LL) = *a1;
    v9 = (_QWORD *)*a1;
    a1[1] = 0LL;
    *a2 = *v9;
  }
  else
  {
    while ( v7 != a4 )
    {
      v10 = v7;
      if ( !*((_BYTE *)v7 + 25) )
      {
        v11 = v7[2];
        if ( *(_BYTE *)(v11 + 25) )
        {
          for ( i = (_QWORD *)v7[1]; !*((_BYTE *)i + 25) && v7 == (_QWORD *)i[2]; i = (_QWORD *)i[1] )
            v7 = i;
        }
        else
        {
          i = std::_Tree_val<std::_Tree_simple_types<std::pair<_bstr_t const,std::list<_FILETIME> *>>>::_Min((_QWORD *)v11);
        }
        v7 = i;
      }
      std::_Tree<std::_Tset_traits<JobMoniker,std::less<JobMoniker>,std::allocator<JobMoniker>,0>>::erase(a1, &v14, v10);
    }
    *a2 = v7;
  }
  return a2;
}
// 18004AF02: variable 'v10' is possibly undefined

//----- (000000018004AF2C) ----------------------------------------------------
_QWORD *__fastcall std::_Tree<std::_Tset_traits<JobMoniker,std::less<JobMoniker>,std::allocator<JobMoniker>,0>>::erase(
        _QWORD *a1,
        _QWORD *a2,
        _QWORD *a3)
{
  _QWORD *v5; // rbp
  _QWORD *v6; // r11
  _QWORD *v7; // rdi
  __int64 v8; // r9
  _QWORD *i; // rbx
  __int64 v10; // r10
  _QWORD *v11; // r8
  _QWORD *v12; // rax
  _QWORD *v13; // rax
  __int64 v14; // rcx
  __int64 v15; // rdx
  char v16; // cl
  _QWORD *v17; // rax
  __int64 v18; // r11
  _BYTE *v19; // rdx
  __int64 v20; // rcx
  __int64 v21; // rax
  _QWORD *result; // rax

  v5 = a3;
  if ( *((_BYTE *)a3 + 25) )
    std::_Xout_of_range("invalid map/set<T> iterator");
  v6 = a3 + 2;
  v7 = a3;
  v8 = a3[2];
  if ( *(_BYTE *)(v8 + 25) )
  {
    for ( i = (_QWORD *)a3[1]; !*((_BYTE *)i + 25) && a3 == (_QWORD *)i[2]; i = (_QWORD *)i[1] )
      a3 = i;
  }
  else
  {
    i = std::_Tree_val<std::_Tree_simple_types<std::pair<_bstr_t const,std::list<_FILETIME> *>>>::_Min((_QWORD *)a3[2]);
  }
  if ( *(_BYTE *)(*v7 + 25LL) )
    goto LABEL_13;
  if ( *(_BYTE *)(v8 + 25) )
  {
    v8 = *v7;
LABEL_13:
    v10 = v7[1];
    if ( !*(_BYTE *)(v8 + 25) )
      *(_QWORD *)(v8 + 8) = v10;
    if ( *(_QWORD **)(*a1 + 8LL) == v7 )
    {
      *(_QWORD *)(*a1 + 8LL) = v8;
    }
    else if ( *(_QWORD **)v10 == v7 )
    {
      *(_QWORD *)v10 = v8;
    }
    else
    {
      *(_QWORD *)(v10 + 16) = v8;
    }
    v11 = (_QWORD *)*a1;
    v12 = (_QWORD *)*a1;
    if ( *(_QWORD **)*a1 == v7 )
    {
      if ( *(_BYTE *)(v8 + 25) )
        v13 = (_QWORD *)v10;
      else
        v13 = std::_Tree_val<std::_Tree_simple_types<std::pair<_bstr_t const,std::list<_FILETIME> *>>>::_Min((_QWORD *)v8);
      *v11 = v13;
      v11 = (_QWORD *)*a1;
      v12 = (_QWORD *)*a1;
    }
    if ( (_QWORD *)v12[2] == v7 )
    {
      if ( *(_BYTE *)(v8 + 25) )
      {
        v14 = v10;
      }
      else
      {
        v15 = *(_QWORD *)(v8 + 16);
        v14 = v8;
        if ( !*(_BYTE *)(v15 + 25) )
        {
          do
          {
            v14 = v15;
            v15 = *(_QWORD *)(v15 + 16);
          }
          while ( !*(_BYTE *)(v15 + 25) );
          v12 = v11;
        }
      }
      v12[2] = v14;
    }
    v16 = *((_BYTE *)v5 + 24);
    goto LABEL_44;
  }
  v8 = i[2];
  if ( i == v7 )
    goto LABEL_13;
  *(_QWORD *)(*v7 + 8LL) = i;
  *i = *v7;
  if ( i == (_QWORD *)*v6 )
  {
    v10 = (__int64)i;
  }
  else
  {
    v10 = i[1];
    if ( !*(_BYTE *)(v8 + 25) )
      *(_QWORD *)(v8 + 8) = v10;
    *(_QWORD *)v10 = v8;
    i[2] = *v6;
    *(_QWORD *)(*v6 + 8LL) = i;
  }
  if ( *(_QWORD **)(*a1 + 8LL) == v7 )
  {
    *(_QWORD *)(*a1 + 8LL) = i;
  }
  else
  {
    v17 = (_QWORD *)v7[1];
    if ( (_QWORD *)*v17 == v7 )
      *v17 = i;
    else
      v17[2] = i;
  }
  v16 = *((_BYTE *)i + 24);
  i[1] = v7[1];
  *((_BYTE *)i + 24) = *((_BYTE *)v7 + 24);
  *((_BYTE *)v7 + 24) = v16;
LABEL_44:
  if ( v16 == 1 )
  {
    if ( v8 != *(_QWORD *)(*a1 + 8LL) )
    {
      do
      {
        v18 = v10;
        if ( *(_BYTE *)(v8 + 24) != 1 )
          break;
        v19 = *(_BYTE **)v10;
        if ( v8 == *(_QWORD *)v10 )
        {
          v19 = *(_BYTE **)(v10 + 16);
          if ( !v19[24] )
          {
            v19[24] = 1;
            *(_BYTE *)(v10 + 24) = 0;
            std::_Tree<std::_Tmap_traits<User,LogonJob *,User::less,std::allocator<std::pair<User const,LogonJob *>>,1>>::_Lrotate(
              (__int64)a1,
              v10);
            v19 = *(_BYTE **)(v10 + 16);
          }
          if ( v19[25] )
            goto LABEL_62;
          if ( *(_BYTE *)(*(_QWORD *)v19 + 24LL) != 1 || *(_BYTE *)(*((_QWORD *)v19 + 2) + 24LL) != 1 )
          {
            if ( *(_BYTE *)(*((_QWORD *)v19 + 2) + 24LL) == 1 )
            {
              *(_BYTE *)(*(_QWORD *)v19 + 24LL) = 1;
              v19[24] = 0;
              std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::_Rrotate(
                (__int64)a1,
                v19);
              v19 = *(_BYTE **)(v10 + 16);
            }
            v19[24] = *(_BYTE *)(v10 + 24);
            *(_BYTE *)(v10 + 24) = 1;
            *(_BYTE *)(*((_QWORD *)v19 + 2) + 24LL) = 1;
            std::_Tree<std::_Tmap_traits<User,LogonJob *,User::less,std::allocator<std::pair<User const,LogonJob *>>,1>>::_Lrotate(
              (__int64)a1,
              v10);
            break;
          }
        }
        else
        {
          if ( !v19[24] )
          {
            v19[24] = 1;
            *(_BYTE *)(v10 + 24) = 0;
            std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::_Rrotate(
              (__int64)a1,
              (_QWORD *)v10);
            v19 = *(_BYTE **)v10;
          }
          if ( v19[25] )
            goto LABEL_62;
          v20 = *((_QWORD *)v19 + 2);
          if ( *(_BYTE *)(v20 + 24) != 1 || *(_BYTE *)(*(_QWORD *)v19 + 24LL) != 1 )
          {
            if ( *(_BYTE *)(*(_QWORD *)v19 + 24LL) == 1 )
            {
              *(_BYTE *)(v20 + 24) = 1;
              v19[24] = 0;
              std::_Tree<std::_Tmap_traits<User,LogonJob *,User::less,std::allocator<std::pair<User const,LogonJob *>>,1>>::_Lrotate(
                (__int64)a1,
                (__int64)v19);
              v19 = *(_BYTE **)v10;
            }
            v19[24] = *(_BYTE *)(v10 + 24);
            *(_BYTE *)(v10 + 24) = 1;
            *(_BYTE *)(*(_QWORD *)v19 + 24LL) = 1;
            std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::_Rrotate(
              (__int64)a1,
              (_QWORD *)v10);
            break;
          }
        }
        v19[24] = 0;
LABEL_62:
        v8 = v18;
        v10 = *(_QWORD *)(v10 + 8);
      }
      while ( v18 != *(_QWORD *)(*a1 + 8LL) );
    }
    *(_BYTE *)(v8 + 24) = 1;
  }
  wmi::AutoRef<JobBucket>::Release((wmi::RefBase **)v7 + 8);
  _bstr_t::_Free((_bstr_t *)(v7 + 6));
  operator delete(v7);
  v21 = a1[1];
  if ( v21 )
    a1[1] = v21 - 1;
  result = a2;
  *a2 = i;
  return result;
}
// 18004AFA2: variable 'v8' is possibly undefined
// 18004B003: variable 'v11' is possibly undefined
// 18004B018: variable 'v10' is possibly undefined
// 18004B04D: variable 'v6' is possibly undefined
// 18004B194: variable 'v18' is possibly undefined

//----- (000000018004B234) ----------------------------------------------------
__int64 __fastcall WPP_SF_(__int64 a1, unsigned __int16 a2, __int64 a3)
{
  return EtwTraceMessage(a1, 43LL, a3, a2, 0LL);
}
// 1800747B0: using guessed type __int64 __fastcall EtwTraceMessage(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000018004B260) ----------------------------------------------------
__int64 __fastcall WPP_SF_D(__int64 a1, unsigned __int16 a2, __int64 a3, int a4)
{
  int v5; // [rsp+68h] [rbp+20h] BYREF

  v5 = a4;
  return EtwTraceMessage(a1, 43LL, a3, a2, &v5);
}
// 1800747B0: using guessed type __int64 __fastcall EtwTraceMessage(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000018004B2A4) ----------------------------------------------------
__int64 __fastcall WPP_SF_DsDsqq(__int64 a1, __int64 a2, __int64 a3, int a4, __int64 a5, char a6, __int64 a7)
{
  __int64 v7; // rax
  __int64 v8; // rdx
  int v10; // [rsp+B8h] [rbp+20h] BYREF

  v10 = a4;
  v7 = -1LL;
  if ( a7 )
  {
    v8 = -1LL;
    do
      ++v8;
    while ( *(_BYTE *)(a7 + v8) );
  }
  if ( a5 )
  {
    do
      ++v7;
    while ( *(_BYTE *)(a5 + v7) );
  }
  return EtwTraceMessage(a1, 43LL, &WPP_e3966bf9b81b3ab085a9dfdc4dace9ef_Traceguids, 22LL, &v10);
}
// 1800747B0: using guessed type __int64 __fastcall EtwTraceMessage(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000018004B3B4) ----------------------------------------------------
__int64 __fastcall WPP_SF_SD(__int64 a1, unsigned __int16 a2, __int64 a3, const wchar_t *a4)
{
  __int64 v4; // rax

  if ( a4 )
  {
    v4 = -1LL;
    do
      ++v4;
    while ( a4[v4] );
  }
  if ( !a4 )
    a4 = L"NULL";
  return EtwTraceMessage(a1, 43LL, a3, a2, a4);
}
// 1800747B0: using guessed type __int64 __fastcall EtwTraceMessage(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 18007F5B8: using guessed type wchar_t aNull_1[5];

//----- (000000018004B434) ----------------------------------------------------
__int64 WPP_SF_q(__int64 a1, unsigned __int16 a2, __int64 a3, ...)
{
  va_list va; // [rsp+68h] [rbp+20h] BYREF

  va_start(va, a3);
  return EtwTraceMessage(a1, 43LL, a3, a2, (__int64 *)va);
}
// 1800747B0: using guessed type __int64 __fastcall EtwTraceMessage(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000018004B480) ----------------------------------------------------
__int64 __fastcall WppControlCallback(int a1, __int64 a2, _DWORD *a3, __int64 a4)
{
  int v5; // ecx
  __int64 result; // rax
  __int64 TraceLoggerHandle; // rdi
  int TraceEnableFlags; // eax
  char TraceEnableLevel; // si

  *a3 = 0;
  v5 = a1 - 4;
  if ( v5 )
  {
    if ( v5 != 1 )
      return 87LL;
    TraceLoggerHandle = 0LL;
    TraceEnableFlags = 0;
    TraceEnableLevel = 0;
  }
  else
  {
    TraceLoggerHandle = EtwGetTraceLoggerHandle(a4);
    TraceEnableLevel = EtwGetTraceEnableLevel(TraceLoggerHandle);
    TraceEnableFlags = EtwGetTraceEnableFlags(TraceLoggerHandle);
  }
  if ( (*(_BYTE *)(a2 + 26) & 2) != 0 )
  {
    if ( *(_QWORD *)(a2 + 16) )
      a2 = *(_QWORD *)(a2 + 16);
  }
  *(_DWORD *)(a2 + 28) = TraceEnableFlags;
  result = 0LL;
  *(_QWORD *)(a2 + 16) = TraceLoggerHandle;
  *(_BYTE *)(a2 + 25) = TraceEnableLevel;
  return result;
}
// 180074798: using guessed type __int64 __fastcall EtwGetTraceEnableFlags(_QWORD);
// 1800747A0: using guessed type __int64 __fastcall EtwGetTraceEnableLevel(_QWORD);
// 1800747A8: using guessed type __int64 __fastcall EtwGetTraceLoggerHandle(_QWORD);

//----- (000000018004B518) ----------------------------------------------------
void __fastcall CNtService::~CNtService(CNtService *this)
{
  void *v2; // rcx

  *(_QWORD *)this = &CNtService::`vftable';
  v2 = (void *)*((_QWORD *)this + 2);
  if ( v2 )
    operator delete(v2);
  DeleteCriticalSection((LPCRITICAL_SECTION)((char *)this + 72));
}
// 180070568: using guessed type void *CNtService::`vftable';

//----- (000000018004B554) ----------------------------------------------------
void __fastcall tsched::CSLock::~CSLock(LPCRITICAL_SECTION *this)
{
  LeaveCriticalSection(*this);
}

//----- (000000018004B570) ----------------------------------------------------
__int64 __fastcall CNtService::HandlerEx(CNtService *this, int a2, __int64 a3, void *a4)
{
  __int64 v7; // r8
  __int64 v8; // r8

  switch ( a2 )
  {
    case 1:
LABEL_10:
      CNtService::ReportStatusToSCMgr(this, 3, a3, 1, 0x7530u);
      (*(void (__fastcall **)(CNtService *, bool))(*(_QWORD *)this + 16LL))(this, a2 == 5);
      return 0LL;
    case 2:
      CNtService::ReportStatusToSCMgr(this, 6, a3, 1, 0x7530u);
      (*(void (__fastcall **)(CNtService *))(*(_QWORD *)this + 40LL))(this);
      CNtService::ReportStatusToSCMgr(this, 7, v8, 0, 0);
      return 0LL;
    case 3:
      CNtService::ReportStatusToSCMgr(this, 5, a3, 1, 0x7530u);
      (*(void (__fastcall **)(CNtService *))(*(_QWORD *)this + 48LL))(this);
      CNtService::ReportStatusToSCMgr(this, 4, v7, 0, 0);
      break;
    case 4:
      break;
    case 5:
      goto LABEL_10;
    default:
      return 120LL;
  }
  return 0LL;
}
// 18004B5DD: variable 'v7' is possibly undefined
// 18004B616: variable 'v8' is possibly undefined

//----- (000000018004B660) ----------------------------------------------------
void __fastcall CNtService::Log(CNtService *this, const unsigned __int16 *a2)
{
  DWORD LastError; // [rsp+20h] [rbp-228h]
  unsigned __int16 v4[256]; // [rsp+30h] [rbp-218h] BYREF

  LastError = GetLastError();
  StringCchPrintfW(v4, 0x100uLL, (size_t *)L"%s error: %d", *((_QWORD *)this + 2), LastError);
}
// 18004B660: using guessed type unsigned __int16 var_218[256];

//----- (000000018004B6C8) ----------------------------------------------------
wmi::OutOfMemoryException *__fastcall wmi::OutOfMemoryException::OutOfMemoryException(wmi::OutOfMemoryException *this)
{
  wmi::OutOfMemoryException *result; // rax

  *((_DWORD *)this + 11) = -1;
  *((_DWORD *)this + 12) = -1;
  *((_QWORD *)this + 2) = &word_18007630E;
  *(_QWORD *)this = &wmi::OutOfMemoryException::`vftable';
  result = this;
  *((_BYTE *)this + 8) = 0;
  *((_QWORD *)this + 3) = 0LL;
  *((_QWORD *)this + 4) = 0LL;
  *((_DWORD *)this + 10) = 14;
  return result;
}
// 180073740: using guessed type void *wmi::OutOfMemoryException::`vftable';

//----- (000000018004B720) ----------------------------------------------------
void *__stdcall MIDL_user_allocate(size_t size)
{
  return HeapAlloc(g_PrivateHeap, 0, size);
}

//----- (000000018004B740) ----------------------------------------------------
__int64 *__fastcall std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_bstr_t>>>,_bstr_t *,std::allocator<_bstr_t>>(
        __int64 *a1,
        __int64 *a2,
        __int64 *a3)
{
  __int64 v3; // rax

  while ( a1 != a2 )
  {
    v3 = *a1;
    *a3 = *a1;
    if ( v3 )
      _InterlockedIncrement((volatile signed __int32 *)(v3 + 16));
    ++a3;
    ++a1;
  }
  return a3;
}

//----- (000000018004B7C0) ----------------------------------------------------
__int64 **__fastcall std::vector<_bstr_t>::vector<_bstr_t>(__int64 **a1, __int64 **a2)
{
  unsigned __int64 v4; // rax
  __int64 v5; // rdi
  __int64 *v6; // rax

  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  v4 = a2[1] - *a2;
  if ( v4 )
  {
    if ( v4 > 0x1FFFFFFFFFFFFFFFLL )
      std::_Xlength_error("vector<T> too long");
    v5 = v4;
    v6 = (__int64 *)operator new(8 * v4);
    if ( !v6 )
      std::_Xbad_alloc();
    *a1 = v6;
    a1[1] = v6;
    a1[2] = &v6[v5];
    a1[1] = std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<_bstr_t>>>,_bstr_t *,std::allocator<_bstr_t>>(
              *a2,
              a2[1],
              v6);
  }
  return a1;
}

//----- (000000018004B894) ----------------------------------------------------
EmailTask *__fastcall EmailTask::EmailTask(EmailTask *this, const struct _bstr_t *a2, const struct _bstr_t *a3)
{
  _QWORD *v4; // rcx

  Task::Task(this, a2, a3);
  *v4 = &EmailTask::`vftable';
  _bstr_t::_bstr_t((_bstr_t *)(v4 + 5), 0LL);
  _bstr_t::_bstr_t((EmailTask *)((char *)this + 48), 0LL);
  _bstr_t::_bstr_t((EmailTask *)((char *)this + 56), 0LL);
  _bstr_t::_bstr_t((EmailTask *)((char *)this + 64), 0LL);
  _bstr_t::_bstr_t((EmailTask *)((char *)this + 72), 0LL);
  _bstr_t::_bstr_t((EmailTask *)((char *)this + 80), 0LL);
  _bstr_t::_bstr_t((EmailTask *)((char *)this + 88), 0LL);
  _bstr_t::_bstr_t((EmailTask *)((char *)this + 96), 0LL);
  *((_QWORD *)this + 13) = 0LL;
  *((_QWORD *)this + 14) = 0LL;
  *((_QWORD *)this + 15) = 0LL;
  *((_QWORD *)this + 16) = 0LL;
  *((_QWORD *)this + 17) = 0LL;
  *((_QWORD *)this + 18) = 0LL;
  *((_QWORD *)this + 19) = 0LL;
  *((_QWORD *)this + 20) = 0LL;
  *((_QWORD *)this + 21) = 0LL;
  *((_QWORD *)this + 22) = 0LL;
  *((_BYTE *)this + 184) = 0;
  std::vector<_bstr_t>::clear((_bstr_t **)this + 13);
  std::vector<_bstr_t>::clear((_bstr_t **)this + 16);
  std::vector<_bstr_t>::clear((_bstr_t **)this + 19);
  return this;
}
// 18004B8C0: variable 'v4' is possibly undefined
// 180073780: using guessed type void *EmailTask::`vftable';

//----- (000000018004BBF0) ----------------------------------------------------
__int64 __fastcall wmi::AutoRef<INetworkListManagerPrivate>::~AutoRef<INetworkListManagerPrivate>(__int64 *a1)
{
  __int64 v2; // rcx
  __int64 result; // rax

  v2 = *a1;
  if ( v2 )
    result = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v2 + 16LL))(v2);
  *a1 = 0LL;
  return result;
}

//----- (000000018004BC2C) ----------------------------------------------------
void __fastcall std::_Tree_comp<0,std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::~_Tree_comp<0,std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>(
        void **a1)
{
  operator delete(*a1);
}

//----- (000000018004BC48) ----------------------------------------------------
void __fastcall ATL::CComBSTR::~CComBSTR(BSTR *this)
{
  SysFreeString(*this);
}

//----- (000000018004BC60) ----------------------------------------------------
void __fastcall EmailTask::~EmailTask(EmailTask *this)
{
  void *v2; // rcx

  *(_QWORD *)this = &EmailTask::`vftable';
  v2 = (void *)*((_QWORD *)this + 22);
  if ( v2 )
    CloseHandle(v2);
  std::vector<_bstr_t>::_Tidy((__int64)this + 152);
  std::vector<_bstr_t>::_Tidy((__int64)this + 128);
  std::vector<_bstr_t>::_Tidy((__int64)this + 104);
  _bstr_t::_Free((EmailTask *)((char *)this + 96));
  _bstr_t::_Free((EmailTask *)((char *)this + 88));
  _bstr_t::_Free((EmailTask *)((char *)this + 80));
  _bstr_t::_Free((EmailTask *)((char *)this + 72));
  _bstr_t::_Free((EmailTask *)((char *)this + 64));
  _bstr_t::_Free((EmailTask *)((char *)this + 56));
  _bstr_t::_Free((EmailTask *)((char *)this + 48));
  _bstr_t::_Free((EmailTask *)((char *)this + 40));
  Task::~Task(this);
}
// 180073780: using guessed type void *EmailTask::`vftable';

//----- (000000018004BD10) ----------------------------------------------------
EmailTask *__fastcall EmailTask::`vector deleting destructor'(EmailTask *this, char a2)
{
  EmailTask::~EmailTask(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (000000018004BD50) ----------------------------------------------------
Task *__fastcall Task::`scalar deleting destructor'(Task *this, char a2)
{
  Task::~Task(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (000000018004BDB0) ----------------------------------------------------
const unsigned __int16 *__fastcall EmailTask::GetName(EmailTask *this)
{
  BSTR *v1; // rax
  __int64 v2; // rbx
  UINT v4; // eax
  __int64 v5; // rax
  BSTR *v7; // rax
  UINT v8; // eax
  BSTR *v9; // rax
  UINT v10; // eax

  v1 = (BSTR *)*((_QWORD *)this + 2);
  v2 = 0LL;
  if ( v1 && *v1 )
    v4 = SysStringLen(*v1);
  else
    v4 = 0;
  if ( v4 )
  {
    v5 = *((_QWORD *)this + 2);
  }
  else
  {
    v7 = (BSTR *)*((_QWORD *)this + 6);
    if ( v7 && *v7 )
      v8 = SysStringLen(*v7);
    else
      v8 = 0;
    if ( v8 )
    {
      v5 = *((_QWORD *)this + 6);
    }
    else
    {
      v9 = (BSTR *)*((_QWORD *)this + 12);
      if ( v9 && *v9 )
        v10 = SysStringLen(*v9);
      else
        v10 = 0;
      if ( !v10 )
        return L"*";
      v5 = *((_QWORD *)this + 12);
    }
  }
  if ( v5 )
    return *(const unsigned __int16 **)v5;
  return (const unsigned __int16 *)v2;
}
// 18007F990: using guessed type wchar_t asc_18007F990[2];

//----- (000000018004BE70) ----------------------------------------------------
const unsigned __int16 *__fastcall MessageBoxTask::GetName(MessageBoxTask *this)
{
  BSTR *v1; // rax
  __int64 v2; // rbx
  UINT v4; // eax
  __int64 v5; // rax
  BSTR *v7; // rax
  UINT v8; // eax
  BSTR *v9; // rax
  UINT v10; // eax

  v1 = (BSTR *)*((_QWORD *)this + 2);
  v2 = 0LL;
  if ( v1 && *v1 )
    v4 = SysStringLen(*v1);
  else
    v4 = 0;
  if ( v4 )
  {
    v5 = *((_QWORD *)this + 2);
  }
  else
  {
    v7 = (BSTR *)*((_QWORD *)this + 5);
    if ( v7 && *v7 )
      v8 = SysStringLen(*v7);
    else
      v8 = 0;
    if ( v8 )
    {
      v5 = *((_QWORD *)this + 5);
    }
    else
    {
      v9 = (BSTR *)*((_QWORD *)this + 6);
      if ( v9 && *v9 )
        v10 = SysStringLen(*v9);
      else
        v10 = 0;
      if ( !v10 )
        return L"*";
      v5 = *((_QWORD *)this + 6);
    }
  }
  if ( v5 )
    return *(const unsigned __int16 **)v5;
  return (const unsigned __int16 *)v2;
}
// 18007F990: using guessed type wchar_t asc_18007F990[2];

//----- (000000018004BF30) ----------------------------------------------------
__int64 __fastcall EmailTask::GetStorageSize(EmailTask *this)
{
  BSTR *v1; // rax
  UINT v3; // r13d
  BSTR *v4; // rax
  BSTR *v5; // rax
  UINT v6; // r12d
  BSTR *v7; // rax
  UINT v8; // r15d
  BSTR *v9; // rax
  UINT v10; // r14d
  BSTR *v11; // rax
  UINT v12; // ebp
  BSTR *v13; // rax
  UINT v14; // edi
  BSTR *v15; // rax
  UINT v16; // ebx
  BSTR *v17; // rax
  UINT v18; // eax
  UINT v19; // eax
  BSTR **v20; // rbx
  int v21; // ebp
  BSTR *v22; // rax
  UINT v23; // eax
  BSTR **v24; // rbx
  unsigned int v25; // ebp
  BSTR **i; // rdi
  BSTR *v27; // rax
  UINT v28; // r14d
  BSTR *v29; // rax
  UINT v30; // eax
  UINT v32; // [rsp+50h] [rbp+8h]

  v1 = (BSTR *)*((_QWORD *)this + 2);
  if ( v1 && *v1 )
    v3 = SysStringLen(*v1);
  else
    v3 = 0;
  v4 = (BSTR *)*((_QWORD *)this + 11);
  if ( v4 && *v4 )
    v32 = SysStringLen(*v4);
  else
    v32 = 0;
  v5 = (BSTR *)*((_QWORD *)this + 7);
  if ( v5 && *v5 )
    v6 = SysStringLen(*v5);
  else
    v6 = 0;
  v7 = (BSTR *)*((_QWORD *)this + 8);
  if ( v7 && *v7 )
    v8 = SysStringLen(*v7);
  else
    v8 = 0;
  v9 = (BSTR *)*((_QWORD *)this + 9);
  if ( v9 && *v9 )
    v10 = SysStringLen(*v9);
  else
    v10 = 0;
  v11 = (BSTR *)*((_QWORD *)this + 10);
  if ( v11 && *v11 )
    v12 = SysStringLen(*v11);
  else
    v12 = 0;
  v13 = (BSTR *)*((_QWORD *)this + 5);
  if ( v13 && *v13 )
    v14 = SysStringLen(*v13);
  else
    v14 = 0;
  v15 = (BSTR *)*((_QWORD *)this + 6);
  if ( v15 && *v15 )
    v16 = SysStringLen(*v15);
  else
    v16 = 0;
  v17 = (BSTR *)*((_QWORD *)this + 12);
  if ( v17 && *v17 )
    v18 = SysStringLen(*v17);
  else
    v18 = 0;
  v19 = v16 + v18;
  v20 = (BSTR **)*((_QWORD *)this + 13);
  v21 = 2 * (v3 + v32 + v6 + v8 + v10 + v12 + v14 + v19) + 40;
  if ( (__int64)(*((_QWORD *)this + 14) - (_QWORD)v20) >> 3 )
  {
    while ( v20 != *((BSTR ***)this + 14) )
    {
      v22 = *v20;
      if ( *v20 && *v22 )
        v23 = SysStringLen(*v22);
      else
        v23 = 0;
      v21 += 2 * v23 + 4;
      ++v20;
    }
  }
  v24 = (BSTR **)*((_QWORD *)this + 16);
  v25 = v21 + 4;
  if ( (__int64)(*((_QWORD *)this + 17) - (_QWORD)v24) >> 3
    || (__int64)(*((_QWORD *)this + 20) - *((_QWORD *)this + 19)) >> 3 )
  {
    for ( i = (BSTR **)*((_QWORD *)this + 19); v24 != *((BSTR ***)this + 17) && i != *((BSTR ***)this + 20); ++i )
    {
      v27 = *v24;
      if ( *v24 && *v27 )
        v28 = SysStringLen(*v27);
      else
        v28 = 0;
      v29 = *i;
      if ( *i && *v29 )
        v30 = SysStringLen(*v29);
      else
        v30 = 0;
      ++v24;
      v25 += 2 * (v28 + v30) + 8;
    }
  }
  return v25;
}

//----- (000000018004C1D0) ----------------------------------------------------
__int64 __fastcall MessageBoxTask::GetStorageSize(MessageBoxTask *this)
{
  BSTR *v1; // rax
  UINT v2; // ebx
  UINT v4; // esi
  BSTR *v5; // rax
  UINT v6; // ebp
  BSTR *v7; // rax

  v1 = (BSTR *)*((_QWORD *)this + 2);
  v2 = 0;
  if ( v1 && *v1 )
    v4 = SysStringLen(*v1);
  else
    v4 = 0;
  v5 = (BSTR *)*((_QWORD *)this + 5);
  if ( v5 && *v5 )
    v6 = SysStringLen(*v5);
  else
    v6 = 0;
  v7 = (BSTR *)*((_QWORD *)this + 6);
  if ( v7 && *v7 )
    v2 = SysStringLen(*v7);
  return 2 * (v4 + v2 + v6) + 12;
}

//----- (000000018004C278) ----------------------------------------------------
void __fastcall __noreturn ATL::PrivateAtlThrow(int a1)
{
  void **v1; // [rsp+20h] [rbp-48h] BYREF
  char v2; // [rsp+28h] [rbp-40h]
  const unsigned __int16 *v3; // [rsp+30h] [rbp-38h]
  __int64 v4; // [rsp+38h] [rbp-30h]
  __int64 v5; // [rsp+40h] [rbp-28h]
  int v6; // [rsp+48h] [rbp-20h]
  int v7; // [rsp+4Ch] [rbp-1Ch]
  int v8; // [rsp+50h] [rbp-18h]

  v2 = 0;
  v1 = &wmi::GenericException::`vftable';
  v4 = 0LL;
  v5 = 0LL;
  v3 = &word_18007630E;
  v7 = -1;
  v8 = -1;
  v6 = a1;
  CxxThrowException_0(&v1, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
}
// 1800716D8: using guessed type void *wmi::GenericException::`vftable';

//----- (000000018004C2C8) ----------------------------------------------------
__int64 __fastcall ExeTask::ResolveLink(ExeTask *this, unsigned __int16 **a2)
{
  unsigned int v4; // edi
  HRESULT Instance; // ebx
  char ***v6; // r15
  const wchar_t **v7; // rax
  const wchar_t *v8; // rcx
  __int64 v9; // r14
  BSTR *v10; // rax
  UINT v11; // eax
  char **v12; // rax
  char *v13; // r8
  signed int LastError; // eax
  __int64 v15; // rax
  __int64 v16; // rcx
  WCHAR *v17; // rax
  __int64 v18; // r8
  __int64 v19; // rcx
  WCHAR *v20; // rdx
  __int64 v21; // rax
  char *v22; // r9
  WCHAR v23; // r8
  WCHAR *v24; // rax
  char *v25; // r8
  __int64 v26; // rax
  const wchar_t *v27; // rcx
  char *v28; // r8
  unsigned __int16 *v29; // rax
  __int64 v31; // [rsp+38h] [rbp-D0h] BYREF
  LPVOID ppv[3]; // [rsp+40h] [rbp-C8h] BYREF
  OLECHAR Src[264]; // [rsp+58h] [rbp-B0h] BYREF
  WCHAR Dst[264]; // [rsp+268h] [rbp+160h] BYREF

  ppv[1] = (LPVOID)-2LL;
  ppv[0] = 0LL;
  v4 = 1;
  Instance = CoCreateInstance(&CLSID_ShellLink, 0LL, 1u, &IID_IShellLinkW, ppv);
  if ( Instance < 0 )
  {
LABEL_61:
    v4 = Instance;
    goto LABEL_62;
  }
  v6 = (char ***)((char *)this + 48);
  v7 = (const wchar_t **)*((_QWORD *)this + 6);
  if ( v7 )
    v8 = *v7;
  else
    v8 = 0LL;
  v9 = -1LL;
  if ( wcsrchr(v8, 0x5Cu)
    || ((v10 = (BSTR *)*((_QWORD *)this + 8)) == 0LL || !*v10 ? (v11 = 0) : (v11 = SysStringLen(*v10)), !v11) )
  {
    if ( *v6 )
      v28 = **v6;
    else
      v28 = 0LL;
    LastError = StringCchCopyW((char *)Src, 261LL, v28);
  }
  else
  {
    v12 = (char **)*((_QWORD *)this + 8);
    if ( v12 )
      v13 = *v12;
    else
      v13 = 0LL;
    LastError = StringCchCopyW((char *)Src, 261LL, v13);
    if ( LastError < 0 )
      goto LABEL_67;
    v15 = -1LL;
    do
      ++v15;
    while ( Src[v15] );
    if ( Src[v15] != 92 )
    {
      v16 = 261LL;
      v17 = Src;
      do
      {
        if ( !*v17 )
          break;
        ++v17;
        --v16;
      }
      while ( v16 );
      LastError = v16 == 0 ? 0x80070057 : 0;
      v18 = v16 ? 261 - v16 : 0LL;
      if ( !v16 )
        goto LABEL_67;
      v19 = 261 - v18;
      v20 = &Src[v18];
      if ( v18 != 261 )
      {
        v21 = 2147483646LL;
        v22 = (char *)((char *)L"\\" - (char *)v20);
        do
        {
          if ( !v21 )
            break;
          v23 = *(WCHAR *)((char *)v20 + (_QWORD)v22);
          if ( !v23 )
            break;
          *v20++ = v23;
          --v21;
          --v19;
        }
        while ( v19 );
      }
      v24 = v20 - 1;
      if ( v19 )
        v24 = v20;
      *v24 = 0;
      LastError = v19 == 0 ? 0x8007007A : 0;
      if ( !v19 )
        goto LABEL_67;
    }
    if ( *v6 )
      v25 = **v6;
    else
      v25 = 0LL;
    LastError = StringCchCatW(Src, 261LL, v25);
  }
  if ( LastError < 0 )
  {
LABEL_67:
    v4 = LastError;
    goto LABEL_62;
  }
  if ( ExpandEnvironmentStringsW(Src, Dst, 0x105u) - 1 > 0x104 )
  {
    LastError = GetLastError();
    if ( LastError > 0 )
      LastError = (unsigned __int16)LastError | 0x80070000;
    goto LABEL_67;
  }
  v31 = 0LL;
  Instance = (**(__int64 (__fastcall ***)(LPVOID, GUID *, __int64 *))ppv[0])(ppv[0], &IID_IPersistFile, &v31);
  if ( Instance < 0 )
    goto LABEL_59;
  Instance = (*(__int64 (__fastcall **)(__int64, WCHAR *, _QWORD))(*(_QWORD *)v31 + 40LL))(v31, Dst, 0LL);
  if ( Instance < 0 )
    goto LABEL_59;
  Instance = (*(__int64 (__fastcall **)(LPVOID, OLECHAR *, __int64, _QWORD, _DWORD))(*(_QWORD *)ppv[0] + 24LL))(
               ppv[0],
               Src,
               260LL,
               0LL,
               0);
  if ( Instance < 0 )
    goto LABEL_59;
  v26 = -1LL;
  do
    ++v26;
  while ( Src[v26] );
  if ( !v26 )
  {
    Instance = -2147418113;
    goto LABEL_59;
  }
  _bstr_t::operator=((_bstr_t::Data_t **)v6, Src);
  v27 = *v6 ? (const wchar_t *)**v6 : 0LL;
  v29 = wcsrchr(v27, 0x2Eu);
  *a2 = v29;
  if ( v29 )
  {
    do
      ++v9;
    while ( v29[v9] );
    if ( v9 != 1 )
    {
LABEL_59:
      if ( v31 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v31 + 16LL))(v31);
      goto LABEL_61;
    }
  }
  if ( v31 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v31 + 16LL))(v31);
LABEL_62:
  if ( ppv[0] )
    (*(void (__fastcall **)(LPVOID, _QWORD))(*(_QWORD *)ppv[0] + 16LL))(ppv[0], *(_QWORD *)ppv[0]);
  return v4;
}
// 18004C2C8: using guessed type OLECHAR Src[264];

//----- (000000018004C6B0) ----------------------------------------------------
__int64 __fastcall EmailTask::StreamIn(EmailTask *this, __int64 a2, unsigned __int8 **a3, unsigned __int8 *a4)
{
  __int64 result; // rax
  unsigned int v8; // r14d
  int v9; // r15d
  int v10; // r12d
  int v11; // r14d
  unsigned int v12; // r15d
  int v13; // r12d
  _bstr_t::Data_t *v14[2]; // [rsp+20h] [rbp-10h] BYREF
  _bstr_t::Data_t *v15; // [rsp+60h] [rbp+30h] BYREF

  v14[1] = (_bstr_t::Data_t *)-2LL;
  result = JobStore::StreamInBSTR((_bstr_t::Data_t **)this + 2, a3, a4);
  if ( (int)result >= 0 )
  {
    result = JobStore::StreamInBSTR((_bstr_t::Data_t **)this + 11, a3, a4);
    if ( (int)result >= 0 )
    {
      result = JobStore::StreamInBSTR((_bstr_t::Data_t **)this + 7, a3, a4);
      if ( (int)result >= 0 )
      {
        result = JobStore::StreamInBSTR((_bstr_t::Data_t **)this + 8, a3, a4);
        if ( (int)result >= 0 )
        {
          result = JobStore::StreamInBSTR((_bstr_t::Data_t **)this + 9, a3, a4);
          if ( (int)result >= 0 )
          {
            result = JobStore::StreamInBSTR((_bstr_t::Data_t **)this + 10, a3, a4);
            if ( (int)result >= 0 )
            {
              result = JobStore::StreamInBSTR((_bstr_t::Data_t **)this + 5, a3, a4);
              if ( (int)result >= 0 )
              {
                result = JobStore::StreamInBSTR((_bstr_t::Data_t **)this + 6, a3, a4);
                if ( (int)result >= 0 )
                {
                  result = JobStore::StreamInBSTR((_bstr_t::Data_t **)this + 12, a3, a4);
                  if ( (int)result >= 0 )
                  {
                    result = JobStore::StreamInDWORD((unsigned int *)&v15, (unsigned int **)a3, a4);
                    if ( (int)result >= 0 )
                    {
                      v8 = (unsigned int)v15;
                      if ( (_DWORD)v15 )
                      {
                        v9 = 0;
                        while ( 1 )
                        {
                          v14[0] = 0LL;
                          v10 = JobStore::StreamInBSTR(v14, a3, a4);
                          if ( v10 < 0 )
                            break;
                          std::vector<_bstr_t>::push_back((__int64 *)this + 13, (__int64 *)v14);
                          _bstr_t::_Free((_bstr_t *)v14);
                          if ( ++v9 >= v8 )
                            goto LABEL_15;
                        }
                        _bstr_t::_Free((_bstr_t *)v14);
                        return (unsigned int)v10;
                      }
                      else
                      {
LABEL_15:
                        result = JobStore::StreamInDWORD((unsigned int *)&v15, (unsigned int **)a3, a4);
                        v11 = result;
                        if ( (int)result >= 0 )
                        {
                          v12 = (unsigned int)v15;
                          if ( (_DWORD)v15 )
                          {
                            v13 = 0;
                            while ( 1 )
                            {
                              v14[0] = 0LL;
                              v15 = 0LL;
                              v11 = JobStore::StreamInBSTR(v14, a3, a4);
                              if ( v11 < 0 )
                                break;
                              v11 = JobStore::StreamInBSTR(&v15, a3, a4);
                              if ( v11 < 0 )
                                break;
                              std::vector<_bstr_t>::push_back((__int64 *)this + 16, (__int64 *)v14);
                              std::vector<_bstr_t>::push_back((__int64 *)this + 19, (__int64 *)&v15);
                              _bstr_t::_Free((_bstr_t *)&v15);
                              _bstr_t::_Free((_bstr_t *)v14);
                              if ( ++v13 >= v12 )
                                return (unsigned int)v11;
                            }
                            _bstr_t::_Free((_bstr_t *)&v15);
                            _bstr_t::_Free((_bstr_t *)v14);
                          }
                          return (unsigned int)v11;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (000000018004C920) ----------------------------------------------------
__int64 __fastcall MessageBoxTask::StreamIn(
        _bstr_t::Data_t **this,
        __int64 a2,
        unsigned __int8 **a3,
        unsigned __int8 *a4)
{
  __int64 result; // rax

  result = JobStore::StreamInBSTR(this + 2, a3, a4);
  if ( (int)result >= 0 )
  {
    result = JobStore::StreamInBSTR(this + 5, a3, a4);
    if ( (int)result >= 0 )
      return JobStore::StreamInBSTR(this + 6, a3, a4);
  }
  return result;
}

//----- (000000018004C990) ----------------------------------------------------
__int64 __fastcall EmailTask::StreamOut(EmailTask *this, __int64 a2, unsigned __int8 **a3, unsigned __int8 *a4)
{
  __int64 result; // rax
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 v10; // rax
  __int64 v11; // rax
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v14; // rax
  __int64 v15; // rax
  int v16; // r10d
  __int64 *i; // rbx
  __int64 v18; // rax
  __int64 v19; // r10
  int v20; // r10d
  __int64 *v21; // rbx
  __int64 *j; // rdi
  __int64 v23; // rax
  __int64 v24; // rax
  __int64 v25; // [rsp+20h] [rbp-60h] BYREF
  __int64 v26; // [rsp+28h] [rbp-58h] BYREF
  __int64 v27; // [rsp+30h] [rbp-50h] BYREF
  __int64 v28; // [rsp+38h] [rbp-48h] BYREF
  __int64 v29; // [rsp+40h] [rbp-40h] BYREF
  __int64 v30; // [rsp+48h] [rbp-38h] BYREF
  __int64 v31; // [rsp+50h] [rbp-30h] BYREF
  __int64 v32; // [rsp+58h] [rbp-28h] BYREF
  __int64 v33; // [rsp+60h] [rbp-20h] BYREF
  __int64 v34; // [rsp+68h] [rbp-18h] BYREF
  __int64 v35; // [rsp+70h] [rbp-10h] BYREF

  result = Task::StreamOut(this, a2, a3, a4);
  if ( (int)result >= 0 )
  {
    v8 = *((_QWORD *)this + 11);
    v25 = v8;
    if ( v8 )
      _InterlockedIncrement((volatile signed __int32 *)(v8 + 16));
    result = JobStore::StreamOutBSTR((_bstr_t *)&v25, a3, (unsigned __int64)a4);
    if ( (int)result >= 0 )
    {
      v9 = *((_QWORD *)this + 7);
      v26 = v9;
      if ( v9 )
        _InterlockedIncrement((volatile signed __int32 *)(v9 + 16));
      result = JobStore::StreamOutBSTR((_bstr_t *)&v26, a3, (unsigned __int64)a4);
      if ( (int)result >= 0 )
      {
        v10 = *((_QWORD *)this + 8);
        v27 = v10;
        if ( v10 )
          _InterlockedIncrement((volatile signed __int32 *)(v10 + 16));
        result = JobStore::StreamOutBSTR((_bstr_t *)&v27, a3, (unsigned __int64)a4);
        if ( (int)result >= 0 )
        {
          v11 = *((_QWORD *)this + 9);
          v28 = v11;
          if ( v11 )
            _InterlockedIncrement((volatile signed __int32 *)(v11 + 16));
          result = JobStore::StreamOutBSTR((_bstr_t *)&v28, a3, (unsigned __int64)a4);
          if ( (int)result >= 0 )
          {
            v12 = *((_QWORD *)this + 10);
            v29 = v12;
            if ( v12 )
              _InterlockedIncrement((volatile signed __int32 *)(v12 + 16));
            result = JobStore::StreamOutBSTR((_bstr_t *)&v29, a3, (unsigned __int64)a4);
            if ( (int)result >= 0 )
            {
              v13 = *((_QWORD *)this + 5);
              v30 = v13;
              if ( v13 )
                _InterlockedIncrement((volatile signed __int32 *)(v13 + 16));
              result = JobStore::StreamOutBSTR((_bstr_t *)&v30, a3, (unsigned __int64)a4);
              if ( (int)result >= 0 )
              {
                v14 = *((_QWORD *)this + 6);
                v31 = v14;
                if ( v14 )
                  _InterlockedIncrement((volatile signed __int32 *)(v14 + 16));
                result = JobStore::StreamOutBSTR((_bstr_t *)&v31, a3, (unsigned __int64)a4);
                if ( (int)result >= 0 )
                {
                  v15 = *((_QWORD *)this + 12);
                  v32 = v15;
                  if ( v15 )
                    _InterlockedIncrement((volatile signed __int32 *)(v15 + 16));
                  result = JobStore::StreamOutBSTR((_bstr_t *)&v32, a3, (unsigned __int64)a4);
                  if ( (int)result >= 0 )
                  {
                    result = JobStore::StreamOutDWORD(
                               (__int64)(*((_QWORD *)this + 14) - *((_QWORD *)this + 13)) >> 3,
                               a3,
                               a4);
                    if ( (int)result >= 0 )
                    {
                      if ( v16 )
                      {
                        for ( i = (__int64 *)*((_QWORD *)this + 13); i != *((__int64 **)this + 14); ++i )
                        {
                          v18 = *i;
                          v33 = v18;
                          if ( v18 )
                            _InterlockedIncrement((volatile signed __int32 *)(v18 + 16));
                          result = JobStore::StreamOutBSTR((_bstr_t *)&v33, a3, (unsigned __int64)a4);
                          if ( (int)result < 0 )
                            return result;
                        }
                      }
                      v19 = (__int64)(*((_QWORD *)this + 17) - *((_QWORD *)this + 16)) >> 3;
                      if ( (unsigned int)v19 >= (unsigned int)((__int64)(*((_QWORD *)this + 20) - *((_QWORD *)this + 19)) >> 3) )
                        LODWORD(v19) = (__int64)(*((_QWORD *)this + 20) - *((_QWORD *)this + 19)) >> 3;
                      result = JobStore::StreamOutDWORD(v19, a3, a4);
                      if ( (int)result >= 0 && v20 )
                      {
                        v21 = (__int64 *)*((_QWORD *)this + 19);
                        for ( j = (__int64 *)*((_QWORD *)this + 16);
                              v21 != *((__int64 **)this + 20) && j != *((__int64 **)this + 17);
                              ++j )
                        {
                          v23 = *j;
                          v34 = v23;
                          if ( v23 )
                            _InterlockedIncrement((volatile signed __int32 *)(v23 + 16));
                          result = JobStore::StreamOutBSTR((_bstr_t *)&v34, a3, (unsigned __int64)a4);
                          if ( (int)result < 0 )
                            break;
                          v24 = *v21;
                          v35 = v24;
                          if ( v24 )
                            _InterlockedIncrement((volatile signed __int32 *)(v24 + 16));
                          result = JobStore::StreamOutBSTR((_bstr_t *)&v35, a3, (unsigned __int64)a4);
                          if ( (int)result < 0 )
                            break;
                          ++v21;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 18004CB29: variable 'v16' is possibly undefined
// 18004CBA2: variable 'v20' is possibly undefined

//----- (000000018004CC40) ----------------------------------------------------
__int64 __fastcall MessageBoxTask::StreamOut(
        MessageBoxTask *this,
        __int64 a2,
        unsigned __int8 **a3,
        const unsigned __int8 *a4)
{
  __int64 result; // rax
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 v10; // [rsp+20h] [rbp-18h] BYREF
  __int64 v11; // [rsp+28h] [rbp-10h] BYREF

  result = Task::StreamOut(this, a2, a3, a4);
  if ( (int)result >= 0 )
  {
    v8 = *((_QWORD *)this + 5);
    v10 = v8;
    if ( v8 )
      _InterlockedIncrement((volatile signed __int32 *)(v8 + 16));
    result = JobStore::StreamOutBSTR((_bstr_t *)&v10, a3, (unsigned __int64)a4);
    if ( (int)result >= 0 )
    {
      v9 = *((_QWORD *)this + 6);
      v11 = v9;
      if ( v9 )
        _InterlockedIncrement((volatile signed __int32 *)(v9 + 16));
      return JobStore::StreamOutBSTR((_bstr_t *)&v11, a3, (unsigned __int64)a4);
    }
  }
  return result;
}

//----- (000000018004CCC0) ----------------------------------------------------
__int64 __fastcall EmailTask::WriteXml(EmailTask *this, struct TaskXmlWriter *a2)
{
  __int64 *v2; // rax
  __int64 v5; // rcx
  __int64 v6; // r9
  __int64 result; // rax
  __int64 *v8; // rax
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 *v11; // rax
  __int64 v12; // rcx
  __int64 v13; // r8
  __int64 *v14; // rax
  __int64 v15; // rcx
  __int64 v16; // r8
  __int64 *v17; // rax
  __int64 v18; // rcx
  __int64 v19; // r8
  __int64 *v20; // rax
  __int64 v21; // rcx
  __int64 v22; // r8
  __int64 *v23; // rax
  __int64 v24; // rcx
  __int64 v25; // r8
  __int64 *v26; // rax
  __int64 v27; // rcx
  __int64 v28; // r8
  __int64 *v29; // rax
  __int64 v30; // rcx
  __int64 v31; // r8
  __int64 **i; // rbx
  __int64 v33; // r8
  _QWORD *v34; // rbx
  _QWORD *j; // rdi
  __int64 v36; // r8
  __int64 v37; // r8

  v2 = (__int64 *)*((_QWORD *)this + 2);
  if ( v2 )
    v5 = *v2;
  else
    v5 = 0LL;
  if ( v5 )
  {
    if ( v2 )
      v6 = *v2;
    else
      v6 = 0LL;
    result = TaskXmlWriter::StartElementWithAttribute((__int64)a2, 113, 109, v6);
  }
  else
  {
    result = TaskXmlWriter::StartElement((int *)a2, 113);
  }
  if ( (int)result >= 0 )
  {
    v8 = (__int64 *)*((_QWORD *)this + 5);
    v9 = v8 ? *v8 : 0LL;
    if ( !v9
      || (!v8 ? (v10 = 0LL) : (v10 = *v8), result = TaskXmlWriter::Element((__int64)a2, 114, v10), (int)result >= 0) )
    {
      v11 = (__int64 *)*((_QWORD *)this + 11);
      v12 = v11 ? *v11 : 0LL;
      if ( !v12
        || (!v11 ? (v13 = 0LL) : (v13 = *v11), result = TaskXmlWriter::Element((__int64)a2, 120, v13), (int)result >= 0) )
      {
        v14 = (__int64 *)*((_QWORD *)this + 7);
        v15 = v14 ? *v14 : 0LL;
        if ( !v15
          || (!v14 ? (v16 = 0LL) : (v16 = *v14), result = TaskXmlWriter::Element((__int64)a2, 116, v16),
                                                 (int)result >= 0) )
        {
          v17 = (__int64 *)*((_QWORD *)this + 8);
          v18 = v17 ? *v17 : 0LL;
          if ( !v18
            || (!v17 ? (v19 = 0LL) : (v19 = *v17),
                result = TaskXmlWriter::Element((__int64)a2, 117, v19),
                (int)result >= 0) )
          {
            v20 = (__int64 *)*((_QWORD *)this + 9);
            v21 = v20 ? *v20 : 0LL;
            if ( !v21
              || (!v20 ? (v22 = 0LL) : (v22 = *v20),
                  result = TaskXmlWriter::Element((__int64)a2, 118, v22),
                  (int)result >= 0) )
            {
              v23 = (__int64 *)*((_QWORD *)this + 10);
              v24 = v23 ? *v23 : 0LL;
              if ( !v24
                || (!v23 ? (v25 = 0LL) : (v25 = *v23),
                    result = TaskXmlWriter::Element((__int64)a2, 119, v25),
                    (int)result >= 0) )
              {
                v26 = (__int64 *)*((_QWORD *)this + 6);
                v27 = v26 ? *v26 : 0LL;
                if ( !v27
                  || (!v26 ? (v28 = 0LL) : (v28 = *v26),
                      result = TaskXmlWriter::Element((__int64)a2, 115, v28),
                      (int)result >= 0) )
                {
                  v29 = (__int64 *)*((_QWORD *)this + 12);
                  v30 = v29 ? *v29 : 0LL;
                  if ( !v30
                    || (!v29 ? (v31 = 0LL) : (v31 = *v29),
                        result = TaskXmlWriter::Element((__int64)a2, 121, v31),
                        (int)result >= 0) )
                  {
                    if ( !((__int64)(*((_QWORD *)this + 14) - *((_QWORD *)this + 13)) >> 3) )
                      goto LABEL_105;
                    result = TaskXmlWriter::StartElement((int *)a2, 122);
                    if ( (int)result >= 0 )
                    {
                      for ( i = (__int64 **)*((_QWORD *)this + 13); i != *((__int64 ***)this + 14); ++i )
                      {
                        if ( *i )
                          v33 = **i;
                        else
                          v33 = 0LL;
                        result = TaskXmlWriter::Element((__int64)a2, 123, v33);
                        if ( (int)result < 0 )
                          return result;
                      }
                      result = TaskXmlWriter::EndElement((__int64)a2);
                      if ( (int)result >= 0 )
                      {
LABEL_105:
                        if ( !((__int64)(*((_QWORD *)this + 20) - *((_QWORD *)this + 19)) >> 3) )
                          return TaskXmlWriter::EndElement((__int64)a2);
                        result = TaskXmlWriter::StartElement((int *)a2, 124);
                        if ( (int)result >= 0 )
                        {
                          v34 = (_QWORD *)*((_QWORD *)this + 19);
                          for ( j = (_QWORD *)*((_QWORD *)this + 16);
                                v34 != *((_QWORD **)this + 20) && j != *((_QWORD **)this + 17);
                                ++j )
                          {
                            result = TaskXmlWriter::StartElement((int *)a2, 125);
                            if ( (int)result < 0 )
                              return result;
                            v36 = *j ? *(_QWORD *)*j : 0LL;
                            result = TaskXmlWriter::Element((__int64)a2, 126, v36);
                            if ( (int)result < 0 )
                              return result;
                            v37 = *v34 ? *(_QWORD *)*v34 : 0LL;
                            result = TaskXmlWriter::Element((__int64)a2, 127, v37);
                            if ( (int)result < 0 )
                              return result;
                            result = TaskXmlWriter::EndElement((__int64)a2);
                            if ( (int)result < 0 )
                              return result;
                            ++v34;
                          }
                          result = TaskXmlWriter::EndElement((__int64)a2);
                          if ( (int)result >= 0 )
                            return TaskXmlWriter::EndElement((__int64)a2);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (000000018004D030) ----------------------------------------------------
__int64 __fastcall MessageBoxTask::WriteXml(MessageBoxTask *this, struct TaskXmlWriter *a2)
{
  __int64 *v2; // rax
  __int64 v5; // rdx
  __int64 v6; // r9
  __int64 result; // rax
  __int64 *v8; // rax
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 *v11; // rax
  __int64 v12; // rcx
  __int64 v13; // r8

  v2 = (__int64 *)*((_QWORD *)this + 2);
  if ( v2 )
    v5 = *v2;
  else
    v5 = 0LL;
  if ( v5 )
  {
    if ( v2 )
      v6 = *v2;
    else
      v6 = 0LL;
    result = TaskXmlWriter::StartElementWithAttribute((__int64)a2, 128, 109, v6);
  }
  else
  {
    result = TaskXmlWriter::StartElement((int *)a2, 128);
  }
  if ( (int)result >= 0 )
  {
    v8 = (__int64 *)*((_QWORD *)this + 5);
    v9 = v8 ? *v8 : 0LL;
    if ( !v9
      || (!v8 ? (v10 = 0LL) : (v10 = *v8), result = TaskXmlWriter::Element((__int64)a2, 129, v10), (int)result >= 0) )
    {
      v11 = (__int64 *)*((_QWORD *)this + 6);
      if ( v11 )
        v12 = *v11;
      else
        v12 = 0LL;
      if ( !v12 )
        return TaskXmlWriter::EndElement((__int64)a2);
      v13 = v11 ? *v11 : 0LL;
      result = TaskXmlWriter::Element((__int64)a2, 130, v13);
      if ( (int)result >= 0 )
        return TaskXmlWriter::EndElement((__int64)a2);
    }
  }
  return result;
}

//----- (000000018004D108) ----------------------------------------------------
__int64 *__fastcall std::vector<_bstr_t>::push_back(__int64 *a1, __int64 *a2)
{
  __int64 *result; // rax
  __int64 v6; // rcx
  __int64 v7; // rdi
  __int64 v8; // rcx

  result = (__int64 *)a1[1];
  if ( a2 < result && *a1 <= (unsigned __int64)a2 )
  {
    v6 = *a1;
    v7 = ((__int64)a2 - *a1) >> 3;
    if ( result == (__int64 *)a1[2] )
    {
      std::vector<_bstr_t>::_Reserve(a1);
      result = (__int64 *)a1[1];
      v6 = *a1;
    }
    v8 = *(_QWORD *)(v6 + 8 * v7);
  }
  else
  {
    if ( result == (__int64 *)a1[2] )
    {
      std::vector<_bstr_t>::_Reserve(a1);
      result = (__int64 *)a1[1];
    }
    v8 = *a2;
  }
  *result = v8;
  if ( v8 )
    _InterlockedIncrement((volatile signed __int32 *)(v8 + 16));
  a1[1] += 8LL;
  return result;
}

//----- (000000018004D190) ----------------------------------------------------
__int64 __fastcall Task::GetStorageSize(Task *this)
{
  BSTR *v1; // rcx
  UINT v2; // eax

  v1 = (BSTR *)*((_QWORD *)this + 2);
  v2 = 0;
  if ( v1 && *v1 )
    v2 = SysStringLen(*v1);
  return 2 * v2 + 4;
}

//----- (000000018004D1D0) ----------------------------------------------------
__int64 __fastcall Task::StreamIn(_bstr_t::Data_t **this, __int64 a2, unsigned __int8 **a3, unsigned __int8 *a4)
{
  return JobStore::StreamInBSTR(this + 2, a3, a4);
}

//----- (000000018004D1E8) ----------------------------------------------------
BSTR ***__fastcall std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::find(
        BSTR ***a1,
        BSTR ***a2,
        BSTR **a3)
{
  BSTR **v3; // rdi
  BSTR **v7; // r9
  BSTR **v8; // rax
  BSTR **v9; // rbx
  BSTR ***result; // rax

  v3 = *a1;
  v7 = *a1;
  v8 = *a1;
  v9 = (BSTR **)(*a1)[1];
  if ( !*((_BYTE *)v9 + 25) )
  {
    do
    {
      if ( (int)_bstr_t::_Compare(v9 + 4, a3) >= 0 )
      {
        v3 = v9;
        v9 = (BSTR **)*v9;
      }
      else
      {
        v9 = (BSTR **)v9[2];
      }
    }
    while ( !*((_BYTE *)v9 + 25) );
    v7 = *a1;
    v8 = *a1;
  }
  if ( v3 == v7 )
    goto LABEL_10;
  if ( (int)_bstr_t::_Compare(a3, v3 + 4) < 0 )
  {
    v8 = *a1;
LABEL_10:
    v3 = v8;
  }
  result = a2;
  *a2 = v3;
  return result;
}

//----- (000000018004D288) ----------------------------------------------------
void __fastcall tsched::ClearList<IdleJobList>(_QWORD *a1)
{
  _QWORD *v2; // rbx
  LogonJob *v3; // rcx

  if ( a1[1] )
  {
    v2 = (_QWORD *)*a1;
    while ( 1 )
    {
      v2 = (_QWORD *)*v2;
      if ( v2 == (_QWORD *)*a1 )
        break;
      v3 = (LogonJob *)v2[2];
      if ( v3 )
      {
        LogonJob::`scalar deleting destructor'(v3);
        v2[2] = 0LL;
      }
    }
    std::list<IdleJob *>::clear((__int64)a1);
  }
}

//----- (000000018004D2D8) ----------------------------------------------------
_QWORD *__fastcall std::_List_buy<wmi::AutoVectorPtr<_SID_AND_ATTRIBUTES> *,std::allocator<wmi::AutoVectorPtr<_SID_AND_ATTRIBUTES> *>>::_Buynode<wmi::AutoVectorPtr<_SID_AND_ATTRIBUTES> * const &>(
        __int64 a1,
        _QWORD *a2,
        _QWORD *a3,
        _QWORD *a4)
{
  _QWORD *result; // rax

  result = std::_List_alloc<0,std::_List_base_types<std::vector<unsigned char> *,std::allocator<std::vector<unsigned char> *>>>::_Buynode0(
             a1,
             a2,
             a3);
  result[2] = *a4;
  return result;
}

//----- (000000018004D32C) ----------------------------------------------------
_QWORD *__fastcall std::_Tree_buy<std::pair<User const,SessionChangeJob *>>::_Buynode<std::pair<User const,SessionChangeJob *>>(
        _QWORD *a1,
        __int64 a2)
{
  _QWORD *v3; // rbx
  User::UserEntry *v4; // rcx

  v3 = std::_Tree_buy<std::pair<User const,LogonJob *>>::_Buynode0(a1);
  *((_WORD *)v3 + 12) = 0;
  v4 = *(User::UserEntry **)a2;
  v3[4] = *(_QWORD *)a2;
  if ( v4 )
    User::UserEntry::AddRef(v4);
  v3[5] = *(_QWORD *)(a2 + 8);
  return v3;
}

//----- (000000018004D3A4) ----------------------------------------------------
__int64 __fastcall std::list<IdleJob *>::_Insert<IdleJob * const &>(__int64 a1, __int64 a2, _QWORD *a3)
{
  _QWORD *v5; // rdi
  __int64 result; // rax

  v5 = std::_List_buy<wmi::AutoVectorPtr<_SID_AND_ATTRIBUTES> *,std::allocator<wmi::AutoVectorPtr<_SID_AND_ATTRIBUTES> *>>::_Buynode<wmi::AutoVectorPtr<_SID_AND_ATTRIBUTES> * const &>(
         a1,
         (_QWORD *)a2,
         *(_QWORD **)(a2 + 8),
         a3);
  result = std::list<IdleJob *>::_Incsize(a1, 1uLL);
  *(_QWORD *)(a2 + 8) = v5;
  *(_QWORD *)v5[1] = v5;
  return result;
}

//----- (000000018004D3F8) ----------------------------------------------------
_QWORD *__fastcall std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::_Insert_at<std::pair<User const,SessionChangeJob *>,std::_Nil>(
        _QWORD *a1,
        _QWORD *a2,
        char a3,
        _QWORD *a4,
        __int64 a5)
{
  _QWORD *v9; // rax
  _QWORD *v10; // r10
  char v11; // r11
  __int64 v12; // rax
  _QWORD *v13; // r9
  __int64 v14; // rax
  __int64 *v15; // rdx
  __int64 v16; // rcx
  __int64 v17; // rcx
  _QWORD *result; // rax

  if ( a1[1] >= 0x555555555555554uLL )
    std::_Xlength_error("map/set<T> too long");
  v9 = std::_Tree_buy<std::pair<User const,SessionChangeJob *>>::_Buynode<std::pair<User const,SessionChangeJob *>>(
         a1,
         a5);
  ++a1[1];
  v10 = v9;
  v11 = 0;
  v9[1] = a4;
  if ( a4 == (_QWORD *)*a1 )
  {
    *(_QWORD *)(*a1 + 8LL) = v9;
    *(_QWORD *)*a1 = v9;
    *(_QWORD *)(*a1 + 16LL) = v9;
  }
  else if ( a3 )
  {
    *a4 = v9;
    if ( a4 == *(_QWORD **)*a1 )
      *(_QWORD *)*a1 = v9;
  }
  else
  {
    a4[2] = v9;
    if ( a4 == *(_QWORD **)(*a1 + 16LL) )
      *(_QWORD *)(*a1 + 16LL) = v9;
  }
  v12 = v9[1];
  v13 = v10;
  while ( *(_BYTE *)(v12 + 24) == v11 )
  {
    v14 = v13[1];
    v15 = *(__int64 **)(v14 + 8);
    v16 = *v15;
    if ( v14 == *v15 )
    {
      v16 = v15[2];
      if ( *(_BYTE *)(v16 + 24) == v11 )
        goto LABEL_17;
      if ( v13 == *(_QWORD **)(v14 + 16) )
        std::_Tree<std::_Tmap_traits<User,LogonJob *,User::less,std::allocator<std::pair<User const,LogonJob *>>,1>>::_Lrotate(
          (__int64)a1,
          v13[1]);
      *(_BYTE *)(v13[1] + 24LL) = 1;
      *(_BYTE *)(*(_QWORD *)(v13[1] + 8LL) + 24LL) = v11;
      std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::_Rrotate(
        (__int64)a1,
        *(_QWORD **)(v13[1] + 8LL));
    }
    else
    {
      if ( *(_BYTE *)(v16 + 24) == v11 )
      {
LABEL_17:
        *(_BYTE *)(v14 + 24) = 1;
        *(_BYTE *)(v16 + 24) = 1;
        *(_BYTE *)(*(_QWORD *)(v13[1] + 8LL) + 24LL) = v11;
        v13 = *(_QWORD **)(v13[1] + 8LL);
        goto LABEL_21;
      }
      if ( v13 == *(_QWORD **)v14 )
        std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::_Rrotate(
          (__int64)a1,
          (_QWORD *)v13[1]);
      *(_BYTE *)(v13[1] + 24LL) = 1;
      *(_BYTE *)(*(_QWORD *)(v13[1] + 8LL) + 24LL) = v11;
      std::_Tree<std::_Tmap_traits<User,LogonJob *,User::less,std::allocator<std::pair<User const,LogonJob *>>,1>>::_Lrotate(
        (__int64)a1,
        *(_QWORD *)(v13[1] + 8LL));
    }
LABEL_21:
    v12 = v13[1];
  }
  v17 = *(_QWORD *)(*a1 + 8LL);
  result = a2;
  *a2 = v10;
  *(_BYTE *)(v17 + 24) = 1;
  return result;
}
// 18004D49B: variable 'v13' is possibly undefined
// 18004D4B3: variable 'v11' is possibly undefined
// 18004D571: variable 'v10' is possibly undefined

//----- (000000018004D588) ----------------------------------------------------
__int64 __fastcall std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::_Insert_nohint<std::pair<User const,SessionChangeJob *>,std::_Nil>(
        _QWORD *a1,
        __int64 a2,
        __int64 a3,
        _QWORD *a4)
{
  _QWORD *v7; // rsi
  __int64 *v8; // rbx
  char v9; // al
  __int64 v11; // [rsp+60h] [rbp+8h] BYREF

  v7 = (_QWORD *)*a1;
  v8 = *(__int64 **)(*a1 + 8LL);
  v9 = 1;
  while ( !*((_BYTE *)v8 + 25) )
  {
    v7 = v8;
    v9 = User::less::operator()((__int64)a1, a4, v8 + 4);
    if ( v9 )
      v8 = (__int64 *)*v8;
    else
      v8 = (__int64 *)v8[2];
  }
  *(_QWORD *)a2 = *std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::_Insert_at<std::pair<User const,SessionChangeJob *>,std::_Nil>(
                     a1,
                     &v11,
                     v9,
                     v7,
                     (__int64)a4);
  *(_BYTE *)(a2 + 8) = 1;
  return a2;
}
// 18004D5C3: variable 'a1' is possibly undefined

//----- (000000018004D634) ----------------------------------------------------
void __fastcall std::list<IdleJob *>::merge<IdleLess>(__int64 ***a1, __int64 a2)
{
  __int64 ***v2; // r15
  __int64 *v4; // r14
  __int64 **v6; // rsi
  __int64 v7; // rdi
  unsigned int *v8; // rax
  unsigned int v9; // edx
  _DWORD *v10; // rax
  __int64 v11; // rbx
  __int64 *v12; // rcx

  if ( (__int64 ***)a2 != a1 )
  {
    v2 = (__int64 ***)*a1;
    v4 = *(__int64 **)a2;
    v6 = (__int64 **)**a1;
    v7 = **(_QWORD **)a2;
    while ( v6 != (__int64 **)v2 )
    {
      if ( (__int64 *)v7 == v4 )
        return;
      v8 = *(unsigned int **)(*(_QWORD *)(*(_QWORD *)(v7 + 16) + 32LL) + 208LL);
      if ( v8 )
        v9 = *v8;
      else
        v9 = 0;
      v10 = *(_DWORD **)(v6[2][4] + 208);
      if ( v10 )
        LODWORD(v10) = *v10;
      if ( v9 >= (unsigned int)v10 )
      {
        v6 = (__int64 **)*v6;
      }
      else
      {
        v11 = *(_QWORD *)v7;
        std::list<IdleJob *>::_Incsize((__int64)a1, 1uLL);
        --*(_QWORD *)(a2 + 8);
        **(_QWORD **)(v7 + 8) = v11;
        **(_QWORD **)(v11 + 8) = v6;
        *v6[1] = v7;
        v12 = v6[1];
        v6[1] = *(__int64 **)(v11 + 8);
        *(_QWORD *)(v11 + 8) = *(_QWORD *)(v7 + 8);
        *(_QWORD *)(v7 + 8) = v12;
        v7 = v11;
      }
    }
    if ( (__int64 *)v7 != v4 )
      std::list<IdleJob *>::_Splice_same((__int64)a1, (__int64)v2, a2, v7, (__int64)v4, *(_QWORD *)(a2 + 8));
  }
}

//----- (000000018004D750) ----------------------------------------------------
__int64 (__fastcall ****__fastcall tsched::DeleteMe<Triggers::LogonTrigger>::~DeleteMe<Triggers::LogonTrigger>(
        __int64 a1))(_QWORD, __int64)
{
  __int64 (__fastcall ****result)(_QWORD, __int64); // rax
  __int64 (__fastcall ***v2)(_QWORD, __int64); // rcx

  if ( *(_BYTE *)(a1 + 8) )
  {
    result = *(__int64 (__fastcall *****)(_QWORD, __int64))a1;
    v2 = **(__int64 (__fastcall *****)(_QWORD, __int64))a1;
    if ( v2 )
      return (__int64 (__fastcall ****)(_QWORD, __int64))(**v2)(v2, 1LL);
  }
  return result;
}

//----- (000000018004D784) ----------------------------------------------------
LogonJob **__fastcall tsched::DeleteMe<SessionChangeJob>::~DeleteMe<SessionChangeJob>(__int64 a1)
{
  LogonJob **result; // rax
  LogonJob *v2; // rcx

  if ( *(_BYTE *)(a1 + 8) )
  {
    result = *(LogonJob ***)a1;
    v2 = **(LogonJob ***)a1;
    if ( v2 )
      return (LogonJob **)LogonJob::`scalar deleting destructor'(v2);
  }
  return result;
}

//----- (000000018004D7AC) ----------------------------------------------------
void __fastcall std::multimap<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>>::~multimap<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>>(
        __int64 ***a1)
{
  __int64 *v2; // [rsp+40h] [rbp+8h] BYREF

  std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::erase(
    a1,
    &v2,
    **a1,
    (__int64 *)*a1);
  operator delete(*a1);
}

//----- (000000018004D7E8) ----------------------------------------------------
void __fastcall IdleJobList::~IdleJobList(void **this)
{
  std::list<IdleJob *>::clear((__int64)this);
  operator delete(*this);
}

//----- (000000018004D80C) ----------------------------------------------------
void __fastcall PseudoEventTrap::~PseudoEventTrap(PseudoEventTrap *this)
{
  void **v2; // r12
  __int64 ***v3; // r14
  __int64 *v4; // rbx
  LogonJob *v5; // rcx
  __int64 v6; // rcx
  __int64 *i; // rax
  __int64 ***v8; // rsi
  __int64 *v9; // rbx
  LogonJob *v10; // rcx
  __int64 v11; // rcx
  __int64 *j; // rax
  __int64 *v13; // [rsp+60h] [rbp+8h] BYREF

  *(_QWORD *)this = &PseudoEventTrap::`vftable';
  v2 = (void **)((char *)this + 48);
  tsched::ClearList<IdleJobList>((_QWORD *)this + 6);
  tsched::ClearList<IdleJobList>((_QWORD *)this + 8);
  std::list<IdleJob *>::clear((__int64)this + 216);
  v3 = (__int64 ***)((char *)this + 144);
  if ( *((_QWORD *)this + 19) )
  {
    v4 = **v3;
    while ( v4 != (__int64 *)*v3 )
    {
      v5 = (LogonJob *)v4[5];
      if ( v5 )
      {
        LogonJob::`scalar deleting destructor'(v5);
        v4[5] = 0LL;
      }
      if ( !*((_BYTE *)v4 + 25) )
      {
        v6 = v4[2];
        if ( *(_BYTE *)(v6 + 25) )
        {
          for ( i = (__int64 *)v4[1]; !*((_BYTE *)i + 25) && v4 == (__int64 *)i[2]; i = (__int64 *)i[1] )
            v4 = i;
        }
        else
        {
          i = std::_Tree_val<std::_Tree_simple_types<std::pair<_bstr_t const,std::list<_FILETIME> *>>>::_Min((_QWORD *)v6);
        }
        v4 = i;
      }
    }
    std::_Tree<std::_Tmap_traits<User,LogonJob *,User::less,std::allocator<std::pair<User const,LogonJob *>>,1>>::clear((_QWORD *)this + 18);
  }
  v8 = (__int64 ***)((char *)this + 200);
  if ( *((_QWORD *)this + 26) )
  {
    v9 = **v8;
    while ( v9 != (__int64 *)*v8 )
    {
      v10 = (LogonJob *)v9[5];
      if ( v10 )
      {
        LogonJob::`scalar deleting destructor'(v10);
        v9[5] = 0LL;
      }
      if ( !*((_BYTE *)v9 + 25) )
      {
        v11 = v9[2];
        if ( *(_BYTE *)(v11 + 25) )
        {
          for ( j = (__int64 *)v9[1]; !*((_BYTE *)j + 25) && v9 == (__int64 *)j[2]; j = (__int64 *)j[1] )
            v9 = j;
        }
        else
        {
          j = std::_Tree_val<std::_Tree_simple_types<std::pair<_bstr_t const,std::list<_FILETIME> *>>>::_Min((_QWORD *)v11);
        }
        v9 = j;
      }
    }
    std::_Tree<std::_Tmap_traits<User,LogonJob *,User::less,std::allocator<std::pair<User const,LogonJob *>>,1>>::clear((_QWORD *)this + 25);
  }
  std::list<IdleJob *>::clear((__int64)this + 216);
  operator delete(*((void **)this + 27));
  std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::erase(
    (__int64 ***)this + 25,
    &v13,
    **v8,
    (__int64 *)*v8);
  operator delete(*v8);
  DeleteCriticalSection((LPCRITICAL_SECTION)this + 4);
  std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::erase(
    (__int64 ***)this + 18,
    &v13,
    **v3,
    (__int64 *)*v3);
  operator delete(*v3);
  DeleteCriticalSection((LPCRITICAL_SECTION)((char *)this + 96));
  std::list<IdleJob *>::clear((__int64)this + 64);
  operator delete(*((void **)this + 8));
  std::list<IdleJob *>::clear((__int64)v2);
  operator delete(*v2);
  DeleteCriticalSection((LPCRITICAL_SECTION)((char *)this + 8));
}
// 180070430: using guessed type void *PseudoEventTrap::`vftable';

//----- (000000018004DA10) ----------------------------------------------------
char __fastcall User::less::operator()(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  struct _RTL_CRITICAL_SECTION *v3; // rbx

  v3 = User::s_cs;
  EnterCriticalSection(User::s_cs);
  LOBYTE(a2) = *a2 < *a3;
  LeaveCriticalSection(v3);
  return (char)a2;
}

//----- (000000018004DA70) ----------------------------------------------------
LogonJob *__fastcall LogonJob::`scalar deleting destructor'(LogonJob *this)
{
  void (__fastcall ***v2)(_QWORD, __int64); // rcx

  v2 = (void (__fastcall ***)(_QWORD, __int64))*((_QWORD *)this + 5);
  if ( v2 )
    (**v2)(v2, 1LL);
  wmi::AutoRef<JobBucket>::Release((wmi::RefBase **)this + 4);
  _bstr_t::_Free((LogonJob *)((char *)this + 16));
  operator delete(this);
  return this;
}

//----- (000000018004DAC0) ----------------------------------------------------
void __fastcall PseudoEventTrap::IdleEnded(PseudoEventTrap *this)
{
  PseudoEventTrap *v1; // rdi
  struct _RTL_CRITICAL_SECTION *v2; // rbx

  v1 = g_pPseudoEventTrap;
  v2 = (struct _RTL_CRITICAL_SECTION *)((char *)g_pPseudoEventTrap + 8);
  EnterCriticalSection((LPCRITICAL_SECTION)((char *)g_pPseudoEventTrap + 8));
  *((_DWORD *)v1 + 21) = 0;
  if ( *((_QWORD *)v1 + 9) )
    std::list<IdleJob *>::merge<IdleLess>((__int64 ***)v1 + 6, (__int64)v1 + 64);
  LeaveCriticalSection(v2);
}

//----- (000000018004DB3C) ----------------------------------------------------
void __fastcall PseudoEventTrap::IdleStarted(PseudoEventTrap *this)
{
  PseudoEventTrap *v1; // rbx

  v1 = g_pPseudoEventTrap;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xEu, (__int64)&WPP_c0b0770bd08e382a040e2237764c2feb_Traceguids);
  }
  PseudoEventTrap::StartIdleTasks(v1);
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018004DB90) ----------------------------------------------------
void __fastcall PseudoEventTrap::JobEnded(__int64 a1, __int64 a2)
{
  struct _RTL_CRITICAL_SECTION *v4; // rbx
  int v5; // eax

  v4 = (struct _RTL_CRITICAL_SECTION *)(a1 + 8);
  EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 8));
  v5 = *(_DWORD *)(a1 + 84);
  if ( v5 )
    *(_DWORD *)(a1 + 84) = v5 - 1;
  PseudoEventTrap::StartIdleTasks((PseudoEventTrap *)a1);
  LeaveCriticalSection(v4);
  wmi::AutoRef<JobBucket>::Release((wmi::RefBase **)(a2 + 32));
  _bstr_t::_Free((_bstr_t *)(a2 + 16));
}

//----- (000000018004DC30) ----------------------------------------------------
void __fastcall PseudoEventTrap::NotifyOtherSessionChanges(struct _RTL_CRITICAL_SECTION *this, int a2, DWORD a3)
{
  void *v6; // r8
  int v7; // eax
  __int64 v8; // rsi
  struct _RTL_CRITICAL_SECTION *v9; // rdi
  struct _RTL_CRITICAL_SECTION *v10; // r14
  __int64 *v11; // rbx
  __int64 v12; // r15
  __int64 v13; // r8
  const struct JobMoniker *v14; // rdx
  _DWORD *v15; // rsi
  LogonJob *v16; // rcx
  __int64 v17; // rcx
  __int64 *i; // rax
  __int64 *v19; // rbx
  __int64 v20; // r8
  const struct JobMoniker *v21; // rdx
  __int64 v22; // rsi
  LogonJob *v23; // rcx
  __int64 v24; // rcx
  __int64 *j; // rax
  User::UserEntry *v26; // [rsp+38h] [rbp-49h] BYREF
  __int64 *v27; // [rsp+40h] [rbp-41h] BYREF
  DWORD pBytesReturned; // [rsp+48h] [rbp-39h] BYREF
  LPWSTR ppBuffer; // [rsp+50h] [rbp-31h] BYREF
  __int64 *v30[4]; // [rsp+58h] [rbp-29h] BYREF
  char v31[16]; // [rsp+78h] [rbp-9h] BYREF
  char v32[16]; // [rsp+88h] [rbp+7h] BYREF
  wmi::RefBase *v33; // [rsp+98h] [rbp+17h] BYREF

  v30[1] = (__int64 *)-2LL;
  if ( WTSQuerySessionInformationW(0LL, a3, WTSConnectState, &ppBuffer, &pBytesReturned) )
  {
    if ( (*(_DWORD *)ppBuffer & 0xFFFFFFFB) != 0 )
    {
      WTSFreeMemory(ppBuffer);
    }
    else
    {
      WTSFreeMemory(ppBuffer);
      v30[2] = 0LL;
      if ( *(_QWORD *)&this[5].LockCount )
      {
        v26 = 0LL;
        v7 = User::FromUserSession(&v26, a3, v6);
        v8 = v7;
        if ( v7 >= 0 )
        {
          v9 = this + 4;
          v30[3] = (__int64 *)&this[4];
          EnterCriticalSection(this + 4);
          v10 = this + 5;
          v11 = (__int64 *)*std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::find(
                              (__int64)v10,
                              &v27,
                              &v26);
          v12 = v8;
          while ( v11 != (__int64 *)v10->DebugInfo && User::operator==((User *)(v11 + 4), (User *)&v26) )
          {
            v14 = (const struct JobMoniker *)v11[5];
            v15 = (_DWORD *)*((_QWORD *)v14 + 5);
            JobMoniker::JobMoniker((JobMoniker *)v31, v14, v13);
            if ( !(*(unsigned __int8 (__fastcall **)(_DWORD *))(*(_QWORD *)v15 + 32LL))(v15) )
              goto LABEL_53;
            if ( v15[24] == a2 )
              User::operator==((wmi::RefBase *)((char *)v33 + 64), (User *)&v26);
            if ( v12 >= 0 && (*((_BYTE *)v33 + 16) & 1) != 0 )
            {
              v16 = (LogonJob *)v11[5];
              if ( v16 )
                LogonJob::`scalar deleting destructor'(v16);
              v11 = *std::_Tree<std::_Tmap_traits<User,LogonJob *,User::less,std::allocator<std::pair<User const,LogonJob *>>,1>>::erase(
                       v10,
                       v30,
                       v11);
            }
            else
            {
LABEL_53:
              if ( !*((_BYTE *)v11 + 25) )
              {
                v17 = v11[2];
                if ( *(_BYTE *)(v17 + 25) )
                {
                  for ( i = (__int64 *)v11[1]; !*((_BYTE *)i + 25) && v11 == (__int64 *)i[2]; i = (__int64 *)i[1] )
                    v11 = i;
                }
                else
                {
                  i = std::_Tree_val<std::_Tree_simple_types<std::pair<_bstr_t const,std::list<_FILETIME> *>>>::_Min((_QWORD *)v17);
                }
                v11 = i;
              }
            }
            wmi::AutoRef<JobBucket>::Release(&v33);
            _bstr_t::_Free((_bstr_t *)v32);
          }
          v27 = 0LL;
          v19 = (__int64 *)*std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::find(
                              (__int64)v10,
                              v30,
                              &v27);
          wmi::AutoRef<User::UserEntry>::Release(&v27);
          while ( v19 != (__int64 *)v10->DebugInfo && !v19[4] )
          {
            v21 = (const struct JobMoniker *)v19[5];
            v22 = *((_QWORD *)v21 + 5);
            JobMoniker::JobMoniker((JobMoniker *)v31, v21, v20);
            if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v22 + 32LL))(v22)
              && v12 >= 0
              && (*((_BYTE *)v33 + 16) & 1) != 0 )
            {
              v23 = (LogonJob *)v19[5];
              if ( v23 )
                LogonJob::`scalar deleting destructor'(v23);
              v19 = *std::_Tree<std::_Tmap_traits<User,LogonJob *,User::less,std::allocator<std::pair<User const,LogonJob *>>,1>>::erase(
                       v10,
                       &v27,
                       v19);
            }
            else if ( !*((_BYTE *)v19 + 25) )
            {
              v24 = v19[2];
              if ( *(_BYTE *)(v24 + 25) )
              {
                for ( j = (__int64 *)v19[1]; !*((_BYTE *)j + 25) && v19 == (__int64 *)j[2]; j = (__int64 *)j[1] )
                  v19 = j;
              }
              else
              {
                j = std::_Tree_val<std::_Tree_simple_types<std::pair<_bstr_t const,std::list<_FILETIME> *>>>::_Min((_QWORD *)v24);
              }
              v19 = j;
            }
            wmi::AutoRef<JobBucket>::Release(&v33);
            _bstr_t::_Free((_bstr_t *)v32);
          }
          LeaveCriticalSection(v9);
        }
        else if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
               && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 4) != 0
               && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
        {
          WPP_SF_D(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x1Cu,
            (__int64)&WPP_c0b0770bd08e382a040e2237764c2feb_Traceguids,
            v7);
        }
        wmi::AutoRef<User::UserEntry>::Release(&v26);
      }
      operator delete(0LL);
    }
  }
}
// 18004DCDE: variable 'v6' is possibly undefined
// 18004DD94: variable 'v13' is possibly undefined
// 18004DE82: variable 'v20' is possibly undefined
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018004DFA4) ----------------------------------------------------
__int64 __fastcall PseudoEventTrap::RegisterIdleJob(
        PseudoEventTrap *this,
        const struct JobMoniker *a2,
        struct Triggers::IdleTrigger *a3)
{
  PseudoEventTrap *v4; // rbp
  const wchar_t *Path; // rax
  JobMoniker *v7; // rax
  __int64 v8; // r8
  JobMoniker *v9; // rsi

  v4 = g_pPseudoEventTrap;
  if ( !byte_1800B0CC8 )
    return 2147942421LL;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
  {
    Path = JobMoniker::GetPath(a2);
    WPP_SF_S(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xFu, (__int64)&WPP_c0b0770bd08e382a040e2237764c2feb_Traceguids, Path);
  }
  EnterCriticalSection((LPCRITICAL_SECTION)((char *)v4 + 8));
  v7 = (JobMoniker *)operator new(0x30uLL);
  v9 = v7;
  if ( v7 )
  {
    JobMoniker::JobMoniker(v7, a2, v8);
    *((_QWORD *)v9 + 5) = a3;
  }
  else
  {
    v9 = 0LL;
  }
  IdleJobList::insert_sorted((PseudoEventTrap *)((char *)v4 + 48), v9);
  ++*((_DWORD *)v4 + 22);
  PseudoEventTrap::StartIdleTasks(v4);
  LeaveCriticalSection((LPCRITICAL_SECTION)((char *)v4 + 8));
  return 0LL;
}
// 18004E07A: variable 'v8' is possibly undefined
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 1800B0CC8: using guessed type char byte_1800B0CC8;

//----- (000000018004E0E0) ----------------------------------------------------
__int64 __fastcall PseudoEventTrap::RegisterLogonJob(
        PseudoEventTrap *this,
        const struct JobMoniker *a2,
        struct Triggers::LogonTrigger *a3)
{
  PseudoEventTrap *v4; // r15
  const wchar_t *Path; // rax
  unsigned int v6; // esi
  JobMoniker *v7; // rax
  __int64 v8; // r8
  __int64 v9; // r14
  struct Triggers::LogonTrigger *v10; // rdi
  User::UserEntry *v11; // rcx
  __int64 v13[2]; // [rsp+38h] [rbp-38h] BYREF
  struct Triggers::LogonTrigger **v14; // [rsp+48h] [rbp-28h] BYREF
  char v15; // [rsp+50h] [rbp-20h]
  char v16[24]; // [rsp+58h] [rbp-18h] BYREF
  struct Triggers::LogonTrigger *v17; // [rsp+C0h] [rbp+50h] BYREF
  JobMoniker *v18; // [rsp+C8h] [rbp+58h]

  v17 = a3;
  v4 = g_pPseudoEventTrap;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
  {
    Path = JobMoniker::GetPath(a2);
    WPP_SF_S(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x13u,
      (__int64)&WPP_c0b0770bd08e382a040e2237764c2feb_Traceguids,
      Path);
    a3 = v17;
  }
  v14 = &v17;
  v15 = 1;
  if ( *((_DWORD *)v4 + 34) == -1 )
  {
    v6 = -2147024882;
  }
  else
  {
    v6 = 0;
    if ( (int)Triggers::SessionBasedTrigger::ResolveUPN(a3) >= 0 )
    {
      EnterCriticalSection((LPCRITICAL_SECTION)((char *)v4 + 96));
      v7 = (JobMoniker *)operator new(0x30uLL);
      v9 = (__int64)v7;
      v18 = v7;
      if ( v7 )
      {
        v10 = v17;
        JobMoniker::JobMoniker(v7, a2, v8);
        *(_QWORD *)(v9 + 40) = v10;
      }
      else
      {
        v9 = 0LL;
      }
      v11 = *(User::UserEntry **)(*(_QWORD *)(v9 + 40) + 88LL);
      v13[0] = (__int64)v11;
      if ( v11 )
        User::UserEntry::AddRef(v11);
      v13[1] = v9;
      std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::_Insert_nohint<std::pair<User const,SessionChangeJob *>,std::_Nil>(
        (_QWORD *)v4 + 18,
        (__int64)v16,
        v8,
        v13);
      wmi::AutoRef<User::UserEntry>::Release(v13);
      v15 = 0;
      ++*((_DWORD *)v4 + 34);
      LeaveCriticalSection((LPCRITICAL_SECTION)((char *)v4 + 96));
    }
  }
  tsched::DeleteMe<Triggers::LogonTrigger>::~DeleteMe<Triggers::LogonTrigger>((__int64)&v14);
  return v6;
}
// 18004E1C2: variable 'v8' is possibly undefined
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 18004E0E0: using guessed type char var_18[24];

//----- (000000018004E274) ----------------------------------------------------
__int64 __fastcall PseudoEventTrap::RegisterSessionChangeJob(
        PseudoEventTrap *this,
        const struct JobMoniker *a2,
        struct Triggers::SessionChangeTrigger *a3)
{
  struct _RTL_CRITICAL_SECTION *v4; // r13
  const wchar_t *Path; // rax
  int v6; // r14d
  char v7; // cl
  JobMoniker *v8; // rax
  __int64 v9; // r8
  __int64 v10; // rsi
  struct Triggers::SessionChangeTrigger *v11; // rdi
  User::UserEntry *v12; // rcx
  __int64 v14[3]; // [rsp+38h] [rbp-48h] BYREF
  char v15; // [rsp+50h] [rbp-30h]
  PseudoEventTrap **v16; // [rsp+58h] [rbp-28h]
  char v17; // [rsp+60h] [rbp-20h]
  char v18[24]; // [rsp+68h] [rbp-18h] BYREF
  PseudoEventTrap *v19; // [rsp+C0h] [rbp+40h] BYREF
  struct Triggers::SessionChangeTrigger *v20; // [rsp+D0h] [rbp+50h] BYREF
  struct _RTL_CRITICAL_SECTION *v21; // [rsp+D8h] [rbp+58h]

  v20 = a3;
  v19 = this;
  v4 = (struct _RTL_CRITICAL_SECTION *)g_pPseudoEventTrap;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
  {
    Path = JobMoniker::GetPath(a2);
    WPP_SF_S(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x1Au,
      (__int64)&WPP_c0b0770bd08e382a040e2237764c2feb_Traceguids,
      Path);
    a3 = v20;
  }
  v14[2] = (__int64)&v20;
  v15 = 1;
  v6 = Triggers::SessionBasedTrigger::ResolveUPN(a3);
  v7 = 1;
  if ( v6 >= 0 )
  {
    v21 = v4 + 4;
    EnterCriticalSection(v4 + 4);
    v8 = (JobMoniker *)operator new(0x30uLL);
    v10 = (__int64)v8;
    v14[0] = (__int64)v8;
    if ( v8 )
    {
      v11 = v20;
      JobMoniker::JobMoniker(v8, a2, v9);
      *(_QWORD *)(v10 + 40) = v11;
    }
    else
    {
      v10 = 0LL;
    }
    v19 = (PseudoEventTrap *)v10;
    v15 = 0;
    v16 = &v19;
    v17 = 1;
    v12 = *(User::UserEntry **)(*(_QWORD *)(v10 + 40) + 88LL);
    v14[0] = (__int64)v12;
    if ( v12 )
    {
      User::UserEntry::AddRef(v12);
      v10 = (__int64)v19;
    }
    v14[1] = v10;
    std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::_Insert_nohint<std::pair<User const,SessionChangeJob *>,std::_Nil>(
      &v4[5].DebugInfo,
      (__int64)v18,
      v9,
      v14);
    wmi::AutoRef<User::UserEntry>::Release(v14);
    LeaveCriticalSection(v4 + 4);
    v7 = 0;
  }
  if ( v7 && v20 )
    (**(void (__fastcall ***)(struct Triggers::SessionChangeTrigger *, __int64))v20)(v20, 1LL);
  return (unsigned int)v6;
}
// 18004E34D: variable 'v9' is possibly undefined
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);
// 1800747C8: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 18004E274: using guessed type char var_18[24];

//----- (000000018004E430) ----------------------------------------------------
void __fastcall PseudoEventTrap::StartIdleTasks(PseudoEventTrap *this)
{
  struct _RTL_CRITICAL_SECTION *v2; // rbx
  __int64 *v3; // r8
  JobMoniker *v4; // rsi
  const unsigned __int16 *Path; // rax
  __int64 v6; // [rsp+68h] [rbp+10h] BYREF

  v2 = (struct _RTL_CRITICAL_SECTION *)((char *)this + 8);
  EnterCriticalSection((LPCRITICAL_SECTION)((char *)this + 8));
  while ( byte_1800B0CC8 )
  {
    if ( !byte_1800B0C70 || !*((_QWORD *)this + 7) || *((_DWORD *)this + 21) >= *((_DWORD *)this + 20) )
      break;
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x10) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x11u, (__int64)&WPP_c0b0770bd08e382a040e2237764c2feb_Traceguids);
    }
    v3 = (__int64 *)**((_QWORD **)this + 6);
    v4 = (JobMoniker *)v3[2];
    std::list<IdleJob *>::erase((__int64 **)this + 6, &v6, v3);
    if ( (*(unsigned __int8 (__fastcall **)(_QWORD *))(**((_QWORD **)v4 + 5) + 32LL))(*((_QWORD **)v4 + 5))
      && WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x10) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
    {
      Path = JobMoniker::GetPath(v4);
      WPP_SF_dS(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x12u,
        (__int64)&WPP_c0b0770bd08e382a040e2237764c2feb_Traceguids,
        *((_DWORD *)this + 21) + 1,
        (__int64)Path);
    }
    IdleJobList::insert_sorted((PseudoEventTrap *)((char *)this + 64), v4);
  }
  LeaveCriticalSection(v2);
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 1800B0C70: using guessed type char byte_1800B0C70;
// 1800B0CC8: using guessed type char byte_1800B0CC8;

//----- (000000018004E584) ----------------------------------------------------
__int64 __fastcall StringCbLengthW(const unsigned __int16 *a1, unsigned __int64 a2, unsigned __int64 *a3)
{
  unsigned __int64 v3; // rdx
  unsigned __int64 v5; // rax
  unsigned __int64 i; // r8
  signed int v7; // ecx

  v3 = a2 >> 1;
  v5 = 0LL;
  if ( a1 && v3 <= 0x7FFFFFFF )
  {
    for ( i = v3; i; --i )
    {
      if ( !*a1 )
        break;
      ++a1;
    }
    v7 = i == 0 ? 0x80070057 : 0;
    if ( i )
      v5 = v3 - i;
    else
      v5 = 0LL;
  }
  else
  {
    v7 = -2147024809;
  }
  if ( a3 )
  {
    if ( v7 < 0 )
      *a3 = 0LL;
    else
      *a3 = 2 * v5;
  }
  return (unsigned int)v7;
}

//----- (000000018004E5FC) ----------------------------------------------------
_QWORD *__fastcall std::_Tree_buy<std::pair<User const,LogonJob *>>::_Buynode0(_QWORD *a1)
{
  _QWORD *result; // rax

  result = operator new(0x30uLL);
  if ( !result )
    std::_Xbad_alloc();
  *result = *a1;
  result[1] = *a1;
  result[2] = *a1;
  return result;
}

//----- (000000018004E670) ----------------------------------------------------
void __fastcall std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::_Erase(
        __int64 a1,
        char *a2)
{
  char *v2; // rbx
  char *i; // rdi

  v2 = a2;
  for ( i = a2; !i[25]; v2 = i )
  {
    std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::_Erase(
      a1,
      *((_QWORD *)i + 2));
    i = *(char **)i;
    wmi::AutoRef<User::UserEntry>::Release(v2 + 32);
    operator delete(v2);
  }
}
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);

//----- (000000018004E6D0) ----------------------------------------------------
__int64 __fastcall std::list<IdleJob *>::_Incsize(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // r8
  __int64 result; // rax

  v2 = *(_QWORD *)(a1 + 8);
  if ( 0xAAAAAAAAAAAAAA9LL - v2 < a2 )
    std::_Xlength_error("list<T> too long");
  result = v2 + a2;
  *(_QWORD *)(a1 + 8) = v2 + a2;
  return result;
}

//----- (000000018004E70C) ----------------------------------------------------
__int64 __fastcall std::list<IdleJob *>::_Splice_same(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        unsigned __int64 a6)
{
  __int64 result; // rax
  __int64 v10; // rdx

  if ( a1 != a3 )
  {
    std::list<IdleJob *>::_Incsize(a1, a6);
    *(_QWORD *)(a3 + 8) -= a6;
  }
  result = a5;
  **(_QWORD **)(a4 + 8) = a5;
  **(_QWORD **)(a5 + 8) = a2;
  **(_QWORD **)(a2 + 8) = a4;
  v10 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = *(_QWORD *)(a5 + 8);
  *(_QWORD *)(a5 + 8) = *(_QWORD *)(a4 + 8);
  *(_QWORD *)(a4 + 8) = v10;
  return result;
}

//----- (000000018004E790) ----------------------------------------------------
__int64 __fastcall std::_Tree<std::_Tmap_traits<User,LogonJob *,User::less,std::allocator<std::pair<User const,LogonJob *>>,1>>::clear(
        _QWORD *a1)
{
  __int64 result; // rax

  std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::_Erase(
    (__int64)a1,
    *(char **)(*a1 + 8LL));
  *(_QWORD *)(*a1 + 8LL) = *a1;
  *(_QWORD *)*a1 = *a1;
  result = *a1;
  *(_QWORD *)(*a1 + 16LL) = *a1;
  a1[1] = 0LL;
  return result;
}

//----- (000000018004E7CC) ----------------------------------------------------
void __fastcall std::list<IdleJob *>::clear(__int64 a1)
{
  _QWORD *v1; // rax
  _QWORD *v3; // rcx
  _QWORD *v4; // rbx

  v1 = *(_QWORD **)a1;
  v3 = **(_QWORD ***)a1;
  *v1 = v1;
  *(_QWORD *)(*(_QWORD *)a1 + 8LL) = *(_QWORD *)a1;
  *(_QWORD *)(a1 + 8) = 0LL;
  if ( v3 != *(_QWORD **)a1 )
  {
    do
    {
      v4 = (_QWORD *)*v3;
      operator delete(v3);
      v3 = v4;
    }
    while ( v4 != *(_QWORD **)a1 );
  }
}

//----- (000000018004E818) ----------------------------------------------------
__int64 **__fastcall std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::erase(
        __int64 ***a1,
        __int64 **a2,
        __int64 *a3,
        __int64 *a4)
{
  __int64 *v5; // rbx
  __int64 *v8; // r8
  __int64 v9; // rcx
  __int64 *i; // rax
  __int64 *v12; // [rsp+30h] [rbp+8h] BYREF

  v5 = a3;
  if ( a3 == **a1 && a4 == (__int64 *)*a1 )
  {
    std::_Tree<std::_Tmap_traits<User,LogonJob *,User::less,std::allocator<std::pair<User const,LogonJob *>>,1>>::clear(a1);
    *a2 = **a1;
  }
  else
  {
    while ( v5 != a4 )
    {
      v8 = v5;
      if ( !*((_BYTE *)v5 + 25) )
      {
        v9 = v5[2];
        if ( *(_BYTE *)(v9 + 25) )
        {
          for ( i = (__int64 *)v5[1]; !*((_BYTE *)i + 25) && v5 == (__int64 *)i[2]; i = (__int64 *)i[1] )
            v5 = i;
        }
        else
        {
          i = std::_Tree_val<std::_Tree_simple_types<std::pair<_bstr_t const,std::list<_FILETIME> *>>>::_Min((_QWORD *)v9);
        }
        v5 = i;
      }
      std::_Tree<std::_Tmap_traits<User,LogonJob *,User::less,std::allocator<std::pair<User const,LogonJob *>>,1>>::erase(
        a1,
        &v12,
        v8);
    }
    *a2 = v5;
  }
  return a2;
}
// 18004E899: variable 'v8' is possibly undefined

//----- (000000018004E8C4) ----------------------------------------------------
__int64 **__fastcall std::_Tree<std::_Tmap_traits<User,LogonJob *,User::less,std::allocator<std::pair<User const,LogonJob *>>,1>>::erase(
        _QWORD *a1,
        __int64 **a2,
        __int64 *a3)
{
  __int64 *v5; // rbp
  _QWORD *v6; // r11
  __int64 *v7; // rdi
  __int64 v8; // r9
  __int64 *i; // rbx
  __int64 v10; // r10
  _QWORD *v11; // r8
  _QWORD *v12; // rax
  _QWORD *v13; // rax
  __int64 v14; // rcx
  __int64 v15; // rdx
  char v16; // cl
  __int64 **v17; // rax
  __int64 v18; // r11
  _BYTE *v19; // rdx
  __int64 v20; // rcx
  __int64 v21; // rax
  __int64 **result; // rax

  v5 = a3;
  if ( *((_BYTE *)a3 + 25) )
    std::_Xout_of_range("invalid map/set<T> iterator");
  v6 = a3 + 2;
  v7 = a3;
  v8 = a3[2];
  if ( *(_BYTE *)(v8 + 25) )
  {
    for ( i = (__int64 *)a3[1]; !*((_BYTE *)i + 25) && a3 == (__int64 *)i[2]; i = (__int64 *)i[1] )
      a3 = i;
  }
  else
  {
    i = std::_Tree_val<std::_Tree_simple_types<std::pair<_bstr_t const,std::list<_FILETIME> *>>>::_Min((_QWORD *)a3[2]);
  }
  if ( *(_BYTE *)(*v7 + 25) )
    goto LABEL_13;
  if ( *(_BYTE *)(v8 + 25) )
  {
    v8 = *v7;
LABEL_13:
    v10 = v7[1];
    if ( !*(_BYTE *)(v8 + 25) )
      *(_QWORD *)(v8 + 8) = v10;
    if ( *(__int64 **)(*a1 + 8LL) == v7 )
    {
      *(_QWORD *)(*a1 + 8LL) = v8;
    }
    else if ( *(__int64 **)v10 == v7 )
    {
      *(_QWORD *)v10 = v8;
    }
    else
    {
      *(_QWORD *)(v10 + 16) = v8;
    }
    v11 = (_QWORD *)*a1;
    v12 = (_QWORD *)*a1;
    if ( *(__int64 **)*a1 == v7 )
    {
      if ( *(_BYTE *)(v8 + 25) )
        v13 = (_QWORD *)v10;
      else
        v13 = std::_Tree_val<std::_Tree_simple_types<std::pair<_bstr_t const,std::list<_FILETIME> *>>>::_Min((_QWORD *)v8);
      *v11 = v13;
      v11 = (_QWORD *)*a1;
      v12 = (_QWORD *)*a1;
    }
    if ( (__int64 *)v12[2] == v7 )
    {
      if ( *(_BYTE *)(v8 + 25) )
      {
        v14 = v10;
      }
      else
      {
        v15 = *(_QWORD *)(v8 + 16);
        v14 = v8;
        if ( !*(_BYTE *)(v15 + 25) )
        {
          do
          {
            v14 = v15;
            v15 = *(_QWORD *)(v15 + 16);
          }
          while ( !*(_BYTE *)(v15 + 25) );
          v12 = v11;
        }
      }
      v12[2] = v14;
    }
    v16 = *((_BYTE *)v5 + 24);
    goto LABEL_44;
  }
  v8 = i[2];
  if ( i == v7 )
    goto LABEL_13;
  *(_QWORD *)(*v7 + 8) = i;
  *i = *v7;
  if ( i == (__int64 *)*v6 )
  {
    v10 = (__int64)i;
  }
  else
  {
    v10 = i[1];
    if ( !*(_BYTE *)(v8 + 25) )
      *(_QWORD *)(v8 + 8) = v10;
    *(_QWORD *)v10 = v8;
    i[2] = *v6;
    *(_QWORD *)(*v6 + 8LL) = i;
  }
  if ( *(__int64 **)(*a1 + 8LL) == v7 )
  {
    *(_QWORD *)(*a1 + 8LL) = i;
  }
  else
  {
    v17 = (__int64 **)v7[1];
    if ( *v17 == v7 )
      *v17 = i;
    else
      v17[2] = i;
  }
  v16 = *((_BYTE *)i + 24);
  i[1] = v7[1];
  *((_BYTE *)i + 24) = *((_BYTE *)v7 + 24);
  *((_BYTE *)v7 + 24) = v16;
LABEL_44:
  if ( v16 == 1 )
  {
    if ( v8 != *(_QWORD *)(*a1 + 8LL) )
    {
      do
      {
        v18 = v10;
        if ( *(_BYTE *)(v8 + 24) != 1 )
          break;
        v19 = *(_BYTE **)v10;
        if ( v8 == *(_QWORD *)v10 )
        {
          v19 = *(_BYTE **)(v10 + 16);
          if ( !v19[24] )
          {
            v19[24] = 1;
            *(_BYTE *)(v10 + 24) = 0;
            std::_Tree<std::_Tmap_traits<User,LogonJob *,User::less,std::allocator<std::pair<User const,LogonJob *>>,1>>::_Lrotate(
              (__int64)a1,
              v10);
            v19 = *(_BYTE **)(v10 + 16);
          }
          if ( v19[25] )
            goto LABEL_62;
          if ( *(_BYTE *)(*(_QWORD *)v19 + 24LL) != 1 || *(_BYTE *)(*((_QWORD *)v19 + 2) + 24LL) != 1 )
          {
            if ( *(_BYTE *)(*((_QWORD *)v19 + 2) + 24LL) == 1 )
            {
              *(_BYTE *)(*(_QWORD *)v19 + 24LL) = 1;
              v19[24] = 0;
              std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::_Rrotate(
                (__int64)a1,
                v19);
              v19 = *(_BYTE **)(v10 + 16);
            }
            v19[24] = *(_BYTE *)(v10 + 24);
            *(_BYTE *)(v10 + 24) = 1;
            *(_BYTE *)(*((_QWORD *)v19 + 2) + 24LL) = 1;
            std::_Tree<std::_Tmap_traits<User,LogonJob *,User::less,std::allocator<std::pair<User const,LogonJob *>>,1>>::_Lrotate(
              (__int64)a1,
              v10);
            break;
          }
        }
        else
        {
          if ( !v19[24] )
          {
            v19[24] = 1;
            *(_BYTE *)(v10 + 24) = 0;
            std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::_Rrotate(
              (__int64)a1,
              (_QWORD *)v10);
            v19 = *(_BYTE **)v10;
          }
          if ( v19[25] )
            goto LABEL_62;
          v20 = *((_QWORD *)v19 + 2);
          if ( *(_BYTE *)(v20 + 24) != 1 || *(_BYTE *)(*(_QWORD *)v19 + 24LL) != 1 )
          {
            if ( *(_BYTE *)(*(_QWORD *)v19 + 24LL) == 1 )
            {
              *(_BYTE *)(v20 + 24) = 1;
              v19[24] = 0;
              std::_Tree<std::_Tmap_traits<User,LogonJob *,User::less,std::allocator<std::pair<User const,LogonJob *>>,1>>::_Lrotate(
                (__int64)a1,
                (__int64)v19);
              v19 = *(_BYTE **)v10;
            }
            v19[24] = *(_BYTE *)(v10 + 24);
            *(_BYTE *)(v10 + 24) = 1;
            *(_BYTE *)(*(_QWORD *)v19 + 24LL) = 1;
            std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::_Rrotate(
              (__int64)a1,
              (_QWORD *)v10);
            break;
          }
        }
        v19[24] = 0;
LABEL_62:
        v8 = v18;
        v10 = *(_QWORD *)(v10 + 8);
      }
      while ( v18 != *(_QWORD *)(*a1 + 8LL) );
    }
    *(_BYTE *)(v8 + 24) = 1;
  }
  wmi::AutoRef<User::UserEntry>::Release(v7 + 4);
  operator delete(v7);
  v21 = a1[1];
  if ( v21 )
    a1[1] = v21 - 1;
  result = a2;
  *a2 = i;
  return result;
}
// 18004E93A: variable 'v8' is possibly undefined
// 18004E99B: variable 'v11' is possibly undefined
// 18004E9B0: variable 'v10' is possibly undefined
// 18004E9E5: variable 'v6' is possibly undefined
// 18004EB2C: variable 'v18' is possibly undefined
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);

//----- (000000018004EBC4) ----------------------------------------------------
_QWORD *__fastcall std::list<IdleJob *>::erase(__int64 **a1, _QWORD *a2, __int64 *a3)
{
  __int64 v4; // rbx
  _QWORD *result; // rax

  v4 = *a3;
  if ( a3 != *a1 )
  {
    *(_QWORD *)a3[1] = v4;
    *(_QWORD *)(*a3 + 8) = a3[1];
    operator delete(a3);
    a1[1] = (__int64 *)((char *)a1[1] - 1);
  }
  result = a2;
  *a2 = v4;
  return result;
}

//----- (000000018004EC1C) ----------------------------------------------------
_QWORD *__fastcall std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::find(
        __int64 a1,
        _QWORD *a2,
        _QWORD *a3)
{
  __int64 *v3; // rdi
  __int64 *v7; // rax
  __int64 *v8; // rbx
  _QWORD *result; // rax

  v3 = *(__int64 **)a1;
  v7 = *(__int64 **)a1;
  v8 = *(__int64 **)(*(_QWORD *)a1 + 8LL);
  if ( !*((_BYTE *)v8 + 25) )
  {
    do
    {
      if ( User::less::operator()(a1, v8 + 4, a3) )
      {
        v8 = (__int64 *)v8[2];
      }
      else
      {
        v3 = v8;
        v8 = (__int64 *)*v8;
      }
    }
    while ( !*((_BYTE *)v8 + 25) );
    v7 = *(__int64 **)a1;
  }
  if ( v3 == v7 || User::less::operator()(a1, a3, v3 + 4) )
    v3 = *(__int64 **)a1;
  result = a2;
  *a2 = v3;
  return result;
}
// 18004EC55: variable 'a1' is possibly undefined

//----- (000000018004ECB4) ----------------------------------------------------
void __fastcall IdleJobList::insert_sorted(IdleJobList *this, struct IdleJob *a2)
{
  unsigned int *v3; // rcx
  unsigned int v4; // r8d
  _QWORD *v5; // rdx
  _DWORD *v6; // rcx
  unsigned int v7; // eax
  _DWORD *v8; // rax
  _DWORD *v9; // rax
  struct IdleJob *v10; // [rsp+38h] [rbp+10h] BYREF

  v10 = a2;
  v3 = *(unsigned int **)(*((_QWORD *)a2 + 4) + 208LL);
  if ( v3 )
    v4 = *v3;
  else
    v4 = 0;
  v5 = *(_QWORD **)this;
  if ( *((_QWORD *)this + 1) )
  {
    v6 = *(_DWORD **)(*(_QWORD *)(*(_QWORD *)(v5[1] + 16LL) + 32LL) + 208LL);
    v7 = v6 ? *v6 : 0;
    if ( v4 < v7 )
    {
      v5 = (_QWORD *)*v5;
      v8 = *(_DWORD **)(*(_QWORD *)(v5[2] + 32LL) + 208LL);
      if ( v8 )
        LODWORD(v8) = *v8;
      if ( v4 >= (unsigned int)v8 )
      {
        while ( 1 )
        {
          v9 = *(_DWORD **)(*(_QWORD *)(v5[2] + 32LL) + 208LL);
          if ( v9 )
            LODWORD(v9) = *v9;
          if ( v4 <= (unsigned int)v9 )
            break;
          v5 = (_QWORD *)*v5;
        }
      }
    }
  }
  std::list<IdleJob *>::_Insert<IdleJob * const &>((__int64)this, (__int64)v5, &v10);
}

//----- (000000018004ED5C) ----------------------------------------------------
__int64 __fastcall WPP_SF_S(__int64 a1, unsigned __int16 a2, __int64 a3, const wchar_t *a4)
{
  __int64 v4; // rax

  if ( a4 )
  {
    v4 = -1LL;
    do
      ++v4;
    while ( a4[v4] );
  }
  if ( !a4 )
    a4 = L"NULL";
  return EtwTraceMessage(a1, 43LL, a3, a2, a4);
}
// 1800747B0: using guessed type __int64 __fastcall EtwTraceMessage(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 18007F5B8: using guessed type wchar_t aNull_1[5];

//----- (000000018004EDC4) ----------------------------------------------------
__int64 __fastcall WPP_SF_dS(__int64 a1, unsigned __int16 a2, __int64 a3, int a4, __int64 a5)
{
  __int64 v5; // rax
  int v7; // [rsp+78h] [rbp+20h] BYREF

  v7 = a4;
  if ( a5 )
  {
    v5 = -1LL;
    do
      ++v5;
    while ( *(_WORD *)(a5 + 2 * v5) );
  }
  return EtwTraceMessage(a1, 43LL, a3, a2, &v7);
}
// 1800747B0: using guessed type __int64 __fastcall EtwTraceMessage(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000018004EE4C) ----------------------------------------------------
__int64 __fastcall WPP_SF_dd(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v5; // [rsp+78h] [rbp+20h] BYREF

  v5 = a4;
  return EtwTraceMessage(a1, 43LL, &WPP_c0b0770bd08e382a040e2237764c2feb_Traceguids, 23LL, &v5);
}
// 1800747B0: using guessed type __int64 __fastcall EtwTraceMessage(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000018004EEA8) ----------------------------------------------------
__int64 __fastcall WPP_SF_dsd(__int64 a1, __int64 a2, __int64 a3, int a4, __int64 a5)
{
  __int64 v5; // rax
  int v7; // [rsp+88h] [rbp+20h] BYREF

  v7 = a4;
  if ( a5 )
  {
    v5 = -1LL;
    do
      ++v5;
    while ( *(_BYTE *)(a5 + v5) );
  }
  return EtwTraceMessage(a1, 43LL, &WPP_c0b0770bd08e382a040e2237764c2feb_Traceguids, 10LL, &v7);
}
// 1800747B0: using guessed type __int64 __fastcall EtwTraceMessage(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000018004EF48) ----------------------------------------------------
void __fastcall std::vector<unsigned short>::_Insert<unsigned short const *>(
        __int64 a1,
        _WORD *a2,
        const void *a3,
        __int64 a4)
{
  unsigned __int64 v7; // rsi
  __int64 v8; // r8
  void *v9; // rcx
  __int64 v10; // rcx
  unsigned __int64 v11; // r12
  unsigned __int64 v12; // r8
  unsigned __int64 v13; // rdx
  char *v14; // r15
  size_t v15; // rdi
  char *v16; // rcx
  char *v17; // rax
  unsigned __int64 v18; // rsi

  v7 = (a4 - (__int64)a3) >> 1;
  if ( v7 )
  {
    v8 = *(_QWORD *)(a1 + 16);
    v9 = *(void **)(a1 + 8);
    if ( (v8 - (__int64)v9) >> 1 >= v7 )
    {
      memmove_0(v9, a3, 2 * v7);
      std::rotate<unsigned short *>(a2, *(_QWORD *)(a1 + 8), (_WORD *)(2 * v7 + *(_QWORD *)(a1 + 8)));
      *(_QWORD *)(a1 + 8) += 2 * v7;
    }
    else
    {
      v10 = ((__int64)v9 - *(_QWORD *)a1) >> 1;
      if ( 0x7FFFFFFFFFFFFFFFLL - v10 < v7 )
        std::_Xlength_error("vector<T> too long");
      v11 = v10 + v7;
      v12 = (v8 - *(_QWORD *)a1) >> 1;
      v13 = 0LL;
      if ( 0x7FFFFFFFFFFFFFFFLL - (v12 >> 1) >= v12 )
        v13 = v12 + (v12 >> 1);
      if ( v13 >= v11 )
        v11 = v13;
      v14 = 0LL;
      if ( v11 )
      {
        if ( v11 > 0x7FFFFFFFFFFFFFFFLL || (v14 = (char *)operator new(2 * v11)) == 0LL )
          std::_Xbad_alloc();
      }
      v15 = 2 * (((__int64)a2 - *(_QWORD *)a1) >> 1);
      v16 = (char *)memmove_0(v14, *(const void **)a1, v15) + v15;
      v17 = (char *)memmove_0(v16, a3, 2 * v7);
      memmove_0(&v17[2 * v7], a2, 2 * ((__int64)(*(_QWORD *)(a1 + 8) - (_QWORD)a2) >> 1));
      v18 = ((__int64)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 1) + v7;
      if ( *(_QWORD *)a1 )
        operator delete(*(void **)a1);
      *(_QWORD *)(a1 + 16) = &v14[2 * v11];
      *(_QWORD *)(a1 + 8) = &v14[2 * v18];
      *(_QWORD *)a1 = v14;
    }
  }
}

//----- (000000018004F0F4) ----------------------------------------------------
__int64 __fastcall std::_Rotate<unsigned short *,__int64,unsigned short>(_WORD *a1, __int64 a2, _WORD *a3)
{
  __int64 result; // rax
  __int64 v4; // r9
  __int64 v6; // r10
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // rax
  __int64 v11; // rt2
  __int64 v12; // rbx
  _WORD *v13; // r8
  __int16 v14; // si
  _WORD *v15; // rdx
  _WORD *v16; // rdi
  __int64 v17; // r10
  void *retaddr; // [rsp+0h] [rbp+0h] BYREF

  result = (__int64)&retaddr;
  v4 = (a2 - (__int64)a1) >> 1;
  v6 = a3 - a1;
  v8 = v6;
  v9 = v4;
  if ( v4 )
  {
    do
    {
      v10 = v8;
      v8 = v9;
      v11 = v10 % v9;
      result = v10 / v9;
      v9 = v11;
    }
    while ( v11 );
    if ( v8 < v6 && v8 > 0 )
    {
      v12 = v4;
      v13 = &a1[v8];
      do
      {
        v14 = *v13;
        v15 = &v13[v12];
        v16 = v13;
        if ( &v13[v12] == a3 )
          v15 = a1;
        do
        {
          result = (unsigned __int16)*v15;
          *v16 = result;
          v17 = a3 - v15;
          v16 = v15;
          *v15 = v14;
          if ( v4 >= v17 )
          {
            result = v4 - v17;
            v15 = &a1[v4 - v17];
          }
          else
          {
            v15 = (_WORD *)((char *)v15 + v12 * 2);
          }
        }
        while ( v15 != v13 );
        --v8;
        --v13;
      }
      while ( v8 > 0 );
    }
  }
  return result;
}

//----- (000000018004F1B8) ----------------------------------------------------
void __fastcall std::vector<unsigned short>::assign<unsigned short *>(_WORD **a1, const void *a2, __int64 a3)
{
  char *v6; // [rsp+40h] [rbp+8h] BYREF

  std::vector<unsigned short>::erase(a1, &v6, (char *)*a1, (char *)a1[1]);
  std::vector<unsigned short>::_Insert<unsigned short const *>((__int64)a1, *a1, a2, a3);
}

//----- (000000018004F20C) ----------------------------------------------------
_WORD *__fastcall std::rotate<unsigned short *>(_WORD *a1, __int64 a2, _WORD *a3)
{
  if ( a1 != (_WORD *)a2 && (_WORD *)a2 != a3 )
    std::_Rotate<unsigned short *,__int64,unsigned short>(a1, a2, a3);
  return &a1[((__int64)a3 - a2) >> 1];
}

//----- (000000018004F254) ----------------------------------------------------
void __fastcall std::map<_bstr_t,_bstr_t>::~map<_bstr_t,_bstr_t>(void **a1)
{
  std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::clear(a1);
  operator delete(*a1);
}

//----- (000000018004F280) ----------------------------------------------------
void __fastcall std::pair<_bstr_t const,_bstr_t>::~pair<_bstr_t const,_bstr_t>(_bstr_t *this)
{
  _bstr_t::_Free((_bstr_t *)((char *)this + 8));
  _bstr_t::_Free(this);
}

//----- (000000018004F2B4) ----------------------------------------------------
void __fastcall Aggregator::~Aggregator(__int64 ***this)
{
  __int64 *v2; // rbx
  _QWORD *v3; // rsi
  _QWORD *v4; // rdx
  _QWORD *v5; // rcx
  _QWORD *v6; // rdi
  __int64 v7; // rcx
  __int64 *i; // rax
  __int64 *v9; // [rsp+40h] [rbp+8h] BYREF

  v2 = **this;
  while ( v2 != (__int64 *)*this )
  {
    v3 = (_QWORD *)v2[5];
    if ( v3 )
    {
      v4 = *(_QWORD **)*v3;
      *(_QWORD *)*v3 = *v3;
      *(_QWORD *)(*v3 + 8LL) = *v3;
      v3[1] = 0LL;
      v5 = (_QWORD *)*v3;
      if ( v4 != (_QWORD *)*v3 )
      {
        do
        {
          v6 = (_QWORD *)*v4;
          operator delete(v4);
          v4 = v6;
          v5 = (_QWORD *)*v3;
        }
        while ( v6 != (_QWORD *)*v3 );
      }
      operator delete(v5);
      operator delete(v3);
    }
    v2[5] = 0LL;
    if ( !*((_BYTE *)v2 + 25) )
    {
      v7 = v2[2];
      if ( *(_BYTE *)(v7 + 25) )
      {
        for ( i = (__int64 *)v2[1]; !*((_BYTE *)i + 25) && v2 == (__int64 *)i[2]; i = (__int64 *)i[1] )
          v2 = i;
      }
      else
      {
        i = std::_Tree_val<std::_Tree_simple_types<std::pair<_bstr_t const,std::list<_FILETIME> *>>>::_Min((_QWORD *)v7);
      }
      v2 = i;
    }
  }
  std::_Tree<std::_Tmap_traits<_bstr_t,std::list<_FILETIME> *,Aggregator::less,std::allocator<std::pair<_bstr_t const,std::list<_FILETIME> *>>,0>>::clear(this);
  std::_Tree<std::_Tmap_traits<_bstr_t,std::list<_FILETIME> *,Aggregator::less,std::allocator<std::pair<_bstr_t const,std::list<_FILETIME> *>>,0>>::erase(
    this,
    &v9,
    **this,
    (__int64 *)*this);
  operator delete(*this);
}

//----- (000000018004F3BC) ----------------------------------------------------
void __fastcall EventTrapMap::~EventTrapMap(EventTrapMap *this)
{
  struct _RTL_CRITICAL_SECTION *v2; // rbx
  EventTrap **v3; // rdi
  __int64 v4; // rbp
  EVT_HANDLE **v5; // r14
  __int64 v6; // r15

  v2 = (struct _RTL_CRITICAL_SECTION *)((char *)this + 8);
  *(_QWORD *)this = &EventTrapMap::`vftable';
  EnterCriticalSection((LPCRITICAL_SECTION)((char *)this + 8));
  v3 = (EventTrap **)((char *)this + 48);
  v4 = 255LL;
  v5 = (EVT_HANDLE **)((char *)this + 48);
  v6 = 255LL;
  do
  {
    if ( *v5 )
      EvtClose(**v5);
    ++v5;
    --v6;
  }
  while ( v6 );
  do
  {
    if ( *v3 )
    {
      EventTrap::`scalar deleting destructor'(*v3);
      *v3 = 0LL;
    }
    ++v3;
    --v4;
  }
  while ( v4 );
  if ( *((_QWORD *)this + 261) )
  {
    EtwEventUnregister();
    *((_QWORD *)this + 261) = 0LL;
  }
  LeaveCriticalSection(v2);
  DeleteCriticalSection(v2);
}
// 180070438: using guessed type void *EventTrapMap::`vftable';
// 180074770: using guessed type __int64 EtwEventUnregister(void);

//----- (000000018004F49C) ----------------------------------------------------
EventTrap *__fastcall EventTrap::`scalar deleting destructor'(EventTrap *this)
{
  void (__fastcall ***v2)(_QWORD, __int64); // rcx
  void *v3; // rdi

  v2 = (void (__fastcall ***)(_QWORD, __int64))*((_QWORD *)this + 6);
  if ( v2 )
    (**v2)(v2, 1LL);
  v3 = (void *)*((_QWORD *)this + 7);
  if ( v3 )
  {
    Aggregator::~Aggregator(*((__int64 ****)this + 7));
    operator delete(v3);
  }
  AutoEvtHandle::Close((void **)this + 9);
  AutoEvtHandle::Close((void **)this + 8);
  wmi::AutoRef<JobBucket>::Release((wmi::RefBase **)this + 5);
  _bstr_t::_Free((EventTrap *)((char *)this + 24));
  operator delete(this);
  return this;
}

//----- (000000018004F520) ----------------------------------------------------
signed int __fastcall EventTrapMap::FormatEvtVariant(char *a1, LPCCH *a2)
{
  __int64 *v3; // rdi
  int v4; // ebx
  unsigned __int64 cchWideChar; // r15
  unsigned int v6; // eax
  unsigned int v7; // eax
  unsigned int v8; // eax
  unsigned int v9; // eax
  unsigned int v10; // eax
  __int64 v11; // r8
  __int64 v12; // r8
  int v13; // eax
  int v14; // eax
  const unsigned __int16 *v15; // rdx
  __int64 v16; // rsi
  unsigned int v17; // eax
  unsigned int v18; // eax
  unsigned int v19; // eax
  double v20; // xmm2_8
  unsigned int v21; // eax
  unsigned int v22; // eax
  unsigned int v23; // eax
  unsigned int v24; // eax
  unsigned int v25; // eax
  unsigned int v26; // eax
  unsigned int v27; // eax
  unsigned int v28; // eax
  __int64 v29; // rsi
  unsigned __int16 *v30; // r8
  int wMilliseconds; // eax
  int wSecond; // ecx
  int wMinute; // edx
  int wHour; // r10d
  int wDay; // r11d
  __int64 wMonth; // r9
  __int64 wYear; // r8
  signed int result; // eax
  __int64 v39; // rsi
  _QWORD *v40; // rcx
  __int64 v41; // rdx
  __int64 v42; // rsi
  __int64 v43; // rax
  WCHAR *lpWideCharStr; // r12
  unsigned int j; // r13d
  char *v46; // r8
  signed int v47; // eax
  unsigned __int64 v48; // rdx
  WCHAR *v49; // rax
  unsigned __int64 v50; // rcx
  unsigned __int64 v51; // r8
  char *v52; // rdx
  __int64 v53; // r9
  signed __int64 v54; // rcx
  __int16 v55; // ax
  char *v56; // rax
  unsigned int v57; // r12d
  unsigned int i; // r13d
  const CHAR *v59; // r8
  signed int v60; // eax
  unsigned __int64 v61; // rdx
  WCHAR *v62; // rax
  unsigned __int64 v63; // rcx
  unsigned __int64 v64; // r8
  char *v65; // rdx
  __int64 v66; // r9
  signed __int64 v67; // rcx
  __int16 v68; // ax
  char *v69; // rax
  unsigned __int16 v70[2]; // [rsp+88h] [rbp-58h] BYREF
  int v71; // [rsp+8Ch] [rbp-54h]
  RPC_WSTR StringSid[2]; // [rsp+90h] [rbp-50h] BYREF
  struct _SYSTEMTIME SystemTime; // [rsp+A0h] [rbp-40h] BYREF

  StringSid[1] = (LPWSTR)-2LL;
  v3 = (__int64 *)a1;
  v4 = 0;
  v71 = 0;
  cchWideChar = 0LL;
  v6 = *((_DWORD *)a2 + 3);
  if ( v6 > 0x81 )
  {
    if ( v6 != 130 )
      goto LABEL_24;
    std::vector<unsigned short>::resize(a1, 0LL);
    v70[0] = 0;
    std::vector<unsigned short>::push_back(v3, v70);
    v57 = 0;
    if ( !*((_DWORD *)a2 + 2) )
      goto LABEL_131;
    v42 = -1LL;
    do
      cchWideChar += MultiByteToWideChar(0, 0, *(LPCCH *)&(*a2)[8 * v57++], -1, 0LL, 0) + 1;
    while ( v57 < *((_DWORD *)a2 + 2) );
    if ( cchWideChar <= 2 )
      goto LABEL_131;
    lpWideCharStr = (WCHAR *)operator new(saturated_mul(cchWideChar, 2uLL));
    *lpWideCharStr = 0;
    for ( i = 0; i < *((_DWORD *)a2 + 2); ++i )
    {
      v59 = *(const CHAR **)&(*a2)[8 * i];
      if ( v59 )
      {
        MultiByteToWideChar(0, 0, v59, -1, lpWideCharStr, cchWideChar);
        if ( i < *((_DWORD *)a2 + 2) - 1 )
        {
          v60 = 0;
          if ( cchWideChar > 0x7FFFFFFF )
            v60 = -2147024809;
          if ( v60 < 0 )
            goto LABEL_118;
          v61 = cchWideChar;
          v62 = lpWideCharStr;
          do
          {
            if ( !*v62 )
              break;
            ++v62;
            --v61;
          }
          while ( v61 );
          v60 = v61 == 0 ? 0x80070057 : 0;
          if ( v61 )
            v63 = cchWideChar - v61;
          else
LABEL_118:
            v63 = 0LL;
          if ( v60 >= 0 )
          {
            v64 = cchWideChar - v63;
            v65 = (char *)&lpWideCharStr[v63];
            if ( cchWideChar != v63 )
            {
              v66 = 2147483646LL;
              v67 = (char *)L"," - v65;
              do
              {
                if ( !v66 )
                  break;
                v68 = *(_WORD *)&v65[v67];
                if ( !v68 )
                  break;
                *(_WORD *)v65 = v68;
                v65 += 2;
                --v66;
                --v64;
              }
              while ( v64 );
            }
            v69 = v65 - 2;
            if ( v64 )
              v69 = v65;
            *(_WORD *)v69 = 0;
          }
        }
      }
    }
    do
      ++v42;
    while ( lpWideCharStr[v42] );
LABEL_101:
    std::vector<unsigned short>::assign<unsigned short *>((_WORD **)v3, lpWideCharStr, (__int64)&lpWideCharStr[v42 + 1]);
    return v4;
  }
  if ( v6 == 129 )
  {
    std::vector<unsigned short>::resize(a1, 0LL);
    v70[0] = 0;
    std::vector<unsigned short>::push_back(v3, v70);
    if ( !*((_DWORD *)a2 + 2) )
      goto LABEL_131;
    v40 = *a2;
    v41 = *((unsigned int *)a2 + 2);
    v42 = -1LL;
    do
    {
      v43 = -1LL;
      do
        ++v43;
      while ( *(_WORD *)(*v40 + 2 * v43) );
      cchWideChar += v43 + 1;
      ++v40;
      --v41;
    }
    while ( v41 );
    if ( cchWideChar <= 2 )
      goto LABEL_131;
    lpWideCharStr = (WCHAR *)operator new(saturated_mul(cchWideChar, 2uLL));
    *lpWideCharStr = 0;
    for ( j = 0; j < *((_DWORD *)a2 + 2); ++j )
    {
      v46 = *(char **)&(*a2)[8 * j];
      if ( v46 )
      {
        StringCchCatW(lpWideCharStr, cchWideChar, v46);
        if ( j < *((_DWORD *)a2 + 2) - 1 )
        {
          v47 = 0;
          if ( cchWideChar > 0x7FFFFFFF )
            v47 = -2147024809;
          if ( v47 < 0 )
            goto LABEL_89;
          v48 = cchWideChar;
          v49 = lpWideCharStr;
          do
          {
            if ( !*v49 )
              break;
            ++v49;
            --v48;
          }
          while ( v48 );
          v47 = v48 == 0 ? 0x80070057 : 0;
          if ( v48 )
            v50 = cchWideChar - v48;
          else
LABEL_89:
            v50 = 0LL;
          if ( v47 >= 0 )
          {
            v51 = cchWideChar - v50;
            v52 = (char *)&lpWideCharStr[v50];
            if ( cchWideChar != v50 )
            {
              v53 = 2147483646LL;
              v54 = (char *)L"," - v52;
              do
              {
                if ( !v53 )
                  break;
                v55 = *(_WORD *)&v52[v54];
                if ( !v55 )
                  break;
                *(_WORD *)v52 = v55;
                v52 += 2;
                --v53;
                --v51;
              }
              while ( v51 );
            }
            v56 = v52 - 2;
            if ( v51 )
              v56 = v52;
            *(_WORD *)v56 = 0;
          }
        }
      }
    }
    do
      ++v42;
    while ( lpWideCharStr[v42] );
    goto LABEL_101;
  }
  if ( v6 <= 0xB )
  {
    if ( v6 != 11 )
    {
      if ( v6 > 6 )
      {
        v17 = v6 - 7;
        if ( !v17 )
        {
          v11 = *(unsigned int *)a2;
          goto LABEL_17;
        }
        v18 = v17 - 1;
        if ( !v18 )
        {
          v12 = *(unsigned int *)a2;
          goto LABEL_14;
        }
        v19 = v18 - 1;
        if ( !v19 )
        {
          v13 = EventTrapMap::StringPrintf(a1, L"%I64i", *a2);
          goto LABEL_15;
        }
        if ( v19 == 1 )
        {
          v13 = EventTrapMap::StringPrintf(a1, L"%I64u", *a2);
          goto LABEL_15;
        }
        goto LABEL_24;
      }
      if ( v6 == 6 )
      {
        v12 = *(unsigned __int16 *)a2;
        goto LABEL_14;
      }
      v7 = v6 - 1;
      if ( v7 )
      {
        v8 = v7 - 1;
        if ( v8 )
        {
          v9 = v8 - 1;
          if ( !v9 )
          {
            v11 = (unsigned int)*(char *)a2;
            goto LABEL_17;
          }
          v10 = v9 - 1;
          if ( v10 )
          {
            if ( v10 == 1 )
            {
              v11 = (unsigned int)*(__int16 *)a2;
LABEL_17:
              v13 = EventTrapMap::StringPrintf(a1, L"%i", v11);
              goto LABEL_15;
            }
            goto LABEL_24;
          }
          v12 = *(unsigned __int8 *)a2;
LABEL_14:
          v13 = EventTrapMap::StringPrintf(a1, L"%u", v12);
LABEL_15:
          v4 = v13;
          v71 = v13;
          return v4;
        }
        v14 = MultiByteToWideChar(0, 0, *a2, -1, 0LL, 0);
        a1 = (char *)v3;
        if ( v14 )
        {
          std::vector<unsigned short>::resize((char *)v3, v14);
          MultiByteToWideChar(0, 0, *a2, -1, (LPWSTR)*v3, (v3[1] - *v3) >> 1);
          return v4;
        }
LABEL_24:
        std::vector<unsigned short>::resize(a1, 0LL);
LABEL_131:
        v70[0] = 0;
        std::vector<unsigned short>::push_back(v3, v70);
        return v4;
      }
      v15 = (const unsigned __int16 *)*a2;
      if ( !v15 )
        goto LABEL_24;
      v16 = -1LL;
      do
        ++v16;
      while ( v15[v16] );
LABEL_70:
      std::vector<unsigned short>::assign<unsigned short *>((_WORD **)a1, v15, (__int64)&v15[v16 + 1]);
      return v4;
    }
    v20 = *(float *)a2;
LABEL_36:
    v13 = EventTrapMap::StringPrintf(a1, L"%f", v20);
    goto LABEL_15;
  }
  v21 = v6 - 12;
  if ( !v21 )
  {
    v20 = *(double *)a2;
    goto LABEL_36;
  }
  v22 = v21 - 1;
  if ( !v22 )
  {
    v15 = L"true";
    if ( !*(_DWORD *)a2 )
      v15 = L"false";
    v16 = -1LL;
    do
      ++v16;
    while ( v15[v16] );
    goto LABEL_70;
  }
  v23 = v22 - 2;
  if ( !v23 )
  {
    StringSid[0] = 0LL;
    result = UuidToStringW((const UUID *)*a2, StringSid);
    if ( result )
      return result;
    v39 = -1LL;
    do
      ++v39;
    while ( StringSid[0][v39] );
    std::vector<unsigned short>::assign<unsigned short *>((_WORD **)v3, StringSid[0], (__int64)&StringSid[0][v39 + 1]);
    RpcStringFreeW(StringSid);
    return v4;
  }
  v24 = v23 - 1;
  if ( !v24 )
  {
    v13 = EventTrapMap::StringPrintf(a1, L"%u", *a2);
    goto LABEL_15;
  }
  v25 = v24 - 1;
  if ( v25 )
  {
    v26 = v25 - 1;
    if ( v26 )
    {
      v27 = v26 - 1;
      if ( !v27 )
      {
        if ( *a2 )
        {
          StringSid[0] = 0LL;
          if ( ConvertSidToStringSidW((PSID)*a2, StringSid) )
          {
            v29 = -1LL;
            do
              ++v29;
            while ( StringSid[0][v29] );
            std::vector<unsigned short>::assign<unsigned short *>(
              (_WORD **)v3,
              StringSid[0],
              (__int64)&StringSid[0][v29 + 1]);
            LocalFree(StringSid[0]);
          }
        }
        return v4;
      }
      v28 = v27 - 1;
      if ( !v28 )
      {
        v13 = EventTrapMap::StringPrintf(a1, L"0x%X", *(unsigned int *)a2);
        goto LABEL_15;
      }
      if ( v28 == 1 )
      {
        v13 = EventTrapMap::StringPrintf(a1, L"0x%I64X", *a2);
        goto LABEL_15;
      }
      goto LABEL_24;
    }
    v30 = (unsigned __int16 *)*a2;
    if ( !*a2 )
      return v4;
    wMilliseconds = v30[7];
    wSecond = v30[6];
    wMinute = v30[5];
    wHour = v30[4];
    wDay = v30[3];
    wMonth = v30[1];
    wYear = *v30;
LABEL_60:
    v13 = EventTrapMap::StringPrintf(
            (char *)v3,
            L"%4.4hd-%2.2hd-%2.2hdT%2.2hd:%2.2hd:%2.2hd.%3.3hdZ",
            wYear,
            wMonth,
            wDay,
            wHour,
            wMinute,
            wSecond,
            wMilliseconds);
    goto LABEL_15;
  }
  if ( FileTimeToSystemTime((const FILETIME *)a2, &SystemTime) )
  {
    wMilliseconds = SystemTime.wMilliseconds;
    wSecond = SystemTime.wSecond;
    wMinute = SystemTime.wMinute;
    wHour = SystemTime.wHour;
    wDay = SystemTime.wDay;
    wMonth = SystemTime.wMonth;
    wYear = SystemTime.wYear;
    goto LABEL_60;
  }
  result = GetLastError();
  if ( result > 0 )
    return (unsigned __int16)result | 0x80070000;
  return result;
}
// 18004F520: could not find valid save-restore pair for rbp
// 18004F520: too many cbuild loops
// 18007FDD8: using guessed type wchar_t asc_18007FDD8[2];
// 18007FDDC: using guessed type wchar_t aU[3];
// 18007FDE8: using guessed type wchar_t aI64u[6];
// 18007FDF4: using guessed type wchar_t aI[3];
// 18007FE00: using guessed type wchar_t a0xX[5];
// 18007FE10: using guessed type wchar_t a0xI64x[8];
// 18007FE20: using guessed type wchar_t aI64i[6];
// 18007FE2C: using guessed type wchar_t asc_18007FE2C[3];
// 18007FE40: using guessed type wchar_t a44hd22hd22hdt2[50];
// 18004F520: using guessed type RPC_WSTR StringSid[2];

//----- (000000018004FCA8) ----------------------------------------------------
__int64 __fastcall StringCchVPrintfExW(
        STRSAFE_LPWSTR pszDest,
        size_t a2,
        unsigned __int16 **a3,
        unsigned __int64 *a4,
        unsigned int a5,
        const unsigned __int16 *pszFormat,
        va_list argList)
{
  unsigned __int16 *v7; // rbx
  HRESULT v8; // r9d
  size_t pcchNewDestLength; // [rsp+58h] [rbp+20h] BYREF

  pcchNewDestLength = (size_t)a4;
  v7 = pszDest;
  v8 = 0;
  if ( a2 - 1 > 0x7FFFFFFE )
    v8 = -2147024809;
  if ( v8 < 0 )
  {
    if ( a2 )
      *pszDest = 0;
  }
  else
  {
    v8 = 0;
    if ( a2 )
    {
      pcchNewDestLength = 0LL;
      v8 = StringVPrintfWorkerW_1(pszDest, a2, &pcchNewDestLength, pszFormat, argList);
      v7 += pcchNewDestLength;
      if ( (int)(v8 + 0x80000000) >= 0 && v8 != -2147024774 )
        return (unsigned int)v8;
    }
    else if ( *pszFormat )
    {
      if ( !pszDest )
        return (unsigned int)-2147024809;
      v8 = -2147024774;
    }
    if ( a3 )
      *a3 = v7;
  }
  return (unsigned int)v8;
}

//----- (000000018004FD74) ----------------------------------------------------
__int64 EventTrapMap::StringPrintf(char *a1, const unsigned __int16 *a2, ...)
{
  va_list va; // [rsp+40h] [rbp+18h] BYREF

  va_start(va, a2);
  return EventTrapMap::StringVPrintf(a1, a2, va);
}

//----- (000000018004FD9C) ----------------------------------------------------
__int64 __fastcall EventTrapMap::StringVPrintf(char *a1, const unsigned __int16 *a2, va_list a3)
{
  __int64 v5; // rdx
  char *v6; // rbx
  unsigned __int64 v7; // rdx
  unsigned __int64 v8; // rdi
  unsigned __int64 *v9; // r9
  int v10; // esi
  unsigned int v12; // [rsp+20h] [rbp-38h]
  unsigned __int16 *v13; // [rsp+60h] [rbp+8h] BYREF

  v5 = -1LL;
  v6 = a1;
  do
    ++v5;
  while ( a2[v5] );
  v7 = v5 + 20;
  while ( 1 )
  {
    std::vector<unsigned short>::resize(a1, v7);
    v10 = StringCchVPrintfExW(
            *(STRSAFE_LPWSTR *)v6,
            (__int64)(*((_QWORD *)v6 + 1) - *(_QWORD *)v6) >> 1,
            &v13,
            v9,
            v12,
            a2,
            a3);
    if ( v10 != -2147024774 )
      break;
    v8 = (__int64)(*((_QWORD *)v6 + 1) - *(_QWORD *)v6) >> 1;
    if ( v8 >= 0x7FFFFFFF )
      break;
    std::vector<unsigned short>::resize(v6, 0LL);
    v7 = 0x7FFFFFFFLL;
    if ( v8 < 0x3FFFFFFF )
      v7 = 2 * v8;
    a1 = v6;
  }
  if ( v10 < 0 )
  {
    std::vector<unsigned short>::resize(v6, 1uLL);
    **(_WORD **)v6 = 0;
  }
  else
  {
    std::vector<unsigned short>::resize(v6, (((__int64)v13 - *(_QWORD *)v6) >> 1) + 1);
  }
  return (unsigned int)v10;
}
// 18004FE28: variable 'v9' is possibly undefined
// 18004FE28: variable 'v12' is possibly undefined

//----- (000000018004FE88) ----------------------------------------------------
HRESULT __stdcall StringVPrintfWorkerW_1(
        STRSAFE_LPWSTR pszDest,
        size_t cchDest,
        size_t *pcchNewDestLength,
        STRSAFE_LPCWSTR pszFormat,
        va_list argList)
{
  size_t v5; // rbx
  HRESULT v8; // ebp
  int v9; // eax

  v5 = cchDest - 1;
  v8 = 0;
  v9 = _vsnwprintf(pszDest, cchDest - 1, pszFormat, argList);
  if ( v9 < 0 || v9 > v5 )
  {
    v8 = -2147024774;
  }
  else if ( v9 != v5 )
  {
    v5 = v9;
    goto LABEL_7;
  }
  pszDest[v5] = 0;
LABEL_7:
  if ( pcchNewDestLength )
    *pcchNewDestLength = v5;
  return v8;
}

//----- (000000018004FF14) ----------------------------------------------------
__int64 __fastcall std::_Tree_val<std::_Tree_simple_types<std::pair<_bstr_t const,_bstr_t>>>::_Max(__int64 a1)
{
  __int64 i; // rax

  for ( i = *(_QWORD *)(a1 + 16); !*(_BYTE *)(i + 25); i = *(_QWORD *)(i + 16) )
    a1 = i;
  return a1;
}

//----- (000000018004FF34) ----------------------------------------------------
char *__fastcall std::vector<unsigned short>::_Reallocate(__int64 a1, unsigned __int64 a2)
{
  char *v4; // rbx
  __int64 v5; // r14
  char *result; // rax

  v4 = 0LL;
  if ( a2 )
  {
    if ( a2 > 0x7FFFFFFFFFFFFFFFLL || (v4 = (char *)operator new(2 * a2)) == 0LL )
      std::_Xbad_alloc();
  }
  memmove_0(v4, *(const void **)a1, 2 * ((__int64)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 1));
  v5 = (__int64)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 1;
  if ( *(_QWORD *)a1 )
    operator delete(*(void **)a1);
  *(_QWORD *)(a1 + 16) = &v4[2 * a2];
  result = &v4[2 * v5];
  *(_QWORD *)(a1 + 8) = result;
  *(_QWORD *)a1 = v4;
  return result;
}

//----- (0000000180050010) ----------------------------------------------------
char *__fastcall std::vector<void *>::_Reallocate(__int64 a1, unsigned __int64 a2)
{
  char *v4; // rbx
  __int64 v5; // r14
  char *result; // rax

  v4 = 0LL;
  if ( a2 )
  {
    if ( a2 > 0x1FFFFFFFFFFFFFFFLL || (v4 = (char *)operator new(8 * a2)) == 0LL )
      std::_Xbad_alloc();
  }
  memmove_0(v4, *(const void **)a1, (*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) & 0xFFFFFFFFFFFFFFF8uLL);
  v5 = (__int64)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3;
  if ( *(_QWORD *)a1 )
    operator delete(*(void **)a1);
  *(_QWORD *)(a1 + 16) = &v4[8 * a2];
  result = &v4[8 * v5];
  *(_QWORD *)(a1 + 8) = result;
  *(_QWORD *)a1 = v4;
  return result;
}

//----- (00000001800500EC) ----------------------------------------------------
unsigned __int64 __fastcall std::vector<unsigned short>::_Reserve(_QWORD *a1, unsigned __int64 a2)
{
  __int64 v3; // r8
  unsigned __int64 result; // rax
  __int64 v5; // r8
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // r10
  unsigned __int64 v8; // rcx

  v3 = a1[1];
  result = (a1[2] - v3) >> 1;
  if ( result < a2 )
  {
    v5 = (v3 - *a1) >> 1;
    if ( 0x7FFFFFFFFFFFFFFFLL - v5 < a2 )
      std::_Xlength_error("vector<T> too long");
    v6 = v5 + a2;
    v7 = (__int64)(a1[2] - *a1) >> 1;
    v8 = 0LL;
    if ( 0x7FFFFFFFFFFFFFFFLL - (v7 >> 1) >= v7 )
      v8 = v7 + (v7 >> 1);
    if ( v8 >= v6 )
      v6 = v8;
    return (unsigned __int64)std::vector<unsigned short>::_Reallocate((__int64)a1, v6);
  }
  return result;
}

//----- (000000018005016C) ----------------------------------------------------
__int64 __fastcall std::vector<_DAB_REGISTRATION_TRIGGER_PARAMS *>::_Reserve(_QWORD *a1)
{
  __int64 v2; // rdx
  __int64 result; // rax
  __int64 v4; // rdx
  unsigned __int64 v5; // rdx
  unsigned __int64 v6; // r9
  unsigned __int64 v7; // rcx

  v2 = a1[1];
  result = (a1[2] - v2) >> 3;
  if ( !result )
  {
    v4 = (v2 - *a1) >> 3;
    if ( v4 == 0x1FFFFFFFFFFFFFFFLL )
      std::_Xlength_error("vector<T> too long");
    v5 = v4 + 1;
    v6 = (__int64)(a1[2] - *a1) >> 3;
    v7 = 0LL;
    if ( 0x1FFFFFFFFFFFFFFFLL - (v6 >> 1) >= v6 )
      v7 = v6 + (v6 >> 1);
    if ( v7 >= v5 )
      v5 = v7;
    return (__int64)std::vector<void *>::_Reallocate((__int64)a1, v5);
  }
  return result;
}

//----- (00000001800501F0) ----------------------------------------------------
__int64 __fastcall std::_Tree<std::_Tmap_traits<_bstr_t,std::list<_FILETIME> *,Aggregator::less,std::allocator<std::pair<_bstr_t const,std::list<_FILETIME> *>>,0>>::clear(
        _QWORD *a1)
{
  __int64 result; // rax

  std::_Tree<std::_Tmap_traits<_bstr_t,std::list<_FILETIME> *,Aggregator::less,std::allocator<std::pair<_bstr_t const,std::list<_FILETIME> *>>,0>>::_Erase(
    (__int64)a1,
    *(__int64 **)(*a1 + 8LL));
  *(_QWORD *)(*a1 + 8LL) = *a1;
  *(_QWORD *)*a1 = *a1;
  result = *a1;
  *(_QWORD *)(*a1 + 16LL) = *a1;
  a1[1] = 0LL;
  return result;
}

//----- (000000018005022C) ----------------------------------------------------
__int64 **__fastcall std::_Tree<std::_Tmap_traits<_bstr_t,std::list<_FILETIME> *,Aggregator::less,std::allocator<std::pair<_bstr_t const,std::list<_FILETIME> *>>,0>>::erase(
        __int64 ***a1,
        __int64 **a2,
        __int64 *a3,
        __int64 *a4)
{
  __int64 *v5; // rbx
  __int64 *v8; // r8
  __int64 v9; // rcx
  __int64 *i; // rax
  __int64 *v12; // [rsp+30h] [rbp+8h] BYREF

  v5 = a3;
  if ( a3 == **a1 && a4 == (__int64 *)*a1 )
  {
    std::_Tree<std::_Tmap_traits<_bstr_t,std::list<_FILETIME> *,Aggregator::less,std::allocator<std::pair<_bstr_t const,std::list<_FILETIME> *>>,0>>::clear(a1);
    *a2 = **a1;
  }
  else
  {
    while ( v5 != a4 )
    {
      v8 = v5;
      if ( !*((_BYTE *)v5 + 25) )
      {
        v9 = v5[2];
        if ( *(_BYTE *)(v9 + 25) )
        {
          for ( i = (__int64 *)v5[1]; !*((_BYTE *)i + 25) && v5 == (__int64 *)i[2]; i = (__int64 *)i[1] )
            v5 = i;
        }
        else
        {
          i = std::_Tree_val<std::_Tree_simple_types<std::pair<_bstr_t const,std::list<_FILETIME> *>>>::_Min((_QWORD *)v9);
        }
        v5 = i;
      }
      std::_Tree<std::_Tmap_traits<_bstr_t,std::list<_FILETIME> *,Aggregator::less,std::allocator<std::pair<_bstr_t const,std::list<_FILETIME> *>>,0>>::erase(
        a1,
        &v12,
        v8);
    }
    *a2 = v5;
  }
  return a2;
}
// 1800502AD: variable 'v8' is possibly undefined

//----- (00000001800502D8) ----------------------------------------------------
__int64 **__fastcall std::_Tree<std::_Tmap_traits<_bstr_t,std::list<_FILETIME> *,Aggregator::less,std::allocator<std::pair<_bstr_t const,std::list<_FILETIME> *>>,0>>::erase(
        _QWORD *a1,
        __int64 **a2,
        __int64 *a3)
{
  __int64 *v5; // rbp
  _QWORD *v6; // r11
  __int64 *v7; // rdi
  __int64 v8; // r9
  __int64 *i; // rbx
  __int64 v10; // r10
  _QWORD *v11; // r8
  _QWORD *v12; // rax
  _QWORD *v13; // rax
  __int64 v14; // rcx
  __int64 v15; // rdx
  char v16; // cl
  __int64 **v17; // rax
  __int64 v18; // r11
  _BYTE *v19; // rdx
  __int64 v20; // rcx
  __int64 v21; // rax
  __int64 **result; // rax

  v5 = a3;
  if ( *((_BYTE *)a3 + 25) )
    std::_Xout_of_range("invalid map/set<T> iterator");
  v6 = a3 + 2;
  v7 = a3;
  v8 = a3[2];
  if ( *(_BYTE *)(v8 + 25) )
  {
    for ( i = (__int64 *)a3[1]; !*((_BYTE *)i + 25) && a3 == (__int64 *)i[2]; i = (__int64 *)i[1] )
      a3 = i;
  }
  else
  {
    i = std::_Tree_val<std::_Tree_simple_types<std::pair<_bstr_t const,std::list<_FILETIME> *>>>::_Min((_QWORD *)a3[2]);
  }
  if ( *(_BYTE *)(*v7 + 25) )
    goto LABEL_13;
  if ( *(_BYTE *)(v8 + 25) )
  {
    v8 = *v7;
LABEL_13:
    v10 = v7[1];
    if ( !*(_BYTE *)(v8 + 25) )
      *(_QWORD *)(v8 + 8) = v10;
    if ( *(__int64 **)(*a1 + 8LL) == v7 )
    {
      *(_QWORD *)(*a1 + 8LL) = v8;
    }
    else if ( *(__int64 **)v10 == v7 )
    {
      *(_QWORD *)v10 = v8;
    }
    else
    {
      *(_QWORD *)(v10 + 16) = v8;
    }
    v11 = (_QWORD *)*a1;
    v12 = (_QWORD *)*a1;
    if ( *(__int64 **)*a1 == v7 )
    {
      if ( *(_BYTE *)(v8 + 25) )
        v13 = (_QWORD *)v10;
      else
        v13 = std::_Tree_val<std::_Tree_simple_types<std::pair<_bstr_t const,std::list<_FILETIME> *>>>::_Min((_QWORD *)v8);
      *v11 = v13;
      v11 = (_QWORD *)*a1;
      v12 = (_QWORD *)*a1;
    }
    if ( (__int64 *)v12[2] == v7 )
    {
      if ( *(_BYTE *)(v8 + 25) )
      {
        v14 = v10;
      }
      else
      {
        v15 = *(_QWORD *)(v8 + 16);
        v14 = v8;
        if ( !*(_BYTE *)(v15 + 25) )
        {
          do
          {
            v14 = v15;
            v15 = *(_QWORD *)(v15 + 16);
          }
          while ( !*(_BYTE *)(v15 + 25) );
          v12 = v11;
        }
      }
      v12[2] = v14;
    }
    v16 = *((_BYTE *)v5 + 24);
    goto LABEL_44;
  }
  v8 = i[2];
  if ( i == v7 )
    goto LABEL_13;
  *(_QWORD *)(*v7 + 8) = i;
  *i = *v7;
  if ( i == (__int64 *)*v6 )
  {
    v10 = (__int64)i;
  }
  else
  {
    v10 = i[1];
    if ( !*(_BYTE *)(v8 + 25) )
      *(_QWORD *)(v8 + 8) = v10;
    *(_QWORD *)v10 = v8;
    i[2] = *v6;
    *(_QWORD *)(*v6 + 8LL) = i;
  }
  if ( *(__int64 **)(*a1 + 8LL) == v7 )
  {
    *(_QWORD *)(*a1 + 8LL) = i;
  }
  else
  {
    v17 = (__int64 **)v7[1];
    if ( *v17 == v7 )
      *v17 = i;
    else
      v17[2] = i;
  }
  v16 = *((_BYTE *)i + 24);
  i[1] = v7[1];
  *((_BYTE *)i + 24) = *((_BYTE *)v7 + 24);
  *((_BYTE *)v7 + 24) = v16;
LABEL_44:
  if ( v16 == 1 )
  {
    if ( v8 != *(_QWORD *)(*a1 + 8LL) )
    {
      do
      {
        v18 = v10;
        if ( *(_BYTE *)(v8 + 24) != 1 )
          break;
        v19 = *(_BYTE **)v10;
        if ( v8 == *(_QWORD *)v10 )
        {
          v19 = *(_BYTE **)(v10 + 16);
          if ( !v19[24] )
          {
            v19[24] = 1;
            *(_BYTE *)(v10 + 24) = 0;
            std::_Tree<std::_Tmap_traits<User,LogonJob *,User::less,std::allocator<std::pair<User const,LogonJob *>>,1>>::_Lrotate(
              (__int64)a1,
              v10);
            v19 = *(_BYTE **)(v10 + 16);
          }
          if ( v19[25] )
            goto LABEL_62;
          if ( *(_BYTE *)(*(_QWORD *)v19 + 24LL) != 1 || *(_BYTE *)(*((_QWORD *)v19 + 2) + 24LL) != 1 )
          {
            if ( *(_BYTE *)(*((_QWORD *)v19 + 2) + 24LL) == 1 )
            {
              *(_BYTE *)(*(_QWORD *)v19 + 24LL) = 1;
              v19[24] = 0;
              std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::_Rrotate(
                (__int64)a1,
                v19);
              v19 = *(_BYTE **)(v10 + 16);
            }
            v19[24] = *(_BYTE *)(v10 + 24);
            *(_BYTE *)(v10 + 24) = 1;
            *(_BYTE *)(*((_QWORD *)v19 + 2) + 24LL) = 1;
            std::_Tree<std::_Tmap_traits<User,LogonJob *,User::less,std::allocator<std::pair<User const,LogonJob *>>,1>>::_Lrotate(
              (__int64)a1,
              v10);
            break;
          }
        }
        else
        {
          if ( !v19[24] )
          {
            v19[24] = 1;
            *(_BYTE *)(v10 + 24) = 0;
            std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::_Rrotate(
              (__int64)a1,
              (_QWORD *)v10);
            v19 = *(_BYTE **)v10;
          }
          if ( v19[25] )
            goto LABEL_62;
          v20 = *((_QWORD *)v19 + 2);
          if ( *(_BYTE *)(v20 + 24) != 1 || *(_BYTE *)(*(_QWORD *)v19 + 24LL) != 1 )
          {
            if ( *(_BYTE *)(*(_QWORD *)v19 + 24LL) == 1 )
            {
              *(_BYTE *)(v20 + 24) = 1;
              v19[24] = 0;
              std::_Tree<std::_Tmap_traits<User,LogonJob *,User::less,std::allocator<std::pair<User const,LogonJob *>>,1>>::_Lrotate(
                (__int64)a1,
                (__int64)v19);
              v19 = *(_BYTE **)v10;
            }
            v19[24] = *(_BYTE *)(v10 + 24);
            *(_BYTE *)(v10 + 24) = 1;
            *(_BYTE *)(*(_QWORD *)v19 + 24LL) = 1;
            std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::_Rrotate(
              (__int64)a1,
              (_QWORD *)v10);
            break;
          }
        }
        v19[24] = 0;
LABEL_62:
        v8 = v18;
        v10 = *(_QWORD *)(v10 + 8);
      }
      while ( v18 != *(_QWORD *)(*a1 + 8LL) );
    }
    *(_BYTE *)(v8 + 24) = 1;
  }
  _bstr_t::_Free((_bstr_t *)(v7 + 4));
  operator delete(v7);
  v21 = a1[1];
  if ( v21 )
    a1[1] = v21 - 1;
  result = a2;
  *a2 = i;
  return result;
}
// 18005034E: variable 'v8' is possibly undefined
// 1800503AF: variable 'v11' is possibly undefined
// 1800503C4: variable 'v10' is possibly undefined
// 1800503F9: variable 'v6' is possibly undefined
// 180050540: variable 'v18' is possibly undefined

//----- (00000001800505D8) ----------------------------------------------------
char **__fastcall std::vector<unsigned short>::erase(_QWORD *a1, char **a2, char *a3, char *a4)
{
  size_t v7; // rdi
  char **result; // rax

  if ( a3 == (char *)*a1 && a4 == (char *)a1[1] )
  {
    a1[1] = *a1;
  }
  else if ( a3 != a4 )
  {
    v7 = 2 * ((__int64)(a1[1] - (_QWORD)a4) >> 1);
    memmove_0(a3, a4, v7);
    a1[1] = &a3[v7];
  }
  result = a2;
  *a2 = a3;
  return result;
}

//----- (0000000180050658) ----------------------------------------------------
__int64 __fastcall std::vector<unsigned short>::push_back(__int64 *a1, unsigned __int16 *a2)
{
  unsigned __int16 *v4; // rcx
  __int64 v6; // rax
  __int64 v7; // rdi
  __int64 result; // rax

  v4 = (unsigned __int16 *)a1[1];
  if ( a2 < v4 && *a1 <= (unsigned __int64)a2 )
  {
    v6 = *a1;
    v7 = ((__int64)a2 - *a1) >> 1;
    if ( v4 == (unsigned __int16 *)a1[2] )
    {
      std::vector<unsigned short>::_Reserve(a1, 1uLL);
      v6 = *a1;
      v4 = (unsigned __int16 *)a1[1];
    }
    result = *(unsigned __int16 *)(v6 + 2 * v7);
  }
  else
  {
    if ( v4 == (unsigned __int16 *)a1[2] )
    {
      std::vector<unsigned short>::_Reserve(a1, 1uLL);
      v4 = (unsigned __int16 *)a1[1];
    }
    result = *a2;
  }
  *v4 = result;
  a1[1] += 2LL;
  return result;
}

//----- (00000001800506D8) ----------------------------------------------------
unsigned __int64 __fastcall std::vector<unsigned short>::resize(char *a1, unsigned __int64 a2)
{
  char *v4; // r9
  __int64 v5; // rcx
  unsigned __int64 result; // rax
  _WORD *v7; // rdi
  __int64 v8; // rax
  unsigned __int64 v9; // rcx
  char *v10; // [rsp+40h] [rbp+8h] BYREF

  v10 = a1;
  v4 = (char *)*((_QWORD *)a1 + 1);
  v5 = *(_QWORD *)a1;
  result = (__int64)&v4[-v5] >> 1;
  if ( a2 < result )
    return (unsigned __int64)std::vector<unsigned short>::erase(a1, &v10, (char *)(v5 + 2 * a2), v4);
  if ( a2 > result )
  {
    std::vector<unsigned short>::_Reserve(a1, a2 - result);
    v7 = (_WORD *)*((_QWORD *)a1 + 1);
    v8 = ((__int64)v7 - *(_QWORD *)a1) >> 1;
    v9 = a2 - v8;
    if ( a2 != v8 )
    {
      while ( v9 )
      {
        *v7++ = 0;
        --v9;
      }
    }
    result = *((_QWORD *)a1 + 1) + 2 * (a2 - ((__int64)(*((_QWORD *)a1 + 1) - *(_QWORD *)a1) >> 1));
    *((_QWORD *)a1 + 1) = result;
  }
  return result;
}

//----- (000000018005079C) ----------------------------------------------------
__int64 __fastcall WPP_SF_SSD(__int64 a1, unsigned __int16 a2, __int64 a3, const wchar_t *a4, __int64 a5)
{
  __int64 v5; // r10
  __int64 v6; // rax
  bool v7; // zf

  v5 = -1LL;
  if ( a5 )
  {
    v6 = -1LL;
    do
      ++v6;
    while ( *(_WORD *)(a5 + 2 * v6) );
  }
  v7 = a4 == 0LL;
  if ( a4 )
  {
    do
      ++v5;
    while ( a4[v5] );
    v7 = a4 == 0LL;
  }
  if ( v7 )
    a4 = L"NULL";
  return EtwTraceMessage(a1, 43LL, a3, a2, a4);
}
// 1800747B0: using guessed type __int64 __fastcall EtwTraceMessage(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 18007F5B8: using guessed type wchar_t aNull_1[5];

//----- (0000000180050864) ----------------------------------------------------
__int64 WPP_SF_qS(__int64 a1, unsigned __int16 a2, __int64 a3, ...)
{
  __int64 v3; // rax
  __int64 v5; // [rsp+78h] [rbp+20h] BYREF
  va_list va; // [rsp+78h] [rbp+20h]
  __int64 v7; // [rsp+80h] [rbp+28h]
  va_list va1; // [rsp+88h] [rbp+30h] BYREF

  va_start(va1, a3);
  va_start(va, a3);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  if ( v7 )
  {
    v3 = -1LL;
    do
      ++v3;
    while ( *(_WORD *)(v7 + 2 * v3) );
  }
  return EtwTraceMessage(a1, 43LL, a3, a2, (__int64 *)va);
}
// 1800747B0: using guessed type __int64 __fastcall EtwTraceMessage(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001800508EC) ----------------------------------------------------
void __fastcall Idolater::IdleStart(Idolater *this, struct _FILETIME *a2)
{
  char v2; // di
  Idolater *v3; // rcx
  PseudoEventTrap *v4; // rcx
  __int128 v5; // [rsp+28h] [rbp-18h] BYREF
  __int32 v6; // [rsp+70h] [rbp+30h] BYREF

  v6 = 0;
  _InterlockedExchange(&v6, 0);
  _InterlockedIncrement(&ShutdownMgr::s_sync);
  _InterlockedExchange(&v6, _InterlockedCompareExchange(&dword_1800B0A14, 0, 0) != 0);
  if ( _InterlockedCompareExchange(&v6, 0, 0) )
  {
    v2 = 0;
    EnterCriticalSection(&stru_1800B0CA0);
    if ( !byte_1800B0C70 )
    {
      byte_1800B0C70 = 1;
      v2 = 1;
      TSTime::TSTime((TSTime *)&v5);
      g_Idolater = v5;
    }
    LeaveCriticalSection(&stru_1800B0CA0);
    if ( v2 )
    {
      Idolater::SendUbpmIdleEvent(v3, 1);
      if ( g_pPseudoEventTrap )
        PseudoEventTrap::IdleStarted(v4);
    }
  }
  _InterlockedExchange(&v6, 0);
  if ( _InterlockedExchangeAdd(&ShutdownMgr::s_sync, 0xFFFFFFFF) == 1 )
    SetEvent((HANDLE)_InterlockedCompareExchange64((volatile signed __int64 *)&ShutdownMgr::s_hEvent, -1LL, -1LL));
}
// 18005098F: variable 'v3' is possibly undefined
// 18005099D: variable 'v4' is possibly undefined
// 1800B0A10: using guessed type int ShutdownMgr::s_sync;
// 1800B0A14: using guessed type int dword_1800B0A14;
// 1800B0C60: using guessed type __int128 g_Idolater;
// 1800B0C70: using guessed type char byte_1800B0C70;
// 1800508EC: using guessed type __int128 var_18;

//----- (0000000180050A00) ----------------------------------------------------
void __fastcall Idolater::IdleStartCallback(void *a1, struct _FILETIME *a2)
{
  Idolater *v2; // rcx
  __int32 v3; // [rsp+78h] [rbp+18h] BYREF
  int v4; // [rsp+80h] [rbp+20h]

  v3 = 0;
  _InterlockedExchange(&v3, 0);
  _InterlockedIncrement(&ShutdownMgr::s_sync);
  v2 = (Idolater *)(unsigned int)_InterlockedExchange(&v3, _InterlockedCompareExchange(&dword_1800B0A14, 0, 0) != 0);
  if ( _InterlockedCompareExchange(&v3, 0, 0) )
  {
    v4 = 0;
    Idolater::IdleStart(v2, a2);
  }
  _InterlockedExchange(&v3, 0);
  if ( _InterlockedExchangeAdd(&ShutdownMgr::s_sync, 0xFFFFFFFF) == 1 )
    SetEvent((HANDLE)_InterlockedCompareExchange64((volatile signed __int64 *)&ShutdownMgr::s_hEvent, -1LL, -1LL));
}
// 180050A00: could not find valid save-restore pair for rbp
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 1800B0A10: using guessed type int ShutdownMgr::s_sync;
// 1800B0A14: using guessed type int dword_1800B0A14;

//----- (0000000180050B00) ----------------------------------------------------
__int64 __fastcall Idolater::SendUbpmIdleEvent(Idolater *this, char a2)
{
  void *v2; // rax
  int v4; // ebx
  const wchar_t *v5; // r9
  void *v7; // [rsp+30h] [rbp-28h] BYREF
  __int64 v8; // [rsp+38h] [rbp-20h]

  v8 = 0LL;
  v2 = &MACHINE_IDLE_GUID;
  if ( !a2 )
    v2 = &MACHINE_NOT_IDLE_GUID;
  v7 = v2;
  v8 = 16LL;
  v4 = EtwEventWrite(qword_1800B0CD0, &UBPM_IDLE_TRIGGER_EVENT, 1LL, &v7);
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x10) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
  {
    v5 = L"startIdle";
    if ( !a2 )
      v5 = L"stopIdle";
    WPP_SF_SD(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xEu, (__int64)&WPP_4aaaf28b39ec324c0c8953682ef38beb_Traceguids, v5);
  }
  if ( v4 > 0 )
    return (unsigned __int16)v4 | 0x80070000;
  return (unsigned int)v4;
}
// 180074768: using guessed type __int64 __fastcall EtwEventWrite(_QWORD, _QWORD, _QWORD, _QWORD);
// 18007FEC8: using guessed type wchar_t aStartidle[10];
// 18007FEE0: using guessed type wchar_t aStopidle[9];
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 1800B0CD0: using guessed type __int64 qword_1800B0CD0;

//----- (0000000180050BEC) ----------------------------------------------------
__int64 __fastcall Idolater::UnRegisterWithIdleService(Idolater *this)
{
  int LastError; // eax
  int v2; // eax
  HANDLE v3; // rcx
  HANDLE v4; // rcx

  EnterCriticalSection(&stru_1800B0CA0);
  if ( *(&xmmword_1800B0C80 + 1) )
  {
    if ( !UnregisterWaitEx(*(&xmmword_1800B0C80 + 1), (HANDLE)0xFFFFFFFFFFFFFFFFLL)
      && WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x10) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
    {
      LastError = GetLastError();
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0xCu,
        (__int64)&WPP_4aaaf28b39ec324c0c8953682ef38beb_Traceguids,
        LastError);
    }
    *(&xmmword_1800B0C80 + 1) = 0LL;
  }
  if ( WaitHandle )
  {
    if ( !UnregisterWaitEx(WaitHandle, (HANDLE)0xFFFFFFFFFFFFFFFFLL)
      && WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x10) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
    {
      v2 = GetLastError();
      WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xDu, (__int64)&WPP_4aaaf28b39ec324c0c8953682ef38beb_Traceguids, v2);
    }
    WaitHandle = 0LL;
  }
  v3 = TSchedStartEvent;
  if ( TSchedStartEvent )
  {
    TSchedStartEvent = 0LL;
    CloseHandle(v3);
  }
  v4 = TSchedStopEvent;
  if ( TSchedStopEvent )
  {
    TSchedStopEvent = 0LL;
    CloseHandle(v4);
  }
  wmi::AutoHandle::Close((void **)&hSourceHandle);
  hSourceHandle = 0LL;
  wmi::AutoHandle::Close((void **)&xmmword_1800B0C80);
  xmmword_1800B0C80 = 0LL;
  LeaveCriticalSection(&stru_1800B0CA0);
  return 0LL;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180050D6C) ----------------------------------------------------
void __fastcall Idolater::Uninit(Idolater *this)
{
  Idolater::UnRegisterWithIdleService(this);
  if ( qword_1800B0CD0 )
  {
    EtwEventUnregister();
    qword_1800B0CD0 = 0LL;
  }
  DeleteCriticalSection(&stru_1800B0CA0);
}
// 180074770: using guessed type __int64 EtwEventUnregister(void);
// 1800B0CD0: using guessed type __int64 qword_1800B0CD0;

//----- (0000000180050DB4) ----------------------------------------------------
_QWORD *__fastcall std::_List_buy<_FILETIME>::_Buynode<_FILETIME const &>(
        __int64 a1,
        _QWORD *a2,
        _QWORD *a3,
        _QWORD *a4)
{
  _QWORD *result; // rax

  result = std::_List_alloc<0,std::_List_base_types<_FILETIME>>::_Buynode0(a1, a2, a3);
  result[2] = *a4;
  return result;
}

//----- (0000000180050E08) ----------------------------------------------------
_QWORD *__fastcall std::_Tree_buy<std::pair<_bstr_t const,std::list<_FILETIME> *>>::_Buynode<std::pair<unsigned short const *,std::list<_FILETIME> *>>(
        _QWORD *a1,
        __int64 a2)
{
  _QWORD *v4; // [rsp+48h] [rbp+10h]

  v4 = std::_Tree_buy<std::pair<User const,LogonJob *>>::_Buynode0(a1);
  *((_WORD *)v4 + 12) = 0;
  _bstr_t::_bstr_t((_bstr_t *)(v4 + 4), *(const unsigned __int16 **)a2);
  v4[5] = *(_QWORD *)(a2 + 8);
  return v4;
}

//----- (0000000180050E84) ----------------------------------------------------
__int64 *__fastcall std::_Tree<std::_Tmap_traits<_bstr_t,std::list<_FILETIME> *,Aggregator::less,std::allocator<std::pair<_bstr_t const,std::list<_FILETIME> *>>,0>>::_Insert_at<std::pair<_bstr_t const,std::list<_FILETIME> *> &,std::_Tree_node<std::pair<_bstr_t const,std::list<_FILETIME> *>,void *> *>(
        __int64 *a1,
        __int64 *a2,
        char a3,
        _QWORD *a4,
        int a5,
        __int64 a6)
{
  unsigned __int64 v6; // rax
  __int64 *v7; // r11
  __int64 v9; // r10
  __int64 v10; // rax
  __int64 v11; // rax
  __int64 v12; // r9
  __int64 v13; // rax
  __int64 *v14; // rdx
  __int64 v15; // rcx
  __int64 v16; // rax
  __int64 v17; // rcx
  __int64 *result; // rax

  v6 = a1[1];
  v7 = a1;
  if ( v6 >= 0x555555555555554LL )
  {
    std::_Tree<std::_Tmap_traits<_bstr_t,std::list<_FILETIME> *,Aggregator::less,std::allocator<std::pair<_bstr_t const,std::list<_FILETIME> *>>,0>>::_Destroy_if_not_nil(
      0x555555555555554LL,
      a6);
    std::_Xlength_error("map/set<T> too long");
  }
  v9 = a6;
  a1[1] = v6 + 1;
  *(_QWORD *)(a6 + 8) = a4;
  if ( a4 == (_QWORD *)*a1 )
  {
    *(_QWORD *)(*a1 + 8) = a6;
    *(_QWORD *)*a1 = a6;
    v10 = *a1;
LABEL_9:
    *(_QWORD *)(v10 + 16) = a6;
    goto LABEL_10;
  }
  if ( a3 )
  {
    *a4 = a6;
    if ( a4 == *(_QWORD **)*a1 )
      *(_QWORD *)*a1 = a6;
    goto LABEL_10;
  }
  a4[2] = a6;
  v10 = *a1;
  if ( a4 == *(_QWORD **)(*a1 + 16) )
    goto LABEL_9;
LABEL_10:
  v11 = *(_QWORD *)(a6 + 8);
  v12 = a6;
  while ( !*(_BYTE *)(v11 + 24) )
  {
    v13 = *(_QWORD *)(v12 + 8);
    v14 = *(__int64 **)(v13 + 8);
    v15 = *v14;
    if ( v13 == *v14 )
    {
      v15 = v14[2];
      if ( !*(_BYTE *)(v15 + 24) )
        goto LABEL_17;
      if ( v12 == *(_QWORD *)(v13 + 16) )
        std::_Tree<std::_Tmap_traits<User,LogonJob *,User::less,std::allocator<std::pair<User const,LogonJob *>>,1>>::_Lrotate(
          (__int64)v7,
          *(_QWORD *)(v12 + 8));
      *(_BYTE *)(*(_QWORD *)(v12 + 8) + 24LL) = 1;
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v12 + 8) + 8LL) + 24LL) = 0;
      std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::_Rrotate(
        (__int64)v7,
        *(_QWORD **)(*(_QWORD *)(v12 + 8) + 8LL));
    }
    else
    {
      if ( !*(_BYTE *)(v15 + 24) )
      {
LABEL_17:
        *(_BYTE *)(v13 + 24) = 1;
        *(_BYTE *)(v15 + 24) = 1;
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v12 + 8) + 8LL) + 24LL) = 0;
        v12 = *(_QWORD *)(*(_QWORD *)(v12 + 8) + 8LL);
        goto LABEL_21;
      }
      if ( v12 == *(_QWORD *)v13 )
        std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::_Rrotate(
          (__int64)v7,
          *(_QWORD **)(v12 + 8));
      *(_BYTE *)(*(_QWORD *)(v12 + 8) + 24LL) = 1;
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v12 + 8) + 8LL) + 24LL) = 0;
      std::_Tree<std::_Tmap_traits<User,LogonJob *,User::less,std::allocator<std::pair<User const,LogonJob *>>,1>>::_Lrotate(
        (__int64)v7,
        *(_QWORD *)(*(_QWORD *)(v12 + 8) + 8LL));
    }
LABEL_21:
    v11 = *(_QWORD *)(v12 + 8);
  }
  v16 = *v7;
  *a2 = v9;
  v17 = *(_QWORD *)(v16 + 8);
  result = a2;
  *(_BYTE *)(v17 + 24) = 1;
  return result;
}
// 180050F13: variable 'v12' is possibly undefined
// 180050F3C: variable 'v7' is possibly undefined
// 180050FD3: variable 'v9' is possibly undefined

//----- (0000000180050FF0) ----------------------------------------------------
__int64 __fastcall std::_Tree<std::_Tmap_traits<_bstr_t,std::list<_FILETIME> *,Aggregator::less,std::allocator<std::pair<_bstr_t const,std::list<_FILETIME> *>>,0>>::_Insert_nohint<std::pair<_bstr_t const,std::list<_FILETIME> *> &,std::_Tree_node<std::pair<_bstr_t const,std::list<_FILETIME> *>,void *> *>(
        __int64 *a1,
        __int64 a2,
        __int64 a3,
        const wchar_t ***a4,
        char *lpMem)
{
  __int64 v8; // rdi
  __int64 v9; // rbx
  bool v10; // r14
  const wchar_t *v11; // rax
  const wchar_t *v12; // rcx
  __int64 v13; // rbx
  __int64 v15; // rax
  __int64 i; // rax
  const wchar_t *v17; // rcx
  const wchar_t **v18; // rax
  const wchar_t *v19; // rcx
  void *v20; // rdi
  int v21; // [rsp+20h] [rbp-38h]
  const wchar_t *v22[5]; // [rsp+30h] [rbp-28h] BYREF
  const wchar_t *v23; // [rsp+60h] [rbp+8h] BYREF

  v22[1] = (const wchar_t *)-2LL;
  v8 = *a1;
  v9 = *(_QWORD *)(*a1 + 8);
  v10 = 1;
  while ( !*(_BYTE *)(v9 + 25) )
  {
    v8 = v9;
    v11 = *(const wchar_t **)(v9 + 32);
    if ( v11 )
      v11 = *(const wchar_t **)v11;
    v23 = v11;
    if ( *a4 )
      v12 = **a4;
    else
      v12 = 0LL;
    v22[0] = v12;
    v10 = Aggregator::less::operator()((__int64)v12, v22, &v23);
    if ( v10 )
      v9 = *(_QWORD *)v9;
    else
      v9 = *(_QWORD *)(v9 + 16);
  }
  v13 = v8;
  if ( v10 )
  {
    if ( v8 == *(_QWORD *)*a1 )
    {
      *(_QWORD *)a2 = *std::_Tree<std::_Tmap_traits<_bstr_t,std::list<_FILETIME> *,Aggregator::less,std::allocator<std::pair<_bstr_t const,std::list<_FILETIME> *>>,0>>::_Insert_at<std::pair<_bstr_t const,std::list<_FILETIME> *> &,std::_Tree_node<std::pair<_bstr_t const,std::list<_FILETIME> *>,void *> *>(
                         a1,
                         (__int64 *)&v23,
                         1,
                         (_QWORD *)v8,
                         v21,
                         (__int64)lpMem);
      *(_BYTE *)(a2 + 8) = 1;
      return a2;
    }
    if ( *(_BYTE *)(v8 + 25) )
    {
      v13 = *(_QWORD *)(v8 + 16);
    }
    else
    {
      v15 = *(_QWORD *)v8;
      if ( *(_BYTE *)(*(_QWORD *)v8 + 25LL) )
      {
        for ( i = *(_QWORD *)(v8 + 8); !*(_BYTE *)(i + 25) && v13 == *(_QWORD *)i; i = *(_QWORD *)(i + 8) )
          v13 = i;
        if ( !*(_BYTE *)(v13 + 25) )
          v13 = i;
      }
      else
      {
        do
        {
          v13 = v15;
          v15 = *(_QWORD *)(v15 + 16);
        }
        while ( !*(_BYTE *)(v15 + 25) );
      }
    }
  }
  if ( *a4 )
    v17 = **a4;
  else
    v17 = 0LL;
  v23 = v17;
  v18 = *(const wchar_t ***)(v13 + 32);
  if ( v18 )
    v19 = *v18;
  else
    v19 = 0LL;
  v22[0] = v19;
  if ( Aggregator::less::operator()((__int64)v19, v22, &v23) )
  {
    *(_QWORD *)a2 = *std::_Tree<std::_Tmap_traits<_bstr_t,std::list<_FILETIME> *,Aggregator::less,std::allocator<std::pair<_bstr_t const,std::list<_FILETIME> *>>,0>>::_Insert_at<std::pair<_bstr_t const,std::list<_FILETIME> *> &,std::_Tree_node<std::pair<_bstr_t const,std::list<_FILETIME> *>,void *> *>(
                       a1,
                       (__int64 *)&v23,
                       v10,
                       (_QWORD *)v8,
                       v21,
                       (__int64)lpMem);
    *(_BYTE *)(a2 + 8) = 1;
  }
  else
  {
    v20 = lpMem;
    _bstr_t::_Free((_bstr_t *)(lpMem + 32));
    operator delete(v20);
    *(_QWORD *)a2 = v13;
    *(_BYTE *)(a2 + 8) = 0;
  }
  return a2;
}
// 18005109F: variable 'v21' is possibly undefined

//----- (00000001800511D0) ----------------------------------------------------
bool __fastcall Aggregator::less::operator()(__int64 a1, const wchar_t **a2, const wchar_t **a3)
{
  return (*a2 || *a3) && _wcsicmp(*a2, *a3) < 0;
}

//----- (0000000180051208) ----------------------------------------------------
_QWORD *__fastcall std::_List_alloc<0,std::_List_base_types<_FILETIME>>::_Buynode0(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *result; // rax

  result = operator new(0x18uLL);
  if ( !result )
    std::_Xbad_alloc();
  if ( !a2 )
  {
    a2 = result;
    a3 = result;
  }
  *result = a2;
  result[1] = a3;
  return result;
}

//----- (0000000180051284) ----------------------------------------------------
void __fastcall std::_Tree<std::_Tmap_traits<_bstr_t,std::list<_FILETIME> *,Aggregator::less,std::allocator<std::pair<_bstr_t const,std::list<_FILETIME> *>>,0>>::_Destroy_if_not_nil(
        __int64 a1,
        __int64 a2)
{
  _bstr_t::_Free((_bstr_t *)(a2 + 32));
  operator delete((void *)a2);
}

//----- (00000001800512AC) ----------------------------------------------------
_QWORD *__fastcall std::_Tree<std::_Tmap_traits<_bstr_t,std::list<_FILETIME> *,Aggregator::less,std::allocator<std::pair<_bstr_t const,std::list<_FILETIME> *>>,0>>::find(
        __int64 *a1,
        _QWORD *a2,
        const wchar_t ***a3)
{
  __int64 *v3; // rdi
  __int64 *v7; // rax
  __int64 *v8; // rbx
  const wchar_t *v9; // rcx
  const wchar_t **v10; // rax
  const wchar_t *v11; // rcx
  const wchar_t **v12; // rax
  const wchar_t *v13; // rcx
  const wchar_t **v14; // rax
  const wchar_t *v15; // rcx
  _QWORD *result; // rax
  const wchar_t *v17; // [rsp+40h] [rbp+8h] BYREF
  const wchar_t *v18; // [rsp+48h] [rbp+10h] BYREF

  v3 = (__int64 *)*a1;
  v7 = (__int64 *)*a1;
  v8 = *(__int64 **)(*a1 + 8);
  if ( !*((_BYTE *)v8 + 25) )
  {
    do
    {
      if ( *a3 )
        v9 = **a3;
      else
        v9 = 0LL;
      v10 = (const wchar_t **)v8[4];
      v17 = v9;
      if ( v10 )
        v11 = *v10;
      else
        v11 = 0LL;
      v18 = v11;
      if ( Aggregator::less::operator()((__int64)v11, &v18, &v17) )
      {
        v8 = (__int64 *)v8[2];
      }
      else
      {
        v3 = v8;
        v8 = (__int64 *)*v8;
      }
    }
    while ( !*((_BYTE *)v8 + 25) );
    v7 = (__int64 *)*a1;
  }
  if ( v3 == v7
    || ((v12 = (const wchar_t **)v3[4]) == 0LL ? (v13 = 0LL) : (v13 = *v12),
        (v14 = *a3, v17 = v13, !v14) ? (v15 = 0LL) : (v15 = *v14),
        v18 = v15,
        Aggregator::less::operator()((__int64)v15, &v18, &v17)) )
  {
    v3 = (__int64 *)*a1;
  }
  result = a2;
  *a2 = v3;
  return result;
}

//----- (0000000180051390) ----------------------------------------------------
JobMoniker *__fastcall JobMoniker::JobMoniker(JobMoniker *this, const struct JobMoniker *a2, const struct _GUID *a3)
{
  wmi::RefBase **v3; // rsi
  const unsigned __int16 *Path; // rax
  __int64 v8; // r8
  JobBucket *v9; // rcx

  *((_QWORD *)this + 2) = 0LL;
  v3 = (wmi::RefBase **)((char *)this + 32);
  *((_QWORD *)this + 4) = 0LL;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x40) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
  {
    Path = JobMoniker::GetPath(a2);
    WPP_SF_qS_guid_(*((_QWORD *)WPP_GLOBAL_Control + 2), 0xEu, v8, this, Path, a3);
  }
  wmi::AutoRef<JobBucket>::operator=(v3, *((volatile signed __int32 **)a2 + 4));
  _bstr_t::operator=((__int64 *)this + 2, (__int64 *)a2 + 2);
  v9 = *v3;
  *((_QWORD *)this + 3) = *((_QWORD *)a2 + 3);
  *(struct _GUID *)this = *a3;
  JobBucket::SetHash(
    v9,
    (const unsigned __int8 *)((*((_QWORD *)a2 + 4) + 28LL) & -(__int64)(*(_DWORD *)(*((_QWORD *)a2 + 4) + 60LL) != 0)));
  return this;
}
// 180051403: variable 'v8' is possibly undefined
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180051480) ----------------------------------------------------
wmi::RefBase *__fastcall wmi::RefBase::`vector deleting destructor'(wmi::RefBase *this, char a2)
{
  *(_QWORD *)this = &wmi::RefBase::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 180070980: using guessed type void *wmi::RefBase::`vftable';

//----- (00000001800514B0) ----------------------------------------------------
void __fastcall JobMoniker::_GenId(UUID *this)
{
  RPC_STATUS v1; // eax
  void **pExceptionObject; // [rsp+20h] [rbp-48h] BYREF
  char v3; // [rsp+28h] [rbp-40h]
  const unsigned __int16 *v4; // [rsp+30h] [rbp-38h]
  __int64 v5; // [rsp+38h] [rbp-30h]
  __int64 v6; // [rsp+40h] [rbp-28h]
  RPC_STATUS v7; // [rsp+48h] [rbp-20h]
  int v8; // [rsp+4Ch] [rbp-1Ch]
  int v9; // [rsp+50h] [rbp-18h]

  v1 = UuidCreate(this);
  if ( v1 )
  {
    if ( v1 != 1824 )
    {
      v8 = -1;
      v9 = -1;
      pExceptionObject = &wmi::GenericException::`vftable';
      v4 = &word_18007630E;
      v3 = 0;
      v5 = 0LL;
      v6 = 0LL;
      v7 = v1;
      CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
    }
  }
}
// 1800716D8: using guessed type void *wmi::GenericException::`vftable';

//----- (0000000180051520) ----------------------------------------------------
__int64 WPP_SF_qSS(__int64 a1, __int64 a2, __int64 a3, ...)
{
  __int64 v3; // rdx
  __int64 v4; // rax
  __int64 v6; // [rsp+88h] [rbp+20h] BYREF
  va_list va; // [rsp+88h] [rbp+20h]
  __int64 v8; // [rsp+90h] [rbp+28h]
  __int64 v9; // [rsp+98h] [rbp+30h]
  va_list va1; // [rsp+A0h] [rbp+38h] BYREF

  va_start(va1, a3);
  va_start(va, a3);
  v6 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v3 = -1LL;
  if ( v9 )
  {
    v4 = -1LL;
    do
      ++v4;
    while ( *(_WORD *)(v9 + 2 * v4) );
  }
  if ( v8 )
  {
    do
      ++v3;
    while ( *(_WORD *)(v8 + 2 * v3) );
  }
  return EtwTraceMessage(a1, 43LL, &WPP_16e3f8fe698a3782de2a32e152cb4c16_Traceguids, 10LL, (__int64 *)va);
}
// 1800747B0: using guessed type __int64 __fastcall EtwTraceMessage(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001800515F8) ----------------------------------------------------
__int64 WPP_SF_qS_guid_(__int64 a1, unsigned __int16 a2, __int64 a3, ...)
{
  __int64 v3; // rax
  __int64 v5; // [rsp+88h] [rbp+20h] BYREF
  va_list va; // [rsp+88h] [rbp+20h]
  __int64 v7; // [rsp+90h] [rbp+28h]
  va_list va1; // [rsp+98h] [rbp+30h] BYREF

  va_start(va1, a3);
  va_start(va, a3);
  v5 = va_arg(va1, _QWORD);
  v7 = va_arg(va1, _QWORD);
  if ( v7 )
  {
    v3 = -1LL;
    do
      ++v3;
    while ( *(_WORD *)(v7 + 2 * v3) );
  }
  return EtwTraceMessage(a1, 43LL, &WPP_16e3f8fe698a3782de2a32e152cb4c16_Traceguids, a2, (__int64 *)va);
}
// 1800747B0: using guessed type __int64 __fastcall EtwTraceMessage(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001800516A8) ----------------------------------------------------
__int64 WPP_SF_qq(__int64 a1, __int64 a2, __int64 a3, ...)
{
  va_list va; // [rsp+78h] [rbp+20h] BYREF

  va_start(va, a3);
  return EtwTraceMessage(a1, 43LL, &WPP_16e3f8fe698a3782de2a32e152cb4c16_Traceguids, 12LL, (__int64 *)va);
}
// 1800747B0: using guessed type __int64 __fastcall EtwTraceMessage(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180051704) ----------------------------------------------------
__int64 WPP_SF_qqq(__int64 a1, __int64 a2, __int64 a3, ...)
{
  va_list va; // [rsp+88h] [rbp+20h] BYREF

  va_start(va, a3);
  return EtwTraceMessage(a1, 43LL, &WPP_16e3f8fe698a3782de2a32e152cb4c16_Traceguids, 13LL, (__int64 *)va);
}
// 1800747B0: using guessed type __int64 __fastcall EtwTraceMessage(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000018005176C) ----------------------------------------------------
void __fastcall ATL::CStringT<unsigned short,ATL::StrTraitATL<unsigned short,ATL::ChTraitsCRT<unsigned short>>>::~CStringT<unsigned short,ATL::StrTraitATL<unsigned short,ATL::ChTraitsCRT<unsigned short>>>(
        _QWORD *a1)
{
  ATL::CStringData::Release((ATL::CStringData *)(*a1 - 24LL));
}

//----- (0000000180051780) ----------------------------------------------------
void __fastcall ATL::CTempBuffer<unsigned short,128,ATL::CCRTAllocator>::~CTempBuffer<unsigned short,128,ATL::CCRTAllocator>(
        void **a1)
{
  if ( *a1 != a1 + 1 )
    ATL::CTempBuffer<unsigned short,128,ATL::CCRTAllocator>::FreeHeap(a1);
}

//----- (00000001800517A0) ----------------------------------------------------
HLOCAL __fastcall tsched::LocalFreeMe<unsigned short>::~LocalFreeMe<unsigned short>(HLOCAL **a1)
{
  return LocalFree(**a1);
}

//----- (00000001800517B8) ----------------------------------------------------
__int64 __fastcall wmi::ScopeGuardImpl1<long (*)(void *),void *>::~ScopeGuardImpl1<long (*)(void *),void *>(__int64 a1)
{
  __int64 result; // rax

  result = a1;
  if ( !*(_BYTE *)a1 )
    return (*(__int64 (__fastcall **)(_QWORD))(a1 + 8))(*(_QWORD *)(a1 + 16));
  return result;
}

//----- (00000001800517E0) ----------------------------------------------------
void __fastcall std::auto_ptr<User>::~auto_ptr<User>(User **a1)
{
  User *v1; // rcx

  v1 = *a1;
  if ( v1 )
    User::`scalar deleting destructor'(v1);
}

//----- (0000000180051800) ----------------------------------------------------
User::UserEntry **__fastcall User::operator=(User::UserEntry **a1, User::UserEntry **a2)
{
  wmi::AutoRef<User::UserEntry>::operator=(a1, *a2);
  return a1;
}

//----- (0000000180051830) ----------------------------------------------------
ATL::CSid *__fastcall ATL::CSid::`scalar deleting destructor'(ATL::CSid *this, char a2)
{
  ATL::CSid::~CSid(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (0000000180051868) ----------------------------------------------------
User *__fastcall User::`scalar deleting destructor'(User *this)
{
  wmi::AutoRef<User::UserEntry>::Release(this);
  operator delete(this);
  return this;
}
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);

//----- (0000000180051890) ----------------------------------------------------
User::UserEntry **__fastcall User::CreateAlias(User::UserEntry **a1, const struct _bstr_t *a2)
{
  char v4; // si
  const wchar_t **v5; // rax
  const wchar_t *v6; // rcx
  const wchar_t *v7; // rcx
  const wchar_t *v8; // r9
  struct _RTL_CRITICAL_SECTION *v9; // rdi
  _QWORD *v10; // r15
  User::UserEntry **v11; // rbx
  _QWORD *v12; // rcx
  const wchar_t *v13; // rdx
  const wchar_t *v14; // rcx
  User::UserEntry *v15; // rbx
  User::UserEntry *v16; // rax
  void **pExceptionObject; // [rsp+60h] [rbp-11h] BYREF
  char v19; // [rsp+68h] [rbp-9h]
  const unsigned __int16 *v20; // [rsp+70h] [rbp-1h]
  __int64 v21; // [rsp+78h] [rbp+7h]
  __int64 v22; // [rsp+80h] [rbp+Fh]
  int v23; // [rsp+88h] [rbp+17h]
  int v24; // [rsp+8Ch] [rbp+1Bh]
  int v25; // [rsp+90h] [rbp+1Fh]
  User::UserEntry *v26; // [rsp+E0h] [rbp+6Fh] BYREF
  __int64 v27; // [rsp+E8h] [rbp+77h] BYREF
  LPCRITICAL_SECTION v28; // [rsp+F0h] [rbp+7Fh]

  v4 = 0;
  v5 = *(const wchar_t ***)a2;
  if ( *(_QWORD *)a2 )
    v6 = *v5;
  else
    v6 = 0LL;
  if ( !v6 )
  {
    v7 = v5 ? *v5 : 0LL;
    if ( !*v7 )
    {
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && *((char *)WPP_GLOBAL_Control + 28) < 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        if ( v5 )
          v8 = *v5;
        else
          v8 = 0LL;
        WPP_SF_S(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0xFu,
          (__int64)&WPP_0a02ad6f637a3dce55ae09b3fc909c99_Traceguids,
          v8);
      }
      v19 = 0;
      pExceptionObject = &wmi::GenericException::`vftable';
      v20 = &word_18007630E;
      v21 = 0LL;
      v22 = 0LL;
      v23 = 87;
      v24 = -1;
      v25 = -1;
      CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
    }
  }
  v9 = User::s_cs;
  v28 = User::s_cs;
  EnterCriticalSection(User::s_cs);
  v10 = User::s_userTable;
  v11 = *(User::UserEntry ***)User::s_userTable;
  if ( *(_QWORD *)User::s_userTable != *((_QWORD *)User::s_userTable + 1) )
  {
    while ( v11 != (User::UserEntry **)v10[1] )
    {
      if ( *(_BYTE *)*v11 )
      {
        v12 = (_QWORD *)*((_QWORD *)*v11 + 2);
        v13 = v12 ? (const wchar_t *)*v12 : 0LL;
        v14 = *(_QWORD *)a2 ? **(const wchar_t ***)a2 : 0LL;
        if ( !_wcsicmp(v14, v13) )
        {
          v15 = *v11;
          v26 = v15;
          if ( v15 )
            User::UserEntry::AddRef(v15);
          *a1 = v15;
          if ( !v15 )
            goto LABEL_47;
          goto LABEL_46;
        }
      }
      ++v11;
    }
  }
  v16 = (User::UserEntry *)operator new(0x30uLL);
  if ( v16 )
  {
    v27 = 0LL;
    v26 = 0LL;
    v4 = 6;
    v15 = User::UserEntry::UserEntry(
            v16,
            1,
            a2,
            (const struct _bstr_t *)&v26,
            (const struct _bstr_t *)&v27,
            SidTypeUnknown,
            0LL);
  }
  else
  {
    v15 = 0LL;
  }
  if ( (v4 & 4) != 0 )
  {
    v4 &= ~4u;
    _bstr_t::_Free((_bstr_t *)&v26);
  }
  if ( (v4 & 2) != 0 )
    _bstr_t::_Free((_bstr_t *)&v27);
  if ( !v15 )
  {
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && *((char *)WPP_GLOBAL_Control + 28) < 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x10u, (__int64)&WPP_0a02ad6f637a3dce55ae09b3fc909c99_Traceguids);
    }
    v19 = 0;
    v20 = &word_18007630E;
    v21 = 0LL;
    v22 = 0LL;
    v23 = 14;
    v24 = -1;
    v25 = -1;
    pExceptionObject = &wmi::OutOfMemoryException::`vftable';
    CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI4_AVOutOfMemoryException_wmi__);
  }
  v26 = v15;
  User::UserEntry::AddRef(v15);
  *a1 = v15;
LABEL_46:
  User::UserEntry::AddRef(v15);
LABEL_47:
  wmi::AutoRef<User::UserEntry>::Release(&v26);
  LeaveCriticalSection(v9);
  return a1;
}
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);
// 1800716D8: using guessed type void *wmi::GenericException::`vftable';
// 180073740: using guessed type void *wmi::OutOfMemoryException::`vftable';
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180051BBC) ----------------------------------------------------
__int64 __fastcall User::FromUserSession(User::UserEntry **this, DWORD SessionId, void *a3)
{
  char *v5; // rdi
  signed int LastError; // eax
  unsigned int v7; // ebx
  signed int v8; // eax
  signed int v9; // eax
  struct _RTL_CRITICAL_SECTION **v10; // rbx
  signed int v11; // eax
  unsigned int v12; // edi
  struct _RTL_CRITICAL_SECTION *v13; // rdi
  User::UserEntry **v14; // rax
  LPWSTR ppBuffer; // [rsp+38h] [rbp-D0h] BYREF
  DWORD ReturnLength[2]; // [rsp+40h] [rbp-C8h] BYREF
  LPWSTR v18; // [rsp+48h] [rbp-C0h] BYREF
  void *phToken; // [rsp+50h] [rbp-B8h] BYREF
  DWORD pBytesReturned; // [rsp+58h] [rbp-B0h] BYREF
  __int64 *v21; // [rsp+60h] [rbp-A8h] BYREF
  const wchar_t **v22; // [rsp+68h] [rbp-A0h] BYREF
  User::UserEntry *v23; // [rsp+70h] [rbp-98h] BYREF
  void **pExceptionObject; // [rsp+78h] [rbp-90h] BYREF
  char v25; // [rsp+80h] [rbp-88h]
  const unsigned __int16 *v26; // [rsp+88h] [rbp-80h]
  __int64 v27; // [rsp+90h] [rbp-78h]
  int v28; // [rsp+98h] [rbp-70h]
  int v29; // [rsp+9Ch] [rbp-6Ch]
  int v30; // [rsp+A0h] [rbp-68h]
  int v31; // [rsp+A4h] [rbp-64h]
  int v32; // [rsp+A8h] [rbp-60h]
  __int64 v33; // [rsp+B0h] [rbp-58h]
  LPWSTR *p_ppBuffer; // [rsp+B8h] [rbp-50h]
  LPWSTR *v35; // [rsp+C0h] [rbp-48h]
  struct _RTL_CRITICAL_SECTION **v36; // [rsp+C8h] [rbp-40h]
  WCHAR AccountName[280]; // [rsp+D8h] [rbp-30h] BYREF

  v33 = -2LL;
  ppBuffer = 0LL;
  v18 = 0LL;
  phToken = 0LL;
  v5 = 0LL;
  if ( WTSQueryUserToken(SessionId, &phToken) )
    v5 = (char *)phToken;
  if ( !WTSQuerySessionInformationW(0LL, SessionId, WTSUserName, &ppBuffer, &pBytesReturned) )
  {
    LastError = GetLastError();
    v7 = LastError;
    if ( LastError > 0 )
      v7 = (unsigned __int16)LastError | 0x80070000;
    goto LABEL_40;
  }
  p_ppBuffer = &ppBuffer;
  if ( !WTSQuerySessionInformationW(0LL, SessionId, WTSDomainName, &v18, &pBytesReturned) )
  {
    v8 = GetLastError();
    v7 = v8;
    if ( v8 > 0 )
      v7 = (unsigned __int16)v8 | 0x80070000;
LABEL_38:
    if ( ppBuffer )
      WTSFreeMemory(ppBuffer);
    goto LABEL_40;
  }
  v35 = &v18;
  if ( (unsigned __int64)(v5 - 1) > 0xFFFFFFFFFFFFFFFDuLL )
  {
    if ( (int)StringCchPrintfW(AccountName, 0x111uLL, (size_t *)L"%s\\%s", v18, ppBuffer) >= 0 )
    {
      v7 = User::FromUsername(this, AccountName);
LABEL_36:
      if ( v18 )
        WTSFreeMemory(v18);
      goto LABEL_38;
    }
    if ( v18 )
      WTSFreeMemory(v18);
    if ( ppBuffer )
      WTSFreeMemory(ppBuffer);
    v7 = -2147418113;
  }
  else
  {
    ReturnLength[0] = 0;
    if ( !GetTokenInformation(v5, TokenUser, 0LL, 0, ReturnLength) && GetLastError() != 122 )
    {
      v9 = GetLastError();
      v7 = v9;
      if ( v9 > 0 )
        v7 = (unsigned __int16)v9 | 0x80070000;
      goto LABEL_36;
    }
    v10 = (struct _RTL_CRITICAL_SECTION **)operator new(ReturnLength[0]);
    v36 = v10;
    if ( !v10 )
    {
      v25 = 0;
      v26 = &word_18007630E;
      v27 = 0LL;
      v28 = 0;
      v29 = 0;
      v30 = 14;
      v31 = -1;
      v32 = -1;
      pExceptionObject = &wmi::OutOfMemoryException::`vftable';
      CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI4_AVOutOfMemoryException_wmi__);
    }
    if ( GetTokenInformation(v5, TokenUser, v10, ReturnLength[0], ReturnLength) )
    {
      v13 = *v10;
      _bstr_t::_bstr_t((_bstr_t *)&v22, v18);
      _bstr_t::_bstr_t((_bstr_t *)&v21, ppBuffer);
      v14 = User::CreateUser(&v23, &v21, &v22, SidTypeUnknown, v13);
      wmi::AutoRef<User::UserEntry>::operator=(this, *v14);
      wmi::AutoRef<User::UserEntry>::Release(&v23);
      _bstr_t::_Free((_bstr_t *)&v21);
      _bstr_t::_Free((_bstr_t *)&v22);
      operator delete(v10);
      if ( v18 )
        WTSFreeMemory(v18);
      if ( ppBuffer )
        WTSFreeMemory(ppBuffer);
      v7 = 0;
    }
    else
    {
      v11 = GetLastError();
      v12 = v11;
      if ( v11 > 0 )
        v12 = (unsigned __int16)v11 | 0x80070000;
      operator delete(v10);
      if ( v18 )
        WTSFreeMemory(v18);
      if ( ppBuffer )
        WTSFreeMemory(ppBuffer);
      v7 = v12;
    }
  }
LABEL_40:
  wmi::AutoHandle::Close(&phToken);
  return v7;
}
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);
// 180073740: using guessed type void *wmi::OutOfMemoryException::`vftable';

//----- (0000000180051FDC) ----------------------------------------------------
WCHAR *User::GetComputerNameW(void)
{
  void **pExceptionObject; // [rsp+20h] [rbp-40h] BYREF
  char v2; // [rsp+28h] [rbp-38h]
  const unsigned __int16 *v3; // [rsp+30h] [rbp-30h]
  __int64 v4; // [rsp+38h] [rbp-28h]
  __int64 v5; // [rsp+40h] [rbp-20h]
  DWORD LastError; // [rsp+48h] [rbp-18h]
  int v7; // [rsp+4Ch] [rbp-14h]
  int v8; // [rsp+50h] [rbp-10h]
  DWORD nSize; // [rsp+70h] [rbp+10h] BYREF

  if ( !User::s_computername )
  {
    nSize = 16;
    if ( !GetComputerNameW(&User::s_computername, &nSize) )
    {
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && *((char *)WPP_GLOBAL_Control + 28) < 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x1Cu, (__int64)&WPP_0a02ad6f637a3dce55ae09b3fc909c99_Traceguids);
      }
      v7 = -1;
      v8 = -1;
      pExceptionObject = &wmi::GenericException::`vftable';
      v3 = &word_18007630E;
      v2 = 0;
      v4 = 0LL;
      v5 = 0LL;
      LastError = GetLastError();
      CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
    }
  }
  return &User::s_computername;
}
// 1800716D8: using guessed type void *wmi::GenericException::`vftable';
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (00000001800520B0) ----------------------------------------------------
__int64 *__fastcall User::GetDomain(__int64 a1, __int64 *a2)
{
  struct _RTL_CRITICAL_SECTION *v2; // rbx

  v2 = User::s_cs;
  *a2 = 0LL;
  EnterCriticalSection(v2);
  _bstr_t::operator=(a2, (__int64 *)(*(_QWORD *)a1 + 24LL));
  LeaveCriticalSection(v2);
  return a2;
}

//----- (0000000180052118) ----------------------------------------------------
__int64 __fastcall User::GetSessionIdForUser(unsigned int *a1, unsigned __int64 *a2)
{
  signed int LastHrError; // ebx
  HANDLE CurrentThread; // rax
  tsched *v6; // rcx
  signed int v7; // eax
  void *TokenHandle; // [rsp+30h] [rbp-10h] BYREF
  unsigned __int64 v10; // [rsp+38h] [rbp-8h] BYREF
  unsigned int TokenInformation; // [rsp+70h] [rbp+30h] BYREF
  DWORD ReturnLength; // [rsp+78h] [rbp+38h] BYREF

  TokenInformation = -1;
  LastHrError = 0;
  v10 = 0LL;
  ReturnLength = 0;
  TokenHandle = 0LL;
  CurrentThread = GetCurrentThread();
  if ( OpenThreadToken(CurrentThread, 8u, 1, &TokenHandle)
    && GetTokenInformation(TokenHandle, TokenSessionId, &TokenInformation, 4u, &ReturnLength) )
  {
    *a1 = TokenInformation;
    if ( !IsUMgrQueryUserContextPresent() )
      goto LABEL_9;
    v7 = UMgrQueryUserContext(TokenHandle, &v10);
    LastHrError = v7;
    if ( v7 == -2147023584 || v7 == -2147023652 )
      LastHrError = 0;
    if ( LastHrError >= 0 )
LABEL_9:
      *a2 = v10;
  }
  else
  {
    LastHrError = tsched::GetLastHrError(v6);
  }
  wmi::AutoHandle::Close(&TokenHandle);
  return (unsigned int)LastHrError;
}
// 180052168: variable 'v6' is possibly undefined
// 1800B92C8: using guessed type __int64 __fastcall UMgrQueryUserContext(_QWORD, _QWORD);

//----- (00000001800521FC) ----------------------------------------------------
__int64 __fastcall User::LookupType(User *this, enum _SID_NAME_USE *a2)
{
  User *v4; // rcx
  __int64 v5; // r8
  __int64 result; // rax

  if ( !*(_QWORD *)this || User::IsAlias(this) )
    return 2147549183LL;
  if ( *(_DWORD *)(v5 + 40) != 8 || (result = User::UpdateEntry(v4), (int)result >= 0) )
  {
    result = 0LL;
    *a2 = *(enum _SID_NAME_USE *)(*(_QWORD *)this + 40LL);
  }
  return result;
}
// 18005221D: variable 'v5' is possibly undefined
// 180052224: variable 'v4' is possibly undefined

//----- (0000000180052250) ----------------------------------------------------
void *__fastcall ATL::CTempBuffer<unsigned short,128,ATL::CCRTAllocator>::ReAllocateHeap(void **a1, size_t a2)
{
  void *result; // rax

  result = realloc(*a1, a2);
  if ( !result )
    ATL::PrivateAtlThrow(-2147024882);
  *a1 = result;
  return result;
}

//----- (0000000180052288) ----------------------------------------------------
__int64 __fastcall ATL::CSimpleStringT<unsigned short,0>::Reallocate(__int64 *a1, unsigned int a2)
{
  __int64 v2; // r8
  _DWORD *v4; // rdx
  __int64 v5; // rax
  __int64 result; // rax

  v2 = a2;
  v4 = (_DWORD *)(*a1 - 24);
  if ( v4[3] >= (int)v2
    || (int)v2 <= 0
    || (v5 = (*(__int64 (__fastcall **)(_QWORD, _DWORD *, __int64, __int64))(**(_QWORD **)v4 + 16LL))(
               *(_QWORD *)v4,
               v4,
               v2,
               2LL)) == 0 )
  {
    ATL::CSimpleStringT<unsigned short,0>::ThrowMemoryException();
  }
  result = v5 + 24;
  *a1 = result;
  return result;
}

//----- (00000001800522DC) ----------------------------------------------------
_QWORD *__fastcall ATL::CTempBuffer<unsigned short,128,ATL::CCRTAllocator>::Reallocate(void **a1, unsigned __int64 a2)
{
  rsize_t v3; // rsi
  void *v5; // rdi
  size_t v6; // rdx
  errno_t v7; // eax

  if ( a2 >= 0x7FFFFFFFFFFFFFFFLL )
    goto LABEL_11;
  v3 = 2 * a2;
  if ( !*a1 )
    return ATL::CTempBuffer<unsigned short,128,ATL::CCRTAllocator>::AllocateBytes(a1, 2 * a2);
  v5 = a1 + 1;
  if ( v3 <= 0x80 )
  {
    *a1 = v5;
  }
  else
  {
    v6 = 2 * a2;
    if ( *a1 == v5 )
    {
      ATL::CTempBuffer<unsigned short,128,ATL::CCRTAllocator>::AllocateHeap(a1, v6);
      v7 = memcpy_s(*a1, v3, v5, 0x80uLL);
      if ( v7 )
      {
        if ( v7 == 12 )
          ATL::PrivateAtlThrow(-2147024882);
        if ( v7 == 22 || v7 == 34 )
          ATL::PrivateAtlThrow(-2147024809);
        if ( v7 != 80 )
LABEL_11:
          ATL::PrivateAtlThrow(-2147467259);
      }
    }
    else
    {
      ATL::CTempBuffer<unsigned short,128,ATL::CCRTAllocator>::ReAllocateHeap(a1, v6);
    }
    return *a1;
  }
  return v5;
}

//----- (00000001800523AC) ----------------------------------------------------
char __fastcall User::SupportsTaskHardening(LPCWSTR lpAccountName)
{
  int v1; // ebx
  char v2; // bl
  void **pExceptionObject; // [rsp+28h] [rbp-38h] BYREF
  char v5; // [rsp+30h] [rbp-30h]
  const unsigned __int16 *v6; // [rsp+38h] [rbp-28h]
  __int64 v7; // [rsp+40h] [rbp-20h]
  int v8; // [rsp+48h] [rbp-18h]
  int v9; // [rsp+4Ch] [rbp-14h]
  int v10; // [rsp+50h] [rbp-10h]
  int v11; // [rsp+54h] [rbp-Ch]
  int v12; // [rsp+58h] [rbp-8h]
  User::UserEntry *v13; // [rsp+78h] [rbp+18h] BYREF

  v13 = 0LL;
  v1 = User::FromUsername(&v13, lpAccountName);
  if ( v1 < 0 )
  {
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && *((char *)WPP_GLOBAL_Control + 28) < 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x20u,
        (__int64)&WPP_0a02ad6f637a3dce55ae09b3fc909c99_Traceguids,
        v1);
    }
    v5 = 0;
    pExceptionObject = &wmi::GenericException::`vftable';
    v6 = &word_18007630E;
    v7 = 0LL;
    v8 = 0;
    v9 = 0;
    v10 = v1;
    v11 = -1;
    v12 = -1;
    CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
  }
  v2 = User::SupportsTaskHardening((User *)&v13);
  wmi::AutoRef<User::UserEntry>::Release(&v13);
  return v2;
}
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);
// 1800716D8: using guessed type void *wmi::GenericException::`vftable';
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180052488) ----------------------------------------------------
void __noreturn ATL::CSimpleStringT<unsigned short,0>::ThrowMemoryException()
{
  ATL::PrivateAtlThrow(-2147024882);
}

//----- (00000001800524A0) ----------------------------------------------------
void User::UninitializeUserTable(void)
{
  void *v0; // rbx
  _QWORD *v1; // rbx
  LPCRITICAL_SECTION v2; // rbx

  v0 = User::s_userCache;
  if ( User::s_userCache )
  {
    `eh vector destructor iterator'(
      User::s_userCache,
      8uLL,
      8uLL,
      (void (__stdcall *)(void *))std::auto_ptr<User>::~auto_ptr<User>);
    operator delete(v0);
    User::s_userCache = 0LL;
  }
  v1 = User::s_userTable;
  if ( User::s_userTable )
  {
    if ( *(_QWORD *)User::s_userTable )
    {
      operator delete(*(void **)User::s_userTable);
      *v1 = 0LL;
      v1[1] = 0LL;
      v1[2] = 0LL;
    }
    operator delete(v1);
    User::s_userTable = 0LL;
  }
  v2 = User::s_cs;
  if ( User::s_cs )
  {
    DeleteCriticalSection(User::s_cs);
    operator delete(v2);
    User::s_cs = 0LL;
  }
}

//----- (0000000180052554) ----------------------------------------------------
__int64 __fastcall std::vector<ServerXMLUpdateHandler::ISubHandler *>::_Reserve(_QWORD *a1)
{
  __int64 v2; // rdx
  __int64 result; // rax
  __int64 v4; // rdx
  unsigned __int64 v5; // rdx
  unsigned __int64 v6; // r9
  unsigned __int64 v7; // rcx

  v2 = a1[1];
  result = (a1[2] - v2) >> 3;
  if ( !result )
  {
    v4 = (v2 - *a1) >> 3;
    if ( v4 == 0x1FFFFFFFFFFFFFFFLL )
      std::_Xlength_error("vector<T> too long");
    v5 = v4 + 1;
    v6 = (__int64)(a1[2] - *a1) >> 3;
    v7 = 0LL;
    if ( 0x1FFFFFFFFFFFFFFFLL - (v6 >> 1) >= v6 )
      v7 = v6 + (v6 >> 1);
    if ( v7 >= v5 )
      v5 = v7;
    return (__int64)std::vector<_CSebiSystemEventCreationParameter *>::_Reallocate((__int64)a1, v5);
  }
  return result;
}

//----- (00000001800525D8) ----------------------------------------------------
ULONG __fastcall tlgWriteTransfer_EventWriteTransfer(
        __int64 a1,
        unsigned __int8 *a2,
        const GUID *a3,
        const GUID *a4,
        ULONG UserDataCount,
        PEVENT_DATA_DESCRIPTOR UserData)
{
  EVENT_DESCRIPTOR EventDescriptor; // [rsp+30h] [rbp-18h] BYREF

  *(_DWORD *)&EventDescriptor.Id = *a2 << 24;
  *(_DWORD *)&EventDescriptor.Level = *(unsigned __int16 *)(a2 + 1);
  EventDescriptor.Keyword = *(_QWORD *)(a2 + 3);
  UserData->Ptr = *(_QWORD *)(a1 + 8);
  UserData->Size = **(unsigned __int16 **)(a1 + 8);
  UserData->Reserved = 2;
  UserData[1].Ptr = (ULONGLONG)(a2 + 11);
  UserData[1].Size = *(unsigned __int16 *)(a2 + 11);
  UserData[1].Reserved = 1;
  return EventWriteTransfer(*(_QWORD *)(a1 + 32), &EventDescriptor, a3, a4, UserDataCount, UserData);
}

//----- (0000000180052674) ----------------------------------------------------
void std::_Rotate<_bstr_t *,__int64,_bstr_t>(__int64 *a1, __int64 a2, __int64 *a3, ...)
{
  __int64 v3; // rbp
  __int64 v5; // r9
  __int64 v7; // rdi
  __int64 v8; // rcx
  __int64 v9; // rax
  __int64 *v10; // rsi
  __int64 v11; // r15
  __int64 *v12; // rbx
  __int64 *v13; // r8
  __int64 v14; // rax
  __int64 v15; // rcx
  __int64 v16; // [rsp+68h] [rbp+20h] BYREF
  va_list va; // [rsp+68h] [rbp+20h]
  va_list va1; // [rsp+70h] [rbp+28h] BYREF

  va_start(va1, a3);
  va_start(va, a3);
  v16 = va_arg(va1, _QWORD);
  v3 = (a2 - (__int64)a1) >> 3;
  v5 = a3 - a1;
  v7 = v5;
  v8 = v3;
  if ( v3 )
  {
    do
    {
      v9 = v7;
      v7 = v8;
      v8 = v9 % v8;
    }
    while ( v8 );
    if ( v7 < v5 && v7 > 0 )
    {
      v10 = &a1[v7];
      v11 = v3;
      do
      {
        v12 = &v10[v11];
        v13 = v10;
        if ( &v10[v11] == a3 )
          v12 = a1;
        do
        {
          v14 = *v13;
          v16 = v14;
          if ( v14 )
            _InterlockedIncrement((volatile signed __int32 *)(v14 + 16));
          _bstr_t::operator=(v13, v12);
          _bstr_t::operator=(v12, (__int64 *)va);
          _bstr_t::_Free((_bstr_t *)va);
          v13 = v12;
          v15 = a3 - v12;
          if ( v3 >= v15 )
            v12 = &a1[v3 - v15];
          else
            v12 = (__int64 *)((char *)v12 + v11 * 8);
        }
        while ( v12 != v10 );
        --v7;
        --v10;
      }
      while ( v7 > 0 );
    }
  }
}

//----- (0000000180052778) ----------------------------------------------------
void __fastcall JobBucket::AddCapability(JobBucket *this, const unsigned __int16 *a2)
{
  __int64 v3; // rdi
  _bstr_t *v4; // rsi
  _QWORD *v5; // rbx
  __int64 v6; // rdi
  _QWORD *v7; // rcx
  __int64 v8; // rax
  __int64 *v9; // r8
  __int64 v10; // rdx
  __int64 *v11; // rcx
  char v12; // [rsp+50h] [rbp+8h] BYREF

  v3 = *((_QWORD *)this + 24);
  v4 = _bstr_t::_bstr_t((_bstr_t *)&v12, a2);
  v5 = (_QWORD *)((char *)this + 184);
  v6 = (v3 - *v5) >> 3;
  v7 = (_QWORD *)v5[1];
  if ( v7 == (_QWORD *)v5[2] )
  {
    std::vector<_bstr_t>::_Reserve(v5);
    v7 = (_QWORD *)v5[1];
  }
  v8 = *(_QWORD *)v4;
  *v7 = *(_QWORD *)v4;
  if ( v8 )
    _InterlockedIncrement((volatile signed __int32 *)(v8 + 16));
  v9 = (__int64 *)(v5[1] + 8LL);
  v5[1] = v9;
  v10 = (__int64)(v9 - 1);
  v11 = (__int64 *)(*v5 + 8 * v6);
  if ( v11 != v9 - 1 && (__int64 *)v10 != v9 )
    std::_Rotate<_bstr_t *,__int64,_bstr_t>(v11, v10, v9);
  _bstr_t::_Free((_bstr_t *)&v12);
}

//----- (0000000180052830) ----------------------------------------------------
void __fastcall JobBucket::SetDisplayName(JobBucket *this, const unsigned __int16 *a2)
{
  _bstr_t::Data_t **v2; // rcx
  __int64 v3; // [rsp+38h] [rbp+10h] BYREF

  v2 = (_bstr_t::Data_t **)((char *)this + 80);
  if ( a2 )
  {
    _bstr_t::operator=(v2, a2);
  }
  else
  {
    v3 = 0LL;
    _bstr_t::operator=((__int64 *)v2, &v3);
    _bstr_t::_Free((_bstr_t *)&v3);
  }
}

//----- (000000018005286C) ----------------------------------------------------
__int64 __fastcall User::GetPrivilegeName(struct _LUID a1, const unsigned __int16 **a2)
{
  unsigned int v2; // edi
  unsigned int v4; // ebx
  struct _LUID Source2; // [rsp+30h] [rbp+8h] BYREF

  Source2 = a1;
  v2 = 0;
  v4 = 0;
  while ( RtlCompareMemory((char *)&unk_1800728D8 + 16 * v4, &Source2, 8uLL) != 8 )
  {
    if ( ++v4 >= 0x23 )
      return v2;
  }
  v2 = 1;
  *a2 = (&off_1800728D0)[2 * v4];
  return v2;
}
// 1800728D0: using guessed type wchar_t *off_1800728D0;

//----- (00000001800528FC) ----------------------------------------------------
void __fastcall CreateDataDescriptor(struct _EVENT_DATA_DESCRIPTOR *a1, const unsigned __int16 *a2)
{
  __int64 v2; // rax
  ULONG v3; // r8d

  if ( a2 )
  {
    v2 = -1LL;
    do
      ++v2;
    while ( a2[v2] );
    v3 = 2 * v2 + 2;
  }
  else
  {
    v3 = 2;
    a2 = &ChannelPath;
  }
  a1->Ptr = (ULONGLONG)a2;
  a1->Size = v3;
  a1->Reserved = 0;
}

//----- (000000018005293C) ----------------------------------------------------
__int64 __fastcall EventManager::EvtReport(
        EventManager *this,
        const struct _EVENT_DESCRIPTOR *a2,
        __int64 a3,
        __int64 a4,
        char a5)
{
  EventManager *v5; // rbx
  __int64 v7; // rcx
  int v8; // eax
  EventManager *v9; // rcx
  int v10; // ebx
  int *v11; // [rsp+20h] [rbp-40h] BYREF
  int v12; // [rsp+28h] [rbp-38h]
  int v13; // [rsp+2Ch] [rbp-34h]
  int *v14; // [rsp+30h] [rbp-30h]
  int v15; // [rsp+38h] [rbp-28h]
  int v16; // [rsp+3Ch] [rbp-24h]
  char *v17; // [rsp+40h] [rbp-20h]
  int v18; // [rsp+48h] [rbp-18h]
  int v19; // [rsp+4Ch] [rbp-14h]
  int v20; // [rsp+80h] [rbp+20h] BYREF
  int v21; // [rsp+88h] [rbp+28h] BYREF

  v21 = a4;
  v20 = a3;
  v5 = g_pEventManager;
  if ( !*(_QWORD *)g_pEventManager )
    return 1LL;
  if ( !(unsigned __int8)EtwEventEnabled(*(_QWORD *)g_pEventManager, &ItSpEvt_PerfTrack_IdleEntryStats, a3, a4) )
    return 0LL;
  v13 = 0;
  v16 = 0;
  v19 = 0;
  v11 = &v20;
  v12 = 4;
  v14 = &v21;
  v15 = 4;
  v18 = 4;
  v7 = *(_QWORD *)v5;
  v17 = &a5;
  v8 = EtwEventWrite(v7, &ItSpEvt_PerfTrack_IdleEntryStats, 3LL, &v11);
  v10 = v8;
  if ( !v8 )
    return 0LL;
  EventManager::LogIt(v9, L"EventWrite error", v8);
  if ( v10 > 0 )
    return (unsigned __int16)v10 | 0x80070000;
  return (unsigned int)v10;
}
// 1800529EF: variable 'v9' is possibly undefined
// 1800746B8: using guessed type __int64 __fastcall EtwEventEnabled(_QWORD, _QWORD, _QWORD, _QWORD);
// 180074768: using guessed type __int64 __fastcall EtwEventWrite(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180052A28) ----------------------------------------------------
__int64 __fastcall EventManager::EvtReport(
        EventManager *this,
        const struct _EVENT_DESCRIPTOR *a2,
        __int64 a3,
        void *a4)
{
  __int64 v6; // rcx
  __int64 v8; // rcx
  int v9; // eax
  EventManager *v10; // rcx
  int v11; // ebx
  int *v12; // [rsp+20h] [rbp-28h] BYREF
  int v13; // [rsp+28h] [rbp-20h]
  int v14; // [rsp+2Ch] [rbp-1Ch]
  int v15; // [rsp+60h] [rbp+18h] BYREF

  v15 = a3;
  v6 = *(_QWORD *)this;
  if ( !v6 )
    return 1LL;
  if ( !(unsigned __int8)EtwEventEnabled(v6, a2, a3, a4) )
    return 0LL;
  v8 = *(_QWORD *)this;
  v14 = 0;
  v12 = &v15;
  v13 = 4;
  v9 = EtwEventWrite(v8, a2, 1LL, &v12);
  v11 = v9;
  if ( !v9 )
    return 0LL;
  EventManager::LogIt(v10, L"EventWrite error", v9);
  if ( v11 > 0 )
    return (unsigned __int16)v11 | 0x80070000;
  return (unsigned int)v11;
}
// 180052AAD: variable 'v10' is possibly undefined
// 1800746B8: using guessed type __int64 __fastcall EtwEventEnabled(_QWORD, _QWORD, _QWORD, _QWORD);
// 180074768: using guessed type __int64 __fastcall EtwEventWrite(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180052AE4) ----------------------------------------------------
__int64 __fastcall EventManager::EvtReport(
        EventManager *this,
        const struct _EVENT_DESCRIPTOR *a2,
        const unsigned __int16 *a3,
        const unsigned __int16 *a4,
        unsigned int a5)
{
  EventManager *v5; // rdi
  __int64 v10; // rcx
  int v11; // eax
  EventManager *v12; // rcx
  int v13; // ebx
  struct _EVENT_DATA_DESCRIPTOR v14; // [rsp+20h] [rbp-58h] BYREF
  struct _EVENT_DATA_DESCRIPTOR v15; // [rsp+30h] [rbp-48h] BYREF
  unsigned int *v16; // [rsp+40h] [rbp-38h]
  int v17; // [rsp+48h] [rbp-30h]
  int v18; // [rsp+4Ch] [rbp-2Ch]

  v5 = g_pEventManager;
  if ( !*(_QWORD *)g_pEventManager )
    return 1LL;
  if ( !(unsigned __int8)EtwEventEnabled(*(_QWORD *)g_pEventManager, a2, a3, a4) )
    return 0LL;
  CreateDataDescriptor(&v14, a3);
  CreateDataDescriptor(&v15, a4);
  v18 = 0;
  v16 = &a5;
  v10 = *(_QWORD *)v5;
  v17 = 4;
  v11 = EtwEventWrite(v10, a2, 3LL, &v14);
  v13 = v11;
  if ( !v11 )
    return 0LL;
  EventManager::LogIt(v12, L"EventWrite error", v11);
  if ( v13 > 0 )
    return (unsigned __int16)v13 | 0x80070000;
  return (unsigned int)v13;
}
// 180052B90: variable 'v12' is possibly undefined
// 1800746B8: using guessed type __int64 __fastcall EtwEventEnabled(_QWORD, _QWORD, _QWORD, _QWORD);
// 180074768: using guessed type __int64 __fastcall EtwEventWrite(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180052BCC) ----------------------------------------------------
__int64 __fastcall EventManager::EvtReport(
        EventManager *this,
        const struct _EVENT_DESCRIPTOR *a2,
        const unsigned __int16 *a3,
        void *a4)
{
  EventManager *v4; // rdi
  int v8; // eax
  EventManager *v9; // rcx
  int v10; // ebx
  struct _EVENT_DATA_DESCRIPTOR v11; // [rsp+20h] [rbp-28h] BYREF

  v4 = g_pEventManager;
  if ( !*(_QWORD *)g_pEventManager )
    return 1LL;
  if ( !(unsigned __int8)EtwEventEnabled(*(_QWORD *)g_pEventManager, a2, a3, a4) )
    return 0LL;
  CreateDataDescriptor(&v11, a3);
  v8 = EtwEventWrite(*(_QWORD *)v4, a2, 1LL, &v11);
  v10 = v8;
  if ( !v8 )
    return 0LL;
  EventManager::LogIt(v9, L"EventWrite error", v8);
  if ( v10 > 0 )
    return (unsigned __int16)v10 | 0x80070000;
  return (unsigned int)v10;
}
// 180052C4E: variable 'v9' is possibly undefined
// 1800746B8: using guessed type __int64 __fastcall EtwEventEnabled(_QWORD, _QWORD, _QWORD, _QWORD);
// 180074768: using guessed type __int64 __fastcall EtwEventWrite(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180052C8C) ----------------------------------------------------
__int64 __fastcall EventManager::EvtReport(
        EventManager *this,
        const struct _EVENT_DESCRIPTOR *a2,
        const unsigned __int16 *a3,
        const struct _GUID *a4)
{
  EventManager *v4; // rsi
  int v9; // eax
  int v10; // edi
  EventManager *v11; // rcx
  __int64 v12[2]; // [rsp+20h] [rbp-40h] BYREF
  struct _EVENT_DATA_DESCRIPTOR v13; // [rsp+30h] [rbp-30h] BYREF
  const struct _GUID *v14; // [rsp+40h] [rbp-20h]
  __int64 v15; // [rsp+48h] [rbp-18h]

  v4 = g_pEventManager;
  if ( !*(_QWORD *)g_pEventManager )
    return 1LL;
  if ( !(unsigned __int8)EtwEventEnabled() )
    return 0LL;
  CreateDataDescriptor(&v13, a3);
  v14 = a4;
  v15 = 16LL;
  EnterCriticalSection((LPCRITICAL_SECTION)((char *)v4 + 8));
  EtwEventActivityIdControl(2LL, a4);
  v9 = EtwEventWrite(*(_QWORD *)v4, a2, 2LL, &v13);
  v12[0] = 0LL;
  v12[1] = 0LL;
  v10 = v9;
  EtwEventActivityIdControl(2LL, v12);
  LeaveCriticalSection((LPCRITICAL_SECTION)((char *)v4 + 8));
  if ( !v10 )
    return 0LL;
  EventManager::LogIt(v11, L"EventWrite error", v10);
  if ( v10 > 0 )
    return (unsigned __int16)v10 | 0x80070000;
  return (unsigned int)v10;
}
// 180052D78: variable 'v11' is possibly undefined
// 1800746B8: using guessed type __int64 EtwEventEnabled(void);
// 1800746C0: using guessed type __int64 __fastcall EtwEventActivityIdControl(_QWORD, _QWORD);
// 180074768: using guessed type __int64 __fastcall EtwEventWrite(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180052DB8) ----------------------------------------------------
errno_t __fastcall EventManager::LogIt(EventManager *this, const unsigned __int16 *a2, int a3)
{
  errno_t result; // eax
  int v6; // [rsp+20h] [rbp-838h]
  FILE *Stream; // [rsp+30h] [rbp-828h] BYREF
  wchar_t Buffer[1024]; // [rsp+40h] [rbp-818h] BYREF

  result = fopen_s(&Stream, "TaskScheduler.log", "a+");
  if ( !result )
  {
    memset_0(Buffer, 0, sizeof(Buffer));
    v6 = a3;
    StringCchPrintfW(Buffer, 0x400uLL, (size_t *)L"%s, (%d)\n", a2, v6);
    Buffer[1023] = 0;
    fputws(Buffer, Stream);
    fflush(Stream);
    fclose(Stream);
    return 0;
  }
  return result;
}

//----- (0000000180052EA4) ----------------------------------------------------
void __fastcall RpcAutoImpersonate::~RpcAutoImpersonate(RpcAutoImpersonate *this)
{
  if ( *(_DWORD *)this )
    RpcRevertToSelf();
}

//----- (0000000180052EC8) ----------------------------------------------------
_QWORD *__fastcall std::_Tree_buy<std::pair<JobMoniker const,_FILETIME>>::_Buynode<std::pair<JobMoniker,_FILETIME>>(
        _QWORD *a1,
        const struct JobMoniker *a2)
{
  __int64 v3; // r8
  _QWORD *v5; // [rsp+48h] [rbp+10h]

  v5 = std::_Tree_buy<std::pair<JobMoniker const,_FILETIME>>::_Buynode0(a1);
  *((_WORD *)v5 + 12) = 0;
  JobMoniker::JobMoniker((JobMoniker *)(v5 + 4), a2, v3);
  v5[9] = *((_QWORD *)a2 + 5);
  return v5;
}
// 180052EFD: variable 'v3' is possibly undefined

//----- (0000000180052F44) ----------------------------------------------------
__int64 *__fastcall std::_Tree<std::_Tmap_traits<JobMoniker,_FILETIME,Scheduler::JobMonikerLess,std::allocator<std::pair<JobMoniker const,_FILETIME>>,0>>::_Insert_at<std::pair<JobMoniker const,_FILETIME> &,std::_Tree_node<std::pair<JobMoniker const,_FILETIME>,void *> *>(
        __int64 *a1,
        __int64 *a2,
        char a3,
        _QWORD *a4,
        int a5,
        __int64 a6)
{
  unsigned __int64 v6; // rax
  __int64 *v7; // r11
  __int64 v9; // r10
  __int64 v10; // rax
  __int64 v11; // rax
  __int64 v12; // r9
  __int64 v13; // rax
  __int64 *v14; // rdx
  __int64 v15; // rcx
  __int64 v16; // rax
  __int64 v17; // rcx
  __int64 *result; // rax

  v6 = a1[1];
  v7 = a1;
  if ( v6 >= 0x333333333333332LL )
  {
    std::_Tree<std::_Tmap_traits<JobMoniker,_FILETIME,Scheduler::JobMonikerLess,std::allocator<std::pair<JobMoniker const,_FILETIME>>,0>>::_Destroy_if_not_nil(
      0x333333333333332LL,
      (wmi::RefBase **)a6);
    std::_Xlength_error("map/set<T> too long");
  }
  v9 = a6;
  a1[1] = v6 + 1;
  *(_QWORD *)(a6 + 8) = a4;
  if ( a4 == (_QWORD *)*a1 )
  {
    *(_QWORD *)(*a1 + 8) = a6;
    *(_QWORD *)*a1 = a6;
    v10 = *a1;
LABEL_9:
    *(_QWORD *)(v10 + 16) = a6;
    goto LABEL_10;
  }
  if ( a3 )
  {
    *a4 = a6;
    if ( a4 == *(_QWORD **)*a1 )
      *(_QWORD *)*a1 = a6;
    goto LABEL_10;
  }
  a4[2] = a6;
  v10 = *a1;
  if ( a4 == *(_QWORD **)(*a1 + 16) )
    goto LABEL_9;
LABEL_10:
  v11 = *(_QWORD *)(a6 + 8);
  v12 = a6;
  while ( !*(_BYTE *)(v11 + 24) )
  {
    v13 = *(_QWORD *)(v12 + 8);
    v14 = *(__int64 **)(v13 + 8);
    v15 = *v14;
    if ( v13 == *v14 )
    {
      v15 = v14[2];
      if ( !*(_BYTE *)(v15 + 24) )
        goto LABEL_17;
      if ( v12 == *(_QWORD *)(v13 + 16) )
        std::_Tree<std::_Tmap_traits<User,LogonJob *,User::less,std::allocator<std::pair<User const,LogonJob *>>,1>>::_Lrotate(
          (__int64)v7,
          *(_QWORD *)(v12 + 8));
      *(_BYTE *)(*(_QWORD *)(v12 + 8) + 24LL) = 1;
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v12 + 8) + 8LL) + 24LL) = 0;
      std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::_Rrotate(
        (__int64)v7,
        *(_QWORD **)(*(_QWORD *)(v12 + 8) + 8LL));
    }
    else
    {
      if ( !*(_BYTE *)(v15 + 24) )
      {
LABEL_17:
        *(_BYTE *)(v13 + 24) = 1;
        *(_BYTE *)(v15 + 24) = 1;
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v12 + 8) + 8LL) + 24LL) = 0;
        v12 = *(_QWORD *)(*(_QWORD *)(v12 + 8) + 8LL);
        goto LABEL_21;
      }
      if ( v12 == *(_QWORD *)v13 )
        std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::_Rrotate(
          (__int64)v7,
          *(_QWORD **)(v12 + 8));
      *(_BYTE *)(*(_QWORD *)(v12 + 8) + 24LL) = 1;
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v12 + 8) + 8LL) + 24LL) = 0;
      std::_Tree<std::_Tmap_traits<User,LogonJob *,User::less,std::allocator<std::pair<User const,LogonJob *>>,1>>::_Lrotate(
        (__int64)v7,
        *(_QWORD *)(*(_QWORD *)(v12 + 8) + 8LL));
    }
LABEL_21:
    v11 = *(_QWORD *)(v12 + 8);
  }
  v16 = *v7;
  *a2 = v9;
  v17 = *(_QWORD *)(v16 + 8);
  result = a2;
  *(_BYTE *)(v17 + 24) = 1;
  return result;
}
// 180052FD3: variable 'v12' is possibly undefined
// 180052FFC: variable 'v7' is possibly undefined
// 180053093: variable 'v9' is possibly undefined

//----- (00000001800530B0) ----------------------------------------------------
__int64 *__fastcall std::_Tree<std::_Tmap_traits<JobMoniker,_FILETIME,Scheduler::JobMonikerLess,std::allocator<std::pair<JobMoniker const,_FILETIME>>,0>>::_Insert_hint<std::pair<JobMoniker const,_FILETIME> &,std::_Tree_node<std::pair<JobMoniker const,_FILETIME>,void *> *>(
        __int64 *a1,
        __int64 *a2,
        BSTR **a3,
        __int64 a4,
        wmi::RefBase **a5)
{
  __int64 **v9; // rcx
  BSTR **v11; // r14
  __int64 v12; // r8
  __int64 *v13; // rax
  BSTR *v14; // rcx
  BSTR *j; // rax
  __int64 *i; // rdx
  BSTR **v17; // rax
  BSTR *v18; // rcx
  BSTR *k; // rcx
  int lpMem; // [rsp+20h] [rbp-58h]
  int v21[2]; // [rsp+38h] [rbp-40h] BYREF
  BSTR *v22; // [rsp+80h] [rbp+8h]
  BSTR **v23; // [rsp+80h] [rbp+8h]

  v9 = (__int64 **)*a1;
  if ( !a1[1] )
  {
    std::_Tree<std::_Tmap_traits<JobMoniker,_FILETIME,Scheduler::JobMonikerLess,std::allocator<std::pair<JobMoniker const,_FILETIME>>,0>>::_Insert_at<std::pair<JobMoniker const,_FILETIME> &,std::_Tree_node<std::pair<JobMoniker const,_FILETIME>,void *> *>(
      a1,
      a2,
      1,
      v9,
      lpMem,
      (__int64)a5);
    return a2;
  }
  v11 = (BSTR **)(a4 + 16);
  if ( a3 == (BSTR **)*v9 )
  {
    if ( (int)_bstr_t::_Compare((BSTR **)(a4 + 16), a3 + 6) < 0 )
    {
      std::_Tree<std::_Tmap_traits<JobMoniker,_FILETIME,Scheduler::JobMonikerLess,std::allocator<std::pair<JobMoniker const,_FILETIME>>,0>>::_Insert_at<std::pair<JobMoniker const,_FILETIME> &,std::_Tree_node<std::pair<JobMoniker const,_FILETIME>,void *> *>(
        a1,
        a2,
        1,
        a3,
        lpMem,
        (__int64)a5);
      return a2;
    }
    goto LABEL_44;
  }
  if ( a3 == (BSTR **)v9 )
  {
    if ( (int)_bstr_t::_Compare((BSTR **)v9[2] + 6, (BSTR **)(a4 + 16)) < 0 )
    {
      std::_Tree<std::_Tmap_traits<JobMoniker,_FILETIME,Scheduler::JobMonikerLess,std::allocator<std::pair<JobMoniker const,_FILETIME>>,0>>::_Insert_at<std::pair<JobMoniker const,_FILETIME> &,std::_Tree_node<std::pair<JobMoniker const,_FILETIME>,void *> *>(
        a1,
        a2,
        0,
        *(_QWORD **)(*a1 + 16),
        lpMem,
        (__int64)a5);
      return a2;
    }
    goto LABEL_44;
  }
  if ( (int)_bstr_t::_Compare((BSTR **)(a4 + 16), a3 + 6) < 0 )
  {
    v13 = (__int64 *)a3;
    if ( *((_BYTE *)a3 + 25) )
    {
      v14 = a3[2];
    }
    else
    {
      v14 = *a3;
      if ( *((_BYTE *)*a3 + 25) )
      {
        for ( i = (__int64 *)a3[1]; !*((_BYTE *)i + 25) && v13 == (__int64 *)*i; i = (__int64 *)i[1] )
          v13 = i;
        v14 = (BSTR *)v13;
        if ( !*((_BYTE *)v13 + 25) )
          v14 = (BSTR *)i;
      }
      else
      {
        for ( j = (BSTR *)v14[2]; !*((_BYTE *)j + 25); j = (BSTR *)j[2] )
          v14 = j;
      }
    }
    v22 = v14;
    if ( (int)_bstr_t::_Compare((BSTR **)v14 + 6, v11) < 0 )
    {
      if ( *((_BYTE *)v22[2] + 25) )
        std::_Tree<std::_Tmap_traits<JobMoniker,_FILETIME,Scheduler::JobMonikerLess,std::allocator<std::pair<JobMoniker const,_FILETIME>>,0>>::_Insert_at<std::pair<JobMoniker const,_FILETIME> &,std::_Tree_node<std::pair<JobMoniker const,_FILETIME>,void *> *>(
          a1,
          a2,
          0,
          v22,
          lpMem,
          (__int64)a5);
      else
        std::_Tree<std::_Tmap_traits<JobMoniker,_FILETIME,Scheduler::JobMonikerLess,std::allocator<std::pair<JobMoniker const,_FILETIME>>,0>>::_Insert_at<std::pair<JobMoniker const,_FILETIME> &,std::_Tree_node<std::pair<JobMoniker const,_FILETIME>,void *> *>(
          a1,
          a2,
          1,
          a3,
          lpMem,
          (__int64)a5);
      return a2;
    }
  }
  if ( (int)_bstr_t::_Compare(a3 + 6, v11) >= 0 )
    goto LABEL_44;
  v17 = a3;
  v23 = a3;
  if ( !*((_BYTE *)a3 + 25) )
  {
    v18 = a3[2];
    if ( *((_BYTE *)v18 + 25) )
    {
      for ( k = a3[1]; !*((_BYTE *)k + 25) && v17 == (BSTR **)k[2]; k = (BSTR *)k[1] )
        v17 = (BSTR **)k;
      v17 = (BSTR **)k;
      v23 = (BSTR **)k;
    }
    else
    {
      v17 = (BSTR **)std::_Tree_val<std::_Tree_simple_types<std::pair<_bstr_t const,std::list<_FILETIME> *>>>::_Min(v18);
      v23 = v17;
    }
  }
  if ( v17 == (BSTR **)*a1 )
    goto LABEL_40;
  if ( (int)_bstr_t::_Compare(v11, v17 + 6) >= 0 )
  {
LABEL_44:
    *a2 = *(_QWORD *)std::_Tree<std::_Tmap_traits<JobMoniker,_FILETIME,Scheduler::JobMonikerLess,std::allocator<std::pair<JobMoniker const,_FILETIME>>,0>>::_Insert_nohint<std::pair<JobMoniker const,_FILETIME> &,std::_Tree_node<std::pair<JobMoniker const,_FILETIME>,void *> *>(
                       a1,
                       (__int64)v21,
                       v12,
                       a4,
                       a5);
    return a2;
  }
  v17 = v23;
LABEL_40:
  if ( *((_BYTE *)a3[2] + 25) )
    std::_Tree<std::_Tmap_traits<JobMoniker,_FILETIME,Scheduler::JobMonikerLess,std::allocator<std::pair<JobMoniker const,_FILETIME>>,0>>::_Insert_at<std::pair<JobMoniker const,_FILETIME> &,std::_Tree_node<std::pair<JobMoniker const,_FILETIME>,void *> *>(
      a1,
      a2,
      0,
      a3,
      lpMem,
      (__int64)a5);
  else
    std::_Tree<std::_Tmap_traits<JobMoniker,_FILETIME,Scheduler::JobMonikerLess,std::allocator<std::pair<JobMoniker const,_FILETIME>>,0>>::_Insert_at<std::pair<JobMoniker const,_FILETIME> &,std::_Tree_node<std::pair<JobMoniker const,_FILETIME>,void *> *>(
      a1,
      a2,
      1,
      v17,
      lpMem,
      (__int64)a5);
  return a2;
}
// 1800530FD: variable 'lpMem' is possibly undefined
// 180053354: variable 'v12' is possibly undefined

//----- (00000001800533A8) ----------------------------------------------------
__int64 __fastcall std::_Tree<std::_Tmap_traits<JobMoniker,_FILETIME,Scheduler::JobMonikerLess,std::allocator<std::pair<JobMoniker const,_FILETIME>>,0>>::_Insert_nohint<std::pair<JobMoniker const,_FILETIME> &,std::_Tree_node<std::pair<JobMoniker const,_FILETIME>,void *> *>(
        __int64 *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        wmi::RefBase **lpMem)
{
  wmi::RefBase **v7; // r14
  __int64 v8; // rsi
  __int64 v9; // rbx
  char v10; // r15
  BSTR **v11; // r13
  __int64 v12; // rbx
  __int64 v14; // rax
  __int64 i; // rax
  int v16; // [rsp+20h] [rbp-48h]
  __int64 v17; // [rsp+70h] [rbp+8h] BYREF
  __int64 v18; // [rsp+88h] [rbp+20h]

  v18 = a4;
  v7 = lpMem;
  v8 = *a1;
  v9 = *(_QWORD *)(*a1 + 8);
  v10 = 1;
  if ( !*(_BYTE *)(v9 + 25) )
  {
    v11 = (BSTR **)(a4 + 16);
    do
    {
      v8 = v9;
      if ( (int)_bstr_t::_Compare(v11, (BSTR **)(v9 + 48)) >= 0 )
      {
        v10 = 0;
        v9 = *(_QWORD *)(v9 + 16);
      }
      else
      {
        v10 = 1;
        v9 = *(_QWORD *)v9;
      }
    }
    while ( !*(_BYTE *)(v9 + 25) );
    a4 = v18;
  }
  v12 = v8;
  if ( v10 )
  {
    if ( v8 == *(_QWORD *)*a1 )
    {
      *(_QWORD *)a2 = *std::_Tree<std::_Tmap_traits<JobMoniker,_FILETIME,Scheduler::JobMonikerLess,std::allocator<std::pair<JobMoniker const,_FILETIME>>,0>>::_Insert_at<std::pair<JobMoniker const,_FILETIME> &,std::_Tree_node<std::pair<JobMoniker const,_FILETIME>,void *> *>(
                         a1,
                         &v17,
                         1,
                         (_QWORD *)v8,
                         v16,
                         (__int64)v7);
      *(_BYTE *)(a2 + 8) = 1;
      return a2;
    }
    if ( *(_BYTE *)(v8 + 25) )
    {
      v12 = *(_QWORD *)(v8 + 16);
    }
    else
    {
      v14 = *(_QWORD *)v8;
      if ( *(_BYTE *)(*(_QWORD *)v8 + 25LL) )
      {
        for ( i = *(_QWORD *)(v8 + 8); !*(_BYTE *)(i + 25) && v12 == *(_QWORD *)i; i = *(_QWORD *)(i + 8) )
          v12 = i;
        if ( !*(_BYTE *)(v12 + 25) )
          v12 = i;
      }
      else
      {
        do
        {
          v12 = v14;
          v14 = *(_QWORD *)(v14 + 16);
        }
        while ( !*(_BYTE *)(v14 + 25) );
      }
    }
  }
  if ( (int)_bstr_t::_Compare((BSTR **)(v12 + 48), (BSTR **)(a4 + 16)) >= 0 )
  {
    wmi::AutoRef<JobBucket>::Release(v7 + 8);
    _bstr_t::_Free((_bstr_t *)(v7 + 6));
    operator delete(v7);
    *(_QWORD *)a2 = v12;
    *(_BYTE *)(a2 + 8) = 0;
  }
  else
  {
    *(_QWORD *)a2 = *std::_Tree<std::_Tmap_traits<JobMoniker,_FILETIME,Scheduler::JobMonikerLess,std::allocator<std::pair<JobMoniker const,_FILETIME>>,0>>::_Insert_at<std::pair<JobMoniker const,_FILETIME> &,std::_Tree_node<std::pair<JobMoniker const,_FILETIME>,void *> *>(
                       a1,
                       &v17,
                       v10,
                       (_QWORD *)v8,
                       v16,
                       (__int64)v7);
    *(_BYTE *)(a2 + 8) = 1;
  }
  return a2;
}
// 180053444: variable 'v16' is possibly undefined

//----- (000000018005353C) ----------------------------------------------------
ScheduleListItem *__fastcall ScheduleListItem::ScheduleListItem(
        ScheduleListItem *this,
        const struct Scheduling::JobSchedule *a2,
        const struct JobMoniker *a3)
{
  ScheduleListItem *result; // rax

  *((_QWORD *)this + 1) = 0LL;
  *((_QWORD *)this + 2) = 0LL;
  *(_QWORD *)this = &ScheduleListItem::`vftable';
  JobMoniker::JobMoniker((ScheduleListItem *)((char *)this + 24), a3, (__int64)a3);
  result = this;
  *((_OWORD *)this + 4) = *(_OWORD *)a2;
  *((_OWORD *)this + 5) = *((_OWORD *)a2 + 1);
  *((_OWORD *)this + 6) = *((_OWORD *)a2 + 2);
  *((_OWORD *)this + 7) = *((_OWORD *)a2 + 3);
  *((_OWORD *)this + 8) = *((_OWORD *)a2 + 4);
  *((_QWORD *)this + 18) = *((_QWORD *)a2 + 10);
  return result;
}
// 180070450: using guessed type void *ScheduleListItem::`vftable';

//----- (00000001800535B8) ----------------------------------------------------
void __fastcall RunList::~RunList(RunList *this)
{
  __int64 i; // rcx
  __int64 v3; // rbx
  void (__fastcall ***v4)(_QWORD, __int64); // rcx

  for ( i = *((_QWORD *)this + 1); *(_DWORD *)(i + 24) || *(_DWORD *)(i + 28); i = v3 )
  {
    v3 = *(_QWORD *)(i + 8);
    CDLink::UnLink((CDLink *)i);
    --*((_DWORD *)this + 10);
    (**v4)(v4, 1LL);
  }
  *((_QWORD *)this + 1) = 0LL;
  *((_QWORD *)this + 2) = 0LL;
  *(_QWORD *)this = &RunListItem::`vftable';
}
// 1800535E6: variable 'v4' is possibly undefined
// 180070228: using guessed type void *RunListItem::`vftable';

//----- (0000000180053620) ----------------------------------------------------
void __fastcall ScheduleListItem::~ScheduleListItem(wmi::RefBase **this)
{
  *this = (wmi::RefBase *)&ScheduleListItem::`vftable';
  wmi::AutoRef<JobBucket>::Release(this + 7);
  _bstr_t::_Free((_bstr_t *)(this + 5));
  this[1] = 0LL;
  this[2] = 0LL;
  *this = (wmi::RefBase *)&RunListItem::`vftable';
}
// 180070228: using guessed type void *RunListItem::`vftable';
// 180070450: using guessed type void *ScheduleListItem::`vftable';

//----- (0000000180053668) ----------------------------------------------------
BSTR **__fastcall std::map<JobMoniker,_FILETIME,Scheduler::JobMonikerLess,std::allocator<std::pair<JobMoniker const,_FILETIME>>>::operator[](
        BSTR ***a1,
        BSTR **a2,
        __int64 a3)
{
  BSTR **v5; // rbx
  BSTR *v6; // rdi
  BSTR **v7; // rax
  wmi::RefBase **v8; // rax
  __int64 v10[2]; // [rsp+30h] [rbp-68h] BYREF
  char v11[16]; // [rsp+40h] [rbp-58h] BYREF
  char v12[16]; // [rsp+50h] [rbp-48h] BYREF
  wmi::RefBase *v13[2]; // [rsp+60h] [rbp-38h] BYREF

  v10[1] = -2LL;
  v5 = *a1;
  v6 = (*a1)[1];
  v7 = *a1;
  if ( !*((_BYTE *)v6 + 25) )
  {
    do
    {
      if ( (int)_bstr_t::_Compare((BSTR **)v6 + 6, a2 + 2) >= 0 )
      {
        v5 = (BSTR **)v6;
        v6 = (BSTR *)*v6;
      }
      else
      {
        v6 = (BSTR *)v6[2];
      }
    }
    while ( !*((_BYTE *)v6 + 25) );
    v7 = *a1;
  }
  if ( v5 == v7 || (int)_bstr_t::_Compare(a2 + 2, v5 + 6) < 0 )
  {
    JobMoniker::JobMoniker((JobMoniker *)v11, (const struct JobMoniker *)a2, a3);
    v13[1] = 0LL;
    v8 = (wmi::RefBase **)std::_Tree_buy<std::pair<JobMoniker const,_FILETIME>>::_Buynode<std::pair<JobMoniker,_FILETIME>>(
                            a1,
                            (const struct JobMoniker *)v11);
    std::_Tree<std::_Tmap_traits<JobMoniker,_FILETIME,Scheduler::JobMonikerLess,std::allocator<std::pair<JobMoniker const,_FILETIME>>,0>>::_Insert_hint<std::pair<JobMoniker const,_FILETIME> &,std::_Tree_node<std::pair<JobMoniker const,_FILETIME>,void *> *>(
      (__int64 *)a1,
      v10,
      v5,
      (__int64)(v8 + 4),
      v8);
    v5 = (BSTR **)v10[0];
    wmi::AutoRef<JobBucket>::Release(v13);
    _bstr_t::_Free((_bstr_t *)v12);
  }
  return v5 + 9;
}
// 1800536EF: variable 'a3' is possibly undefined
// 180053668: using guessed type char var_48[16];

//----- (0000000180053780) ----------------------------------------------------
wmi::RefBase **__fastcall ScheduleListItem::`scalar deleting destructor'(wmi::RefBase **this, char a2)
{
  ScheduleListItem::~ScheduleListItem(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (00000001800537B8) ----------------------------------------------------
__int64 __fastcall ScheduleList::Add(
        ScheduleList *this,
        const struct JobMoniker *a2,
        const struct Scheduling::JobSchedule *a3)
{
  const wchar_t *Path; // rax
  ScheduleListItem *v7; // rax
  CDLink *v8; // rcx
  struct CDLink *v10; // rdx

  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x2000) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
  {
    Path = JobMoniker::GetPath(a2);
    WPP_SF_S(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x11u,
      (__int64)&WPP_5435fee58aaf3c352ed5cdc6abf88a31_Traceguids,
      Path);
  }
  v7 = (ScheduleListItem *)operator new(0x98uLL);
  if ( v7 )
    v8 = ScheduleListItem::ScheduleListItem(v7, a3, a2);
  else
    v8 = 0LL;
  if ( !v8 )
    return 2147942414LL;
  v10 = (struct CDLink *)*((_QWORD *)this + 2);
  if ( v10 )
  {
    CDLink::LinkAfter(v8, v10);
    return 0LL;
  }
  else
  {
    (**(void (__fastcall ***)(CDLink *, __int64))v8)(v8, 1LL);
    return 2147549183LL;
  }
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180053890) ----------------------------------------------------
__int64 __fastcall Scheduler::AddJobSchedule(
        Scheduler *this,
        struct Scheduling::JobSchedule *a2,
        struct JobMoniker *a3,
        unsigned int *a4)
{
  struct _RTL_CRITICAL_SECTION *v8; // rbx
  int v9; // edi
  __int128 v11; // [rsp+40h] [rbp-48h] BYREF
  __int128 v12; // [rsp+50h] [rbp-38h] BYREF
  __int128 v13; // [rsp+60h] [rbp-28h] BYREF

  v8 = (struct _RTL_CRITICAL_SECTION *)((char *)this + 32);
  EnterCriticalSection((LPCRITICAL_SECTION)((char *)this + 32));
  v9 = ScheduleList::Add((Scheduler *)((char *)this + 320), a3, a2);
  if ( v9 >= 0 )
  {
    if ( *a4
      || (*(_BYTE *)(*((_QWORD *)a3 + 4) + 16LL) & 0x40) == 0
      || (v9 = Scheduler::EnqueueMissedRun(this, a2, a3, a4), v9 >= 0) )
    {
      v12 = *((_OWORD *)this + 19);
      TSTime::TSTime((TSTime *)&v11);
      v13 = v11;
      v9 = Scheduler::EvaluateScheduledJob((__int64)this, (__int64)a2, a3, &v13, &v12);
    }
  }
  LeaveCriticalSection(v8);
  return (unsigned int)v9;
}

//----- (0000000180053998) ----------------------------------------------------
void __fastcall ScheduleListItem::Delete(ScheduleListItem *this)
{
  void (__fastcall ***v1)(_QWORD, __int64); // rcx

  CDLink::UnLink(this);
  if ( v1 )
    (**v1)(v1, 1LL);
}
// 1800539A4: variable 'v1' is possibly undefined

//----- (00000001800539C4) ----------------------------------------------------
__int64 __fastcall Scheduler::EnqueueExpiredTaskDeletion(Scheduler *this, const wchar_t **a2, const struct TSTime *a3)
{
  int v6; // esi
  int v8; // edi
  _QWORD v9[3]; // [rsp+40h] [rbp-91h] BYREF
  __int128 v10; // [rsp+58h] [rbp-79h] BYREF
  __int128 v11[4]; // [rsp+68h] [rbp-69h] BYREF
  int v12; // [rsp+B4h] [rbp-1Dh]
  unsigned __int16 v13[28]; // [rsp+C8h] [rbp-9h] BYREF

  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 8) != 0 )
  {
    TSTime::ToString(a3, v13, 28);
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 8) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
    {
      WPP_SF_SS(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0xEu,
        (__int64)&WPP_5435fee58aaf3c352ed5cdc6abf88a31_Traceguids,
        a2[3],
        (__int64)v13);
    }
  }
  Scheduling::JobSchedule::JobSchedule((struct _FILETIME *)v11);
  v11[0] = *(_OWORD *)a3;
  v11[1] = v11[0];
  v12 = 2;
  EnterCriticalSection((LPCRITICAL_SECTION)((char *)this + 32));
  v6 = ScheduleList::Add(
         (Scheduler *)((char *)this + 320),
         (const struct JobMoniker *)a2,
         (const struct Scheduling::JobSchedule *)v11);
  if ( v6 >= 0 )
  {
    *(_OWORD *)&v9[1] = *(_OWORD *)a3;
    v10 = *(_OWORD *)&v9[1];
    v8 = Scheduler::EvaluateScheduledJob((__int64)this, (__int64)v11, (JobMoniker *)a2, &v10, (__int128 *)&v9[1]);
    if ( v8 >= 1 )
      v8 = -2147418113;
    LeaveCriticalSection((LPCRITICAL_SECTION)((char *)this + 32));
    return (unsigned int)v8;
  }
  else
  {
    LeaveCriticalSection((LPCRITICAL_SECTION)((char *)this + 32));
    return (unsigned int)v6;
  }
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180053B44) ----------------------------------------------------
__int64 __fastcall Scheduler::EnqueueMissedRun(
        Scheduler *this,
        struct Scheduling::JobSchedule *a2,
        struct JobMoniker *a3,
        unsigned int *a4)
{
  __int64 Stop; // rax
  const wchar_t *Path; // rax
  unsigned __int16 v9; // dx
  __int64 result; // rax
  BSTR **v11; // rbx
  __int64 v12; // r8
  int RunTimes; // esi
  void **v14; // rax
  const wchar_t *v15; // rax
  __int64 v16; // rdx
  __int64 v17; // r8
  CDLink *v18; // rsi
  const wchar_t *v19; // rax
  const struct TSTime *v20; // rax
  __int64 v21; // r8
  BSTR **v22; // rax
  const wchar_t *v23; // rax
  CDLink *i; // rcx
  CDLink *v25; // rbx
  void (__fastcall ***v26)(_QWORD, __int64); // rcx
  __int128 v27; // [rsp+40h] [rbp-C0h] BYREF
  unsigned int *v28; // [rsp+50h] [rbp-B0h]
  __int128 v29; // [rsp+60h] [rbp-A0h] BYREF
  __int128 v30; // [rsp+70h] [rbp-90h] BYREF
  _BYTE v31[20]; // [rsp+80h] [rbp-80h] BYREF
  __int64 v32; // [rsp+94h] [rbp-6Ch]
  __int64 v33; // [rsp+9Ch] [rbp-64h]
  void **v34; // [rsp+A8h] [rbp-58h] BYREF
  CDLink *v35; // [rsp+B0h] [rbp-50h]
  void ***v36; // [rsp+B8h] [rbp-48h]
  __int64 v37; // [rsp+C0h] [rbp-40h]
  __int64 v38; // [rsp+C8h] [rbp-38h]
  int v39; // [rsp+D0h] [rbp-30h]
  int v40; // [rsp+D4h] [rbp-2Ch]
  int v41; // [rsp+D8h] [rbp-28h]
  __int128 v42; // [rsp+E0h] [rbp-20h] BYREF
  __int64 v43; // [rsp+F0h] [rbp-10h]
  unsigned __int16 v44[8]; // [rsp+F8h] [rbp-8h] BYREF
  __int128 v45; // [rsp+108h] [rbp+8h]
  __int128 v46; // [rsp+118h] [rbp+18h]
  __int64 v47; // [rsp+128h] [rbp+28h]
  unsigned __int16 v48[8]; // [rsp+130h] [rbp+30h] BYREF
  __int128 v49; // [rsp+140h] [rbp+40h]
  __int128 v50; // [rsp+150h] [rbp+50h]
  __int64 v51; // [rsp+160h] [rbp+60h]

  v43 = -2LL;
  v28 = a4;
  TSTime::TSTime((TSTime *)&v29);
  Stop = Scheduling::JobSchedule::GetStop((__int64)a2, (__int64)&v27);
  if ( TSTime::operator<(Stop, &v29) )
  {
    if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
      || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) == 0
      || *((_BYTE *)WPP_GLOBAL_Control + 25) < 4u )
    {
      return 0LL;
    }
    Path = JobMoniker::GetPath(a3);
    v9 = 24;
LABEL_13:
    WPP_SF_S(*((_QWORD *)WPP_GLOBAL_Control + 2), v9, (__int64)&WPP_5435fee58aaf3c352ed5cdc6abf88a31_Traceguids, Path);
    return 0LL;
  }
  *(_QWORD *)v31 = 3LL;
  v32 = 0LL;
  *(_QWORD *)&v31[8] = 0LL;
  v33 = 0LL;
  *(_DWORD *)&v31[16] = 0;
  result = JobStore::GetDynamicTaskInfo(JobStore::m_pCommonStore, a3, (struct DynamicTaskInfo *)v31, 0x20019u, 0LL);
  if ( (int)result < 0 )
    return result;
  v11 = (BSTR **)*((_QWORD *)this + 34);
  if ( *std::_Tree<std::_Tmap_traits<JobMoniker,_FILETIME,Scheduler::JobMonikerLess,std::allocator<std::pair<JobMoniker const,_FILETIME>>,0>>::find(
          (BSTR ***)this + 34,
          (BSTR ***)&v27,
          (__int64)a3) != v11 )
  {
    LOBYTE(v27) = 0;
    *((_QWORD *)&v27 + 1) = *(_QWORD *)&v31[12];
    LOBYTE(v29) = 0;
    *((_QWORD *)&v29 + 1) = *std::map<JobMoniker,_FILETIME,Scheduler::JobMonikerLess,std::allocator<std::pair<JobMoniker const,_FILETIME>>>::operator[](
                               (BSTR ***)this + 34,
                               (BSTR **)a3,
                               v12);
    if ( TSTime::operator==((__int64)&v29, &v27) )
    {
      if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
        || (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) == 0
        || *((_BYTE *)WPP_GLOBAL_Control + 25) < 4u )
      {
        return 0LL;
      }
      Path = JobMoniker::GetPath(a3);
      v9 = 25;
      goto LABEL_13;
    }
  }
  LOBYTE(v30) = 0;
  *((_QWORD *)&v30 + 1) = *(_QWORD *)&v31[12];
  LOBYTE(v42) = 0;
  *((_QWORD *)&v42 + 1) = *(_QWORD *)&v31[4];
  if ( TSTime::operator<((__int64)&v30, &v42) )
    v30 = v42;
  *(_QWORD *)&v27 = 5000000LL;
  TSTime::operator+=((__int64)&v30, (__int64 *)&v27);
  v34 = &RunListItem::`vftable';
  v37 = 0LL;
  v38 = 0LL;
  v39 = 0;
  v40 = -1;
  v41 = 0;
  v35 = (CDLink *)&v34;
  v36 = &v34;
  v29 = *((_OWORD *)this + 18);
  v27 = v30;
  RunTimes = Scheduling::JobSchedule::GetRunTimes((__int64)a2, (TSTime *)&v27, (TSTime *)&v29, (__int64)&v34, 1);
  if ( RunTimes >= 0 )
  {
    *(_OWORD *)v48 = 0LL;
    v49 = 0LL;
    v50 = 0LL;
    v51 = 0LL;
    *(_OWORD *)v44 = 0LL;
    v45 = 0LL;
    v46 = 0LL;
    v47 = 0LL;
    v14 = (void **)WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0 )
    {
      TSTime::ToString((TSTime *)&v30, v48, 28);
      TSTime::ToString((Scheduler *)((char *)this + 288), v44, 28);
      v14 = (void **)WPP_GLOBAL_Control;
    }
    if ( RunTimes == 267012 )
    {
      if ( v14 != &WPP_GLOBAL_Control && (*((_BYTE *)v14 + 28) & 0x20) != 0 && *((_BYTE *)v14 + 25) >= 4u )
      {
        v15 = JobMoniker::GetPath(a3);
        WPP_SF_SSS(*((_QWORD *)WPP_GLOBAL_Control + 2), v16, v17, v15, (__int64)v48, (__int64)v44);
      }
      RunTimes = 0;
    }
    else
    {
      v18 = v35;
      if ( *((_DWORD *)v35 + 6) || *((_DWORD *)v35 + 7) )
      {
        v20 = (const struct TSTime *)Scheduling::JobSchedule::GetStop((__int64)a2, (__int64)&v29);
        RunTimes = SortedRunList::AddSorted((Scheduler *)((char *)this + 176), v18, a3, v20);
        if ( RunTimes >= 0 )
        {
          ++*v28;
          v22 = std::map<JobMoniker,_FILETIME,Scheduler::JobMonikerLess,std::allocator<std::pair<JobMoniker const,_FILETIME>>>::operator[](
                  (BSTR ***)this + 34,
                  (BSTR **)a3,
                  v21);
          *v22 = *(BSTR **)&v31[12];
        }
        v14 = (void **)WPP_GLOBAL_Control;
      }
      else
      {
        if ( v14 != &WPP_GLOBAL_Control && (*((_BYTE *)v14 + 28) & 0x20) != 0 && *((_BYTE *)v14 + 25) >= 2u )
        {
          v19 = JobMoniker::GetPath(a3);
          WPP_SF_S(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x1Bu,
            (__int64)&WPP_5435fee58aaf3c352ed5cdc6abf88a31_Traceguids,
            v19);
          v14 = (void **)WPP_GLOBAL_Control;
        }
        RunTimes = 0;
      }
      if ( v14 != &WPP_GLOBAL_Control
        && (*((_BYTE *)v14 + 28) & 0x20) != 0
        && *((unsigned __int8 *)v14 + 25) >= (int)(((RunTimes >> 31) & 0xFFFFFFFE) + 4) )
      {
        v23 = JobMoniker::GetPath(a3);
        WPP_SF_SSSDd(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x1Cu,
          (__int64)&WPP_5435fee58aaf3c352ed5cdc6abf88a31_Traceguids,
          v23,
          (__int64)v48,
          (__int64)v44);
      }
    }
  }
  for ( i = v35; *((_DWORD *)i + 6) || *((_DWORD *)i + 7); i = v25 )
  {
    v25 = (CDLink *)*((_QWORD *)i + 1);
    CDLink::UnLink(i);
    --v39;
    (**v26)(v26, 1LL);
  }
  return (unsigned int)RunTimes;
}
// 180053C5F: variable 'v12' is possibly undefined
// 180053E42: variable 'v16' is possibly undefined
// 180053E42: variable 'v17' is possibly undefined
// 180053ED7: variable 'v21' is possibly undefined
// 180053F77: variable 'v26' is possibly undefined
// 180070228: using guessed type void *RunListItem::`vftable';
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180053FC4) ----------------------------------------------------
__int64 __fastcall Scheduler::EvaluateScheduledJob(__int64 a1, __int64 a2, JobMoniker *a3, __int128 *a4, __int128 *a5)
{
  int RunTimes; // edi
  unsigned int v8; // ecx
  const wchar_t *Path; // rax
  __int64 v10; // rdx
  __int64 v11; // r8
  CDLink *v12; // rsi
  char v13; // r15
  const struct TSTime *Stop; // rax
  JobStore *v15; // rbx
  const wchar_t *v16; // rax
  signed int LastError; // eax
  CDLink *i; // rcx
  CDLink *v19; // rbx
  void (__fastcall ***v20)(_QWORD, __int64); // rcx
  __int128 v22; // [rsp+48h] [rbp-41h] BYREF
  __int128 v23; // [rsp+58h] [rbp-31h] BYREF
  void **v24; // [rsp+68h] [rbp-21h] BYREF
  CDLink *v25; // [rsp+70h] [rbp-19h]
  void ***v26; // [rsp+78h] [rbp-11h]
  __int64 v27; // [rsp+80h] [rbp-9h]
  __int64 v28; // [rsp+88h] [rbp-1h]
  int v29; // [rsp+90h] [rbp+7h]
  int v30; // [rsp+94h] [rbp+Bh]
  int v31; // [rsp+98h] [rbp+Fh]
  FILETIME FileTime1; // [rsp+100h] [rbp+77h] BYREF

  v24 = &RunListItem::`vftable';
  v27 = 0LL;
  v28 = 0LL;
  v29 = 0;
  v30 = -1;
  v31 = 0;
  v25 = (CDLink *)&v24;
  v26 = &v24;
  v22 = *a5;
  v23 = *a4;
  RunTimes = Scheduling::JobSchedule::GetRunTimes(a2, (TSTime *)&v23, (TSTime *)&v22, (__int64)&v24, -1);
  LODWORD(a5) = RunTimes;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x2000) != 0 )
  {
    v8 = 4;
    if ( RunTimes < 0 )
      v8 = 2;
    if ( *((unsigned __int8 *)WPP_GLOBAL_Control + 25) >= v8 )
    {
      Path = JobMoniker::GetPath(a3);
      WPP_SF_SDd(*((_QWORD *)WPP_GLOBAL_Control + 2), v10, v11, Path);
    }
  }
  if ( RunTimes >= 0 )
  {
    v12 = v25;
    v13 = 0;
    while ( *((_DWORD *)v12 + 6) || *((_DWORD *)v12 + 7) )
    {
      FileTime1 = (FILETIME)*((_QWORD *)v12 + 3);
      *(_QWORD *)&v22 = a1 + 32;
      EnterCriticalSection((LPCRITICAL_SECTION)(a1 + 32));
      Stop = (const struct TSTime *)Scheduling::JobSchedule::GetStop(a2, (__int64)&v23);
      SortedRunList::AddSorted((SortedRunList *)(a1 + 72), v12, a3, Stop);
      if ( CompareFileTime(&FileTime1, (const FILETIME *)(a1 + 168)) < 0 )
      {
        *(FILETIME *)(a1 + 168) = FileTime1;
        v13 = 1;
      }
      LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 32));
      v12 = (CDLink *)*((_QWORD *)v12 + 1);
    }
    RunTimes = (int)a5;
    if ( v13 )
    {
      if ( *(_QWORD *)(a1 + 24) )
      {
        v15 = JobStore::m_pCommonStore;
        JobStore::WaitForConfiguration(JobStore::m_pCommonStore);
        if ( *(_DWORD *)(*((_QWORD *)v15 + 10) + 136LL) > 9u )
          TraceTime("Scheduler::EvaluateScheduledJob: nextRun=", (struct _FILETIME *)(a1 + 168), a3);
        if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
          && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x2000) != 0
          && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
        {
          v16 = JobMoniker::GetPath(a3);
          WPP_SF_S(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0xDu,
            (__int64)&WPP_5435fee58aaf3c352ed5cdc6abf88a31_Traceguids,
            v16);
        }
        if ( !SetEvent(*(HANDLE *)(a1 + 24)) )
        {
          LastError = GetLastError();
          RunTimes = LastError;
          if ( LastError > 0 )
            RunTimes = (unsigned __int16)LastError | 0x80070000;
        }
      }
    }
  }
  for ( i = v25; *((_DWORD *)i + 6) || *((_DWORD *)i + 7); i = v19 )
  {
    v19 = (CDLink *)*((_QWORD *)i + 1);
    CDLink::UnLink(i);
    --v29;
    (**v20)(v20, 1LL);
  }
  return (unsigned int)RunTimes;
}
// 1800540B3: variable 'v10' is possibly undefined
// 1800540B3: variable 'v11' is possibly undefined
// 180054239: variable 'v20' is possibly undefined
// 180070228: using guessed type void *RunListItem::`vftable';
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180054290) ----------------------------------------------------
void __fastcall Scheduler::JobEnded(Scheduler *a1, wmi::RefBase **a2)
{
  const wchar_t *Path; // rax

  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 0x20) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
  {
    Path = JobMoniker::GetPath((JobMoniker *)a2);
    WPP_SF_SD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x20u,
      (__int64)&WPP_5435fee58aaf3c352ed5cdc6abf88a31_Traceguids,
      Path);
  }
  Scheduler::StartFirstMissedRun(a1, 0);
  wmi::AutoRef<JobBucket>::Release(a2 + 4);
  _bstr_t::_Free((_bstr_t *)(a2 + 2));
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180054324) ----------------------------------------------------
__int64 __fastcall Scheduler::StartJobs(Scheduler *this)
{
  __int64 v2; // rax
  bool v3; // dl
  __int64 v4; // r14
  int v5; // edi
  const unsigned __int16 *Path; // rax
  EventManager *v7; // rcx
  void *v9; // [rsp+28h] [rbp-49h]
  const struct _GUID *v10; // [rsp+30h] [rbp-41h]
  struct _FILETIME SystemTimeAsFileTime; // [rsp+38h] [rbp-39h] BYREF
  FILETIME FileTime1; // [rsp+40h] [rbp-31h] BYREF
  __int64 v13; // [rsp+48h] [rbp-29h]
  __int128 v14; // [rsp+50h] [rbp-21h] BYREF
  struct _GUID v15; // [rsp+60h] [rbp-11h] BYREF
  char v16[16]; // [rsp+70h] [rbp-1h] BYREF
  char v17[16]; // [rsp+80h] [rbp+Fh] BYREF
  __int64 v18; // [rsp+90h] [rbp+1Fh] BYREF

  v13 = -2LL;
  GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
  v2 = *(_QWORD *)&SystemTimeAsFileTime + 5000000LL;
  SystemTimeAsFileTime.dwLowDateTime += 5000000;
  SystemTimeAsFileTime.dwHighDateTime = HIDWORD(v2);
  while ( 1 )
  {
    JobMoniker::JobMoniker((JobMoniker *)v16, 0LL, 0LL);
    TSTime::TSTime((TSTime *)&v14, v3);
    EnterCriticalSection((LPCRITICAL_SECTION)((char *)this + 32));
    v4 = *((_QWORD *)this + 10);
    if ( !*(_DWORD *)(v4 + 24) && !*(_DWORD *)(v4 + 28) )
      break;
    FileTime1 = *(FILETIME *)(v4 + 24);
    if ( CompareFileTime(&FileTime1, &SystemTimeAsFileTime) > 0 )
    {
      TraceTime("Scheduler::StartJobs: run time in the future", &FileTime1, (const struct JobMoniker *)(v4 + 40));
      goto LABEL_14;
    }
    JobMoniker::operator=(v16, v4 + 40);
    v14 = *(_OWORD *)(v4 + 80);
    v5 = *(_DWORD *)(v4 + 36);
    SortedRunListItem::Delete((SortedRunListItem *)v4);
    LeaveCriticalSection((LPCRITICAL_SECTION)((char *)this + 32));
    TraceTime("Scheduler::StartJobs: starting", &FileTime1, (const struct JobMoniker *)v16);
    if ( v5 == 2 )
    {
      *(_QWORD *)&v15.Data1 = 0LL;
      *(_QWORD *)v15.Data4 = 0LL;
      Path = JobMoniker::GetPath((JobMoniker *)v16);
      EventManager::EvtReport(v7, &TIME_TRIGGER, Path, &v15, v9, v10);
      JobStore::DeleteExpiredTask(JobStore::m_pCommonStore, (const struct JobMoniker *)v16);
      if ( (*(_DWORD *)(v18 + 16) & 0x2000000) != 0 )
        (*((void (__fastcall **)(void ***, char *))UbpmProxySingleton::s_singleton[0] + 1))(
          UbpmProxySingleton::s_singleton,
          v16);
    }
    wmi::AutoRef<JobBucket>::Release(&v18);
    _bstr_t::_Free((_bstr_t *)v17);
  }
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x2000) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
  {
    WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 22LL, &WPP_5435fee58aaf3c352ed5cdc6abf88a31_Traceguids);
  }
LABEL_14:
  LeaveCriticalSection((LPCRITICAL_SECTION)((char *)this + 32));
  wmi::AutoRef<JobBucket>::Release(&v18);
  _bstr_t::_Free((_bstr_t *)v17);
  EnterCriticalSection((LPCRITICAL_SECTION)((char *)this + 32));
  if ( *((Scheduler **)this + 10) == (Scheduler *)((char *)this + 72) )
  {
    *((_QWORD *)this + 21) = -1LL;
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x2000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
    {
      WPP_SF_(*((_QWORD *)WPP_GLOBAL_Control + 2), 23LL, &WPP_5435fee58aaf3c352ed5cdc6abf88a31_Traceguids);
    }
  }
  else
  {
    *((_QWORD *)this + 21) = *(_QWORD *)(*((_QWORD *)this + 10) + 24LL);
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)((char *)this + 32));
  return 0LL;
}
// 180054399: variable 'v3' is possibly undefined
// 180054456: variable 'v7' is possibly undefined
// 180054456: variable 'v9' is possibly undefined
// 180054456: variable 'v10' is possibly undefined
// 1800106A4: using guessed type __int64 __fastcall JobMoniker::operator=(_QWORD, _QWORD);
// 18001306C: using guessed type __int64 __fastcall wmi::AutoRef<JobBucket>::Release(_QWORD);
// 18004B234: using guessed type __int64 __fastcall WPP_SF_(_QWORD, _QWORD, _QWORD);
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 1800AFFB0: using guessed type void **UbpmProxySingleton::s_singleton[2];

//----- (00000001800545C8) ----------------------------------------------------
_QWORD *__fastcall std::_Tree_buy<std::pair<JobMoniker const,_FILETIME>>::_Buynode0(_QWORD *a1)
{
  _QWORD *result; // rax

  result = operator new(0x50uLL);
  if ( !result )
    std::_Xbad_alloc();
  *result = *a1;
  result[1] = *a1;
  result[2] = *a1;
  return result;
}

//----- (000000018005463C) ----------------------------------------------------
void __fastcall std::_Tree<std::_Tmap_traits<JobMoniker,_FILETIME,Scheduler::JobMonikerLess,std::allocator<std::pair<JobMoniker const,_FILETIME>>,0>>::_Destroy_if_not_nil(
        __int64 a1,
        wmi::RefBase **a2)
{
  wmi::AutoRef<JobBucket>::Release(a2 + 8);
  _bstr_t::_Free((_bstr_t *)(a2 + 6));
  operator delete(a2);
}

//----- (000000018005466C) ----------------------------------------------------
BSTR ***__fastcall std::_Tree<std::_Tmap_traits<JobMoniker,_FILETIME,Scheduler::JobMonikerLess,std::allocator<std::pair<JobMoniker const,_FILETIME>>,0>>::find(
        BSTR ***a1,
        BSTR ***a2,
        __int64 a3)
{
  BSTR **v3; // rdi
  BSTR **v7; // r9
  BSTR **v8; // rax
  BSTR **v9; // rbx
  BSTR ***result; // rax

  v3 = *a1;
  v7 = *a1;
  v8 = *a1;
  v9 = (BSTR **)(*a1)[1];
  if ( !*((_BYTE *)v9 + 25) )
  {
    do
    {
      if ( (int)_bstr_t::_Compare(v9 + 6, (BSTR **)(a3 + 16)) >= 0 )
      {
        v3 = v9;
        v9 = (BSTR **)*v9;
      }
      else
      {
        v9 = (BSTR **)v9[2];
      }
    }
    while ( !*((_BYTE *)v9 + 25) );
    v7 = *a1;
    v8 = *a1;
  }
  if ( v3 == v7 )
    goto LABEL_10;
  if ( (int)_bstr_t::_Compare((BSTR **)(a3 + 16), v3 + 6) < 0 )
  {
    v8 = *a1;
LABEL_10:
    v3 = v8;
  }
  result = a2;
  *a2 = v3;
  return result;
}

//----- (000000018005470C) ----------------------------------------------------
__int64 __fastcall WPP_SF_SDd(__int64 a1, __int64 a2, __int64 a3, const wchar_t *a4)
{
  __int64 v4; // rax

  if ( a4 )
  {
    v4 = -1LL;
    do
      ++v4;
    while ( a4[v4] );
  }
  if ( !a4 )
    a4 = L"NULL";
  return EtwTraceMessage(a1, 43LL, &WPP_5435fee58aaf3c352ed5cdc6abf88a31_Traceguids, 12LL, a4);
}
// 1800747B0: using guessed type __int64 __fastcall EtwTraceMessage(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 18007F5B8: using guessed type wchar_t aNull_1[5];

//----- (00000001800547A8) ----------------------------------------------------
__int64 __fastcall WPP_SF_SS(__int64 a1, unsigned __int16 a2, __int64 a3, const wchar_t *a4, __int64 a5)
{
  __int64 v5; // r10
  __int64 v6; // rax
  bool v7; // zf

  v5 = -1LL;
  if ( a5 )
  {
    v6 = -1LL;
    do
      ++v6;
    while ( *(_WORD *)(a5 + 2 * v6) );
  }
  v7 = a4 == 0LL;
  if ( a4 )
  {
    do
      ++v5;
    while ( a4[v5] );
    v7 = a4 == 0LL;
  }
  if ( v7 )
    a4 = L"NULL";
  return EtwTraceMessage(a1, 43LL, a3, a2, a4);
}
// 1800747B0: using guessed type __int64 __fastcall EtwTraceMessage(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 18007F5B8: using guessed type wchar_t aNull_1[5];

//----- (000000018005485C) ----------------------------------------------------
__int64 __fastcall WPP_SF_SSS(__int64 a1, __int64 a2, __int64 a3, const wchar_t *a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rdx
  __int64 v7; // rax
  __int64 v8; // rax
  bool v9; // zf

  v6 = -1LL;
  if ( a6 )
  {
    v7 = -1LL;
    do
      ++v7;
    while ( *(_WORD *)(a6 + 2 * v7) );
  }
  if ( a5 )
  {
    v8 = -1LL;
    do
      ++v8;
    while ( *(_WORD *)(a5 + 2 * v8) );
  }
  v9 = a4 == 0LL;
  if ( a4 )
  {
    do
      ++v6;
    while ( a4[v6] );
    v9 = a4 == 0LL;
  }
  if ( v9 )
    a4 = L"NULL";
  return EtwTraceMessage(a1, 43LL, &WPP_5435fee58aaf3c352ed5cdc6abf88a31_Traceguids, 26LL, a4);
}
// 1800747B0: using guessed type __int64 __fastcall EtwTraceMessage(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 18007F5B8: using guessed type wchar_t aNull_1[5];

//----- (0000000180054958) ----------------------------------------------------
__int64 __fastcall WPP_SF_SSSDd(__int64 a1, unsigned __int16 a2, __int64 a3, const wchar_t *a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r10
  __int64 v7; // rax
  __int64 v8; // rax
  bool v9; // zf

  v6 = -1LL;
  if ( a6 )
  {
    v7 = -1LL;
    do
      ++v7;
    while ( *(_WORD *)(a6 + 2 * v7) );
  }
  if ( a5 )
  {
    v8 = -1LL;
    do
      ++v8;
    while ( *(_WORD *)(a5 + 2 * v8) );
  }
  v9 = a4 == 0LL;
  if ( a4 )
  {
    do
      ++v6;
    while ( a4[v6] );
    v9 = a4 == 0LL;
  }
  if ( v9 )
    a4 = L"NULL";
  return EtwTraceMessage(a1, 43LL, a3, a2, a4);
}
// 1800747B0: using guessed type __int64 __fastcall EtwTraceMessage(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 18007F5B8: using guessed type wchar_t aNull_1[5];

//----- (0000000180054A8C) ----------------------------------------------------
__int64 __fastcall WPP_SF_Sq(__int64 a1, unsigned __int16 a2, __int64 a3, const wchar_t *a4)
{
  __int64 v4; // rax

  if ( a4 )
  {
    v4 = -1LL;
    do
      ++v4;
    while ( a4[v4] );
  }
  if ( !a4 )
    a4 = L"NULL";
  return EtwTraceMessage(a1, 43LL, a3, a2, a4);
}
// 1800747B0: using guessed type __int64 __fastcall EtwTraceMessage(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 18007F5B8: using guessed type wchar_t aNull_1[5];

//----- (0000000180054B0C) ----------------------------------------------------
__int64 __fastcall WPP_SF_ddS(__int64 a1, unsigned __int16 a2, __int64 a3, int a4, char a5, __int64 a6)
{
  __int64 v6; // rax
  int v8; // [rsp+88h] [rbp+20h] BYREF

  v8 = a4;
  if ( a6 )
  {
    v6 = -1LL;
    do
      ++v6;
    while ( *(_WORD *)(a6 + 2 * v6) );
  }
  return EtwTraceMessage(a1, 43LL, &WPP_5435fee58aaf3c352ed5cdc6abf88a31_Traceguids, a2, &v8);
}
// 1800747B0: using guessed type __int64 __fastcall EtwTraceMessage(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180054BB4) ----------------------------------------------------
__int64 __fastcall WPP_SF_ddddddddddddd(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  int v5; // [rsp+130h] [rbp+2Fh] BYREF

  v5 = a4;
  return EtwTraceMessage(a1, 43LL, &WPP_5435fee58aaf3c352ed5cdc6abf88a31_Traceguids, 46LL, &v5);
}
// 1800747B0: using guessed type __int64 __fastcall EtwTraceMessage(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180054CB4) ----------------------------------------------------
SortedRunListItem *__fastcall SortedRunListItem::SortedRunListItem(
        SortedRunListItem *this,
        const struct RunListItem *a2,
        const struct JobMoniker *a3,
        const struct TSTime *a4)
{
  SortedRunListItem *result; // rax

  *((_QWORD *)this + 1) = 0LL;
  *((_QWORD *)this + 2) = 0LL;
  *(_QWORD *)this = &RunListItem::`vftable';
  *((_QWORD *)this + 1) = *((_QWORD *)a2 + 1);
  *((_QWORD *)this + 2) = *((_QWORD *)a2 + 2);
  *((_QWORD *)this + 3) = *((_QWORD *)a2 + 3);
  *((_DWORD *)this + 8) = *((_DWORD *)a2 + 8);
  *((_DWORD *)this + 9) = *((_DWORD *)a2 + 9);
  *(_QWORD *)this = &SortedRunListItem::`vftable';
  JobMoniker::JobMoniker((SortedRunListItem *)((char *)this + 40), a3, (__int64)a3);
  result = this;
  *((_OWORD *)this + 5) = *(_OWORD *)a4;
  return result;
}
// 180070228: using guessed type void *RunListItem::`vftable';
// 180070448: using guessed type void *SortedRunListItem::`vftable';

//----- (0000000180054D30) ----------------------------------------------------
wmi::RefBase **__fastcall SortedRunListItem::`vector deleting destructor'(wmi::RefBase **this, char a2)
{
  wmi::AutoRef<JobBucket>::Release(this + 9);
  _bstr_t::_Free((_bstr_t *)(this + 7));
  this[1] = 0LL;
  this[2] = 0LL;
  *this = (wmi::RefBase *)&RunListItem::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 180070228: using guessed type void *RunListItem::`vftable';

//----- (0000000180054D88) ----------------------------------------------------
__int64 __fastcall SortedRunList::AddSorted(
        SortedRunList *this,
        const struct RunListItem *a2,
        const struct JobMoniker *a3,
        const struct TSTime *a4)
{
  __int64 v5; // rbx
  SortedRunListItem *v8; // rax
  SortedRunListItem *v9; // rcx
  __int64 result; // rax
  __int64 v11; // rax
  FILETIME FileTime1; // [rsp+50h] [rbp+8h] BYREF
  FILETIME FileTime2; // [rsp+58h] [rbp+10h] BYREF

  v5 = *((_QWORD *)this + 2);
  FileTime2 = (FILETIME)*((_QWORD *)a2 + 3);
  while ( 1 )
  {
    FileTime1 = *(FILETIME *)(v5 + 24);
    if ( !*(_QWORD *)&FileTime1 || CompareFileTime(&FileTime1, &FileTime2) < 0 )
      break;
    v5 = *(_QWORD *)(v5 + 16);
  }
  v8 = (SortedRunListItem *)operator new(0x60uLL);
  if ( v8 )
    v9 = SortedRunListItem::SortedRunListItem(v8, a2, a3, a4);
  else
    v9 = 0LL;
  if ( !v9 )
    return 2147942414LL;
  v11 = *(_QWORD *)(v5 + 8);
  *((_QWORD *)v9 + 1) = v11;
  *(_QWORD *)(v11 + 16) = v9;
  result = 0LL;
  *(_QWORD *)(v5 + 8) = v9;
  *((_QWORD *)v9 + 2) = v5;
  return result;
}

//----- (0000000180054E44) ----------------------------------------------------
void __fastcall SortedRunListItem::Delete(SortedRunListItem *this)
{
  void (__fastcall ***v1)(_QWORD, __int64); // rcx

  if ( *((_DWORD *)this + 6) || *((_DWORD *)this + 7) )
  {
    CDLink::UnLink(this);
    (**v1)(v1, 1LL);
  }
}
// 180054E59: variable 'v1' is possibly undefined

//----- (0000000180054E78) ----------------------------------------------------
void __fastcall TraceTime(const char *a1, struct _FILETIME *a2, const struct JobMoniker *a3)
{
  __int64 v5; // rbx
  int LastError; // eax
  struct _SYSTEMTIME SystemTime; // [rsp+60h] [rbp-38h] BYREF

  if ( FileTimeToSystemTime(a2, &SystemTime) )
  {
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x2000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
    {
      WPP_SF_sddddddS(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        SystemTime.wSecond,
        SystemTime.wMinute,
        a1,
        SystemTime.wYear,
        SystemTime.wMonth,
        SystemTime.wDay,
        SystemTime.wHour,
        SystemTime.wMinute,
        SystemTime.wSecond,
        *((_QWORD *)a3 + 3));
    }
  }
  else if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
         && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x2000) != 0
         && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
  {
    v5 = *((_QWORD *)a3 + 3);
    LastError = GetLastError();
    WPP_SF_dS(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0xAu,
      (__int64)&WPP_36853d0798d4305d7569c8a69e5e95fb_Traceguids,
      LastError,
      v5);
  }
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180054FB8) ----------------------------------------------------
__int64 __fastcall WPP_SF_sddddddS(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        const char *a4,
        char a5,
        char a6,
        char a7,
        char a8,
        char a9,
        char a10,
        __int64 a11)
{
  __int64 v11; // rax
  __int64 v12; // r8

  v11 = -1LL;
  if ( a11 )
  {
    v12 = -1LL;
    do
      ++v12;
    while ( *(_WORD *)(a11 + 2 * v12) );
  }
  if ( a4 )
  {
    do
      ++v11;
    while ( a4[v11] );
  }
  if ( !a4 )
    a4 = "NULL";
  return EtwTraceMessage(a1, 43LL, &WPP_36853d0798d4305d7569c8a69e5e95fb_Traceguids, 11LL, a4);
}
// 1800747B0: using guessed type __int64 __fastcall EtwTraceMessage(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001800550EC) ----------------------------------------------------
LPVOID __fastcall std::_Allocate<char>(SIZE_T a1)
{
  LPVOID result; // rax

  result = 0LL;
  if ( a1 )
  {
    result = operator new(a1);
    if ( !result )
      std::_Xbad_alloc();
  }
  return result;
}

//----- (0000000180055114) ----------------------------------------------------
_QWORD *__fastcall std::string::string(_QWORD *a1, void *a2)
{
  a1[2] = 0LL;
  a1[3] = 15LL;
  *(_BYTE *)a1 = 0;
  std::string::assign(a1, a2);
  return a1;
}

//----- (0000000180055144) ----------------------------------------------------
_DWORD *__fastcall std::bitset<5>::bitset<5>(_DWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // r8
  unsigned __int64 i; // r9

  *a1 = 0;
  v2 = 0LL;
  for ( i = a2; i; i >>= 1 )
  {
    if ( v2 >= 5 )
      break;
    if ( (i & 1) != 0 )
      a1[v2 >> 5] |= 1 << (v2 & 0x1F);
    ++v2;
  }
  return a1;
}
// 180055169: conditional instruction was optimized away because r8.8<5u

//----- (00000001800551A8) ----------------------------------------------------
_DWORD *__fastcall std::bitset<7>::bitset<7>(_DWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // r8
  unsigned __int64 i; // r9

  *a1 = 0;
  v2 = 0LL;
  for ( i = a2; i; i >>= 1 )
  {
    if ( v2 >= 7 )
      break;
    if ( (i & 1) != 0 )
      a1[v2 >> 5] |= 1 << (v2 & 0x1F);
    ++v2;
  }
  return a1;
}
// 1800551CD: conditional instruction was optimized away because r8.8<7u

//----- (000000018005520C) ----------------------------------------------------
_DWORD *__fastcall std::bitset<31>::bitset<31>(_DWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // r8
  unsigned __int64 i; // r9

  *a1 = 0;
  v2 = 0LL;
  for ( i = a2; i; i >>= 1 )
  {
    if ( v2 >= 0x1F )
      break;
    if ( (i & 1) != 0 )
      a1[v2 >> 5] |= 1 << (v2 & 0x1F);
    ++v2;
  }
  return a1;
}
// 180055231: conditional instruction was optimized away because r8.8<1Fu

//----- (0000000180055270) ----------------------------------------------------
_DWORD *__fastcall std::bitset<12>::bitset<12>(_DWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // r8
  unsigned __int64 i; // r9

  *a1 = 0;
  v2 = 0LL;
  for ( i = a2; i; i >>= 1 )
  {
    if ( v2 >= 0xC )
      break;
    if ( (i & 1) != 0 )
      a1[v2 >> 5] |= 1 << (v2 & 0x1F);
    ++v2;
  }
  return a1;
}
// 180055295: conditional instruction was optimized away because r8.8<Cu

//----- (00000001800552E0) ----------------------------------------------------
std::_Iostream_error_category *__fastcall std::_Iostream_error_category::`scalar deleting destructor'(
        std::_Iostream_error_category *this,
        char a2)
{
  *(_QWORD *)this = &std::error_category::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 180070460: using guessed type void *std::error_category::`vftable';

//----- (0000000180055310) ----------------------------------------------------
__int64 __fastcall Scheduling::JobSchedule::GetNextRun(__int64 a1, __int128 *a2, _OWORD *a3)
{
  int RunTimes; // edi
  CDLink *v5; // rcx
  __int64 v6; // rax
  CDLink *v7; // rbx
  void (__fastcall ***v8)(_QWORD, __int64); // rcx
  __int128 v10; // [rsp+48h] [rbp-9h] BYREF
  __int128 v11; // [rsp+58h] [rbp+7h] BYREF
  void **v12; // [rsp+68h] [rbp+17h] BYREF
  CDLink *v13; // [rsp+70h] [rbp+1Fh]
  void ***v14; // [rsp+78h] [rbp+27h]
  __int64 v15; // [rsp+80h] [rbp+2Fh]
  int v16; // [rsp+88h] [rbp+37h]
  int v17; // [rsp+8Ch] [rbp+3Bh]
  int v18; // [rsp+90h] [rbp+3Fh]
  int v19; // [rsp+94h] [rbp+43h]
  int v20; // [rsp+98h] [rbp+47h]

  v12 = &RunListItem::`vftable';
  v15 = 0LL;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 1;
  v20 = 1;
  v13 = (CDLink *)&v12;
  v14 = &v12;
  LOBYTE(v10) = 0;
  *((_QWORD *)&v10 + 1) = -1LL;
  v11 = *a2;
  RunTimes = Scheduling::JobSchedule::GetRunTimes(a1, (TSTime *)&v11, (TSTime *)&v10, (__int64)&v12, 1);
  v5 = v13;
  if ( RunTimes >= 0 )
  {
    RunTimes = 1;
    if ( v13 != (CDLink *)&v12 )
    {
      v6 = *((_QWORD *)v13 + 3);
      LOBYTE(v10) = 0;
      *((_QWORD *)&v10 + 1) = v6;
      *a3 = v10;
      RunTimes = 0;
    }
  }
  while ( *((_DWORD *)v5 + 6) || *((_DWORD *)v5 + 7) )
  {
    v7 = (CDLink *)*((_QWORD *)v5 + 1);
    CDLink::UnLink(v5);
    --v18;
    (**v8)(v8, 1LL);
    v5 = v7;
  }
  return (unsigned int)RunTimes;
}
// 1800553EA: variable 'v8' is possibly undefined
// 180070228: using guessed type void *RunListItem::`vftable';

//----- (000000018005542C) ----------------------------------------------------
_BOOL8 __fastcall TSTime::IsLeapYear(unsigned __int16 a1)
{
  return (a1 & 3) == 0 && a1 != 100 * (a1 / 0x64u) || a1 == 400 * (a1 / 0x190u);
}

//----- (0000000180055474) ----------------------------------------------------
__int64 __fastcall TSTime::MonthDays(unsigned __int16 a1, unsigned __int16 a2, unsigned __int16 *a3)
{
  __int16 v4; // r11
  int v6[3]; // [rsp+20h] [rbp-20h]
  char v7; // [rsp+2Ch] [rbp-14h]

  v6[0] = 521936640;
  v6[1] = 522067742;
  v6[2] = 505355807;
  v7 = 31;
  if ( (unsigned __int16)(a1 - 1) > 0xBu )
    return 2147942487LL;
  *a3 = *((unsigned __int8 *)v6 + a1);
  if ( a1 == 2 && a2 && TSTime::IsLeapYear(a2) )
    *a3 = v4 + 1;
  return 0LL;
}
// 1800554DD: variable 'v4' is possibly undefined

//----- (0000000180055514) ----------------------------------------------------
__int64 __fastcall std::string::_Copy(const void **Src, unsigned __int64 a2, size_t a3)
{
  const void **v4; // rbx
  unsigned __int64 v5; // rdi
  unsigned __int64 v6; // r8
  unsigned __int64 v7; // rcx
  __int64 v8; // rdx
  void *v9; // r14
  const void *v10; // rdx
  __int64 result; // rax

  v4 = Src;
  v5 = a2 | 0xF;
  if ( (a2 | 0xF) == -1LL )
  {
    v5 = a2;
  }
  else
  {
    v6 = (unsigned __int64)Src[3];
    v7 = v6 >> 1;
    if ( v6 >> 1 > v5 / 3 )
    {
      v5 = v7 + v6;
      if ( v6 > -2LL - v7 )
        v5 = -2LL;
    }
  }
  v9 = std::_Allocate<char>(v5 + 1);
  if ( a3 )
  {
    if ( (unsigned __int64)v4[3] < 0x10 )
      v10 = v4;
    else
      v10 = *v4;
    memcpy_0(v9, v10, a3);
  }
  LOBYTE(v8) = 1;
  result = std::string::_Tidy(v4, v8, 0LL);
  *v4 = v9;
  v4[3] = (const void *)v5;
  v4[2] = (const void *)a3;
  if ( v5 >= 0x10 )
    v4 = (const void **)v9;
  *((_BYTE *)v4 + a3) = 0;
  return result;
}
// 180055514: could not find valid save-restore pair for rbp
// 1800555CE: variable 'v8' is possibly undefined
// 180055714: using guessed type __int64 __fastcall std::string::_Tidy(_QWORD, _QWORD, _QWORD);

//----- (0000000180055654) ----------------------------------------------------
bool __fastcall std::string::_Grow(void *a1, unsigned __int64 a2, char a3)
{
  unsigned __int64 v3; // rbx
  unsigned __int64 v4; // r8
  bool v5; // zf

  v3 = a2;
  if ( a2 == -1LL )
    std::_Xlength_error("string too long");
  if ( *((_QWORD *)a1 + 3) < a2 )
  {
    std::string::_Copy((const void **)a1, a2, *((_QWORD *)a1 + 2));
LABEL_14:
    v5 = v3 == 0;
    return !v5;
  }
  if ( a3 && a2 < 0x10 )
  {
    v4 = *((_QWORD *)a1 + 2);
    LOBYTE(a2) = 1;
    if ( v3 < v4 )
      v4 = v3;
    std::string::_Tidy(a1, a2, v4);
    goto LABEL_14;
  }
  v5 = a2 == 0;
  if ( !a2 )
  {
    *((_QWORD *)a1 + 2) = 0LL;
    if ( *((_QWORD *)a1 + 3) >= 0x10uLL )
      a1 = *(void **)a1;
    *(_BYTE *)a1 = 0;
    goto LABEL_14;
  }
  return !v5;
}
// 180055714: using guessed type __int64 __fastcall std::string::_Tidy(_QWORD, _QWORD, _QWORD);

//----- (00000001800556CC) ----------------------------------------------------
bool __fastcall std::string::_Inside(_QWORD *a1, unsigned __int64 a2)
{
  _QWORD *v3; // rax
  _QWORD *v4; // rdx
  bool result; // al

  result = 0;
  if ( a2 )
  {
    v3 = a1[3] < 0x10uLL ? a1 : (_QWORD *)*a1;
    if ( a2 >= (unsigned __int64)v3 )
    {
      v4 = a1[3] < 0x10uLL ? a1 : (_QWORD *)*a1;
      if ( (unsigned __int64)v4 + a1[2] > a2 )
        return 1;
    }
  }
  return result;
}

//----- (000000018005587C) ----------------------------------------------------
void **__fastcall std::string::assign(void **a1, void *Src, size_t Size)
{
  unsigned __int64 v7; // rax
  void *v8; // rcx
  void **v9; // rax

  if ( std::string::_Inside(a1, (unsigned __int64)Src) )
    return (void **)std::string::assign(a1);
  if ( std::string::_Grow(a1, Size, 0) )
  {
    v7 = (unsigned __int64)a1[3];
    if ( v7 < 0x10 )
      v8 = a1;
    else
      v8 = *a1;
    if ( Size )
    {
      memcpy_0(v8, Src, Size);
      v7 = (unsigned __int64)a1[3];
    }
    a1[2] = (void *)Size;
    if ( v7 < 0x10 )
      v9 = a1;
    else
      v9 = (void **)*a1;
    *((_BYTE *)v9 + Size) = 0;
  }
  return a1;
}

//----- (0000000180055930) ----------------------------------------------------
__int64 __fastcall std::_System_error_category::default_error_condition(__int64 a1, __int64 a2, int a3)
{
  bool v5; // zf
  void ***v6; // rax

  v5 = std::_Syserror_map(a3) == 0LL;
  *(_DWORD *)a2 = a3;
  v6 = &std::_Error_objects<int>::_Generic_object;
  if ( v5 )
    v6 = std::_Error_objects<int>::_System_object;
  *(_QWORD *)(a2 + 8) = v6;
  return a2;
}
// 1800AFF50: using guessed type void **std::_Error_objects<int>::_System_object[3];
// 1800AFF60: using guessed type void **std::_Error_objects<int>::_Generic_object;

//----- (0000000180055980) ----------------------------------------------------
__int64 __fastcall std::error_category::default_error_condition(__int64 a1, __int64 a2, int a3)
{
  __int64 result; // rax

  *(_DWORD *)a2 = a3;
  result = a2;
  *(_QWORD *)(a2 + 8) = a1;
  return result;
}

//----- (00000001800559A0) ----------------------------------------------------
bool __fastcall std::error_category::equivalent(std::error_category *this, std::error_category **a2, int a3)
{
  return this == a2[1] && *(_DWORD *)a2 == a3;
}

//----- (00000001800559C0) ----------------------------------------------------
bool __fastcall std::error_category::equivalent(
        std::error_category *this,
        unsigned int a2,
        const struct std::error_condition *a3)
{
  __int64 v4; // rax
  char v6[24]; // [rsp+20h] [rbp-18h] BYREF

  v4 = (*(__int64 (__fastcall **)(std::error_category *, char *, _QWORD))(*(_QWORD *)this + 24LL))(this, v6, a2);
  return *(_QWORD *)(v4 + 8) == *((_QWORD *)a3 + 1) && *(_DWORD *)v4 == *(_DWORD *)a3;
}
// 1800559C0: using guessed type char var_18[24];

//----- (0000000180055A04) ----------------------------------------------------
_QWORD *__fastcall std::string::erase(_QWORD *a1, unsigned __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rdi
  _QWORD *v4; // rbx
  bool v5; // cf
  _QWORD *v6; // rax
  unsigned __int64 v7; // rax
  unsigned __int64 v8; // rdi
  _QWORD *v9; // rax

  v3 = a1[2];
  v4 = a1;
  if ( v3 < a2 )
    std::_Xout_of_range("invalid string position");
  if ( v3 - a2 > a3 )
  {
    if ( a3 )
    {
      v7 = a1[3];
      if ( v7 >= 0x10 )
        a1 = (_QWORD *)*a1;
      v8 = v3 - a3;
      if ( v8 != a2 )
      {
        memmove_0((char *)a1 + a2, (char *)a1 + a2 + a3, v8 - a2);
        v7 = v4[3];
      }
      v4[2] = v8;
      if ( v7 < 0x10 )
        v9 = v4;
      else
        v9 = (_QWORD *)*v4;
      *((_BYTE *)v9 + v8) = 0;
    }
  }
  else
  {
    v5 = a1[3] < 0x10uLL;
    a1[2] = a2;
    if ( v5 )
      v6 = a1;
    else
      v6 = (_QWORD *)*a1;
    *((_BYTE *)v6 + a2) = 0;
  }
  return v4;
}

//----- (0000000180055AAC) ----------------------------------------------------
_QWORD *__fastcall std::string::erase(_QWORD *a1, unsigned __int64 a2)
{
  bool v2; // cf
  _QWORD *v3; // rax

  if ( a1[2] < a2 )
    std::_Xout_of_range("invalid string position");
  v2 = a1[3] < 0x10uLL;
  a1[2] = a2;
  if ( v2 )
    v3 = a1;
  else
    v3 = (_QWORD *)*a1;
  *((_BYTE *)v3 + a2) = 0;
  return a1;
}

//----- (0000000180055B10) ----------------------------------------------------
_QWORD *__fastcall std::_Generic_error_category::message(__int64 a1, _QWORD *a2, int a3)
{
  const char *v4; // rax
  char *v5; // rdx

  v4 = std::_Syserror_map(a3);
  v5 = "unknown error";
  if ( v4 )
    v5 = (char *)v4;
  std::string::string(a2, v5);
  return a2;
}

//----- (0000000180055B50) ----------------------------------------------------
_QWORD *__fastcall std::_Iostream_error_category::message(__int64 a1, _QWORD *a2, int a3)
{
  if ( a3 == 1 )
    std::string::string(a2, "iostream stream error");
  else
    std::_Generic_error_category::message(a1, a2, a3);
  return a2;
}

//----- (0000000180055B90) ----------------------------------------------------
_QWORD *__fastcall std::_System_error_category::message(__int64 a1, _QWORD *a2, int a3)
{
  const char *v4; // rax
  char *v5; // rdx

  v4 = std::_Winerror_map(a3);
  v5 = "unknown error";
  if ( v4 )
    v5 = (char *)v4;
  std::string::string(a2, v5);
  return a2;
}

//----- (0000000180055BD0) ----------------------------------------------------
const char *__fastcall std::_Generic_error_category::name(std::_Generic_error_category *this)
{
  return "generic";
}

//----- (0000000180055BE0) ----------------------------------------------------
const char *__fastcall std::_Iostream_error_category::name(std::_Iostream_error_category *this)
{
  return "iostream";
}

//----- (0000000180055BF0) ----------------------------------------------------
const char *__fastcall std::_System_error_category::name(std::_System_error_category *this)
{
  return "system";
}

//----- (0000000180055C00) ----------------------------------------------------
void __fastcall PlugIn::Internal_Unload(PlugIn *this)
{
  HMODULE v2; // rcx

  v2 = (HMODULE)*((_QWORD *)this + 5);
  if ( v2 )
  {
    FreeLibrary(v2);
    *((_QWORD *)this + 5) = 0LL;
  }
  *((_QWORD *)this + 6) = 0LL;
  *((_QWORD *)this + 7) = 0LL;
  *((_QWORD *)this + 8) = 0LL;
  *((_QWORD *)this + 9) = 0LL;
  *((_QWORD *)this + 10) = 0LL;
  *((_QWORD *)this + 11) = 0LL;
  *((_QWORD *)this + 12) = 0LL;
}

//----- (0000000180055C54) ----------------------------------------------------
__int64 __fastcall PlugIn::StartCleanUp(LPCRITICAL_SECTION lpCriticalSection)
{
  void (__fastcall *LockSemaphore)(__int64 *); // rax
  __int64 v3; // rbx
  __int64 v5; // [rsp+40h] [rbp+8h] BYREF
  LPCRITICAL_SECTION v6; // [rsp+48h] [rbp+10h]

  v5 = 0LL;
  v6 = lpCriticalSection;
  EnterCriticalSection(lpCriticalSection);
  LockSemaphore = (void (__fastcall *)(__int64 *))lpCriticalSection[1].LockSemaphore;
  if ( LockSemaphore )
  {
    LockSemaphore(&v5);
    *(_QWORD *)&lpCriticalSection[1].LockCount = 0LL;
    lpCriticalSection[1].OwningThread = 0LL;
    lpCriticalSection[1].LockSemaphore = 0LL;
    lpCriticalSection[1].SpinCount = 0LL;
    lpCriticalSection[2].DebugInfo = 0LL;
    *(_QWORD *)&lpCriticalSection[2].LockCount = 0LL;
    lpCriticalSection[2].OwningThread = 0LL;
  }
  v3 = v5;
  LeaveCriticalSection(lpCriticalSection);
  return v3;
}
// 1800747C8: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();

//----- (0000000180055CF0) ----------------------------------------------------
void __fastcall _lambda_152aa9d2a3a0648fa2fa7fcef514b376_::_lambda_invoker_cdecl_(char *a1)
{
  if ( *a1 )
    wil::details_abi::SubscriptionList::OnSignaled((LPCRITICAL_SECTION)(a1 + 168), (PSRWLOCK)a1 + 4);
}

//----- (0000000180055D18) ----------------------------------------------------
ULONG __fastcall _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapSz<unsigned short>,_tlgWrapSz<unsigned short>>(
        __int64 a1,
        unsigned __int8 *a2,
        __int64 a3,
        __int64 a4,
        const WCHAR **a5,
        const WCHAR **a6)
{
  __int64 v7; // rcx
  int v8; // r9d
  const WCHAR *v9; // rdx
  __int64 v10; // rax
  int v11; // r8d
  const WCHAR *v12; // rdx
  struct _EVENT_DATA_DESCRIPTOR v14; // [rsp+30h] [rbp-58h] BYREF
  const WCHAR *v15; // [rsp+50h] [rbp-38h]
  int v16; // [rsp+58h] [rbp-30h]
  int v17; // [rsp+5Ch] [rbp-2Ch]
  const WCHAR *v18; // [rsp+60h] [rbp-28h]
  int v19; // [rsp+68h] [rbp-20h]
  int v20; // [rsp+6Ch] [rbp-1Ch]

  v7 = -1LL;
  v8 = 2;
  v9 = *a6;
  if ( *a6 )
  {
    v10 = -1LL;
    do
      ++v10;
    while ( v9[v10] );
    v11 = 2 * v10 + 2;
  }
  else
  {
    v9 = &ChannelPath;
    v11 = 2;
  }
  v18 = v9;
  v19 = v11;
  v20 = 0;
  v12 = *a5;
  if ( *a5 )
  {
    do
      ++v7;
    while ( v12[v7] );
    v8 = 2 * v7 + 2;
  }
  else
  {
    v12 = &ChannelPath;
  }
  v15 = v12;
  v16 = v8;
  v17 = 0;
  return tlgWriteTransfer_EventWriteTransfer((__int64)&dword_1800AFF68, a2, 0LL, 0LL, 4u, &v14);
}

//----- (0000000180055DFC) ----------------------------------------------------
ULONG __fastcall _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapperByVal<4>,_tlgWrapSz<unsigned short>,_tlgWrapSz<unsigned short>>(
        __int64 a1,
        unsigned __int8 *a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        const WCHAR **a6,
        const WCHAR **a7)
{
  __int64 v8; // rcx
  int v9; // r9d
  const WCHAR *v10; // rdx
  __int64 v11; // rax
  int v12; // r8d
  const WCHAR *v13; // rdx
  struct _EVENT_DATA_DESCRIPTOR v15; // [rsp+30h] [rbp-68h] BYREF
  __int64 v16; // [rsp+50h] [rbp-48h]
  __int64 v17; // [rsp+58h] [rbp-40h]
  const WCHAR *v18; // [rsp+60h] [rbp-38h]
  int v19; // [rsp+68h] [rbp-30h]
  int v20; // [rsp+6Ch] [rbp-2Ch]
  const WCHAR *v21; // [rsp+70h] [rbp-28h]
  int v22; // [rsp+78h] [rbp-20h]
  int v23; // [rsp+7Ch] [rbp-1Ch]

  v8 = -1LL;
  v9 = 2;
  v10 = *a7;
  if ( *a7 )
  {
    v11 = -1LL;
    do
      ++v11;
    while ( v10[v11] );
    v12 = 2 * v11 + 2;
  }
  else
  {
    v10 = &ChannelPath;
    v12 = 2;
  }
  v21 = v10;
  v22 = v12;
  v23 = 0;
  v13 = *a6;
  if ( *a6 )
  {
    do
      ++v8;
    while ( v13[v8] );
    v9 = 2 * v8 + 2;
  }
  else
  {
    v13 = &ChannelPath;
  }
  v16 = a5;
  v18 = v13;
  v19 = v9;
  v20 = 0;
  v17 = 4LL;
  return tlgWriteTransfer_EventWriteTransfer((__int64)&dword_1800AFF68, a2, 0LL, 0LL, 5u, &v15);
}

//----- (0000000180055EFC) ----------------------------------------------------
ULONG __fastcall _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapperByVal<4>,_tlgWrapperByVal<1>,_tlgWrapperByVal<1>,_tlgWrapperByVal<1>>(
        __int64 a1,
        unsigned __int8 *a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8)
{
  struct _EVENT_DATA_DESCRIPTOR v9; // [rsp+30h] [rbp-39h] BYREF
  __int64 v10; // [rsp+50h] [rbp-19h]
  __int64 v11; // [rsp+58h] [rbp-11h]
  __int64 v12; // [rsp+60h] [rbp-9h]
  __int64 v13; // [rsp+68h] [rbp-1h]
  __int64 v14; // [rsp+70h] [rbp+7h]
  __int64 v15; // [rsp+78h] [rbp+Fh]
  __int64 v16; // [rsp+80h] [rbp+17h]
  __int64 v17; // [rsp+88h] [rbp+1Fh]

  v16 = a8;
  v14 = a7;
  v12 = a6;
  v10 = a5;
  v17 = 1LL;
  v15 = 1LL;
  v13 = 1LL;
  v11 = 4LL;
  return tlgWriteTransfer_EventWriteTransfer((__int64)&dword_1800AFF68, a2, 0LL, 0LL, 6u, &v9);
}

//----- (0000000180055F98) ----------------------------------------------------
char *__fastcall wil::details::WriteResultString<char const *>(
        char *Destination,
        const char *a2,
        wil::details *a3,
        char **a4)
{
  unsigned __int64 v6; // rax
  const void *v7; // r8
  __int64 v8; // rdx
  rsize_t v9; // rdx
  unsigned __int64 v10; // rsi

  if ( Destination != a2
    && a3
    && *(_BYTE *)a3
    && (v6 = wil::details::ResultStringSize(a3, a2), v9 = v8 - (_QWORD)Destination, v10 = v6, v9 >= v6) )
  {
    memcpy_s(Destination, v9, v7, v6);
    if ( a4 )
      *a4 = Destination;
    return &Destination[v10];
  }
  else
  {
    wil::assign_null_to_opt_param<unsigned short const *>(a4);
    return Destination;
  }
}
// 180055FC5: variable 'v8' is possibly undefined
// 180055FD6: variable 'v7' is possibly undefined

//----- (0000000180056014) ----------------------------------------------------
char *__fastcall wil::details::WriteResultString<unsigned short const *>(
        unsigned __int16 *Destination,
        const unsigned __int16 *a2,
        wil::details *a3,
        unsigned __int16 **a4)
{
  unsigned __int64 v6; // rax
  const void *v7; // r8
  __int64 v8; // r10
  rsize_t v9; // r10
  unsigned __int64 v10; // rsi

  if ( Destination != a2
    && a3
    && *(_WORD *)a3
    && (v6 = wil::details::ResultStringSize(a3, a2), v9 = v8 - (_QWORD)Destination, v10 = v6, v9 >= v6) )
  {
    memcpy_s(Destination, v9, v7, v6);
    if ( a4 )
      *a4 = Destination;
    return (char *)Destination + v10;
  }
  else
  {
    wil::assign_null_to_opt_param<unsigned short const *>(a4);
    return (char *)Destination;
  }
}
// 18005604B: variable 'v8' is possibly undefined
// 18005605F: variable 'v7' is possibly undefined

//----- (00000001800560A0) ----------------------------------------------------
_QWORD *__fastcall std::_Tree_buy<JobMoniker>::_Buynode<JobMoniker const &>(_QWORD *a1, const struct JobMoniker *a2)
{
  __int64 v3; // r8
  _QWORD *v5; // [rsp+50h] [rbp+18h]

  v5 = std::_Tree_buy<JobMoniker>::_Buynode0(a1);
  *((_WORD *)v5 + 12) = 0;
  JobMoniker::JobMoniker((JobMoniker *)(v5 + 4), a2, v3);
  return v5;
}
// 1800560D0: variable 'v3' is possibly undefined

//----- (000000018005610C) ----------------------------------------------------
_QWORD *__fastcall std::_Tree<std::_Tset_traits<JobMoniker,std::less<JobMoniker>,std::allocator<JobMoniker>,0>>::_Insert_at<JobMoniker const &,std::_Nil>(
        _QWORD *a1,
        _QWORD *a2,
        char a3,
        _QWORD *a4,
        const struct JobMoniker *a5)
{
  _QWORD *v9; // rax
  _QWORD *v10; // r10
  char v11; // r11
  __int64 v12; // rax
  _QWORD *v13; // r9
  __int64 v14; // rax
  __int64 *v15; // rdx
  __int64 v16; // rcx
  __int64 v17; // rcx
  _QWORD *result; // rax

  if ( a1[1] >= 0x38E38E38E38E38DuLL )
    std::_Xlength_error("map/set<T> too long");
  v9 = std::_Tree_buy<JobMoniker>::_Buynode<JobMoniker const &>(a1, a5);
  ++a1[1];
  v10 = v9;
  v11 = 0;
  v9[1] = a4;
  if ( a4 == (_QWORD *)*a1 )
  {
    *(_QWORD *)(*a1 + 8LL) = v9;
    *(_QWORD *)*a1 = v9;
    *(_QWORD *)(*a1 + 16LL) = v9;
  }
  else if ( a3 )
  {
    *a4 = v9;
    if ( a4 == *(_QWORD **)*a1 )
      *(_QWORD *)*a1 = v9;
  }
  else
  {
    a4[2] = v9;
    if ( a4 == *(_QWORD **)(*a1 + 16LL) )
      *(_QWORD *)(*a1 + 16LL) = v9;
  }
  v12 = v9[1];
  v13 = v10;
  while ( *(_BYTE *)(v12 + 24) == v11 )
  {
    v14 = v13[1];
    v15 = *(__int64 **)(v14 + 8);
    v16 = *v15;
    if ( v14 == *v15 )
    {
      v16 = v15[2];
      if ( *(_BYTE *)(v16 + 24) == v11 )
        goto LABEL_17;
      if ( v13 == *(_QWORD **)(v14 + 16) )
        std::_Tree<std::_Tmap_traits<User,LogonJob *,User::less,std::allocator<std::pair<User const,LogonJob *>>,1>>::_Lrotate(
          (__int64)a1,
          v13[1]);
      *(_BYTE *)(v13[1] + 24LL) = 1;
      *(_BYTE *)(*(_QWORD *)(v13[1] + 8LL) + 24LL) = v11;
      std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::_Rrotate(
        (__int64)a1,
        *(_QWORD **)(v13[1] + 8LL));
    }
    else
    {
      if ( *(_BYTE *)(v16 + 24) == v11 )
      {
LABEL_17:
        *(_BYTE *)(v14 + 24) = 1;
        *(_BYTE *)(v16 + 24) = 1;
        *(_BYTE *)(*(_QWORD *)(v13[1] + 8LL) + 24LL) = v11;
        v13 = *(_QWORD **)(v13[1] + 8LL);
        goto LABEL_21;
      }
      if ( v13 == *(_QWORD **)v14 )
        std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::_Rrotate(
          (__int64)a1,
          (_QWORD *)v13[1]);
      *(_BYTE *)(v13[1] + 24LL) = 1;
      *(_BYTE *)(*(_QWORD *)(v13[1] + 8LL) + 24LL) = v11;
      std::_Tree<std::_Tmap_traits<User,LogonJob *,User::less,std::allocator<std::pair<User const,LogonJob *>>,1>>::_Lrotate(
        (__int64)a1,
        *(_QWORD *)(v13[1] + 8LL));
    }
LABEL_21:
    v12 = v13[1];
  }
  v17 = *(_QWORD *)(*a1 + 8LL);
  result = a2;
  *a2 = v10;
  *(_BYTE *)(v17 + 24) = 1;
  return result;
}
// 1800561AF: variable 'v13' is possibly undefined
// 1800561C7: variable 'v11' is possibly undefined
// 180056285: variable 'v10' is possibly undefined

//----- (000000018005629C) ----------------------------------------------------
__int64 __fastcall std::_Tree<std::_Tset_traits<JobMoniker,std::less<JobMoniker>,std::allocator<JobMoniker>,0>>::_Insert_nohint<JobMoniker const &,std::_Nil>(
        __int64 **a1,
        __int64 a2,
        __int64 a3,
        BSTR **a4)
{
  __int64 *v7; // rsi
  BSTR **v8; // rbx
  char v9; // r14
  __int64 *v10; // rbx
  __int64 *v12; // rax
  __int64 *i; // rax
  __int64 v14; // [rsp+70h] [rbp+8h] BYREF

  v7 = *a1;
  v8 = (BSTR **)(*a1)[1];
  v9 = 1;
  while ( !*((_BYTE *)v8 + 25) )
  {
    v7 = (__int64 *)v8;
    if ( (int)_bstr_t::_Compare(a4 + 2, v8 + 6) >= 0 )
    {
      v9 = 0;
      v8 = (BSTR **)v8[2];
    }
    else
    {
      v9 = 1;
      v8 = (BSTR **)*v8;
    }
  }
  v10 = v7;
  if ( v9 )
  {
    if ( v7 == (__int64 *)**a1 )
    {
      *(_QWORD *)a2 = *std::_Tree<std::_Tset_traits<JobMoniker,std::less<JobMoniker>,std::allocator<JobMoniker>,0>>::_Insert_at<JobMoniker const &,std::_Nil>(
                         a1,
                         &v14,
                         1,
                         v7,
                         (const struct JobMoniker *)a4);
      *(_BYTE *)(a2 + 8) = 1;
      return a2;
    }
    if ( *((_BYTE *)v7 + 25) )
    {
      v10 = (__int64 *)v7[2];
    }
    else
    {
      v12 = (__int64 *)*v7;
      if ( *(_BYTE *)(*v7 + 25) )
      {
        for ( i = (__int64 *)v7[1]; !*((_BYTE *)i + 25) && v10 == (__int64 *)*i; i = (__int64 *)i[1] )
          v10 = i;
        if ( !*((_BYTE *)v10 + 25) )
          v10 = i;
      }
      else
      {
        do
        {
          v10 = v12;
          v12 = (__int64 *)v12[2];
        }
        while ( !*((_BYTE *)v12 + 25) );
      }
    }
  }
  if ( (int)_bstr_t::_Compare((BSTR **)v10 + 6, a4 + 2) >= 0 )
  {
    *(_QWORD *)a2 = v10;
    *(_BYTE *)(a2 + 8) = 0;
  }
  else
  {
    *(_QWORD *)a2 = *std::_Tree<std::_Tset_traits<JobMoniker,std::less<JobMoniker>,std::allocator<JobMoniker>,0>>::_Insert_at<JobMoniker const &,std::_Nil>(
                       a1,
                       &v14,
                       v9,
                       v7,
                       (const struct JobMoniker *)a4);
    *(_BYTE *)(a2 + 8) = 1;
  }
  return a2;
}

//----- (00000001800563F4) ----------------------------------------------------
__int64 __fastcall wil::details_abi::ProcessLocalStorageData<wil::details_abi::FeatureStateData>::ProcessLocalStorageData<wil::details_abi::FeatureStateData>(
        __int64 a1,
        _QWORD *a2,
        _QWORD *a3)
{
  *(_DWORD *)a1 = 1;
  *(_QWORD *)(a1 + 8) = *a2;
  *a2 = 0LL;
  *(_QWORD *)(a1 + 16) = *a3;
  *a3 = 0LL;
  *(_QWORD *)(a1 + 24) = a3[1];
  a3[1] = 0LL;
  memset_0((void *)(a1 + 40), 0, 0x108uLL);
  *(_QWORD *)(a1 + 32) = 0LL;
  wil::details_abi::UsageIndexes::UsageIndexes((wil::details_abi::UsageIndexes *)(a1 + 40));
  wil::details_abi::SubscriptionList::SubscriptionList((struct _RTL_CRITICAL_SECTION *)(a1 + 232));
  return a1;
}

//----- (0000000180056464) ----------------------------------------------------
ATL::CDacl::CAccessObjectAce *__fastcall ATL::CDacl::CAccessObjectAce::CAccessObjectAce(
        ATL::CDacl::CAccessObjectAce *this,
        const struct ATL::CSid *a2,
        int a3,
        char a4,
        bool a5,
        const struct _GUID *a6,
        const struct _GUID *a7)
{
  struct _GUID *v10; // rax
  struct _GUID *v11; // rax

  *(_QWORD *)this = &ATL::CAcl::CAce::`vftable';
  ATL::CSid::CSid((ATL::CDacl::CAccessObjectAce *)((char *)this + 8), a2);
  *((_DWORD *)this + 32) = a3;
  *((_BYTE *)this + 132) = a4;
  *((_QWORD *)this + 17) = 0LL;
  *((_BYTE *)this + 144) = a5;
  *(_QWORD *)this = &ATL::CDacl::CAccessObjectAce::`vftable';
  *((_QWORD *)this + 19) = 0LL;
  *((_QWORD *)this + 20) = 0LL;
  if ( a6 )
  {
    v10 = (struct _GUID *)operator new(0x10uLL);
    if ( v10 )
      *v10 = *a6;
    *((_QWORD *)this + 19) = v10;
    if ( !v10 )
      ATL::PrivateAtlThrow(-2147024882);
  }
  if ( a7 )
  {
    v11 = (struct _GUID *)operator new(0x10uLL);
    if ( v11 )
      *v11 = *a7;
    *((_QWORD *)this + 20) = v11;
    if ( !v11 )
    {
      operator delete(*((void **)this + 19));
      *((_QWORD *)this + 19) = 0LL;
      ATL::PrivateAtlThrow(-2147024882);
    }
  }
  return this;
}
// 180070388: using guessed type void *ATL::CAcl::CAce::`vftable';
// 1800737C8: using guessed type void *ATL::CDacl::CAccessObjectAce::`vftable';

//----- (00000001800565D0) ----------------------------------------------------
__int64 __fastcall wil::details_abi::RawUsageIndex::RawUsageIndex(
        __int64 a1,
        __int16 a2,
        __int16 a3,
        char a4,
        __int16 a5,
        char a6)
{
  __int64 v6; // r10
  __int64 v7; // rdx
  __int64 Size; // rax
  __int64 result; // rax
  __int16 v10; // [rsp+20h] [rbp-28h] BYREF
  char v11; // [rsp+22h] [rbp-26h]
  int v12; // [rsp+24h] [rbp-24h]
  __int16 v13; // [rsp+28h] [rbp-20h]
  __int128 v14; // [rsp+30h] [rbp-18h]

  v6 = a1;
  *(_WORD *)a1 = a2;
  v7 = 0LL;
  *(_WORD *)(a1 + 6) = a5;
  *(_WORD *)(a1 + 2) = a3;
  *(_BYTE *)(a1 + 4) = a4;
  *(_BYTE *)(a1 + 8) = a6;
  if ( a5 )
  {
    v11 = a6;
    v10 = a5;
    v14 = 0LL;
    v12 = 0;
    v13 = 0;
    Size = wil::details_abi::UsageIndexProperty::GetSize((wil::details_abi::UsageIndexProperty *)&v10);
  }
  else
  {
    Size = 0LL;
  }
  *(_QWORD *)(v6 + 16) = Size;
  result = v6;
  *(_QWORD *)(v6 + 24) = v7;
  *(_QWORD *)(v6 + 32) = v7;
  *(_QWORD *)(v6 + 40) = v7;
  *(_QWORD *)(v6 + 48) = v7;
  *(_WORD *)(v6 + 56) = v7;
  *(_BYTE *)(v6 + 58) = v7;
  return result;
}
// 180056625: variable 'v6' is possibly undefined
// 18005662C: variable 'v7' is possibly undefined

//----- (0000000180056654) ----------------------------------------------------
wil::ResultException *__fastcall wil::ResultException::ResultException(
        wil::ResultException *this,
        const struct wil::ResultException *a2)
{
  exception::exception(this, a2);
  *(_QWORD *)this = &wil::ResultException::`vftable';
  *(_OWORD *)((char *)this + 24) = *(_OWORD *)((char *)a2 + 24);
  *(_OWORD *)((char *)this + 40) = *(_OWORD *)((char *)a2 + 40);
  *(_OWORD *)((char *)this + 56) = *(_OWORD *)((char *)a2 + 56);
  *(_OWORD *)((char *)this + 72) = *(_OWORD *)((char *)a2 + 72);
  *(_OWORD *)((char *)this + 88) = *(_OWORD *)((char *)a2 + 88);
  *(_OWORD *)((char *)this + 104) = *(_OWORD *)((char *)a2 + 104);
  *(_OWORD *)((char *)this + 120) = *(_OWORD *)((char *)a2 + 120);
  *(_OWORD *)((char *)this + 136) = *(_OWORD *)((char *)a2 + 136);
  *(_OWORD *)((char *)this + 152) = *(_OWORD *)((char *)a2 + 152);
  *((_QWORD *)this + 21) = 0LL;
  *((_QWORD *)this + 22) = 0LL;
  wil::details::shared_buffer::assign((LPVOID *)this + 21, *((int **)a2 + 21), *((void **)a2 + 22));
  *((_QWORD *)this + 23) = 0LL;
  *((_QWORD *)this + 24) = 0LL;
  wil::details::shared_buffer::assign((LPVOID *)this + 23, *((int **)a2 + 23), *((void **)a2 + 24));
  return this;
}
// 180073800: using guessed type void *wil::ResultException::`vftable';

//----- (0000000180056728) ----------------------------------------------------
__int64 __fastcall wil::details_abi::UsageIndexes::UsageIndexes(wil::details_abi::UsageIndexes *this)
{
  __int64 v1; // r11
  __int16 v2; // r8
  char v3; // r9
  __int64 v4; // r11
  __int16 v5; // r8
  char v6; // r9
  __int64 v7; // r11

  wil::details_abi::RawUsageIndex::RawUsageIndex((__int64)this, 0, 4, 1, 4, 0);
  wil::details_abi::RawUsageIndex::RawUsageIndex(v1 + 64, 0, v2, v3, v2, 2);
  wil::details_abi::RawUsageIndex::RawUsageIndex(v4 + 128, 0, v5, v6, 0, v6);
  return v7;
}
// 180056752: variable 'v1' is possibly undefined
// 18005675C: variable 'v2' is possibly undefined
// 18005675C: variable 'v3' is possibly undefined
// 180056768: variable 'v4' is possibly undefined
// 180056774: variable 'v5' is possibly undefined
// 180056774: variable 'v6' is possibly undefined
// 180056779: variable 'v7' is possibly undefined

//----- (000000018005678C) ----------------------------------------------------
wil::last_error_context *__fastcall wil::last_error_context::last_error_context(wil::last_error_context *this)
{
  *(_BYTE *)this = 0;
  *((_DWORD *)this + 1) = GetLastError();
  return this;
}

//----- (00000001800567D0) ----------------------------------------------------
__int64 __fastcall wil::details_abi::ProcessLocalStorageData<wil::details_abi::ProcessLocalData>::~ProcessLocalStorageData<wil::details_abi::ProcessLocalData>(
        _QWORD *a1)
{
  __int64 *v2; // rdi
  __int64 *v3; // r15
  __int64 v4; // r14
  __int64 v5; // rbx
  HANDLE ProcessHeap; // rax
  __int64 result; // rax
  __int64 v8; // [rsp+20h] [rbp-28h] BYREF
  __int64 (__fastcall *v9[4])(_QWORD); // [rsp+28h] [rbp-20h] BYREF
  __int64 v10; // [rsp+80h] [rbp+38h] BYREF
  void (__fastcall *v11)(wil::details *, void *); // [rsp+88h] [rbp+40h] BYREF
  __int64 v12; // [rsp+90h] [rbp+48h] BYREF
  void (__fastcall *v13)(wil::details *, void *); // [rsp+98h] [rbp+50h] BYREF

  v9[1] = (__int64 (__fastcall *)(_QWORD))-2LL;
  v2 = a1 + 5;
  v3 = a1 + 15;
  while ( v2 != v3 )
  {
    v4 = *v2;
    while ( v4 )
    {
      v5 = v4;
      v4 = *(_QWORD *)(v4 + 8);
      wil::details_abi::ThreadLocalData::Clear((wil::details_abi::ThreadLocalData *)(v5 + 16));
      ProcessHeap = GetProcessHeap();
      HeapFree(ProcessHeap, 0, (LPVOID)v5);
    }
    *v2++ = 0LL;
  }
  if ( a1[3] )
  {
    v10 = a1[3];
    v11 = wil::details::CloseHandle;
    wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>((__int64 (__fastcall **)(_QWORD))&v11, &v10);
  }
  if ( a1[2] )
  {
    v12 = a1[2];
    v13 = wil::details::CloseHandle;
    wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>((__int64 (__fastcall **)(_QWORD))&v13, &v12);
  }
  result = a1[1];
  if ( result )
  {
    v8 = a1[1];
    v9[0] = (__int64 (__fastcall *)(_QWORD))wil::details::CloseHandle;
    return wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>(v9, &v8);
  }
  return result;
}

//----- (00000001800568B8) ----------------------------------------------------
__int64 __fastcall wil::details_abi::ProcessLocalStorageData<wil::details_abi::FeatureStateData>::~ProcessLocalStorageData<wil::details_abi::FeatureStateData>(
        __int64 a1)
{
  void *v2; // rdx
  wil::details *v3; // rcx
  void *v4; // rdx
  __int64 result; // rax
  __int64 v6; // [rsp+50h] [rbp+20h] BYREF
  void (__fastcall *v7)(wil::details *, void *); // [rsp+58h] [rbp+28h] BYREF

  wil::details_abi::FeatureStateData::ProcessShutdown((wil::details_abi::FeatureStateData *)(a1 + 32));
  v3 = *(wil::details **)(a1 + 296);
  *(_QWORD *)(a1 + 296) = 0LL;
  if ( v3 )
    wil::details::FreeProcessHeap(v3, v2);
  DeleteCriticalSection((LPCRITICAL_SECTION)(a1 + 232));
  wil::details_abi::UsageIndexes::~UsageIndexes((wil::details_abi::UsageIndexes *)(a1 + 40), v4);
  if ( *(_QWORD *)(a1 + 24) )
  {
    v6 = *(_QWORD *)(a1 + 24);
    v7 = wil::details::CloseHandle;
    wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>((__int64 (__fastcall **)(_QWORD))&v7, &v6);
  }
  if ( *(_QWORD *)(a1 + 16) )
  {
    v6 = *(_QWORD *)(a1 + 16);
    v7 = wil::details::CloseHandle;
    wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>((__int64 (__fastcall **)(_QWORD))&v7, &v6);
  }
  result = *(_QWORD *)(a1 + 8);
  if ( result )
  {
    v6 = *(_QWORD *)(a1 + 8);
    v7 = wil::details::CloseHandle;
    return wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>((__int64 (__fastcall **)(_QWORD))&v7, &v6);
  }
  return result;
}
// 1800568F2: variable 'v2' is possibly undefined
// 18005690C: variable 'v4' is possibly undefined

//----- (0000000180056998) ----------------------------------------------------
TaskXmlWriter *__fastcall std::auto_ptr<TaskXmlWriter>::~auto_ptr<TaskXmlWriter>(TaskXmlWriter **a1)
{
  TaskXmlWriter *v1; // rcx
  TaskXmlWriter *result; // rax

  v1 = *a1;
  if ( v1 )
    return TaskXmlWriter::`scalar deleting destructor'(v1);
  return result;
}

//----- (00000001800569B8) ----------------------------------------------------
__int64 __fastcall wistd::function<bool (void *,unsigned __int64,void *,unsigned __int64,unsigned int)>::~function<bool (void *,unsigned __int64,void *,unsigned __int64,unsigned int)>(
        __int64 a1)
{
  __int64 v1; // rcx
  __int64 result; // rax

  v1 = *(_QWORD *)(a1 + 112);
  if ( v1 )
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v1 + 24LL))(v1);
  return result;
}

//----- (00000001800569E8) ----------------------------------------------------
__int64 __fastcall wil::unique_any_t<wil::mutex_t<wil::details::unique_storage<wil::details::resource_policy<void *,void (*)(void *),&void wil::details::CloseHandle(void *),wistd::integral_constant<unsigned __int64,0>,void *,void *,0,std::nullptr_t>>,wil::err_returncode_policy>>::~unique_any_t<wil::mutex_t<wil::details::unique_storage<wil::details::resource_policy<void *,void (*)(void *),&void wil::details::CloseHandle(void *),wistd::integral_constant<unsigned __int64,0>,void *,void *,0,std::nullptr_t>>,wil::err_returncode_policy>>(
        __int64 *a1)
{
  __int64 result; // rax
  __int64 v2; // [rsp+40h] [rbp+8h] BYREF
  void (__fastcall *v3)(wil::details *, void *); // [rsp+48h] [rbp+10h] BYREF

  result = *a1;
  if ( *a1 )
  {
    v2 = *a1;
    v3 = wil::details::CloseHandle;
    return wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>((__int64 (__fastcall **)(_QWORD))&v3, &v2);
  }
  return result;
}

//----- (0000000180056A28) ----------------------------------------------------
__int64 __fastcall wil::unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_SRWLOCK *,void (*)(_RTL_SRWLOCK *),&void ReleaseSRWLockExclusive(_RTL_SRWLOCK *),wistd::integral_constant<unsigned __int64,1>,_RTL_SRWLOCK *,_RTL_SRWLOCK *,0,std::nullptr_t>>>::~unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_SRWLOCK *,void (*)(_RTL_SRWLOCK *),&void ReleaseSRWLockExclusive(_RTL_SRWLOCK *),wistd::integral_constant<unsigned __int64,1>,_RTL_SRWLOCK *,_RTL_SRWLOCK *,0,std::nullptr_t>>>(
        __int64 *a1)
{
  __int64 result; // rax
  __int64 v2; // [rsp+40h] [rbp+8h] BYREF
  void (__stdcall *v3)(PSRWLOCK); // [rsp+48h] [rbp+10h] BYREF

  result = *a1;
  if ( *a1 )
  {
    v2 = *a1;
    v3 = ReleaseSRWLockExclusive;
    return wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>((__int64 (__fastcall **)(_QWORD))&v3, &v2);
  }
  return result;
}

//----- (0000000180056A68) ----------------------------------------------------
__int64 __fastcall wil::unique_any_t<wil::details::unique_storage<wil::details::resource_policy<void *,void (*)(void *),&void wil::details::ReleaseMutex(void *),wistd::integral_constant<unsigned __int64,2>,void *,void *,0,std::nullptr_t>>>::~unique_any_t<wil::details::unique_storage<wil::details::resource_policy<void *,void (*)(void *),&void wil::details::ReleaseMutex(void *),wistd::integral_constant<unsigned __int64,2>,void *,void *,0,std::nullptr_t>>>(
        __int64 *a1)
{
  __int64 result; // rax
  __int64 v2; // [rsp+40h] [rbp+8h] BYREF
  void (__fastcall *v3)(wil::details *, void *); // [rsp+48h] [rbp+10h] BYREF

  result = *a1;
  if ( *a1 )
  {
    v2 = *a1;
    v3 = wil::details::ReleaseMutex;
    return wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>((__int64 (__fastcall **)(_QWORD))&v3, &v2);
  }
  return result;
}

//----- (0000000180056AA8) ----------------------------------------------------
void __fastcall wistd::unique_ptr<wil::details_abi::ProcessLocalStorageData<wil::details_abi::ProcessLocalData>,wil::process_heap_deleter>::~unique_ptr<wil::details_abi::ProcessLocalStorageData<wil::details_abi::ProcessLocalData>,wil::process_heap_deleter>(
        wil::details **a1,
        void *a2)
{
  wil::details *v2; // rax

  v2 = *a1;
  *a1 = 0LL;
  if ( v2 )
    wil::details::FreeProcessHeap(v2, a2);
}

//----- (0000000180056B00) ----------------------------------------------------
void __fastcall ATL::CDacl::CAccessAce::~CAccessAce(void **this)
{
  *this = &ATL::CDacl::CAccessAce::`vftable';
  ATL::CAcl::CAce::~CAce(this);
}
// 180070350: using guessed type void *ATL::CDacl::CAccessAce::`vftable';

//----- (0000000180056B18) ----------------------------------------------------
void __fastcall ATL::CSecurityDesc::~CSecurityDesc(ATL::CSecurityDesc *this)
{
  *(_QWORD *)this = &ATL::CSecurityDesc::`vftable';
  ATL::CSecurityDesc::Clear(this);
}
// 180071740: using guessed type void *ATL::CSecurityDesc::`vftable';

//----- (0000000180056B30) ----------------------------------------------------
void __fastcall wil::details::EnabledStateManager::~EnabledStateManager(struct _TP_TIMER **this)
{
  struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ *v2; // rdx
  wil::details *v3; // rcx
  wil::details *v4; // rcx
  wil::details *v5; // rcx
  struct _TP_TIMER *v6; // [rsp+30h] [rbp+8h] BYREF
  void (__fastcall *v7)(PTP_TIMER); // [rsp+38h] [rbp+10h] BYREF

  *(_BYTE *)this = 0;
  wil::details::unique_storage<wil::details::resource_policy<_TP_TIMER *,void (*)(_TP_TIMER *),&public: static void wil::details::DestroyThreadPoolTimer<wil::details::SystemThreadPoolMethods,0>::Destroy(_TP_TIMER *),wistd::integral_constant<unsigned __int64,0>,_TP_TIMER *,_TP_TIMER *,0,std::nullptr_t>>::reset(
    this + 2,
    0LL);
  *(_BYTE *)this = 0;
  wil::details::EnabledStateManager::RecordCachedUsageUnderLock((wil::details::EnabledStateManager *)this);
  v3 = this[13];
  this[13] = 0LL;
  if ( v3 )
    wil::details::FreeProcessHeap(v3, v2);
  v4 = this[9];
  this[9] = 0LL;
  if ( v4 )
    wil::details::FreeProcessHeap(v4, v2);
  v5 = this[5];
  if ( v5 )
    wil::details::WilApi_UnsubscribeFeatureStateChangeNotification(v5, v2);
  if ( this[4] )
  {
    v6 = this[4];
    v7 = (void (__fastcall *)(PTP_TIMER))wil::details::WilApi_UnsubscribeFeatureStateChangeNotification;
    wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>((__int64 (__fastcall **)(_QWORD))&v7, &v6);
  }
  if ( this[2] )
  {
    v6 = this[2];
    v7 = wil::details::DestroyThreadPoolTimer<wil::details::SystemThreadPoolMethods,0>::Destroy;
    wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>((__int64 (__fastcall **)(_QWORD))&v7, &v6);
  }
}
// 180056B64: variable 'v2' is possibly undefined

//----- (0000000180056BF0) ----------------------------------------------------
void __fastcall wil::details::FeatureStateManager::~FeatureStateManager(wil::details::FeatureStateManager *this)
{
  void *v2; // rdx
  wil::details *v3; // rcx
  wil::details *v4; // rcx
  void *v5; // rdx
  wil::details *v6; // rcx
  HANDLE *v7; // rcx
  __int64 v8; // [rsp+40h] [rbp+20h] BYREF
  void (__fastcall *v9)(PTP_TIMER); // [rsp+48h] [rbp+28h] BYREF

  *(_BYTE *)this = 0;
  wil::details::unique_storage<wil::details::resource_policy<_TP_TIMER *,void (*)(_TP_TIMER *),&public: static void wil::details::DestroyThreadPoolTimer<wil::details::SystemThreadPoolMethods,0>::Destroy(_TP_TIMER *),wistd::integral_constant<unsigned __int64,0>,_TP_TIMER *,_TP_TIMER *,0,std::nullptr_t>>::reset(
    (struct _TP_TIMER **)this + 6,
    0LL);
  wil::details::unique_storage<wil::details::resource_policy<_TP_TIMER *,void (*)(_TP_TIMER *),&public: static void wil::details::DestroyThreadPoolTimer<wil::details::SystemThreadPoolMethods,0>::Destroy(_TP_TIMER *),wistd::integral_constant<unsigned __int64,0>,_TP_TIMER *,_TP_TIMER *,0,std::nullptr_t>>::reset(
    (struct _TP_TIMER **)this + 7,
    0LL);
  v3 = (wil::details *)*((_QWORD *)this + 34);
  *((_QWORD *)this + 34) = 0LL;
  if ( v3 )
    wil::details::FreeProcessHeap(v3, v2);
  if ( *((_QWORD *)this + 30) )
  {
    v8 = *((_QWORD *)this + 30);
    v9 = (void (__fastcall *)(PTP_TIMER))wil::details::UnsubscribeProcessWideUsageFlush;
    wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>((__int64 (__fastcall **)(_QWORD))&v9, &v8);
  }
  v4 = (wil::details *)*((_QWORD *)this + 29);
  *((_QWORD *)this + 29) = 0LL;
  if ( v4 )
    wil::details::FreeProcessHeap(v4, v2);
  DeleteCriticalSection((LPCRITICAL_SECTION)((char *)this + 168));
  wil::unique_any_t<wil::details::unique_storage<wil::details::resource_policy<void *,void (*)(void *),&void wil::details::UnregisterWilFeatureConfigurationChange(void *),wistd::integral_constant<unsigned __int64,0>,void *,void *,0,std::nullptr_t>>>::~unique_any_t<wil::details::unique_storage<wil::details::resource_policy<void *,void (*)(void *),&void wil::details::UnregisterWilFeatureConfigurationChange(void *),wistd::integral_constant<unsigned __int64,0>,void *,void *,0,std::nullptr_t>>>((__int64 *)this + 20);
  if ( *((_QWORD *)this + 19) )
  {
    v8 = *((_QWORD *)this + 19);
    v9 = (void (__fastcall *)(PTP_TIMER))wil::details::UnsubscribeWilWnf;
    wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>((__int64 (__fastcall **)(_QWORD))&v9, &v8);
  }
  if ( *((_QWORD *)this + 18) )
  {
    v8 = *((_QWORD *)this + 18);
    v9 = (void (__fastcall *)(PTP_TIMER))wil::details::UnsubscribeWilWnf;
    wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>((__int64 (__fastcall **)(_QWORD))&v9, &v8);
  }
  v6 = (wil::details *)*((_QWORD *)this + 17);
  *((_QWORD *)this + 17) = 0LL;
  if ( v6 )
    wil::details::FreeProcessHeap(v6, v5);
  DeleteCriticalSection((LPCRITICAL_SECTION)((char *)this + 72));
  if ( *((_QWORD *)this + 7) )
  {
    v8 = *((_QWORD *)this + 7);
    v9 = wil::details::DestroyThreadPoolTimer<wil::details::SystemThreadPoolMethods,0>::Destroy;
    wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>((__int64 (__fastcall **)(_QWORD))&v9, &v8);
  }
  if ( *((_QWORD *)this + 6) )
  {
    v8 = *((_QWORD *)this + 6);
    v9 = wil::details::DestroyThreadPoolTimer<wil::details::SystemThreadPoolMethods,0>::Destroy;
    wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>((__int64 (__fastcall **)(_QWORD))&v9, &v8);
  }
  v7 = (HANDLE *)*((_QWORD *)this + 2);
  if ( v7 )
    wil::details_abi::ProcessLocalStorageData<wil::details_abi::FeatureStateData>::Release(v7);
}
// 180056C35: variable 'v2' is possibly undefined
// 180056CF4: variable 'v5' is possibly undefined

//----- (0000000180056D74) ----------------------------------------------------
void __fastcall JobStore::~JobStore(JobStore *this)
{
  HKEY v2; // rcx
  HKEY v3; // rcx
  HKEY v4; // rcx
  void *v5; // rcx
  int LastError; // eax
  __int64 v7; // [rsp+40h] [rbp+8h] BYREF

  v2 = (HKEY)*((_QWORD *)this + 2);
  if ( v2 )
    RegCloseKey(v2);
  v3 = (HKEY)*((_QWORD *)this + 3);
  if ( v3 )
    RegCloseKey(v3);
  v4 = (HKEY)*((_QWORD *)this + 4);
  if ( v4 )
    RegCloseKey(v4);
  v5 = (void *)*((_QWORD *)this + 7);
  if ( v5
    && !UnregisterWaitEx(v5, (HANDLE)0xFFFFFFFFFFFFFFFFLL)
    && WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
  {
    LastError = GetLastError();
    WPP_SF_D(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0xAu,
      (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
      LastError);
  }
  operator delete(*((void **)this + 10));
  std::_Tree<std::_Tset_traits<JobMoniker,std::less<JobMoniker>,std::allocator<JobMoniker>,0>>::erase(
    (_QWORD *)this + 8,
    &v7,
    **((_QWORD ***)this + 8),
    *((_QWORD **)this + 8));
  operator delete(*((void **)this + 8));
  wmi::AutoHandle::Close((void **)this + 6);
  wmi::AutoRegKey::Close((HKEY *)this + 5);
  operator delete(*((void **)this + 1));
  operator delete(*(void **)this);
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180056EAC) ----------------------------------------------------
void __fastcall ServerXMLUpdateHandler::NetworkInputHandler::~NetworkInputHandler(
        ServerXMLUpdateHandler::NetworkInputHandler *this)
{
  _bstr_t::_Free((ServerXMLUpdateHandler::NetworkInputHandler *)((char *)this + 32));
}

//----- (0000000180056EBC) ----------------------------------------------------
void __fastcall wil::details_abi::RawUsageIndex::~RawUsageIndex(wil::details_abi::RawUsageIndex *this, void *a2)
{
  wil::details *v2; // rax

  v2 = (wil::details *)*((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = 0LL;
  if ( v2 )
    wil::details::FreeProcessHeap(v2, a2);
}

//----- (0000000180056EE4) ----------------------------------------------------
void __fastcall wil::ResultException::~ResultException(LPVOID *this)
{
  wil::details::shared_buffer::reset(this + 23);
  wil::details::shared_buffer::reset(this + 21);
  exception::~exception((exception *)this);
}

//----- (0000000180056F18) ----------------------------------------------------
void __fastcall wil::details_abi::SemaphoreValue::~SemaphoreValue(wil::details_abi::SemaphoreValue *this)
{
  __int64 v2; // [rsp+40h] [rbp+8h] BYREF
  void (__fastcall *v3)(wil::details *, void *); // [rsp+48h] [rbp+10h] BYREF

  if ( *((_QWORD *)this + 1) )
  {
    v2 = *((_QWORD *)this + 1);
    v3 = wil::details::CloseHandle;
    wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>((__int64 (__fastcall **)(_QWORD))&v3, &v2);
  }
  if ( *(_QWORD *)this )
  {
    v2 = *(_QWORD *)this;
    v3 = wil::details::CloseHandle;
    wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>((__int64 (__fastcall **)(_QWORD))&v3, &v2);
  }
}

//----- (0000000180056F8C) ----------------------------------------------------
void __fastcall wil::details_abi::UsageIndexes::~UsageIndexes(wil::details_abi::UsageIndexes *this, void *a2)
{
  wil::details *v3; // rcx
  wil::details *v4; // rcx
  wil::details *v5; // rcx

  v3 = (wil::details *)*((_QWORD *)this + 22);
  *((_QWORD *)this + 22) = 0LL;
  if ( v3 )
    wil::details::FreeProcessHeap(v3, a2);
  v4 = (wil::details *)*((_QWORD *)this + 14);
  *((_QWORD *)this + 14) = 0LL;
  if ( v4 )
    wil::details::FreeProcessHeap(v4, a2);
  v5 = (wil::details *)*((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = 0LL;
  if ( v5 )
    wil::details::FreeProcessHeap(v5, a2);
}
// 180056FBC: variable 'a2' is possibly undefined

//----- (0000000180056FF0) ----------------------------------------------------
void __fastcall wil::details_abi::heap_buffer::~heap_buffer(wil::details_abi::heap_buffer *this, void *a2)
{
  wil::details *v2; // rax

  v2 = (wil::details *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = 0LL;
  if ( v2 )
    wil::details::FreeProcessHeap(v2, a2);
}

//----- (0000000180057018) ----------------------------------------------------
void __fastcall wil::last_error_context::~last_error_context(wil::last_error_context *this)
{
  if ( !*(_BYTE *)this )
    SetLastError(*((_DWORD *)this + 1));
}

//----- (000000018005703C) ----------------------------------------------------
__int64 (__fastcall ****__fastcall ATL::CAutoPtr<ATL::CDacl::CAccessAce>::operator=(
        __int64 (__fastcall ****a1)(_QWORD, __int64),
        _QWORD *a2))(_QWORD, __int64)
{
  __int64 (__fastcall ***v4)(_QWORD, __int64); // rax

  if ( *a1 == (__int64 (__fastcall ***)(_QWORD, __int64))*a2 )
  {
    if ( a1 != a2 )
      *a2 = 0LL;
  }
  else
  {
    ATL::CAutoPtr<ATL::CDacl::CAccessAce>::Free(a1);
    v4 = (__int64 (__fastcall ***)(_QWORD, __int64))*a2;
    *a2 = 0LL;
    *a1 = v4;
  }
  return a1;
}

//----- (0000000180057084) ----------------------------------------------------
__int64 *__fastcall _com_ptr_t<_com_IIID<IStream,&__s_GUID const _GUID_0000000c_0000_0000_c000_000000000046>>::operator=(
        __int64 *a1)
{
  __int64 v1; // rdi

  v1 = *a1;
  if ( *a1 )
  {
    *a1 = 0LL;
    _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::_AddRef(a1);
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v1 + 16LL))(v1);
  }
  return a1;
}

//----- (00000001800570D0) ----------------------------------------------------
char __fastcall wistd::__function::__func<_lambda_8db0ce862824541f40dfb767113f1e28_,bool (void *,unsigned __int64,void *,unsigned __int64,unsigned int)>::operator()(
        __int64 a1,
        void **a2,
        size_t *a3,
        void **a4,
        unsigned __int64 *a5,
        unsigned int *a6)
{
  char v7; // al
  char v8; // dl

  if ( **(_QWORD **)(a1 + 8) < **(_QWORD **)(a1 + 16)
    || (v7 = wil::details_abi::RawUsageIndex::RecordUsage(*(wil::details ***)(a1 + 24), *a2, *a3, *a4, *a5, *a6),
        v8 = 0,
        v7) )
  {
    v8 = 1;
    ++**(_QWORD **)(a1 + 8);
  }
  return v8;
}

//----- (0000000180057140) ----------------------------------------------------
_QWORD *__fastcall wistd::__function::__func<_lambda_8db0ce862824541f40dfb767113f1e28_,bool (void *,unsigned __int64,void *,unsigned __int64,unsigned int)>::`vector deleting destructor'(
        _QWORD *a1,
        char a2)
{
  *a1 = &wistd::__function::__base<bool (void *,unsigned __int64,void *,unsigned __int64,unsigned int)>::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(a1);
  return a1;
}
// 180071750: using guessed type void *wistd::__function::__base<bool (void *,unsigned __int64,void *,unsigned __int64,unsigned int)>::`vftable';

//----- (0000000180057170) ----------------------------------------------------
void **__fastcall ATL::CDacl::CAccessObjectAce::`vector deleting destructor'(void **this, char a2)
{
  *this = &ATL::CDacl::CAccessObjectAce::`vftable';
  operator delete(this[19]);
  operator delete(this[20]);
  *this = &ATL::CDacl::CAccessAce::`vftable';
  ATL::CAcl::CAce::~CAce(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 180070350: using guessed type void *ATL::CDacl::CAccessAce::`vftable';
// 1800737C8: using guessed type void *ATL::CDacl::CAccessObjectAce::`vftable';

//----- (00000001800571E0) ----------------------------------------------------
void **__fastcall ATL::CAcl::CAce::`scalar deleting destructor'(void **this, char a2)
{
  ATL::CAcl::CAce::~CAce(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (0000000180057220) ----------------------------------------------------
void **__fastcall ATL::CAcl::`vector deleting destructor'(void **this, char a2)
{
  *this = &ATL::CAcl::`vftable';
  free(this[1]);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 1800703C8: using guessed type void *ATL::CAcl::`vftable';

//----- (0000000180057270) ----------------------------------------------------
ATL::CDacl *__fastcall ATL::CDacl::`vector deleting destructor'(ATL::CDacl *this, char a2)
{
  ATL::CDacl::~CDacl(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (00000001800572B0) ----------------------------------------------------
ATL::CSecurityDesc *__fastcall ATL::CSecurityDesc::`scalar deleting destructor'(ATL::CSecurityDesc *this, char a2)
{
  *(_QWORD *)this = &ATL::CSecurityDesc::`vftable';
  ATL::CSecurityDesc::Clear(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 180071740: using guessed type void *ATL::CSecurityDesc::`vftable';

//----- (00000001800572F0) ----------------------------------------------------
LPVOID *__fastcall wil::ResultException::`scalar deleting destructor'(LPVOID *this, char a2)
{
  wil::ResultException::~ResultException(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (0000000180057330) ----------------------------------------------------
unsigned __int8 __fastcall ATL::CDacl::CAccessObjectAce::AceType(ATL::CDacl::CAccessObjectAce *this)
{
  return 6 - (*((_BYTE *)this + 144) != 0);
}

//----- (0000000180057344) ----------------------------------------------------
__int64 __fastcall wil::details_abi::ProcessLocalStorageData<wil::details_abi::ProcessLocalData>::Acquire(
        __int64 a1,
        wil::details **a2)
{
  DWORD CurrentProcessId; // eax
  HANDLE Mutex; // rax
  __int64 v6; // rdx
  wil::details *v7; // rcx
  __int64 v8; // r8
  const char *v9; // r9
  __int64 v10; // rbx
  unsigned int LastErrorFailHr; // edi
  __int64 v12; // r8
  bool *v13; // r9
  int Pointer; // eax
  __int64 v15; // r8
  _DWORD *v16; // rax
  int v18; // eax
  __int64 v19; // r8
  __int64 v20; // [rsp+38h] [rbp-D0h] BYREF
  void *v21; // [rsp+40h] [rbp-C8h] BYREF
  __int64 v22; // [rsp+48h] [rbp-C0h] BYREF
  __int64 v23; // [rsp+50h] [rbp-B8h] BYREF
  void (__fastcall *v24)(wil::details *, void *); // [rsp+58h] [rbp-B0h] BYREF
  __int64 v25; // [rsp+60h] [rbp-A8h] BYREF
  __int64 (__fastcall *v26[2])(_QWORD); // [rsp+68h] [rbp-A0h] BYREF
  WCHAR Name[264]; // [rsp+78h] [rbp-90h] BYREF
  wil::details::in1diag3 *retaddr; // [rsp+2B0h] [rbp+1A8h]

  v26[1] = (__int64 (__fastcall *)(_QWORD))-2LL;
  *a2 = 0LL;
  CurrentProcessId = GetCurrentProcessId();
  StringCchPrintfW(Name, 0x104uLL, (size_t *)L"Local\\SM0:%d:%d:%hs", CurrentProcessId, 120, a1);
  v20 = 0LL;
  Mutex = CreateMutexExW(0LL, Name, 0, 0x1F0001u);
  wil::details::unique_storage<wil::details::resource_policy<void *,void (*)(void *),&void wil::details::CloseHandle(void *),wistd::integral_constant<unsigned __int64,0>,void *,void *,0,std::nullptr_t>>::reset(
    &v20,
    (__int64)Mutex);
  v10 = v20;
  if ( !v20 )
  {
    LastErrorFailHr = wil::details::GetLastErrorFailHr(v7, v6, v8, v9);
    goto LABEL_11;
  }
  wil::mutex_t<wil::details::unique_storage<wil::details::resource_policy<void *,void (*)(void *),&void wil::details::CloseHandle(void *),wistd::integral_constant<unsigned __int64,0>,void *,void *,0,std::nullptr_t>>,wil::err_returncode_policy>::acquire(
    (HANDLE *)&v20,
    &v22);
  v21 = 0LL;
  Pointer = wil::details_abi::SemaphoreValue::TryGetPointer((char *)Name, &v21, v12, v13);
  LastErrorFailHr = Pointer;
  if ( Pointer < 0 )
  {
    wil::details::in1diag3::Return_Hr(retaddr, (void *)0x126, v15, (const char *)(unsigned int)Pointer);
    goto LABEL_9;
  }
  v16 = v21;
  if ( v21 )
  {
    *a2 = (wil::details *)v21;
    *(_DWORD *)*a2 = *v16 + 1;
  }
  else
  {
    v18 = wil::details_abi::ProcessLocalStorageData<wil::details_abi::ProcessLocalData>::MakeAndInitialize(
            (char *)Name,
            &v20,
            a2);
    LastErrorFailHr = v18;
    if ( v18 < 0 )
    {
      wil::details::in1diag3::Return_Hr(retaddr, (void *)0x12E, v19, (const char *)(unsigned int)v18);
      goto LABEL_8;
    }
  }
  LastErrorFailHr = 0;
LABEL_8:
  v10 = v20;
LABEL_9:
  if ( v22 )
  {
    v23 = v22;
    v24 = wil::details::ReleaseMutex;
    wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>((__int64 (__fastcall **)(_QWORD))&v24, &v23);
  }
LABEL_11:
  if ( v10 )
  {
    v25 = v10;
    v26[0] = (__int64 (__fastcall *)(_QWORD))wil::details::CloseHandle;
    wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>(v26, &v25);
  }
  return LastErrorFailHr;
}
// 1800573EB: variable 'v7' is possibly undefined
// 1800573EB: variable 'v6' is possibly undefined
// 1800573EB: variable 'v8' is possibly undefined
// 1800573EB: variable 'v9' is possibly undefined
// 180057417: variable 'v12' is possibly undefined
// 180057417: variable 'v13' is possibly undefined
// 180057431: variable 'v15' is possibly undefined
// 1800574F9: variable 'v19' is possibly undefined

//----- (0000000180057524) ----------------------------------------------------
__int64 __fastcall wil::details_abi::ProcessLocalStorageData<wil::details_abi::FeatureStateData>::Acquire(
        __int64 a1,
        __int64 *a2)
{
  DWORD CurrentProcessId; // eax
  HANDLE Mutex; // rax
  __int64 v6; // rdx
  wil::details *v7; // rcx
  __int64 v8; // r8
  const char *v9; // r9
  __int64 v10; // rbx
  unsigned int LastErrorFailHr; // edi
  __int64 v12; // r8
  bool *v13; // r9
  int Pointer; // eax
  __int64 v15; // r8
  _DWORD *v16; // rax
  int v18; // eax
  __int64 v19; // r8
  __int64 v20; // [rsp+38h] [rbp-D0h] BYREF
  void *v21; // [rsp+40h] [rbp-C8h] BYREF
  __int64 v22; // [rsp+48h] [rbp-C0h] BYREF
  __int64 v23; // [rsp+50h] [rbp-B8h] BYREF
  void (__fastcall *v24)(wil::details *, void *); // [rsp+58h] [rbp-B0h] BYREF
  __int64 v25; // [rsp+60h] [rbp-A8h] BYREF
  __int64 (__fastcall *v26[2])(_QWORD); // [rsp+68h] [rbp-A0h] BYREF
  WCHAR Name[264]; // [rsp+78h] [rbp-90h] BYREF
  wil::details::in1diag3 *retaddr; // [rsp+2B0h] [rbp+1A8h]

  v26[1] = (__int64 (__fastcall *)(_QWORD))-2LL;
  *a2 = 0LL;
  CurrentProcessId = GetCurrentProcessId();
  StringCchPrintfW(Name, 0x104uLL, (size_t *)L"Local\\SM0:%d:%d:%hs", CurrentProcessId, 304, a1);
  v20 = 0LL;
  Mutex = CreateMutexExW(0LL, Name, 0, 0x1F0001u);
  wil::details::unique_storage<wil::details::resource_policy<void *,void (*)(void *),&void wil::details::CloseHandle(void *),wistd::integral_constant<unsigned __int64,0>,void *,void *,0,std::nullptr_t>>::reset(
    &v20,
    (__int64)Mutex);
  v10 = v20;
  if ( !v20 )
  {
    LastErrorFailHr = wil::details::GetLastErrorFailHr(v7, v6, v8, v9);
    goto LABEL_11;
  }
  wil::mutex_t<wil::details::unique_storage<wil::details::resource_policy<void *,void (*)(void *),&void wil::details::CloseHandle(void *),wistd::integral_constant<unsigned __int64,0>,void *,void *,0,std::nullptr_t>>,wil::err_returncode_policy>::acquire(
    (HANDLE *)&v20,
    &v22);
  v21 = 0LL;
  Pointer = wil::details_abi::SemaphoreValue::TryGetPointer((char *)Name, &v21, v12, v13);
  LastErrorFailHr = Pointer;
  if ( Pointer < 0 )
  {
    wil::details::in1diag3::Return_Hr(retaddr, (void *)0x126, v15, (const char *)(unsigned int)Pointer);
    goto LABEL_9;
  }
  v16 = v21;
  if ( v21 )
  {
    *a2 = (__int64)v21;
    *(_DWORD *)*a2 = *v16 + 1;
  }
  else
  {
    v18 = wil::details_abi::ProcessLocalStorageData<wil::details_abi::FeatureStateData>::MakeAndInitialize(
            (char *)Name,
            &v20,
            a2);
    LastErrorFailHr = v18;
    if ( v18 < 0 )
    {
      wil::details::in1diag3::Return_Hr(retaddr, (void *)0x12E, v19, (const char *)(unsigned int)v18);
      goto LABEL_8;
    }
  }
  LastErrorFailHr = 0;
LABEL_8:
  v10 = v20;
LABEL_9:
  if ( v22 )
  {
    v23 = v22;
    v24 = wil::details::ReleaseMutex;
    wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>((__int64 (__fastcall **)(_QWORD))&v24, &v23);
  }
LABEL_11:
  if ( v10 )
  {
    v25 = v10;
    v26[0] = (__int64 (__fastcall *)(_QWORD))wil::details::CloseHandle;
    wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>(v26, &v25);
  }
  return LastErrorFailHr;
}
// 1800575CB: variable 'v7' is possibly undefined
// 1800575CB: variable 'v6' is possibly undefined
// 1800575CB: variable 'v8' is possibly undefined
// 1800575CB: variable 'v9' is possibly undefined
// 1800575F7: variable 'v12' is possibly undefined
// 1800575F7: variable 'v13' is possibly undefined
// 180057611: variable 'v15' is possibly undefined
// 1800576D9: variable 'v19' is possibly undefined

//----- (0000000180057704) ----------------------------------------------------
bool __fastcall ATL::CDacl::AddAllowedAce(ATL::CDacl *this, const struct ATL::CSid *a2)
{
  bool result; // al
  __int64 (__fastcall ***v5)(_QWORD, __int64); // rbx
  __int64 (__fastcall ***v6[5])(_QWORD, __int64); // [rsp+20h] [rbp-28h] BYREF

  v6[1] = (__int64 (__fastcall ***)(_QWORD, __int64))-2LL;
  result = ATL::CSid::IsValid(a2);
  if ( result )
  {
    if ( *((_BYTE *)this + 16) )
    {
      (*(void (__fastcall **)(ATL::CDacl *))(*(_QWORD *)this + 16LL))(this);
      *((_BYTE *)this + 16) = 0;
    }
    v6[0] = 0LL;
    v5 = (__int64 (__fastcall ***)(_QWORD, __int64))operator new(0x98uLL);
    v6[2] = v5;
    if ( v5 )
    {
      *v5 = (__int64 (__fastcall **)(_QWORD, __int64))&ATL::CAcl::CAce::`vftable';
      ATL::CSid::CSid((ATL::CSid *)(v5 + 1), a2);
      *((_DWORD *)v5 + 32) = 1179785;
      *((_BYTE *)v5 + 132) = 0;
      v5[17] = 0LL;
      *v5 = (__int64 (__fastcall **)(_QWORD, __int64))&ATL::CDacl::CAccessAce::`vftable';
      *((_BYTE *)v5 + 144) = 1;
    }
    v6[0] = v5;
    if ( !v5 )
      ATL::PrivateAtlThrow(-2147024882);
    ATL::CAtlArray<ATL::CAutoPtr<ATL::CDacl::CAccessAce>,ATL::CAutoPtrElementTraits<ATL::CDacl::CAccessAce>>::Add(
      (__int64 *)this + 3,
      (__int64 *)v6);
    free(*((void **)this + 1));
    *((_QWORD *)this + 1) = 0LL;
    ATL::CAutoPtr<ATL::CDacl::CAccessAce>::Free(v6);
    return 1;
  }
  return result;
}
// 180070350: using guessed type void *ATL::CDacl::CAccessAce::`vftable';
// 180070388: using guessed type void *ATL::CAcl::CAce::`vftable';

//----- (000000018005784C) ----------------------------------------------------
signed int ATL::AtlHresultFromLastError(void)
{
  signed int result; // eax

  result = GetLastError();
  if ( result > 0 )
    return (unsigned __int16)result | 0x80070000;
  return result;
}

//----- (0000000180057874) ----------------------------------------------------
bool __fastcall ATL::AtlSetDacl(HANDLE handle, enum _SE_OBJECT_TYPE a2, const struct ATL::CDacl *a3)
{
  struct _ACL *pDacl; // rax
  DWORD v6; // ebx

  if ( !handle )
    return 0;
  pDacl = (struct _ACL *)ATL::CAcl::GetPACL(a3);
  v6 = SetSecurityInfo(handle, SE_FILE_OBJECT, 4u, 0LL, 0LL, pDacl, 0LL);
  SetLastError(v6);
  return v6 == 0;
}

//----- (00000001800578DC) ----------------------------------------------------
void __noreturn ATL::AtlThrowLastWin32(void)
{
  int LastError; // eax

  LastError = GetLastError();
  if ( LastError > 0 )
    LastError = (unsigned __int16)LastError | 0x80070000;
  ATL::PrivateAtlThrow(LastError);
}

//----- (0000000180057908) ----------------------------------------------------
void __fastcall JobSecurity::Attach(void **this, struct _SECURITY_DESCRIPTOR *a2)
{
  ULONG v2; // edi

  v2 = 0;
  if ( a2 )
  {
    tsched::AutoLocalPtr<_SECURITY_DESCRIPTOR>::Attach(this, a2);
    v2 = RtlLengthSecurityDescriptor(a2);
  }
  else
  {
    tsched::AutoLocalPtr<_SECURITY_DESCRIPTOR>::Attach(this, 0LL);
  }
  *((_DWORD *)this + 2) = v2;
}

//----- (0000000180057960) ----------------------------------------------------
void __fastcall ATL::CSecurityDesc::Clear(ATL::CSecurityDesc *this)
{
  void *v2; // rcx
  PSID pGroup; // [rsp+20h] [rbp-20h] BYREF
  PACL pDacl; // [rsp+28h] [rbp-18h] BYREF
  PACL pSacl; // [rsp+30h] [rbp-10h] BYREF
  WORD pControl; // [rsp+60h] [rbp+20h] BYREF
  DWORD dwRevision; // [rsp+68h] [rbp+28h] BYREF
  WINBOOL bDaclPresent; // [rsp+70h] [rbp+30h] BYREF
  PSID pOwner; // [rsp+78h] [rbp+38h] BYREF

  v2 = (void *)*((_QWORD *)this + 1);
  if ( v2 )
  {
    pControl = 0;
    if ( GetSecurityDescriptorControl(v2, &pControl, &dwRevision) && (pControl & 0x8000u) == 0 )
    {
      GetSecurityDescriptorOwner(*((PSECURITY_DESCRIPTOR *)this + 1), &pOwner, (LPBOOL)&dwRevision);
      free(pOwner);
      GetSecurityDescriptorGroup(*((PSECURITY_DESCRIPTOR *)this + 1), &pGroup, (LPBOOL)&dwRevision);
      free(pGroup);
      GetSecurityDescriptorDacl(*((PSECURITY_DESCRIPTOR *)this + 1), &bDaclPresent, &pDacl, (LPBOOL)&dwRevision);
      if ( bDaclPresent )
        free(pDacl);
      GetSecurityDescriptorSacl(*((PSECURITY_DESCRIPTOR *)this + 1), &bDaclPresent, &pSacl, (LPBOOL)&dwRevision);
      if ( bDaclPresent )
        free(pSacl);
    }
    free(*((void **)this + 1));
    *((_QWORD *)this + 1) = 0LL;
  }
}

//----- (0000000180057A84) ----------------------------------------------------
void __fastcall wil::details_abi::ThreadLocalData::Clear(wil::details_abi::ThreadLocalData *this)
{
  char *v1; // rbx
  char *v3; // rsi
  char *v4; // rbx
  HANDLE ProcessHeap; // rax
  HANDLE v6; // rax

  v1 = (char *)*((_QWORD *)this + 3);
  v3 = &v1[80 * *((unsigned __int16 *)this + 16)];
  if ( v1 != v3 )
  {
    v4 = v1 + 64;
    do
    {
      ProcessHeap = GetProcessHeap();
      HeapFree(ProcessHeap, 0, *(LPVOID *)v4);
      *(_QWORD *)v4 = 0LL;
      *((_QWORD *)v4 + 1) = 0LL;
      v4 += 80;
    }
    while ( v4 - 64 != v3 );
    v1 = (char *)*((_QWORD *)this + 3);
  }
  v6 = GetProcessHeap();
  HeapFree(v6, 0, v1);
  *((_DWORD *)this + 8) = 0;
  *((_QWORD *)this + 3) = 0LL;
}

//----- (0000000180057B40) ----------------------------------------------------
void __fastcall wil::details::CloseHandle(wil::details *this, void *a2)
{
  __int64 v2; // r8
  const char *v3; // r9
  wil::details::in1diag3 *retaddr; // [rsp+28h] [rbp+0h]

  if ( !CloseHandle(this) )
  {
    wil::details::in1diag3::_FailFast_GetLastError(retaddr, (void *)0x926, v2, v3);
    __debugbreak();
  }
}
// 180057B5E: variable 'v2' is possibly undefined
// 180057B5E: variable 'v3' is possibly undefined

//----- (0000000180057B70) ----------------------------------------------------
__int64 __fastcall wil::details_abi::UsageIndexProperty::Compare(const void **this, void *a2, size_t a3)
{
  __int64 v3; // rax

  v3 = *((unsigned __int16 *)this + 4);
  if ( a3 == v3 )
    return (unsigned int)memcmp_0(a2, this[3], a3);
  else
    return (unsigned int)(a3 - v3);
}

//----- (0000000180057BA4) ----------------------------------------------------
__int64 __fastcall JobStore::CopyDirectoryWithPermissions(char **this, unsigned __int16 *a2, unsigned __int16 *a3)
{
  unsigned int v5; // edi
  signed int LastError; // eax
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  unsigned int v11; // ebx
  int v13; // eax
  const WCHAR *v14; // [rsp+40h] [rbp-48h] BYREF
  const WCHAR *v15; // [rsp+48h] [rbp-40h] BYREF
  struct _SECURITY_ATTRIBUTES v16; // [rsp+50h] [rbp-38h] BYREF
  unsigned int v17; // [rsp+A8h] [rbp+20h] BYREF

  v16.nLength = 24;
  v5 = 0;
  v16.bInheritHandle = 0;
  v16.lpSecurityDescriptor = 0LL;
  if ( CreateDirectoryW(a3, &v16) || (LastError = GetLastError(), v11 = LastError, LastError == 183) )
  {
    v13 = JobStore::DuplicateFilePermissions(this, a2, a3);
    if ( v13 < 0 )
      return (unsigned int)v13;
    return v5;
  }
  else
  {
    if ( LastError > 0 )
      v11 = (unsigned __int16)LastError | 0x80070000;
    if ( (unsigned int)dword_1800AFF68 > 4
      && (qword_1800AFF78 & 0x400000000001LL) != 0
      && (qword_1800AFF80 & 0x400000000001LL) == qword_1800AFF80 )
    {
      v14 = a3;
      v15 = a2;
      v17 = v11;
      _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapperByVal<4>,_tlgWrapSz<unsigned short>,_tlgWrapSz<unsigned short>>(
        v8,
        byte_18007ED45,
        v9,
        v10,
        (__int64)&v17,
        &v15,
        &v14);
    }
    return v11;
  }
}
// 180057C75: variable 'v8' is possibly undefined
// 180057C75: variable 'v9' is possibly undefined
// 180057C75: variable 'v10' is possibly undefined
// 18007ED45: using guessed type unsigned __int8 byte_18007ED45[54];
// 1800AFF78: using guessed type __int64 qword_1800AFF78;
// 1800AFF80: using guessed type __int64 qword_1800AFF80;
// 180057BA4: using guessed type struct _SECURITY_ATTRIBUTES anonymous_0;

//----- (0000000180057CB0) ----------------------------------------------------
__int64 __fastcall JobStore::CopyDirectoryWithPermissionsRecursive(
        char **this,
        unsigned __int16 *a2,
        unsigned __int16 *a3)
{
  int LastHrError; // edi
  const WCHAR *v7; // rcx
  tsched *v8; // rcx
  HANDLE FirstFileW; // rsi
  unsigned __int16 *v10; // r8
  const wchar_t **v11; // rbx
  unsigned __int16 *v12; // rdx
  _QWORD *v13; // rcx
  const wchar_t *v14; // r9
  unsigned __int16 v15; // dx
  unsigned __int16 *v16; // r8
  const wchar_t **v17; // rbx
  unsigned __int16 *v18; // rdx
  signed int LastError; // eax
  const wchar_t **v21; // [rsp+30h] [rbp-D0h] BYREF
  OLECHAR **v22; // [rsp+38h] [rbp-C8h] BYREF
  const WCHAR **v23; // [rsp+40h] [rbp-C0h] BYREF
  BSTR *v24; // [rsp+48h] [rbp-B8h] BYREF
  BSTR *v25; // [rsp+50h] [rbp-B0h] BYREF
  BSTR *v26; // [rsp+58h] [rbp-A8h] BYREF
  BSTR *v27[2]; // [rsp+60h] [rbp-A0h] BYREF
  struct _WIN32_FIND_DATAW FindFileData; // [rsp+70h] [rbp-90h] BYREF

  v27[1] = (BSTR *)-2LL;
  LastHrError = JobStore::CopyDirectoryWithPermissions(this, a2, a3);
  if ( LastHrError < 0
    && WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
  {
    WPP_SF_SD(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x18u, (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids, a2);
  }
  _bstr_t::_bstr_t((_bstr_t *)&v23, a2);
  _bstr_t::_bstr_t((_bstr_t *)&v21, L"\\*");
  _bstr_t::operator+=((OLECHAR ***)&v23, (BSTR **)&v21);
  _bstr_t::_Free((_bstr_t *)&v21);
  if ( v23 )
    v7 = *v23;
  else
    v7 = 0LL;
  FirstFileW = FindFirstFileW(v7, &FindFileData);
  if ( FirstFileW == (HANDLE)-1LL )
  {
    LastHrError = tsched::GetLastHrError(v8);
    goto LABEL_49;
  }
  do
  {
    if ( FindFileData.cFileName[0] == 46 )
      continue;
    _bstr_t::_bstr_t((_bstr_t *)&v21, a2);
    _bstr_t::_bstr_t((_bstr_t *)&v24, L"\\");
    _bstr_t::operator+=((OLECHAR ***)&v21, &v24);
    _bstr_t::_Free((_bstr_t *)&v24);
    _bstr_t::_bstr_t((_bstr_t *)&v25, FindFileData.cFileName);
    _bstr_t::operator+=((OLECHAR ***)&v21, &v25);
    _bstr_t::_Free((_bstr_t *)&v25);
    _bstr_t::_bstr_t((_bstr_t *)&v22, a3);
    _bstr_t::_bstr_t((_bstr_t *)&v26, L"\\");
    _bstr_t::operator+=(&v22, &v26);
    _bstr_t::_Free((_bstr_t *)&v26);
    _bstr_t::_bstr_t((_bstr_t *)v27, FindFileData.cFileName);
    _bstr_t::operator+=(&v22, v27);
    _bstr_t::_Free((_bstr_t *)v27);
    if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
    {
      if ( v22 )
        v10 = *v22;
      else
        v10 = 0LL;
      v11 = v21;
      if ( v21 )
        v12 = (unsigned __int16 *)*v21;
      else
        v12 = 0LL;
      LastHrError = JobStore::CopyDirectoryWithPermissionsRecursive((JobStore *)this, v12, v10);
      if ( LastHrError >= 0 )
        goto LABEL_42;
      v13 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
        || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) == 0
        || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
      {
        goto LABEL_42;
      }
      if ( v11 )
        v14 = *v11;
      else
        v14 = 0LL;
      v15 = 25;
    }
    else
    {
      if ( v22 )
        v16 = *v22;
      else
        v16 = 0LL;
      v17 = v21;
      if ( v21 )
        v18 = (unsigned __int16 *)*v21;
      else
        v18 = 0LL;
      LastHrError = JobStore::CopyFileWithPermissions(this, v18, v16);
      if ( LastHrError >= 0 )
        goto LABEL_42;
      v13 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
        || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) == 0
        || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
      {
        goto LABEL_42;
      }
      if ( v17 )
        v14 = *v17;
      else
        v14 = 0LL;
      v15 = 26;
    }
    WPP_SF_SD(v13[2], v15, (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids, v14);
LABEL_42:
    _bstr_t::_Free((_bstr_t *)&v22);
    _bstr_t::_Free((_bstr_t *)&v21);
  }
  while ( FindNextFileW(FirstFileW, &FindFileData) );
  LastError = GetLastError();
  if ( LastError != 18 )
  {
    if ( LastError > 0 )
      LastHrError = (unsigned __int16)LastError | 0x80070000;
    else
      LastHrError = LastError;
  }
  FindClose(FirstFileW);
LABEL_49:
  _bstr_t::_Free((_bstr_t *)&v23);
  return (unsigned int)LastHrError;
}
// 180057D9B: variable 'v8' is possibly undefined
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180058064) ----------------------------------------------------
__int64 __fastcall JobStore::CopyFileWithPermissions(char **this, unsigned __int16 *a2, unsigned __int16 *a3)
{
  tsched *v6; // rcx
  unsigned int LastHrError; // ebx
  __int64 v8; // r8
  __int64 v9; // r9
  int v10; // eax
  const WCHAR *v12; // [rsp+40h] [rbp-18h] BYREF
  const WCHAR *v13; // [rsp+48h] [rbp-10h] BYREF
  unsigned int v14; // [rsp+78h] [rbp+20h] BYREF

  LastHrError = 0;
  if ( CopyFileW(a2, a3, 0) )
  {
    v10 = JobStore::DuplicateFilePermissions(this, a2, a3);
    if ( v10 < 0 )
      return (unsigned int)v10;
  }
  else
  {
    LastHrError = tsched::GetLastHrError(v6);
    if ( (unsigned int)dword_1800AFF68 > 4
      && (qword_1800AFF78 & 0x400000000001LL) != 0
      && (qword_1800AFF80 & 0x400000000001LL) == qword_1800AFF80 )
    {
      v12 = a3;
      v13 = a2;
      v14 = LastHrError;
      _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapperByVal<4>,_tlgWrapSz<unsigned short>,_tlgWrapSz<unsigned short>>(
        qword_1800AFF80 & 0x400000000001LL,
        byte_18007ED45,
        v8,
        v9,
        (__int64)&v14,
        &v13,
        &v12);
    }
  }
  return LastHrError;
}
// 18005809C: variable 'v6' is possibly undefined
// 180058105: variable 'v8' is possibly undefined
// 180058105: variable 'v9' is possibly undefined
// 18007ED45: using guessed type unsigned __int8 byte_18007ED45[54];
// 1800AFF78: using guessed type __int64 qword_1800AFF78;
// 1800AFF80: using guessed type __int64 qword_1800AFF80;

//----- (0000000180058140) ----------------------------------------------------
__int64 __fastcall wil::details_abi::SemaphoreValue::CreateFromValueInternal(
        wil::details_abi::SemaphoreValue *this,
        char *a2,
        __int64 a3,
        unsigned __int64 a4)
{
  WCHAR *v6; // rax
  __int64 v7; // rcx
  LONG v8; // edi
  __int64 v9; // rax
  WCHAR *v10; // rcx
  __int64 v11; // rdx
  __int64 v12; // r8
  char *v13; // rax
  WCHAR v14; // r9
  WCHAR *v15; // rax
  LONG v16; // r8d
  unsigned __int64 v17; // rbp
  LONG v18; // esi
  HANDLE Semaphore; // rax
  __int64 v20; // rdx
  wil::details *v21; // rcx
  __int64 v22; // r8
  const char *v23; // r9
  __int64 v24; // r8
  signed int LastErrorFailHr; // esi
  __int64 v27; // rcx
  WCHAR *v28; // rax
  __int64 v29; // rax
  WCHAR *v30; // rcx
  __int64 v31; // rbx
  __int64 v32; // rdx
  char *v33; // rax
  WCHAR v34; // r8
  WCHAR *v35; // rax
  HANDLE v36; // rax
  __int64 v37; // rdx
  wil::details *v38; // rcx
  __int64 v39; // r8
  const char *v40; // r9
  __int64 v41; // r8
  signed int v42; // ebx
  WCHAR Name[264]; // [rsp+30h] [rbp-248h] BYREF
  wil::details::in1diag3 *retaddr; // [rsp+278h] [rbp+0h]

  if ( (a4 & 0xC000000000000000uLL) != 0 )
    wil::details::in1diag3::_FailFastImmediate_Unexpected(this);
  StringCchCopyW((char *)Name, 260LL, a2);
  v6 = Name;
  v7 = 260LL;
  v8 = 1;
  do
  {
    if ( !*v6 )
      break;
    ++v6;
    --v7;
  }
  while ( v7 );
  if ( v7 )
    v9 = 260 - v7;
  else
    v9 = 0LL;
  if ( v7 )
  {
    v10 = &Name[v9];
    v11 = 260 - v9;
    if ( v9 != 260 )
    {
      v12 = 2147483646LL;
      v13 = (char *)((char *)L"_p0" - (char *)v10);
      do
      {
        if ( !v12 )
          break;
        v14 = *(WCHAR *)((char *)v10 + (_QWORD)v13);
        if ( !v14 )
          break;
        *v10 = v14;
        --v12;
        ++v10;
        --v11;
      }
      while ( v11 );
    }
    v15 = v10 - 1;
    if ( v11 )
      v15 = v10;
    *v15 = 0;
  }
  v16 = 1;
  v17 = a4 >> 31;
  v18 = a4 & 0x7FFFFFFF;
  if ( v18 )
    v16 = v18;
  Semaphore = CreateSemaphoreExW(0LL, v18, v16, Name, 0, 0x1F0003u);
  if ( Semaphore )
  {
    wil::details::unique_storage<wil::details::resource_policy<void *,void (*)(void *),&void wil::details::CloseHandle(void *),wistd::integral_constant<unsigned __int64,0>,void *,void *,0,std::nullptr_t>>::reset(
      (__int64 *)this,
      (__int64)Semaphore);
    LastErrorFailHr = 0;
  }
  else
  {
    LastErrorFailHr = wil::details::GetLastErrorFailHr(v21, v20, v22, v23);
  }
  if ( LastErrorFailHr >= 0 )
  {
    v27 = 260LL;
    v28 = Name;
    do
    {
      if ( !*v28 )
        break;
      ++v28;
      --v27;
    }
    while ( v27 );
    if ( v27 )
      v29 = 260 - v27;
    else
      v29 = 0LL;
    if ( v27 )
    {
      v30 = &Name[v29];
      v31 = 260 - v29;
      if ( 260 != v29 )
      {
        v32 = 2147483646LL;
        v33 = (char *)((char *)L"h" - (char *)v30);
        do
        {
          if ( !v32 )
            break;
          v34 = *(WCHAR *)((char *)v30 + (_QWORD)v33);
          if ( !v34 )
            break;
          *v30 = v34;
          --v32;
          ++v30;
          --v31;
        }
        while ( v31 );
      }
      v35 = v30 - 1;
      if ( v31 )
        v35 = v30;
      *v35 = 0;
    }
    if ( (_DWORD)v17 )
      v8 = v17;
    v36 = CreateSemaphoreExW(0LL, v17, v8, Name, 0, 0x1F0003u);
    if ( v36 )
    {
      wil::details::unique_storage<wil::details::resource_policy<void *,void (*)(void *),&void wil::details::CloseHandle(void *),wistd::integral_constant<unsigned __int64,0>,void *,void *,0,std::nullptr_t>>::reset(
        (__int64 *)this + 1,
        (__int64)v36);
      v42 = 0;
    }
    else
    {
      v42 = wil::details::GetLastErrorFailHr(v38, v37, v39, v40);
    }
    if ( v42 >= 0 )
    {
      return 0LL;
    }
    else
    {
      wil::details::in1diag3::Return_Hr(retaddr, (void *)0x89, v41, (const char *)(unsigned int)v42);
      return (unsigned int)v42;
    }
  }
  else
  {
    wil::details::in1diag3::Return_Hr(retaddr, (void *)0x85, v24, (const char *)(unsigned int)LastErrorFailHr);
    return (unsigned int)LastErrorFailHr;
  }
}
// 180058265: variable 'v21' is possibly undefined
// 180058265: variable 'v20' is possibly undefined
// 180058265: variable 'v22' is possibly undefined
// 180058265: variable 'v23' is possibly undefined
// 180058280: variable 'v24' is possibly undefined
// 180058349: variable 'v38' is possibly undefined
// 180058349: variable 'v37' is possibly undefined
// 180058349: variable 'v39' is possibly undefined
// 180058349: variable 'v40' is possibly undefined
// 180058364: variable 'v41' is possibly undefined
// 1800803C0: using guessed type wchar_t aP0[4];
// 1800803C8: using guessed type wchar_t asc_1800803C8[2];
// 180058140: using guessed type WCHAR Name[264];

//----- (00000001800583A0) ----------------------------------------------------
__int64 __fastcall JobStore::CreateXmlFolder(JobStore *this, char *a2, LPCWSTR StringSecurityDescriptor)
{
  int XmlFileSystemPath; // edi
  wchar_t *v8; // rbx
  struct _SECURITY_ATTRIBUTES *v9; // r14
  signed int LastError; // eax
  _QWORD *v11; // rcx
  unsigned __int16 v12; // dx
  LPWSTR v13; // r15
  LPWSTR v14; // rax
  LPWSTR v15; // rsi
  WCHAR v16; // ax
  WCHAR v17; // cx
  struct _SECURITY_ATTRIBUTES *v18; // rdx
  LPCWSTR lpPathName; // [rsp+38h] [rbp-D0h] BYREF
  void **v20; // [rsp+40h] [rbp-C8h] BYREF
  __int64 v21; // [rsp+48h] [rbp-C0h]
  __int64 v22; // [rsp+50h] [rbp-B8h] BYREF
  __int64 v23; // [rsp+58h] [rbp-B0h]
  __int64 v24; // [rsp+60h] [rbp-A8h]
  __int64 v25; // [rsp+68h] [rbp-A0h]
  WCHAR pszPath[264]; // [rsp+78h] [rbp-90h] BYREF

  v25 = -2LL;
  if ( !JobStore::GetUseXmlStore(this) )
    return 0LL;
  lpPathName = 0LL;
  XmlFileSystemPath = JobStore::GetXmlFileSystemPath((char **)this, a2, (void **)&lpPathName);
  v8 = (wchar_t *)lpPathName;
  if ( XmlFileSystemPath >= 0 )
  {
    v20 = &ATL::CSecurityDesc::`vftable';
    v21 = 0LL;
    LODWORD(v22) = 0;
    v23 = 0LL;
    LODWORD(v24) = 0;
    v9 = 0LL;
    if ( StringSecurityDescriptor )
    {
      if ( !ATL::CSecurityDesc::FromString((ATL::CSecurityDesc *)&v20, StringSecurityDescriptor) )
      {
        if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
          && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
          && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
        {
          WPP_SF_SD(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x1Bu,
            (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
            StringSecurityDescriptor);
        }
        XmlFileSystemPath = -2147023558;
        goto LABEL_46;
      }
      v23 = v21;
      LODWORD(v22) = 24;
      v9 = (struct _SECURITY_ATTRIBUTES *)&v22;
    }
    if ( !CreateDirectoryW(v8, v9) )
    {
      memset_0(pszPath, 0, 0x208uLL);
      LastError = GetLastError();
      XmlFileSystemPath = LastError;
      if ( LastError != 3 )
      {
        if ( LastError > 0 )
          XmlFileSystemPath = (unsigned __int16)LastError | 0x80070000;
        if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
          && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
          && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
        {
          WPP_SF_SD(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x1Cu,
            (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
            v8);
        }
        goto LABEL_46;
      }
      if ( (int)StringCchCopyW((char *)pszPath, 260LL, (char *)v8) < 0 )
      {
        v11 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
          || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) == 0
          || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
        {
          goto LABEL_36;
        }
        v12 = 29;
LABEL_35:
        WPP_SF_SD(v11[2], v12, (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids, v8);
LABEL_36:
        XmlFileSystemPath = -2147024690;
LABEL_46:
        v20 = &ATL::CSecurityDesc::`vftable';
        ATL::CSecurityDesc::Clear((ATL::CSecurityDesc *)&v20);
        goto LABEL_47;
      }
      v13 = PathAddBackslashW(pszPath);
      if ( !v13 )
      {
        v11 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
          || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) == 0
          || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
        {
          goto LABEL_36;
        }
        v12 = 30;
        goto LABEL_35;
      }
      v14 = PathSkipRootW(pszPath);
      v15 = v14;
      if ( !v14 )
      {
        v11 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
          || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) == 0
          || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
        {
          goto LABEL_36;
        }
        v12 = 31;
        goto LABEL_35;
      }
      v16 = *v14;
      if ( v16 )
      {
        do
        {
          do
          {
            v17 = v16;
            if ( v16 == 92 )
              break;
            v16 = *++v15;
            v17 = *v15;
          }
          while ( *v15 );
          if ( v17 )
          {
            *v15 = 0;
            v18 = 0LL;
            if ( v15 + 1 == v13 )
              v18 = v9;
            CreateDirectoryW(pszPath, v18);
            *v15++ = 92;
          }
          v16 = *v15;
        }
        while ( *v15 );
      }
    }
    XmlFileSystemPath = 0;
    goto LABEL_46;
  }
LABEL_47:
  operator delete(v8);
  return (unsigned int)XmlFileSystemPath;
}
// 180071740: using guessed type void *ATL::CSecurityDesc::`vftable';
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180058724) ----------------------------------------------------
void JobStore::DeleteCommonJobStore(void)
{
  JobStore *v0; // rbx

  v0 = JobStore::m_pCommonStore;
  if ( JobStore::m_pCommonStore )
  {
    if ( pbHashObject )
    {
      operator delete(pbHashObject);
      pbHashObject = 0LL;
      v0 = JobStore::m_pCommonStore;
    }
    if ( *(&pbHashObject + 1) )
    {
      BCryptCloseAlgorithmProvider(*(&pbHashObject + 1), 0);
      *(&pbHashObject + 1) = 0LL;
      v0 = JobStore::m_pCommonStore;
    }
    if ( v0 )
    {
      JobStore::~JobStore(v0);
      operator delete(v0);
    }
    JobStore::m_pCommonStore = 0LL;
  }
}

//----- (00000001800587AC) ----------------------------------------------------
__int64 __fastcall JobStore::DeleteExpiredTask(JobStore *this, const struct JobMoniker *a2)
{
  const unsigned __int16 *Path; // rax
  unsigned __int16 *v5; // rdx
  unsigned int v6; // ebx
  int v8; // [rsp+40h] [rbp-48h] BYREF
  __int64 v9; // [rsp+48h] [rbp-40h]
  char v10[16]; // [rsp+50h] [rbp-38h] BYREF
  char v11[16]; // [rsp+60h] [rbp-28h] BYREF
  char v12[8]; // [rsp+70h] [rbp-18h] BYREF

  v9 = -2LL;
  JobMoniker::JobMoniker((JobMoniker *)v10, 0LL, 0LL);
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
  {
    Path = JobMoniker::GetPath(a2);
    WPP_SF_S(*((_QWORD *)WPP_GLOBAL_Control + 2), 80LL, &WPP_0fa9442aab3237762f9b607a66102705_Traceguids, Path);
  }
  v5 = (unsigned __int16 *)JobMoniker::GetPath(a2);
  v6 = JobStore::RemoveTaskOrFolderP(this, v5, 0, 0, 1, &v8, (struct JobMoniker *)v10);
  wmi::AutoRef<JobBucket>::Release(v12);
  _bstr_t::_Free((_bstr_t *)v11);
  return v6;
}
// 18001306C: using guessed type __int64 __fastcall wmi::AutoRef<JobBucket>::Release(_QWORD);
// 18004ED5C: using guessed type __int64 __fastcall WPP_SF_S(_QWORD, _QWORD, _QWORD, _QWORD);
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 1800587AC: using guessed type char var_18[8];
// 1800587AC: using guessed type char var_28[16];

//----- (00000001800588B0) ----------------------------------------------------
void __fastcall wil::details::DestroyThreadPoolTimer<wil::details::SystemThreadPoolMethods,0>::Destroy(PTP_TIMER pti)
{
  SetThreadpoolTimer(pti, 0LL, 0, 0);
  WaitForThreadpoolTimerCallbacks(pti, 1);
  CloseThreadpoolTimer(pti);
}

//----- (00000001800588FC) ----------------------------------------------------
void __fastcall wil::details_abi::SemaphoreValue::Destroy(wil::details_abi::SemaphoreValue *this)
{
  wil::details::unique_storage<wil::details::resource_policy<void *,void (*)(void *),&void wil::details::CloseHandle(void *),wistd::integral_constant<unsigned __int64,0>,void *,void *,0,std::nullptr_t>>::reset(
    (__int64 *)this,
    0LL);
  wil::details::unique_storage<wil::details::resource_policy<void *,void (*)(void *),&void wil::details::CloseHandle(void *),wistd::integral_constant<unsigned __int64,0>,void *,void *,0,std::nullptr_t>>::reset(
    (__int64 *)this + 1,
    0LL);
}

//----- (0000000180058924) ----------------------------------------------------
__int64 __fastcall JobStore::DestroyMigratedUbpmStatsFiles(JobStore *this)
{
  unsigned int LastHrError; // ebx
  tsched *v2; // rcx
  _QWORD *v3; // rcx
  unsigned __int16 v4; // dx
  tsched *v5; // rcx
  WCHAR Dst[264]; // [rsp+30h] [rbp-228h] BYREF

  LastHrError = 0;
  memset_0(Dst, 0, 0x208uLL);
  if ( ExpandEnvironmentStringsW(L"%SystemRoot%\\System32\\logfiles\\UbpmMigratedStats", Dst, 0x104u) )
  {
    if ( !RemoveDirectoryW(Dst) )
    {
      LastHrError = tsched::GetLastHrError(v5);
      v3 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        v4 = 92;
        goto LABEL_11;
      }
    }
  }
  else
  {
    LastHrError = tsched::GetLastHrError(v2);
    v3 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      v4 = 91;
LABEL_11:
      WPP_SF_SD(v3[2], v4, (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids, Dst);
    }
  }
  return LastHrError;
}
// 180058975: variable 'v2' is possibly undefined
// 1800589BA: variable 'v5' is possibly undefined
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180058A24) ----------------------------------------------------
__int64 __fastcall JobStore::DropBackupRestorePermissions(JobStore *this, BOOLEAN a2, char a3)
{
  int v4; // ebx
  __int64 v6; // rcx
  NTSTATUS v7; // edi
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // rcx
  NTSTATUS v11; // edi
  __int64 v12; // r8
  __int64 v13; // r9
  char v15; // [rsp+40h] [rbp-10h] BYREF
  char v16[3]; // [rsp+41h] [rbp-Fh] BYREF
  int v17[3]; // [rsp+44h] [rbp-Ch] BYREF
  JobStore *OldValue; // [rsp+80h] [rbp+30h] BYREF
  char v19; // [rsp+98h] [rbp+48h] BYREF

  OldValue = this;
  v4 = 0;
  v7 = RtlAdjustPrivilege(0x11u, a2, 0, (PBOOLEAN)&OldValue);
  if ( v7 < 0 )
  {
    if ( (unsigned int)dword_1800AFF68 > 4
      && (qword_1800AFF78 & 0x400000000001LL) != 0
      && (qword_1800AFF80 & 0x400000000001LL) == qword_1800AFF80 )
    {
      v19 = (char)OldValue;
      v15 = a3;
      v16[0] = a2;
      v17[0] = v7;
      _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapperByVal<4>,_tlgWrapperByVal<1>,_tlgWrapperByVal<1>,_tlgWrapperByVal<1>>(
        v6,
        byte_18007EDB6,
        v8,
        v9,
        (__int64)v17,
        (__int64)v16,
        (__int64)&v15,
        (__int64)&v19);
    }
    v4 = v7 | 0x10000000;
  }
  v11 = RtlAdjustPrivilege(0x12u, 0, 0, (PBOOLEAN)&OldValue);
  if ( v11 < 0 )
  {
    if ( (unsigned int)dword_1800AFF68 > 4
      && (qword_1800AFF78 & 0x400000000001LL) != 0
      && (qword_1800AFF80 & 0x400000000001LL) == qword_1800AFF80 )
    {
      v19 = (char)OldValue;
      v16[0] = a3;
      v15 = a2;
      v17[0] = v11;
      _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapperByVal<4>,_tlgWrapperByVal<1>,_tlgWrapperByVal<1>,_tlgWrapperByVal<1>>(
        v10,
        byte_18007EF25,
        v12,
        v13,
        (__int64)v17,
        (__int64)&v15,
        (__int64)v16,
        (__int64)&v19);
    }
    if ( v4 >= 0 )
      return (unsigned int)(v11 | 0x10000000);
  }
  return (unsigned int)v4;
}
// 180058ACB: variable 'v6' is possibly undefined
// 180058ACB: variable 'v8' is possibly undefined
// 180058ACB: variable 'v9' is possibly undefined
// 180058B55: variable 'v10' is possibly undefined
// 180058B55: variable 'v12' is possibly undefined
// 180058B55: variable 'v13' is possibly undefined
// 18007EDB6: using guessed type unsigned __int8 byte_18007EDB6[107];
// 18007EF25: using guessed type unsigned __int8 byte_18007EF25[108];
// 1800AFF78: using guessed type __int64 qword_1800AFF78;
// 1800AFF80: using guessed type __int64 qword_1800AFF80;

//----- (0000000180058B84) ----------------------------------------------------
__int64 __fastcall JobStore::DuplicateFilePermissions(char **this, unsigned __int16 *a2, unsigned __int16 *a3)
{
  unsigned int v5; // ebx
  __int64 v6; // rcx
  __int64 v7; // r9
  tsched *v8; // rcx
  signed int LastHrError; // eax
  __int64 v10; // r9
  HANDLE FileW; // rax
  tsched *v12; // rcx
  void *v13; // r14
  __int64 v14; // rcx
  __int64 v15; // r9
  tsched *v16; // rcx
  __int64 v17; // rcx
  __int64 v18; // r9
  const WCHAR *v20; // [rsp+40h] [rbp-9h] BYREF
  const WCHAR *v21; // [rsp+48h] [rbp-1h] BYREF
  PACL pDacl; // [rsp+50h] [rbp+7h] BYREF
  PSID psidGroup; // [rsp+58h] [rbp+Fh] BYREF
  PSID ppsidOwner; // [rsp+60h] [rbp+17h] BYREF
  PSECURITY_DESCRIPTOR ppSecurityDescriptor; // [rsp+68h] [rbp+1Fh] BYREF
  unsigned int v26; // [rsp+C8h] [rbp+7Fh] BYREF

  v5 = 0;
  if ( JobStore::RealPathIsValid(this, a3) )
  {
    if ( GetNamedSecurityInfoW(a2, SE_FILE_OBJECT, 7u, &ppsidOwner, &psidGroup, &pDacl, 0LL, &ppSecurityDescriptor) )
    {
      LastHrError = tsched::GetLastHrError(v8);
      v5 = LastHrError;
      if ( (unsigned int)dword_1800AFF68 > 4
        && (qword_1800AFF78 & 0x400000000001LL) != 0
        && (qword_1800AFF80 & 0x400000000001LL) == qword_1800AFF80 )
      {
        v26 = LastHrError;
        v21 = a3;
        v20 = a2;
        _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapperByVal<4>,_tlgWrapSz<unsigned short>,_tlgWrapSz<unsigned short>>(
          qword_1800AFF80 & 0x400000000001LL,
          byte_18007ED7B,
          0x400000000001LL,
          v10,
          (__int64)&v26,
          &v20,
          &v21);
      }
    }
    else
    {
      FileW = CreateFileW(a3, 0xE0000u, 0, 0LL, 3u, 0x2200000u, 0LL);
      v13 = FileW;
      if ( FileW == (HANDLE)-1LL )
      {
        v5 = tsched::GetLastHrError(v12);
        if ( (unsigned int)dword_1800AFF68 > 4
          && (qword_1800AFF78 & 0x400000000001LL) != 0
          && (qword_1800AFF80 & 0x400000000001LL) == qword_1800AFF80 )
        {
          v21 = a3;
          v20 = a2;
          v26 = v5;
          _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapperByVal<4>,_tlgWrapSz<unsigned short>,_tlgWrapSz<unsigned short>>(
            v14,
            byte_18007EF91,
            0x400000000001LL,
            v15,
            (__int64)&v26,
            &v20,
            &v21);
        }
      }
      else
      {
        if ( SetSecurityInfo(FileW, SE_FILE_OBJECT, 7u, ppsidOwner, psidGroup, pDacl, 0LL) )
        {
          v5 = tsched::GetLastHrError(v16);
          if ( (unsigned int)dword_1800AFF68 > 4
            && (qword_1800AFF78 & 0x400000000001LL) != 0
            && (qword_1800AFF80 & 0x400000000001LL) == qword_1800AFF80 )
          {
            v21 = a3;
            v20 = a2;
            v26 = v5;
            _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapperByVal<4>,_tlgWrapSz<unsigned short>,_tlgWrapSz<unsigned short>>(
              v17,
              byte_18007ED0A,
              0x400000000001LL,
              v18,
              (__int64)&v26,
              &v20,
              &v21);
          }
        }
        CloseHandle(v13);
      }
    }
  }
  else
  {
    v5 = -2147024891;
    if ( (unsigned int)dword_1800AFF68 > 4
      && (qword_1800AFF78 & 0x400000000001LL) != 0
      && (qword_1800AFF80 & 0x400000000001LL) == qword_1800AFF80 )
    {
      v20 = a3;
      v21 = a2;
      v26 = -2147024891;
      _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapperByVal<4>,_tlgWrapSz<unsigned short>,_tlgWrapSz<unsigned short>>(
        v6,
        byte_18007F03A,
        0x400000000001LL,
        v7,
        (__int64)&v26,
        &v21,
        &v20);
    }
  }
  return v5;
}
// 180058C23: variable 'v6' is possibly undefined
// 180058C23: variable 'v7' is possibly undefined
// 180058C6D: variable 'v8' is possibly undefined
// 180058CCE: variable 'v10' is possibly undefined
// 180058D0B: variable 'v12' is possibly undefined
// 180058D6C: variable 'v14' is possibly undefined
// 180058D6C: variable 'v15' is possibly undefined
// 180058DA8: variable 'v16' is possibly undefined
// 180058E0B: variable 'v17' is possibly undefined
// 180058E0B: variable 'v18' is possibly undefined
// 18007ED0A: using guessed type unsigned __int8 byte_18007ED0A[59];
// 18007ED7B: using guessed type unsigned __int8 byte_18007ED7B[59];
// 18007EF91: using guessed type unsigned __int8 byte_18007EF91[59];
// 18007F03A: using guessed type unsigned __int8 byte_18007F03A[64];
// 1800AFF78: using guessed type __int64 qword_1800AFF78;
// 1800AFF80: using guessed type __int64 qword_1800AFF80;

//----- (0000000180058E40) ----------------------------------------------------
void __fastcall wil::details::EnsureCoalescedTimer_SetTimer(struct _TP_TIMER **a1, _BYTE *a2, __int64 a3)
{
  struct _TP_TIMER *v3; // rcx
  struct _FILETIME pftDueTime; // [rsp+30h] [rbp+8h] BYREF

  v3 = *a1;
  if ( v3 )
  {
    pftDueTime = (struct _FILETIME)(-10000 * a3);
    SetThreadpoolTimer(v3, &pftDueTime, 0, (unsigned int)a3 >> 2);
    *a2 = 1;
  }
}

//----- (0000000180058E88) ----------------------------------------------------
bool __fastcall wil::details::FeatureStateManager::EnsureStateData(RTL_SRWLOCK *this)
{
  __int64 v2; // rdi
  __int64 Ptr; // rcx
  RTL_SRWLOCK *v5; // [rsp+40h] [rbp+8h] BYREF
  void (__stdcall *v6)(PSRWLOCK); // [rsp+48h] [rbp+10h] BYREF
  char v7; // [rsp+50h] [rbp+18h] BYREF

  if ( !this[3].Ptr )
  {
    wil::last_error_context::last_error_context((wil::last_error_context *)&v7);
    if ( this[3].Ptr )
    {
      v2 = 0LL;
    }
    else
    {
      if ( !this[2].Ptr )
      {
        Ptr = (__int64)this[1].Ptr;
        v5 = 0LL;
        if ( (int)wil::details_abi::ProcessLocalStorageData<wil::details_abi::FeatureStateData>::Acquire(
                    Ptr,
                    (__int64 *)&v5) >= 0
          && !this[2].Ptr )
        {
          this[2].Ptr = v5;
        }
      }
      v2 = ((__int64)this[2].Ptr + 32) & -(__int64)(this[2].Ptr != 0LL);
    }
    AcquireSRWLockExclusive(this + 4);
    if ( !this[3].Ptr )
      this[3].Ptr = (PVOID)v2;
    if ( this != (RTL_SRWLOCK *)-32LL )
    {
      v6 = ReleaseSRWLockExclusive;
      v5 = this + 4;
      wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>((__int64 (__fastcall **)(_QWORD))&v6, &v5);
    }
    wil::last_error_context::~last_error_context((wil::last_error_context *)&v7);
  }
  return this[3].Ptr != 0LL;
}

//----- (0000000180058F58) ----------------------------------------------------
void __fastcall wil::details::FeatureStateManager::EnsureSubscribedToProcessWideUsageFlushUnderLock(
        wil::details::FeatureStateManager *this)
{
  struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ **v2; // rcx
  struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ **v3; // rax
  RTL_SRWLOCK *v4; // rbx
  struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ **v5; // rdi
  RTL_SRWLOCK *v6; // [rsp+30h] [rbp+8h] BYREF

  v2 = (struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ **)((char *)this + 240);
  if ( !*v2 )
  {
    if ( *((_QWORD *)this + 3) )
    {
      v3 = wil::unique_any_t<wil::details::unique_storage<wil::details::resource_policy<FEATURE_STATE_CHANGE_SUBSCRIPTION__ *,void (*)(FEATURE_STATE_CHANGE_SUBSCRIPTION__ *),&void wil::details::UnsubscribeProcessWideUsageFlush(FEATURE_STATE_CHANGE_SUBSCRIPTION__ *),wistd::integral_constant<unsigned __int64,0>,FEATURE_STATE_CHANGE_SUBSCRIPTION__ *,FEATURE_STATE_CHANGE_SUBSCRIPTION__ *,0,std::nullptr_t>>>::put(v2);
      v4 = (RTL_SRWLOCK *)*((_QWORD *)this + 3);
      v5 = v3;
      wil::srwlock::lock_exclusive(v4, &v6);
      wil::details_abi::SubscriptionList::SubscribeUnderLock(
        (wil::details_abi::SubscriptionList *)&v4[25],
        v5,
        (void (__stdcall *)(void *))_lambda_152aa9d2a3a0648fa2fa7fcef514b376_::_lambda_invoker_cdecl_,
        (__int64)this);
      wil::unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_SRWLOCK *,void (*)(_RTL_SRWLOCK *),&void ReleaseSRWLockExclusive(_RTL_SRWLOCK *),wistd::integral_constant<unsigned __int64,1>,_RTL_SRWLOCK *,_RTL_SRWLOCK *,0,std::nullptr_t>>>::~unique_any_t<wil::details::unique_storage<wil::details::resource_policy<_RTL_SRWLOCK *,void (*)(_RTL_SRWLOCK *),&void ReleaseSRWLockExclusive(_RTL_SRWLOCK *),wistd::integral_constant<unsigned __int64,1>,_RTL_SRWLOCK *,_RTL_SRWLOCK *,0,std::nullptr_t>>>((__int64 *)&v6);
    }
  }
}

//----- (0000000180058FD4) ----------------------------------------------------
void __fastcall wil::details::EnabledStateManager::EnsureSubscribedToUsageFlush(
        wil::details::EnabledStateManager *this,
        struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ **a2)
{
  char *v4; // rbx
  wil::details **v5; // rax
  void *v6; // r9
  char *v7; // [rsp+30h] [rbp+8h] BYREF
  void (__stdcall *v8)(PSRWLOCK); // [rsp+40h] [rbp+18h] BYREF

  if ( *(_BYTE *)this )
  {
    v4 = (char *)this + 8;
    AcquireSRWLockExclusive((PSRWLOCK)this + 1);
    if ( !*((_QWORD *)this + 5) )
    {
      v5 = wil::unique_any_t<wil::details::unique_storage<wil::details::resource_policy<FEATURE_STATE_CHANGE_SUBSCRIPTION__ *,void (*)(FEATURE_STATE_CHANGE_SUBSCRIPTION__ *),&void wil::details::WilApi_UnsubscribeFeatureStateChangeNotification(FEATURE_STATE_CHANGE_SUBSCRIPTION__ *),wistd::integral_constant<unsigned __int64,0>,FEATURE_STATE_CHANGE_SUBSCRIPTION__ *,FEATURE_STATE_CHANGE_SUBSCRIPTION__ *,0,std::nullptr_t>>>::put((wil::details **)this + 5);
      wil::details::WilApi_SubscribeFeatureStateChangeNotification(
        (wil::details *)v5,
        a2,
        (void (__stdcall *)(void *))0xFFFFFFFFFFFFFFFFLL,
        v6);
    }
    if ( v4 )
    {
      v8 = ReleaseSRWLockExclusive;
      v7 = v4;
      wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>((__int64 (__fastcall **)(_QWORD))&v8, &v7);
    }
  }
}
// 18005901A: variable 'v6' is possibly undefined

//----- (000000018005905C) ----------------------------------------------------
void __fastcall wil::details::in1diag3::FailFast_Unexpected(
        wil::details::in1diag3 *this,
        void *a2,
        __int64 a3,
        const char *a4)
{
  __int64 retaddr; // [rsp+48h] [rbp+0h]

  wil::details::ReportFailure_Hr(
    (__int64)this,
    0xB4Cu,
    (__int64)"onecore\\internal\\sdk\\inc\\wil\\opensource\\wil\\resource.h",
    0LL,
    0LL,
    retaddr,
    3,
    0x8000FFFF);
}

//----- (00000001800590A0) ----------------------------------------------------
__int64 __fastcall JobStore::FileRemoveTaskXml(JobStore *this, const struct JobMoniker *a2)
{
  char *Path; // rdx
  int XmlFileSystemPath; // ebx
  __int64 FileSafe; // rax
  signed int LastError; // eax
  signed int v9; // eax
  const wchar_t *v10; // rax
  struct _SECURITY_ATTRIBUTES *v11; // [rsp+20h] [rbp-48h]
  HANDLE hFile[2]; // [rsp+48h] [rbp-20h] BYREF
  char FileInformation; // [rsp+80h] [rbp+18h] BYREF
  void *lpMem; // [rsp+88h] [rbp+20h] BYREF

  if ( !JobStore::GetUseXmlStore(this) )
    return 0LL;
  lpMem = 0LL;
  Path = (char *)JobMoniker::GetPath(a2);
  XmlFileSystemPath = JobStore::GetXmlFileSystemPath((char **)this, Path, &lpMem);
  if ( XmlFileSystemPath >= 0 )
  {
    *(_OWORD *)hFile = 0LL;
    LODWORD(v11) = 3;
    FileSafe = tsched::CreateFileSafe((wchar_t *)lpMem, (const unsigned __int16 *)0x10000, 3u, 0LL, v11, 0x2000080u);
    tsched::JobsAutoHandle::operator=((tsched::JobsAutoHandle *)hFile, FileSafe);
    if ( hFile[0] == (HANDLE)-1LL )
    {
      LastError = GetLastError();
      XmlFileSystemPath = LastError;
      if ( LastError > 0 )
        XmlFileSystemPath = (unsigned __int16)LastError | 0x80070000;
    }
    else
    {
      FileInformation = 1;
      if ( SetFileInformationByHandle(hFile[0], FileDispositionInfo, &FileInformation, 1u) )
      {
        XmlFileSystemPath = 0;
      }
      else
      {
        v9 = GetLastError();
        XmlFileSystemPath = v9;
        if ( v9 > 0 )
          XmlFileSystemPath = (unsigned __int16)v9 | 0x80070000;
        if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
          && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
          && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
        {
          v10 = JobMoniker::GetPath(a2);
          WPP_SF_SD(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x4Cu,
            (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
            v10);
        }
      }
    }
    tsched::JobsAutoHandle::Close((tsched::JobsAutoHandle *)hFile);
  }
  operator delete(lpMem);
  return (unsigned int)XmlFileSystemPath;
}
// 180059124: variable 'v11' is possibly undefined
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180059234) ----------------------------------------------------
__int64 __fastcall JobStore::FileSddlSet(JobStore *this, char *a2, const unsigned __int16 *a3)
{
  const unsigned __int16 *v7; // rdx
  int XmlFileSystemPath; // ebx
  const unsigned __int16 *v9; // r9
  void *lpMem; // [rsp+58h] [rbp+20h] BYREF

  if ( !JobStore::GetUseXmlStore(this) )
    return 0LL;
  lpMem = 0LL;
  XmlFileSystemPath = JobStore::GetXmlFileSystemPath((char **)this, a2, &lpMem);
  if ( XmlFileSystemPath >= 0 )
    XmlFileSystemPath = tsched::SetJobFileSecurityByName((wchar_t *)lpMem, v7, a3, v9);
  operator delete(lpMem);
  return (unsigned int)XmlFileSystemPath;
}
// 180059287: variable 'v7' is possibly undefined
// 180059287: variable 'v9' is possibly undefined

//----- (00000001800592C0) ----------------------------------------------------
__int64 __fastcall JobStore::FileSddlSetWithRestorePrivs(
        JobStore *this,
        WCHAR *a2,
        const unsigned __int16 *a3,
        __int64 a4)
{
  int v8; // ebx
  JobStore *v9; // rcx
  unsigned __int8 v10[8]; // [rsp+30h] [rbp-28h] BYREF
  const WCHAR *v11; // [rsp+38h] [rbp-20h] BYREF
  WCHAR *v12; // [rsp+40h] [rbp-18h] BYREF
  unsigned __int8 v13; // [rsp+78h] [rbp+20h] BYREF

  if ( NtCurrentTeb()->IsImpersonating )
  {
    if ( (unsigned int)dword_1800AFF68 > 4
      && (qword_1800AFF78 & 0x400000000001LL) != 0
      && (qword_1800AFF80 & 0x400000000001LL) == qword_1800AFF80 )
    {
      v11 = a3;
      v12 = a2;
      _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapSz<unsigned short>,_tlgWrapSz<unsigned short>>(
        (__int64)this,
        byte_18007EEBD,
        (__int64)a3,
        a4,
        (const WCHAR **)&v12,
        &v11);
    }
    return 5LL;
  }
  else
  {
    v8 = JobStore::TakeBackupRestorePermissions(this, v10, &v13);
    if ( v8 >= 0 )
    {
      v8 = JobStore::FileSddlSet(this, (char *)a2, a3);
      JobStore::DropBackupRestorePermissions(v9, v10[0], v13);
    }
    return (unsigned int)v8;
  }
}
// 180059377: variable 'v9' is possibly undefined
// 18007EEBD: using guessed type unsigned __int8 byte_18007EEBD[65];
// 1800AFF78: using guessed type __int64 qword_1800AFF78;
// 1800AFF80: using guessed type __int64 qword_1800AFF80;
// 1800592C0: using guessed type unsigned __int8 var_28[8];

//----- (000000018005939C) ----------------------------------------------------
__int64 __fastcall JobStore::FileTaskFolderRemove(JobStore *this, char *a2)
{
  unsigned int v4; // edi
  int XmlFileSystemPath; // esi
  wchar_t *v7; // rbx
  tsched *v8; // rcx
  LPCWSTR lpPathName; // [rsp+60h] [rbp+18h] BYREF

  v4 = 0;
  if ( !JobStore::GetUseXmlStore(this) )
    return 0LL;
  lpPathName = 0LL;
  XmlFileSystemPath = JobStore::GetXmlFileSystemPath((char **)this, a2, (void **)&lpPathName);
  v7 = (wchar_t *)lpPathName;
  if ( XmlFileSystemPath < 0 )
    goto LABEL_9;
  if ( !RemoveDirectoryW(lpPathName) )
  {
    XmlFileSystemPath = tsched::GetLastHrError(v8);
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_SD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x22u,
        (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
        v7);
    }
LABEL_9:
    v4 = XmlFileSystemPath;
  }
  operator delete(v7);
  return v4;
}
// 180059400: variable 'v8' is possibly undefined
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180059474) ----------------------------------------------------
unsigned __int8 *__fastcall wil::details_abi::RawUsageIndex::FindInsertionPointOrIncrement(
        wil::details_abi::RawUsageIndex *this,
        struct wil::details_abi::UsageIndexProperty *a2,
        unsigned __int8 *a3,
        void *a4,
        unsigned __int64 a5,
        unsigned int a6)
{
  char v6; // bl
  unsigned __int64 v7; // r15
  int v8; // r12d
  unsigned __int8 *v10; // rsi
  __int64 v13; // rax
  unsigned __int64 v14; // rcx
  unsigned __int64 v15; // rax
  size_t v16; // r14
  unsigned __int8 *v17; // r15
  unsigned __int8 *v18; // rax
  unsigned __int8 *v19; // r8
  int v20; // r15d
  unsigned __int8 *v21; // r8
  const void *v23; // [rsp+30h] [rbp-20h] BYREF
  __int16 v24; // [rsp+38h] [rbp-18h]
  __int128 v25; // [rsp+40h] [rbp-10h]
  unsigned __int8 *v26; // [rsp+80h] [rbp+30h] BYREF

  v6 = 0;
  v7 = *((_QWORD *)this + 2);
  v8 = -1;
  LOWORD(v23) = *((_WORD *)this + 3);
  BYTE2(v23) = *((_BYTE *)this + 8);
  v10 = a3;
  HIDWORD(v23) = 0;
  v24 = 0;
  v25 = 0LL;
  if ( v7 )
  {
    v13 = *((_QWORD *)this + 4);
    v14 = *((unsigned int *)a2 + 1);
    v15 = (v13 - (__int64)a3) / v7;
    if ( v14 > v15 )
    {
      wil::details_abi::UsageIndexProperty::UpdateCount(a2, v15);
      LODWORD(v14) = *((_DWORD *)a2 + 1);
      v7 = *((_QWORD *)this + 2);
    }
    v16 = a5;
    v17 = &v10[(unsigned int)v14 * v7];
    v18 = wil::details_abi::RawUsageIndex::LowerBound(this, v10, (unsigned int)v14, a4, a5);
    v10 = v18;
    if ( v18 >= v17 )
      return v10;
    v19 = (unsigned __int8 *)*((_QWORD *)this + 4);
    v26 = v18;
    wil::details_abi::UsageIndexProperty::Read((wil::details_abi::UsageIndexProperty *)&v23, &v26, v19);
    v8 = wil::details_abi::UsageIndexProperty::Compare(&v23, a4, v16);
  }
  else
  {
    v20 = 0;
    if ( !*((_DWORD *)a2 + 1) )
      return v10;
    while ( 1 )
    {
      v21 = (unsigned __int8 *)*((_QWORD *)this + 4);
      v26 = v10;
      if ( !wil::details_abi::UsageIndexProperty::Read((wil::details_abi::UsageIndexProperty *)&v23, &v26, v21) )
        break;
      v8 = wil::details_abi::UsageIndexProperty::Compare(&v23, a4, a5);
      if ( v8 > 0 )
      {
        v10 = v26;
        if ( (unsigned int)++v20 < *((_DWORD *)a2 + 1) )
          continue;
      }
      goto LABEL_12;
    }
    wil::details_abi::UsageIndexProperty::UpdateCount(a2, v20);
  }
LABEL_12:
  if ( !v8 )
  {
    if ( BYTE2(v23) )
    {
      wil::details_abi::UsageIndexProperty::UpdateCount((wil::details_abi::UsageIndexProperty *)&v23, a6 + HIDWORD(v23));
    }
    else if ( !*((_BYTE *)this + 56) )
    {
LABEL_17:
      *((_BYTE *)this + 56) = v6;
      return 0LL;
    }
    v6 = 1;
    goto LABEL_17;
  }
  return v10;
}

//----- (00000001800595EC) ----------------------------------------------------
void __fastcall wil::details::FeatureStateManager::FlushUsage(wil::details::FeatureStateManager *this)
{
  if ( !wil::ProcessShutdownInProgress(this) && wil::details::FeatureStateManager::EnsureStateData((RTL_SRWLOCK *)this) )
  {
    wil::details_abi::SubscriptionList::OnSignaled(
      (LPCRITICAL_SECTION)(*((_QWORD *)this + 3) + 200LL),
      *((PSRWLOCK *)this + 3));
    wil::details_abi::FeatureStateData::RecordUsage(*((RTL_SRWLOCK **)this + 3));
  }
}

//----- (0000000180059630) ----------------------------------------------------
void __fastcall wil::details::FreeProcessHeap(wil::details *this, void *a2)
{
  HANDLE ProcessHeap; // rax

  ProcessHeap = GetProcessHeap();
  HeapFree(ProcessHeap, 0, this);
}

//----- (0000000180059664) ----------------------------------------------------
char __fastcall ATL::CSecurityDesc::FromString(ATL::CSecurityDesc *this, LPCWSTR StringSecurityDescriptor)
{
  struct _SECURITY_DESCRIPTOR *v3; // rbx
  PSECURITY_DESCRIPTOR SecurityDescriptor; // [rsp+40h] [rbp+18h] BYREF

  if ( !ConvertStringSecurityDescriptorToSecurityDescriptorW(StringSecurityDescriptor, 1u, &SecurityDescriptor, 0LL) )
    ATL::AtlThrowLastWin32();
  v3 = (struct _SECURITY_DESCRIPTOR *)SecurityDescriptor;
  if ( *((PSECURITY_DESCRIPTOR *)this + 1) != SecurityDescriptor )
  {
    (*(void (__fastcall **)(ATL::CSecurityDesc *))(*(_QWORD *)this + 8LL))(this);
    ATL::CSecurityDesc::Init(this, v3);
    v3 = (struct _SECURITY_DESCRIPTOR *)SecurityDescriptor;
  }
  LocalFree(v3);
  return 1;
}

//----- (00000001800596F0) ----------------------------------------------------
_WORD *__fastcall ATL::CDacl::CAccessAce::GetACE(ATL::CDacl::CAccessAce *this)
{
  _WORD *v1; // rdi
  size_t v3; // rbx
  _WORD *v4; // rax
  DWORD LengthSid; // eax
  errno_t v6; // eax

  v1 = (_WORD *)*((_QWORD *)this + 17);
  if ( !v1 )
  {
    v3 = (*(unsigned int (__fastcall **)(ATL::CDacl::CAccessAce *))(*(_QWORD *)this + 16LL))(this);
    v4 = malloc(v3);
    v1 = v4;
    if ( v4 )
    {
      memset_0(v4, 0, (unsigned int)v3);
      v1[1] = v3;
      *((_BYTE *)v1 + 1) = *((_BYTE *)this + 132);
      *(_BYTE *)v1 = (*(__int64 (__fastcall **)(ATL::CDacl::CAccessAce *))(*(_QWORD *)this + 24LL))(this);
      *((_DWORD *)v1 + 1) = *((_DWORD *)this + 32);
      LengthSid = GetLengthSid((char *)this + 16);
      v6 = memcpy_s(v1 + 4, v3 - 8, (char *)this + 16, LengthSid);
      if ( !v6 )
      {
LABEL_10:
        *((_QWORD *)this + 17) = v1;
        return v1;
      }
      if ( v6 != 12 )
      {
        if ( v6 == 22 || v6 == 34 )
          ATL::PrivateAtlThrow(-2147024809);
        if ( v6 != 80 )
          ATL::PrivateAtlThrow(-2147467259);
        goto LABEL_10;
      }
    }
    ATL::PrivateAtlThrow(-2147024882);
  }
  return v1;
}
// 1800747C8: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();

//----- (0000000180059800) ----------------------------------------------------
char *__fastcall ATL::CDacl::CAccessObjectAce::GetACE(ATL::CDacl::CAccessObjectAce *this)
{
  char *v1; // rdi
  size_t v3; // rbx
  char *v4; // rax
  char *v5; // rbp
  int v6; // eax
  __int128 *v7; // rax
  int v8; // ecx
  __int128 v9; // xmm0
  __int128 *v10; // rax
  __int128 v11; // xmm0
  DWORD LengthSid; // eax
  errno_t v13; // eax

  v1 = (char *)*((_QWORD *)this + 17);
  if ( !v1 )
  {
    v3 = (*(unsigned int (__fastcall **)(ATL::CDacl::CAccessObjectAce *))(*(_QWORD *)this + 16LL))(this);
    v4 = (char *)malloc(v3);
    v1 = v4;
    if ( v4 )
    {
      memset_0(v4, 0, (unsigned int)v3);
      *((_WORD *)v1 + 1) = v3;
      v1[1] = *((_BYTE *)this + 132);
      *v1 = (*(__int64 (__fastcall **)(ATL::CDacl::CAccessObjectAce *))(*(_QWORD *)this + 24LL))(this);
      v5 = v1 + 44;
      v6 = *((_DWORD *)this + 32);
      *((_DWORD *)v1 + 2) = 0;
      *((_DWORD *)v1 + 1) = v6;
      v7 = (__int128 *)*((_QWORD *)this + 19);
      if ( v7 )
      {
        v9 = *v7;
        *((_DWORD *)v1 + 2) = 1;
        v8 = 3;
        *(_OWORD *)(v1 + 12) = v9;
      }
      else
      {
        v5 = v1 + 28;
        v8 = 2;
      }
      v10 = (__int128 *)*((_QWORD *)this + 20);
      if ( v10 )
      {
        v11 = *v10;
        if ( *((_QWORD *)this + 19) )
          *(_OWORD *)(v1 + 28) = v11;
        else
          *(_OWORD *)(v1 + 12) = v11;
        *((_DWORD *)v1 + 2) = v8;
      }
      else
      {
        v5 -= 16;
      }
      LengthSid = GetLengthSid((char *)this + 16);
      v13 = memcpy_s(v5, v5 - v1, (char *)this + 16, LengthSid);
      if ( !v13 )
      {
LABEL_19:
        *((_QWORD *)this + 17) = v1;
        return v1;
      }
      if ( v13 != 12 )
      {
        if ( v13 == 22 || v13 == 34 )
          ATL::PrivateAtlThrow(-2147024809);
        if ( v13 != 80 )
          ATL::PrivateAtlThrow(-2147467259);
        goto LABEL_19;
      }
    }
    ATL::PrivateAtlThrow(-2147024882);
  }
  return v1;
}
// 1800747C8: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();

//----- (0000000180059970) ----------------------------------------------------
__int64 __fastcall RpcAutoImpersonate::GetClientUser(RpcAutoImpersonate *this, struct User *a2)
{
  void *v3; // rbx
  HANDLE CurrentProcess; // rax
  signed int LastError; // eax
  unsigned int v6; // edi
  void *TokenHandle; // [rsp+40h] [rbp+8h] BYREF

  v3 = 0LL;
  TokenHandle = 0LL;
  if ( *(_DWORD *)this )
    goto LABEL_6;
  CurrentProcess = GetCurrentProcess();
  if ( OpenProcessToken(CurrentProcess, 0x20008u, &TokenHandle) )
  {
    v3 = TokenHandle;
LABEL_6:
    v6 = User::FromImpersonationToken(a2, v3);
    goto LABEL_7;
  }
  LastError = GetLastError();
  v6 = LastError;
  if ( LastError > 0 )
    v6 = (unsigned __int16)LastError | 0x80070000;
LABEL_7:
  wmi::AutoHandle::Close(&TokenHandle);
  return v6;
}

//----- (0000000180059A14) ----------------------------------------------------
void __fastcall wil::details::ThreadFailureCallbackHolder::GetContextAndNotifyFailure(
        struct wil::FailureInfo *a1,
        char *a2,
        unsigned __int64 a3)
{
  char v3; // bp
  struct wil::details::ThreadFailureCallbackHolder ***Local; // rbx
  struct wil::details::ThreadFailureCallbackHolder **v8; // rbx
  char v9; // al

  v3 = 0;
  *a2 = 0;
  if ( wil::details::g_pThreadFailureCallbacks )
    Local = (struct wil::details::ThreadFailureCallbackHolder ***)wil::details_abi::ThreadLocalStorage<wil::details::ThreadFailureCallbackHolder *>::GetLocal();
  else
    Local = 0LL;
  if ( Local && *Local )
  {
    *a2 = 0;
    if ( wil::details::ThreadFailureCallbackHolder::GetThreadContext(a1, *Local, a2, a3) )
      *((_QWORD *)a1 + 8) = a2;
    v8 = *Local;
    do
    {
      v9 = (**(__int64 (__fastcall ***)(struct wil::details::ThreadFailureCallbackHolder *, struct wil::FailureInfo *))v8[1])(
             v8[1],
             a1);
      v8 = (struct wil::details::ThreadFailureCallbackHolder **)v8[2];
      v3 |= v9;
    }
    while ( v8 );
  }
  if ( wil::details::g_pfnTelemetryCallback )
    wil::details::g_pfnTelemetryCallback(v3, a1);
}
// 1800B0990: using guessed type __int64 wil::details::g_pThreadFailureCallbacks;
// 1800B1528: using guessed type void (__stdcall *wil::details::g_pfnTelemetryCallback)(bool, const struct wil::FailureInfo *);

//----- (0000000180059AE0) ----------------------------------------------------
void __fastcall wil::details::GetContextAndNotifyFailure(wil::details *this, struct wil::FailureInfo *a2, char *a3)
{
  DWORD CurrentThreadId; // eax
  wil::details_abi *v5; // rcx
  wil::details_abi::ThreadLocalData *ThreadLocalDataCache; // rax

  wil::details::ThreadFailureCallbackHolder::GetContextAndNotifyFailure(this, (char *)a2, (unsigned __int64)a3);
  CurrentThreadId = GetCurrentThreadId();
  if ( `wil::SetLastError'::`2'::lastThread != CurrentThreadId )
  {
    if ( _InterlockedIncrement(&`wil::SetLastError'::`5'::depth) < 4 )
    {
      `wil::SetLastError'::`2'::lastThread = CurrentThreadId;
      ThreadLocalDataCache = wil::details_abi::GetThreadLocalDataCache(v5);
      if ( ThreadLocalDataCache )
        wil::details_abi::ThreadLocalData::SetLastError(ThreadLocalDataCache, this);
      `wil::SetLastError'::`2'::lastThread = 0;
    }
    _InterlockedDecrement(&`wil::SetLastError'::`5'::depth);
  }
}
// 180059B1E: variable 'v5' is possibly undefined
// 1800B1564: using guessed type int `wil::SetLastError'::`2'::lastThread;
// 1800B1568: using guessed type int `wil::SetLastError'::`5'::depth;

//----- (0000000180059B60) ----------------------------------------------------
const char *__fastcall wil::details::GetCurrentModuleName(wil::details *this)
{
  if ( !`wil::details::GetCurrentModuleName'::`2'::s_fModuleValid )
  {
    wil::details::GetModuleInformation(
      (LPCWSTR)wil::details::RecordFailFast,
      0LL,
      (char *)`wil::details::GetCurrentModuleName'::`2'::s_szModule,
      (char *)0x40);
    `wil::details::GetCurrentModuleName'::`2'::s_fModuleValid = 1;
  }
  return (const char *)`wil::details::GetCurrentModuleName'::`2'::s_szModule;
}
// 1800B1560: using guessed type char `wil::details::GetCurrentModuleName'::`2'::s_fModuleValid;
// 1800B1580: using guessed type unsigned int `wil::details::GetCurrentModuleName'::`2'::s_szModule[16];

//----- (0000000180059BA4) ----------------------------------------------------
__int64 __fastcall wil::GetFailureLogString(
        STRSAFE_LPWSTR pszDest,
        unsigned __int16 *a2,
        __int64 a3,
        const struct wil::FailureInfo *a4)
{
  void (__fastcall *v7)(__int64, STRSAFE_LPWSTR, unsigned __int16 *, const struct wil::FailureInfo *); // rax
  const char *v8; // rsi
  DWORD v9; // r8d
  wchar_t *v10; // rdi
  __int64 v11; // rax
  const unsigned __int16 *v12; // r9
  wchar_t *v13; // rax
  const unsigned __int16 *v14; // r9
  wchar_t *v15; // rbp
  DWORD CurrentThreadId; // eax
  wchar_t *v17; // rax
  const unsigned __int16 *v18; // r9
  wchar_t *v19; // rax
  const unsigned __int16 *v20; // r9
  const unsigned __int16 *v21; // r9
  const unsigned __int16 *v22; // r9
  LPWSTR lpBuffer; // [rsp+20h] [rbp-258h]
  LPWSTR lpBuffera; // [rsp+20h] [rbp-258h]
  __int64 nSize; // [rsp+28h] [rbp-250h]
  va_list *Arguments; // [rsp+30h] [rbp-248h]
  WCHAR Buffer[256]; // [rsp+40h] [rbp-238h] BYREF

  if ( a2 )
  {
    if ( pszDest )
    {
      v7 = (void (__fastcall *)(__int64, STRSAFE_LPWSTR, unsigned __int16 *, const struct wil::FailureInfo *))g_pfnResultLoggingCallback;
      *pszDest = 0;
      if ( !v7 || !wil::details::g_resultMessageCallbackSet || (v7(a3, pszDest, a2, a4), !*pszDest) )
      {
        v8 = (const char *)&word_18007630E;
        if ( *(_DWORD *)a3 )
        {
          switch ( *(_DWORD *)a3 )
          {
            case 1:
              v8 = "ReturnHr";
              break;
            case 2:
              v8 = "LogHr";
              break;
            case 3:
              v8 = "FailFast";
              break;
          }
        }
        else
        {
          v8 = "Exception";
        }
        v9 = *(_DWORD *)(a3 + 4);
        Buffer[0] = 0;
        FormatMessageW(0x1200u, 0LL, v9, 0x400u, Buffer, 0x100u, 0LL);
        v10 = &pszDest[(_QWORD)a2];
        v11 = *(_QWORD *)(a3 + 128);
        v12 = *(const unsigned __int16 **)(a3 + 120);
        if ( *(_QWORD *)(a3 + 48) )
        {
          LODWORD(lpBuffer) = *(_DWORD *)(a3 + 56);
          v13 = wil::details::LogStringPrintf(
                  pszDest,
                  v10,
                  (size_t *)L"%hs(%u)\\%hs!%p: ",
                  *(const unsigned __int16 **)(a3 + 48),
                  lpBuffer,
                  v12,
                  v11);
        }
        else
        {
          v13 = wil::details::LogStringPrintf(pszDest, v10, (size_t *)L"%hs!%p: ", v12, v11);
        }
        v14 = *(const unsigned __int16 **)(a3 + 136);
        v15 = v13;
        if ( v14 )
          v15 = wil::details::LogStringPrintf(v13, v10, (size_t *)L"(caller: %p) ", v14);
        CurrentThreadId = GetCurrentThreadId();
        LODWORD(Arguments) = *(_DWORD *)(a3 + 4);
        LODWORD(nSize) = CurrentThreadId;
        LODWORD(lpBuffera) = *(_DWORD *)(a3 + 60);
        v17 = wil::details::LogStringPrintf(
                v15,
                v10,
                (size_t *)L"%hs(%d) tid(%x) %08X %ws",
                (const unsigned __int16 *)v8,
                lpBuffera,
                nSize,
                Arguments,
                Buffer);
        if ( *(_QWORD *)(a3 + 16) || *(_QWORD *)(a3 + 64) || *(_QWORD *)(a3 + 40) )
        {
          v19 = wil::details::LogStringPrintf(v17, v10, (size_t *)L"    ", v18);
          v20 = *(const unsigned __int16 **)(a3 + 16);
          if ( v20 )
            v19 = wil::details::LogStringPrintf(v19, v10, (size_t *)L"Msg:[%ws] ", v20);
          v21 = *(const unsigned __int16 **)(a3 + 64);
          if ( v21 )
            v19 = wil::details::LogStringPrintf(v19, v10, (size_t *)L"CallContext:[%hs] ", v21);
          v22 = *(const unsigned __int16 **)(a3 + 40);
          if ( *(_QWORD *)(a3 + 32) )
          {
            wil::details::LogStringPrintf(v19, v10, (size_t *)L"[%hs(%hs)]\n", v22, *(_QWORD *)(a3 + 32));
          }
          else if ( v22 )
          {
            wil::details::LogStringPrintf(v19, v10, (size_t *)L"[%hs]\n", v22);
          }
          else
          {
            wil::details::LogStringPrintf(v19, v10, (size_t *)L"\n", 0LL);
          }
        }
      }
    }
  }
  return 0LL;
}
// 180059CC8: variable 'lpBuffer' is possibly undefined
// 180059D3C: variable 'lpBuffera' is possibly undefined
// 180059D3C: variable 'nSize' is possibly undefined
// 180059D3C: variable 'Arguments' is possibly undefined
// 180059D64: variable 'v18' is possibly undefined
// 1800B1520: using guessed type __int64 g_pfnResultLoggingCallback;
// 1800B1530: using guessed type bool wil::details::g_resultMessageCallbackSet;

//----- (0000000180059E18) ----------------------------------------------------
DWORD __fastcall wil::details::GetLastErrorFail(
        wil::details *this,
        void *a2,
        __int64 a3,
        const char *a4,
        const char *a5,
        const char *a6)
{
  unsigned int v7; // edi
  DWORD result; // eax

  v7 = (unsigned int)a2;
  result = GetLastError();
  if ( !result )
  {
    wil::details::ReportFailure_Hr((__int64)this, v7, a3, 0LL, 0LL, (__int64)a6, 2, 0x8007029C);
    return 668;
  }
  return result;
}

//----- (0000000180059E8C) ----------------------------------------------------
signed int __fastcall wil::details::GetLastErrorFailHr(wil::details *this, __int64 a2, __int64 a3, const char *a4)
{
  signed int result; // eax
  const char *v5; // [rsp+20h] [rbp-18h]
  const char *retaddr; // [rsp+38h] [rbp+0h]

  result = wil::details::GetLastErrorFail(0LL, 0LL, 0LL, a4, v5, retaddr);
  if ( result > 0 )
    return (unsigned __int16)result | 0x80070000;
  return result;
}
// 180059EA1: variable 'v5' is possibly undefined

//----- (0000000180059EC0) ----------------------------------------------------
__int64 __fastcall ATL::CDacl::CAccessAce::GetLength(ATL::CDacl::CAccessAce *this)
{
  return GetLengthSid((char *)this + 16) + 8;
}

//----- (0000000180059EF0) ----------------------------------------------------
__int64 __fastcall ATL::CDacl::CAccessObjectAce::GetLength(ATL::CDacl::CAccessObjectAce *this)
{
  __int64 v1; // rbx
  int v2; // edi
  DWORD LengthSid; // eax
  int v4; // ecx

  v1 = *((_QWORD *)this + 20);
  v2 = *((_QWORD *)this + 19) != 0LL ? 44 : 28;
  LengthSid = GetLengthSid((char *)this + 16);
  v4 = v2 - 16;
  if ( v1 )
    v4 = v2;
  return v4 + LengthSid;
}

//----- (0000000180059F40) ----------------------------------------------------
__int64 wil::details_abi::ThreadLocalStorage<wil::details::ThreadFailureCallbackHolder *>::GetLocal()
{
  __int64 v0; // rbx
  DWORD CurrentThreadId; // r9d
  __int64 result; // rax

  v0 = wil::details::g_pThreadFailureCallbacks;
  CurrentThreadId = GetCurrentThreadId();
  for ( result = *(_QWORD *)(v0 + 8 * (CurrentThreadId % 0xAuLL)); result; result = *(_QWORD *)(result + 8) )
  {
    if ( *(_DWORD *)result == CurrentThreadId )
    {
      result += 16LL;
      return result;
    }
  }
  return result;
}
// 1800B0990: using guessed type __int64 wil::details::g_pThreadFailureCallbacks;

//----- (0000000180059FA4) ----------------------------------------------------
__int64 __fastcall wil::details_abi::ThreadLocalStorage<wil::details_abi::ThreadLocalData>::GetLocal(__int64 a1)
{
  DWORD CurrentThreadId; // ecx
  __int64 result; // rax

  CurrentThreadId = GetCurrentThreadId();
  for ( result = *(_QWORD *)(a1 + 8 * (CurrentThreadId % 0xAuLL)); result; result = *(_QWORD *)(result + 8) )
  {
    if ( *(_DWORD *)result == CurrentThreadId )
    {
      result += 16LL;
      return result;
    }
  }
  return result;
}

//----- (000000018005A000) ----------------------------------------------------
__int64 __fastcall JobStore::GetMigratedUbpmDynamicTaskInfo(JobStore *this, UUID *a2, struct DynamicTaskInfo *a3)
{
  JobStore *v5; // rcx
  int UbpmStatsFileName; // ebx
  HANDLE FileW; // rax
  const wchar_t *Path; // rax
  const wchar_t *v9; // rax
  unsigned __int16 v10; // dx
  tsched *v11; // rcx
  __int64 v12; // rcx
  bool v13; // zf
  __int64 v14; // rax
  DWORD NumberOfBytesRead; // [rsp+40h] [rbp-C0h] BYREF
  HANDLE hFile[2]; // [rsp+48h] [rbp-B8h] BYREF
  __int128 Buffer[2]; // [rsp+58h] [rbp-A8h] BYREF
  WCHAR FileName[264]; // [rsp+80h] [rbp-80h] BYREF

  *(_OWORD *)hFile = 0LL;
  memset_0(FileName, 0, 0x208uLL);
  memset(Buffer, 0, 28);
  UbpmStatsFileName = JobStore::GetUbpmStatsFileName(v5, a2, FileName);
  if ( UbpmStatsFileName < 0 )
    goto LABEL_22;
  FileW = CreateFileW(FileName, 0x80000000, 1u, 0LL, 3u, 0, 0LL);
  tsched::JobsAutoHandle::operator=((tsched::JobsAutoHandle *)hFile, (__int64)FileW);
  if ( hFile[0] == (HANDLE)-1LL )
  {
    UbpmStatsFileName = tsched::GetLastHrError((tsched *)0xFFFFFFFFFFFFFFFFLL);
    if ( tsched::IsErrorNotFound((tsched *)(unsigned int)UbpmStatsFileName) )
    {
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 3u )
      {
        Path = JobMoniker::GetPath((JobMoniker *)a2);
        WPP_SF_SD(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x6Eu,
          (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
          Path);
      }
      UbpmStatsFileName = 1;
      goto LABEL_22;
    }
    if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
      || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) == 0
      || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
    {
      goto LABEL_22;
    }
    v9 = JobMoniker::GetPath((JobMoniker *)a2);
    v10 = 111;
LABEL_13:
    WPP_SF_SD(*((_QWORD *)WPP_GLOBAL_Control + 2), v10, (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids, v9);
    goto LABEL_22;
  }
  if ( !ReadFile(hFile[0], Buffer, 0x1Cu, &NumberOfBytesRead, 0LL) )
  {
    UbpmStatsFileName = tsched::GetLastHrError(v11);
    if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
      || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) == 0
      || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
    {
      goto LABEL_22;
    }
    v9 = JobMoniker::GetPath((JobMoniker *)a2);
    v10 = 112;
    goto LABEL_13;
  }
  v12 = *(_QWORD *)&Buffer[0];
  v13 = NumberOfBytesRead == 20;
  *(_QWORD *)((char *)a3 + 4) = *(_QWORD *)((char *)Buffer + 12);
  *((_DWORD *)a3 + 5) = DWORD2(Buffer[0]);
  v14 = *(_QWORD *)((char *)&Buffer[1] + 4);
  if ( v13 )
    v14 = v12;
  *(_QWORD *)((char *)a3 + 12) = v12;
  *(_QWORD *)((char *)a3 + 28) = v14;
LABEL_22:
  tsched::JobsAutoHandle::Close((tsched::JobsAutoHandle *)hFile);
  return (unsigned int)UbpmStatsFileName;
}
// 18005A062: variable 'v5' is possibly undefined
// 18005A1A9: variable 'v11' is possibly undefined
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018005A244) ----------------------------------------------------
char __fastcall wil::details::GetModuleInformation(LPCWSTR lpModuleName, _DWORD *a2, char *a3, char *a4)
{
  HMODULE v6; // rcx
  size_t v10; // r8
  __int64 v11; // rax
  CHAR *i; // r9
  size_t *v13; // r8
  const char *v14; // r9
  size_t v15; // [rsp+20h] [rbp-168h]
  HMODULE phModule; // [rsp+30h] [rbp-158h] BYREF
  CHAR Filename[272]; // [rsp+40h] [rbp-148h] BYREF

  v6 = 0LL;
  phModule = 0LL;
  if ( lpModuleName )
  {
    if ( !GetModuleHandleExW(6u, lpModuleName, &phModule) )
    {
      wil::assign_to_opt_param<unsigned int>(a2);
      return 0;
    }
    v6 = phModule;
  }
  if ( a2 )
  {
    if ( lpModuleName )
      LODWORD(lpModuleName) = (_DWORD)lpModuleName - (_DWORD)v6;
    *a2 = (_DWORD)lpModuleName;
  }
  if ( a3 )
  {
    if ( !GetModuleFileNameA(v6, Filename, 0x104u) )
      return 0;
    v11 = -1LL;
    do
      ++v11;
    while ( Filename[v11] );
    for ( i = &Filename[v11]; i > Filename && *(i - 1) != 92; --i )
      ;
    if ( StringValidateDestA(Filename, (size_t)a4, v10) < 0 )
    {
      if ( a4 )
        *a3 = 0;
    }
    else
    {
      StringCopyWorkerA(a3, (size_t)a4, v13, v14, v15);
    }
  }
  return 1;
}
// 18005A30C: variable 'v10' is possibly undefined
// 18005A31B: variable 'v13' is possibly undefined
// 18005A31B: variable 'v14' is possibly undefined
// 18005A31B: variable 'v15' is possibly undefined
// 18005A244: using guessed type CHAR Filename[272];

//----- (000000018005A350) ----------------------------------------------------
const struct _ACL *__fastcall ATL::CAcl::GetPACL(ATL::CAcl *this)
{
  DWORD v2; // esi
  unsigned int v3; // ebx
  unsigned int v4; // ebp
  __int64 v5; // rax
  struct _ACL *v6; // rax
  int Error; // ebx
  unsigned int i; // esi
  __int64 v9; // rax
  __int64 v10; // r14
  DWORD nAceListLength; // ebx
  void *v12; // rax
  int v14; // ebx

  if ( !*((_QWORD *)this + 1) && !*((_BYTE *)this + 16) )
  {
    v2 = 8;
    v3 = 0;
    v4 = (*(__int64 (__fastcall **)(ATL::CAcl *))(*(_QWORD *)this + 8LL))(this);
    if ( v4 )
    {
      do
      {
        v5 = (*(__int64 (__fastcall **)(ATL::CAcl *, _QWORD))(*(_QWORD *)this + 32LL))(this, v3);
        if ( v5 )
          v2 += (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v5 + 16LL))(v5);
        ++v3;
      }
      while ( v3 < v4 );
    }
    v6 = (struct _ACL *)malloc(v2);
    *((_QWORD *)this + 1) = v6;
    if ( !v6 )
      ATL::PrivateAtlThrow(-2147024882);
    if ( !InitializeAcl(v6, v2, *((_DWORD *)this + 5)) )
    {
      Error = ATL::AtlHresultFromLastError();
      free(*((void **)this + 1));
      *((_QWORD *)this + 1) = 0LL;
      ATL::PrivateAtlThrow(Error);
    }
    (*(void (__fastcall **)(ATL::CAcl *))(*(_QWORD *)this + 40LL))(this);
    for ( i = 0; i < v4; ++i )
    {
      v9 = (*(__int64 (__fastcall **)(ATL::CAcl *, _QWORD))(*(_QWORD *)this + 32LL))(this, i);
      v10 = v9;
      if ( v9 )
      {
        nAceListLength = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v9 + 16LL))(v9);
        v12 = (void *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v10 + 8LL))(v10);
        if ( AddAce(*((PACL *)this + 1), *((_DWORD *)this + 5), 0xFFFFFFFF, v12, nAceListLength) )
          continue;
      }
      v14 = ATL::AtlHresultFromLastError();
      free(*((void **)this + 1));
      *((_QWORD *)this + 1) = 0LL;
      ATL::PrivateAtlThrow(v14);
    }
  }
  return (const struct _ACL *)*((_QWORD *)this + 1);
}

//----- (000000018005A4F0) ----------------------------------------------------
__int64 __fastcall wil::details_abi::ProcessLocalStorage<wil::details_abi::ProcessLocalData>::GetShared(
        wil::details *a1)
{
  __int64 v1; // rbx
  __int64 v2; // rcx
  wil::details *v4; // [rsp+30h] [rbp+8h] BYREF

  v4 = a1;
  v1 = wil::details_abi::g_pProcessLocalData;
  if ( !*(_QWORD *)(wil::details_abi::g_pProcessLocalData + 8) )
  {
    v2 = *(_QWORD *)wil::details_abi::g_pProcessLocalData;
    v4 = 0LL;
    if ( (int)wil::details_abi::ProcessLocalStorageData<wil::details_abi::ProcessLocalData>::Acquire(v2, &v4) >= 0
      && !*(_QWORD *)(v1 + 8) )
    {
      *(_QWORD *)(v1 + 8) = v4;
    }
  }
  return (*(_QWORD *)(v1 + 8) + 32LL) & -(__int64)(*(_QWORD *)(v1 + 8) != 0LL);
}
// 1800B0988: using guessed type __int64 wil::details_abi::g_pProcessLocalData;

//----- (000000018005A550) ----------------------------------------------------
__int64 __fastcall wil::details_abi::UsageIndexProperty::GetSize(wil::details_abi::UsageIndexProperty *this)
{
  __int64 result; // rax

  if ( *(_WORD *)this )
    result = *(unsigned __int16 *)this;
  else
    result = *((unsigned __int16 *)this + 4) + 2LL;
  if ( *((_BYTE *)this + 2) == 1 )
  {
    result += 2LL;
  }
  else if ( *((_BYTE *)this + 2) == 2 )
  {
    result += 4LL;
  }
  return result;
}

//----- (000000018005A584) ----------------------------------------------------
bool __fastcall wil::details::ThreadFailureCallbackHolder::GetThreadContext(
        struct wil::FailureInfo *a1,
        struct wil::details::ThreadFailureCallbackHolder **a2,
        char *a3,
        unsigned __int64 a4)
{
  bool result; // al
  struct wil::details::ThreadFailureCallbackHolder *v9; // rdx
  char *v10; // rcx
  __int64 v11; // rbx
  __int64 v12; // rax
  char *v13; // rdi
  _BYTE *v14; // rdi
  _BYTE *v15; // r8
  rsize_t v16; // rcx
  rsize_t v17; // rbx

  result = 0;
  *a3 = 0;
  if ( a2 )
  {
    result = wil::details::ThreadFailureCallbackHolder::GetThreadContext(a1, a2[2], a3, a4);
    v9 = a2[4];
    if ( v9 )
    {
      if ( !*(_DWORD *)v9 )
        *(_DWORD *)v9 = _InterlockedIncrement(&wil::details::ThreadFailureCallbackHolder::s_telemetryId);
      if ( !*((_DWORD *)a1 + 18) )
      {
        *(_OWORD *)((char *)a1 + 72) = *(_OWORD *)v9;
        *((_QWORD *)a1 + 11) = *((_QWORD *)v9 + 2);
      }
      v10 = &a3[a4];
      *((_OWORD *)a1 + 6) = *(_OWORD *)v9;
      *((_QWORD *)a1 + 14) = *((_QWORD *)v9 + 2);
      v11 = -1LL;
      v12 = -1LL;
      do
        ++v12;
      while ( a3[v12] );
      v13 = &a3[v12];
      if ( v10 - v13 > 2 )
      {
        *v13 = 92;
        v14 = v13 + 1;
        v15 = (_BYTE *)*((_QWORD *)v9 + 1);
        do
          ++v11;
        while ( v15[v11] );
        v16 = v10 - v14;
        v17 = v11 + 1;
        if ( v17 >= v16 )
          v17 = v16;
        memcpy_s(v14, v16, v15, v17);
        v14[v17 - 1] = 0;
      }
      return 1;
    }
  }
  return result;
}
// 1800B0200: using guessed type volatile int wil::details::ThreadFailureCallbackHolder::s_telemetryId;

//----- (000000018005A684) ----------------------------------------------------
struct wil::details_abi::ThreadLocalData *__fastcall wil::details_abi::GetThreadLocalDataCache(wil::details_abi *this)
{
  __int64 v1; // rbx
  __int64 Shared; // rax
  __int64 v3; // rdi
  __int64 Local; // rax

  v1 = 0LL;
  if ( wil::details_abi::g_pProcessLocalData )
  {
    Shared = wil::details_abi::ProcessLocalStorage<wil::details_abi::ProcessLocalData>::GetShared(this);
    v3 = Shared;
    if ( Shared )
    {
      Local = wil::details_abi::ThreadLocalStorage<wil::details_abi::ThreadLocalData>::GetLocal(Shared + 8);
      v1 = Local;
      if ( Local )
      {
        if ( !*(_QWORD *)(Local + 8) )
          *(_QWORD *)(Local + 8) = v3 + 4;
      }
    }
  }
  return (struct wil::details_abi::ThreadLocalData *)v1;
}
// 1800B0988: using guessed type __int64 wil::details_abi::g_pProcessLocalData;

//----- (000000018005A6DC) ----------------------------------------------------
__int64 __fastcall JobStore::GetUbpmStatsFileName(JobStore *this, UUID *a2, unsigned __int16 *a3)
{
  RPC_STATUS v5; // eax
  int LastHrError; // ebx
  tsched *v7; // rcx
  const wchar_t *Path; // rax
  unsigned __int16 v9; // dx
  char *v10; // r8
  RPC_WSTR String; // [rsp+58h] [rbp+20h] BYREF

  String = 0LL;
  v5 = UuidToStringW(a2, &String);
  LastHrError = v5;
  if ( !v5 )
  {
    if ( ExpandEnvironmentStringsW(L"%SystemRoot%\\System32\\logfiles\\UbpmMigratedStats\\", a3, 0x104u) )
    {
      v10 = (char *)String;
      a3[259] = 0;
      LastHrError = StringCchCatW(a3, 260LL, v10);
      if ( LastHrError >= 0
        || WPP_GLOBAL_Control == &WPP_GLOBAL_Control
        || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) == 0
        || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
      {
        goto LABEL_15;
      }
      Path = JobMoniker::GetPath((JobMoniker *)a2);
      v9 = 109;
    }
    else
    {
      LastHrError = tsched::GetLastHrError(v7);
      if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
        || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) == 0
        || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
      {
        goto LABEL_15;
      }
      Path = JobMoniker::GetPath((JobMoniker *)a2);
      v9 = 108;
    }
    WPP_SF_SD(*((_QWORD *)WPP_GLOBAL_Control + 2), v9, (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids, Path);
    goto LABEL_15;
  }
  if ( v5 > 0 )
    LastHrError = (unsigned __int16)v5 | 0x80070000;
LABEL_15:
  RpcStringFreeW(&String);
  return (unsigned int)LastHrError;
}
// 18005A74F: variable 'v7' is possibly undefined
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018005A824) ----------------------------------------------------
__int64 __fastcall wil::details_abi::SemaphoreValue::GetValueFromSemaphore(HANDLE hHandle, int *a2)
{
  DWORD v4; // eax
  __int64 v5; // r8
  const char *v6; // r9
  __int64 v7; // rdx
  __int64 v9; // rdx
  DWORD v10; // eax
  wil::details::in1diag3 *retaddr; // [rsp+28h] [rbp+0h]
  int PreviousCount; // [rsp+40h] [rbp+18h] BYREF
  int v13; // [rsp+48h] [rbp+20h] BYREF

  v4 = WaitForSingleObject(hHandle, 0);
  if ( v4 == -1 )
  {
    v7 = 149LL;
    return wil::details::in1diag3::Return_GetLastError(retaddr, (void *)v7, v5, v6);
  }
  if ( !v4 || v4 == 258 )
  {
    PreviousCount = 0;
    if ( v4 )
    {
      v13 = 0;
      if ( !ReleaseSemaphore(hHandle, 1, &v13) )
      {
        v7 = 173LL;
        return wil::details::in1diag3::Return_GetLastError(retaddr, (void *)v7, v5, v6);
      }
      if ( v13 )
      {
        v9 = 174LL;
        goto LABEL_25;
      }
      if ( ReleaseSemaphore(hHandle, 1, 0LL) || GetLastError() != 298 )
      {
        v9 = 177LL;
        goto LABEL_25;
      }
      v10 = WaitForSingleObject(hHandle, 0);
      if ( v10 == -1 )
      {
        v7 = 180LL;
        return wil::details::in1diag3::Return_GetLastError(retaddr, (void *)v7, v5, v6);
      }
      if ( v10 )
      {
        v9 = 181LL;
        goto LABEL_25;
      }
    }
    else
    {
      if ( !ReleaseSemaphore(hHandle, 1, &PreviousCount) )
      {
        v7 = 158LL;
        return wil::details::in1diag3::Return_GetLastError(retaddr, (void *)v7, v5, v6);
      }
      ++PreviousCount;
      if ( ReleaseSemaphore(hHandle, 1, 0LL) || GetLastError() != 298 )
      {
        v9 = 163LL;
        goto LABEL_25;
      }
    }
    *a2 = PreviousCount;
    return 0LL;
  }
  v9 = 150LL;
LABEL_25:
  wil::details::in1diag3::Return_Hr(retaddr, (void *)v9, v5, (const char *)0x8000FFFFLL);
  return 2147549183LL;
}
// 18005A851: variable 'v5' is possibly undefined
// 18005A851: variable 'v6' is possibly undefined

//----- (000000018005A99C) ----------------------------------------------------
__int64 __fastcall JobStore::GetXmlFileSecurity(JobStore *this, const unsigned __int16 *a2, void **a3)
{
  HANDLE FileW; // rax
  unsigned int LastHrError; // ebx
  signed int SecurityInfo; // eax
  HANDLE handle[3]; // [rsp+40h] [rbp-18h] BYREF

  *(_OWORD *)handle = 0LL;
  FileW = CreateFileW(a2, 0x80000000, 1u, 0LL, 3u, 0x2000080u, 0LL);
  tsched::JobsAutoHandle::operator=((tsched::JobsAutoHandle *)handle, (__int64)FileW);
  if ( handle[0] == (HANDLE)-1LL )
  {
    LastHrError = tsched::GetLastHrError((tsched *)0xFFFFFFFFFFFFFFFFLL);
  }
  else
  {
    SecurityInfo = GetSecurityInfo(handle[0], SE_FILE_OBJECT, 7u, 0LL, 0LL, 0LL, 0LL, a3);
    LastHrError = SecurityInfo;
    if ( SecurityInfo )
    {
      if ( SecurityInfo > 0 )
        LastHrError = (unsigned __int16)SecurityInfo | 0x80070000;
    }
    else
    {
      LastHrError = 0;
    }
  }
  tsched::JobsAutoHandle::Close((tsched::JobsAutoHandle *)handle);
  return LastHrError;
}

//----- (000000018005AA60) ----------------------------------------------------
struct _GUID *__fastcall ATL::CDacl::CAccessObjectAce::InheritedObjectType(
        ATL::CDacl::CAccessObjectAce *this,
        struct _GUID *__return_ptr retstr)
{
  GUID *v2; // rax
  GUID *v3; // rcx
  struct _GUID *result; // rax

  v2 = (GUID *)*((_QWORD *)this + 20);
  v3 = &GUID_NULL;
  if ( v2 )
    v3 = v2;
  result = retstr;
  *retstr = *v3;
  return result;
}

//----- (000000018005AA88) ----------------------------------------------------
void __fastcall ATL::CSecurityDesc::Init(ATL::CSecurityDesc *this, struct _SECURITY_DESCRIPTOR *a2)
{
  void *v4; // rax
  int Error; // ebx
  errno_t v6; // eax
  int v7; // ebx
  WORD pControl; // [rsp+30h] [rbp+8h] BYREF
  rsize_t SourceSize; // [rsp+38h] [rbp+10h] BYREF
  DWORD dwRevision; // [rsp+40h] [rbp+18h] BYREF

  LODWORD(SourceSize) = GetSecurityDescriptorLength(a2);
  v4 = malloc((unsigned int)SourceSize);
  *((_QWORD *)this + 1) = v4;
  if ( !v4 )
    goto LABEL_14;
  if ( !GetSecurityDescriptorControl(a2, &pControl, &dwRevision) )
  {
    Error = ATL::AtlHresultFromLastError();
    free(*((void **)this + 1));
    *((_QWORD *)this + 1) = 0LL;
    ATL::PrivateAtlThrow(Error);
  }
  if ( (pControl & 0x8000u) != 0 )
  {
    v6 = memcpy_s(*((void *const *)this + 1), (unsigned int)SourceSize, a2, (unsigned int)SourceSize);
    if ( !v6 )
      return;
    if ( v6 != 12 )
    {
      if ( v6 == 22 || v6 == 34 )
        ATL::PrivateAtlThrow(-2147024809);
      if ( v6 != 80 )
        ATL::PrivateAtlThrow(-2147467259);
      return;
    }
LABEL_14:
    ATL::PrivateAtlThrow(-2147024882);
  }
  if ( !MakeSelfRelativeSD(a2, *((PSECURITY_DESCRIPTOR *)this + 1), (LPDWORD)&SourceSize) )
  {
    v7 = ATL::AtlHresultFromLastError();
    free(*((void **)this + 1));
    *((_QWORD *)this + 1) = 0LL;
    ATL::PrivateAtlThrow(v7);
  }
}

//----- (000000018005ABBC) ----------------------------------------------------
__int64 JobStore::IsOOBEInProgress(void)
{
  int v0; // eax
  LSTATUS v1; // ebx
  __int64 result; // rax
  DWORD cbData; // [rsp+40h] [rbp+8h] BYREF
  int Data; // [rsp+48h] [rbp+10h] BYREF
  HKEY hKey; // [rsp+50h] [rbp+18h] BYREF

  v0 = RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"System\\Setup", 0, 0x20019u, &hKey);
  if ( v0 )
  {
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x73u,
        (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
        v0);
    }
    return 0LL;
  }
  cbData = 4;
  v1 = RegQueryValueExW(hKey, L"OOBEInProgress", 0LL, 0LL, (LPBYTE)&Data, &cbData);
  RegCloseKey(hKey);
  if ( v1 )
    return 0LL;
  result = 1LL;
  if ( Data != 1 )
    return 0LL;
  return result;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018005AC9C) ----------------------------------------------------
bool __fastcall PlugIn::IsRegistering(PlugIn *this, const unsigned __int16 *a2, const unsigned __int16 *a3)
{
  unsigned int (__fastcall *v3)(const unsigned __int16 *, const unsigned __int16 *); // rax

  v3 = (unsigned int (__fastcall *)(const unsigned __int16 *, const unsigned __int16 *))*((_QWORD *)this + 12);
  if ( v3 )
    LOBYTE(v3) = v3(a2, a3) == 0;
  return (char)v3;
}

//----- (000000018005ACCC) ----------------------------------------------------
char __fastcall wil::details_abi::RawUsageIndex::Iterate(__int64 a1, __int64 a2)
{
  char v4; // r8
  char v5; // cl
  int v6; // ebx
  __int64 v7; // rcx
  __int64 v9; // [rsp+40h] [rbp-29h] BYREF
  __int64 v10; // [rsp+48h] [rbp-21h] BYREF
  __int64 v11[2]; // [rsp+50h] [rbp-19h] BYREF
  __int16 v12; // [rsp+60h] [rbp-9h] BYREF
  char v13; // [rsp+62h] [rbp-7h]
  unsigned int v14; // [rsp+64h] [rbp-5h]
  unsigned __int16 v15; // [rsp+68h] [rbp-1h]
  __int128 v16; // [rsp+70h] [rbp+7h]
  __int16 v17; // [rsp+80h] [rbp+17h] BYREF
  char v18; // [rsp+82h] [rbp+19h]
  int v19; // [rsp+84h] [rbp+1Bh]
  unsigned __int16 v20; // [rsp+88h] [rbp+1Fh]
  __int128 v21; // [rsp+90h] [rbp+27h]
  int v22; // [rsp+D0h] [rbp+67h] BYREF
  __int64 v23; // [rsp+D8h] [rbp+6Fh]
  unsigned __int8 *v24; // [rsp+E0h] [rbp+77h] BYREF
  __int64 v25; // [rsp+E8h] [rbp+7Fh] BYREF

  v23 = a2;
  v11[1] = -2LL;
  v24 = (unsigned __int8 *)(*(_QWORD *)(a1 + 24) + 10LL);
  v4 = *(_BYTE *)(a1 + 4);
  v12 = *(_WORD *)(a1 + 2);
  v13 = v4;
  v14 = 0;
  v15 = 0;
  v16 = 0LL;
  v5 = *(_BYTE *)(a1 + 8);
  v17 = *(_WORD *)(a1 + 6);
  v18 = v5;
  v19 = 0;
  v20 = 0;
  v21 = 0LL;
LABEL_2:
  while ( wil::details_abi::UsageIndexProperty::Read(
            (wil::details_abi::UsageIndexProperty *)&v12,
            &v24,
            *(unsigned __int8 **)(a1 + 32)) )
  {
    v6 = 0;
    if ( v14 )
    {
      while ( wil::details_abi::UsageIndexProperty::Read(
                (wil::details_abi::UsageIndexProperty *)&v17,
                &v24,
                *(unsigned __int8 **)(a1 + 32)) )
      {
        v22 = v19;
        v25 = v20;
        v9 = *((_QWORD *)&v21 + 1);
        v10 = v15;
        v11[0] = *((_QWORD *)&v16 + 1);
        v7 = *(_QWORD *)(a2 + 112);
        if ( !v7 )
          __fastfail(7u);
        if ( !(*(unsigned __int8 (__fastcall **)(__int64, __int64 *, __int64 *, __int64 *, __int64 *, int *))(*(_QWORD *)v7 + 32LL))(
                v7,
                v11,
                &v10,
                &v9,
                &v25,
                &v22) )
        {
          wistd::function<bool (void *,unsigned __int64,void *,unsigned __int64,unsigned int)>::~function<bool (void *,unsigned __int64,void *,unsigned __int64,unsigned int)>(a2);
          return 0;
        }
        if ( ++v6 >= v14 )
          goto LABEL_2;
      }
    }
  }
  wistd::function<bool (void *,unsigned __int64,void *,unsigned __int64,unsigned int)>::~function<bool (void *,unsigned __int64,void *,unsigned __int64,unsigned int)>(a2);
  return 1;
}

//----- (000000018005AE1C) ----------------------------------------------------
__int64 __fastcall JobStore::LoadTaskIfNeeded(JobStore *this, struct JobMoniker *a2)
{
  int Bucket; // ebx
  struct _FILETIME v6[7]; // [rsp+28h] [rbp-38h] BYREF
  HKEY v7; // [rsp+78h] [rbp+18h] BYREF

  Bucket = 0;
  if ( !*(_DWORD *)(*((_QWORD *)a2 + 4) + 24LL) )
  {
    Triggers::Trigulator::Trigulator(v6);
    v7 = 0LL;
    Bucket = JobStore::RegOpenTaskKey(this, a2, &v7, 0x20019u);
    if ( Bucket >= 0 )
    {
      Bucket = Triggers::Trigulator::StreamIn((wmi::RefBase **)v6, v7, 2, 0LL);
      if ( Bucket >= 0 )
        Bucket = Triggers::Trigulator::GetBucket((Triggers::Trigulator *)v6, a2);
    }
    wmi::AutoRegKey::Close(&v7);
    Triggers::Trigulator::~Trigulator((Triggers::Trigulator *)v6);
  }
  return (unsigned int)Bucket;
}

//----- (000000018005AEE8) ----------------------------------------------------
void __fastcall wil::details::LogFailure(
        __int64 a1,
        unsigned int a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        int a7,
        unsigned int a8,
        _WORD *a9,
        __int64 a10,
        WCHAR *lpOutputString,
        __int64 a12,
        char *a13,
        __int64 a14,
        __int64 a15)
{
  unsigned int v17; // edi
  int v19; // ebp
  int v20; // eax
  _WORD *v21; // rax
  DWORD CurrentThreadId; // eax
  wil::details::in1diag3 *v23; // rcx
  const struct wil::FailureInfo *v24; // r9
  __int64 (*v25)(void); // rax
  __int64 v26; // rax
  BOOL IsDebuggerPresent; // eax

  v17 = a8;
  v19 = 0;
  *lpOutputString = 0;
  *a13 = 0;
  switch ( a7 )
  {
    case 0:
      v20 = wil::details::RecordException((wil::details *)a8);
      goto LABEL_11;
    case 1:
      v20 = wil::details::RecordReturn((wil::details *)a8);
      goto LABEL_11;
    case 2:
      if ( (a8 & 0x80000000) == 0 )
      {
        v17 = -2147024228;
        wil::details::ReportFailure_Hr(a1, a2);
      }
      v20 = wil::details::RecordLog((wil::details *)v17);
      goto LABEL_11;
    case 3:
      v20 = wil::details::RecordFailFast((wil::details *)a8);
LABEL_11:
      v19 = v20;
      break;
  }
  *(_DWORD *)a15 = a7;
  *(_DWORD *)(a15 + 4) = v17;
  *(_DWORD *)(a15 + 8) = _InterlockedIncrement(&`wil::details::LogFailure'::`2'::s_failureId);
  v21 = a9;
  if ( !a9 || !*a9 )
    v21 = 0LL;
  *(_QWORD *)(a15 + 16) = v21;
  CurrentThreadId = GetCurrentThreadId();
  *(_QWORD *)(a15 + 48) = a3;
  *(_DWORD *)(a15 + 24) = CurrentThreadId;
  *(_QWORD *)(a15 + 32) = a5;
  *(_QWORD *)(a15 + 128) = a6;
  *(_QWORD *)(a15 + 136) = a1;
  v25 = (__int64 (*)(void))wil::details::g_pfnGetModuleName;
  *(_DWORD *)(a15 + 56) = a2;
  *(_DWORD *)(a15 + 60) = v19;
  *(_QWORD *)(a15 + 40) = a4;
  *(_QWORD *)(a15 + 64) = 0LL;
  *(_OWORD *)(a15 + 72) = 0LL;
  *(_OWORD *)(a15 + 88) = 0LL;
  *(_OWORD *)(a15 + 104) = 0LL;
  if ( v25 )
    v26 = v25();
  else
    v26 = 0LL;
  *(_QWORD *)(a15 + 120) = v26;
  if ( wil::details::g_pfnGetContextAndNotifyFailure )
    wil::details::g_pfnGetContextAndNotifyFailure((struct wil::FailureInfo *)a15, a13, 0x400uLL);
  if ( wil::details::g_pfnLoggingCallback )
    wil::details::g_pfnLoggingCallback((const struct wil::FailureInfo *)a15);
  if ( wil::details::g_pfnOriginateCallback )
    wil::details::g_pfnOriginateCallback((const struct wil::FailureInfo *)a15);
  if ( *(int *)(a15 + 4) >= 0 )
  {
    if ( a7 != 3 )
      wil::details::in1diag3::_FailFastImmediate_Unexpected(v23);
    *(_DWORD *)(a15 + 4) = -2147418113;
  }
  if ( wil::g_fIsDebuggerPresent )
    goto LABEL_36;
  if ( wil::g_pfnIsDebuggerPresent )
  {
    IsDebuggerPresent = wil::g_pfnIsDebuggerPresent();
  }
  else
  {
    if ( ::IsDebuggerPresent() )
      goto LABEL_36;
    IsDebuggerPresent = 0;
  }
  if ( !IsDebuggerPresent )
  {
    if ( g_pfnResultLoggingCallback && !wil::details::g_resultMessageCallbackSet )
      g_pfnResultLoggingCallback(a15, 0LL, 0LL);
    goto LABEL_42;
  }
LABEL_36:
  if ( g_pfnResultLoggingCallback && !wil::details::g_resultMessageCallbackSet )
    g_pfnResultLoggingCallback(a15, lpOutputString, 2048LL);
  if ( !*lpOutputString )
    wil::GetFailureLogString(lpOutputString, (unsigned __int16 *)0x800, a15, v24);
  OutputDebugStringW(lpOutputString);
LABEL_42:
  if ( wil::g_fBreakOnFailure )
  {
    if ( wil::details::g_pfnDebugBreak )
      wil::details::g_pfnDebugBreak();
  }
}
// 1800B1520: invalid function type '?' has been ignored
// 18005B151: variable 'v24' is possibly undefined
// 18005B19F: variable 'v23' is possibly undefined
// 18005EFF0: using guessed type __int64 __fastcall wil::details::ReportFailure_Hr(_QWORD, _QWORD);
// 1800B0998: using guessed type void (__stdcall *wil::details::g_pfnGetContextAndNotifyFailure)(struct wil::FailureInfo *, char *, unsigned __int64);
// 1800B0B80: using guessed type int `wil::details::LogFailure'::`2'::s_failureId;
// 1800B1498: using guessed type void (*wil::details::g_pfnDebugBreak)(void);
// 1800B14A0: using guessed type const char *(*wil::details::g_pfnGetModuleName)(void);
// 1800B1510: using guessed type bool (*wil::g_pfnIsDebuggerPresent)(void);
// 1800B1518: using guessed type bool wil::g_fIsDebuggerPresent;
// 1800B1519: using guessed type bool wil::g_fBreakOnFailure;
// 1800B1520: using guessed type __int64 (__fastcall *g_pfnResultLoggingCallback)(_QWORD, _QWORD, _QWORD);
// 1800B1530: using guessed type bool wil::details::g_resultMessageCallbackSet;
// 1800B1538: using guessed type void (__stdcall *wil::details::g_pfnLoggingCallback)(const struct wil::FailureInfo *);
// 1800B1548: using guessed type void (__stdcall *wil::details::g_pfnOriginateCallback)(const struct wil::FailureInfo *);

//----- (000000018005B1AC) ----------------------------------------------------
STRSAFE_LPWSTR wil::details::LogStringPrintf(
        STRSAFE_LPWSTR pszDest,
        STRSAFE_LPWSTR a2,
        size_t *a3,
        const unsigned __int16 *a4,
        ...)
{
  STRSAFE_LPWSTR v4; // rbx
  size_t v6; // rcx
  __int64 v7; // rax
  const unsigned __int16 *v9; // [rsp+68h] [rbp+20h] BYREF

  v9 = a4;
  v4 = pszDest;
  v6 = a2 - pszDest;
  if ( v6 - 1 > 0x7FFFFFFE )
  {
    if ( v6 )
      *v4 = 0;
  }
  else
  {
    StringVPrintfWorkerW_0(v4, v6, a3, (STRSAFE_LPCWSTR)a3, (va_list)&v9);
  }
  if ( a2 != v4 )
  {
    v7 = -1LL;
    do
      ++v7;
    while ( v4[v7] );
    v4 += v7;
  }
  return v4;
}

//----- (000000018005B224) ----------------------------------------------------
unsigned __int8 *__fastcall wil::details_abi::RawUsageIndex::LowerBound(
        wil::details_abi::RawUsageIndex *this,
        unsigned __int8 *a2,
        unsigned __int64 a3,
        void *a4,
        unsigned __int64 a5)
{
  unsigned __int64 v6; // rbx
  unsigned __int8 *v9; // r8
  const void *v11; // [rsp+20h] [rbp-38h] BYREF
  __int16 v12; // [rsp+28h] [rbp-30h]
  __int128 v13; // [rsp+30h] [rbp-28h]
  unsigned __int8 *v14; // [rsp+60h] [rbp+8h] BYREF

  LOWORD(v11) = *((_WORD *)this + 3);
  BYTE2(v11) = *((_BYTE *)this + 8);
  v6 = a3;
  HIDWORD(v11) = 0;
  v12 = 0;
  v13 = 0LL;
  while ( v6 )
  {
    v9 = (unsigned __int8 *)*((_QWORD *)this + 4);
    v14 = &a2[*((_QWORD *)this + 2) * (v6 >> 1)];
    wil::details_abi::UsageIndexProperty::Read((wil::details_abi::UsageIndexProperty *)&v11, &v14, v9);
    if ( (int)wil::details_abi::UsageIndexProperty::Compare(&v11, a4, a5) <= 0 )
    {
      v6 >>= 1;
    }
    else
    {
      a2 = v14;
      v6 += -1LL - (v6 >> 1);
    }
  }
  return a2;
}

//----- (000000018005B2F0) ----------------------------------------------------
__int64 __fastcall wil::details_abi::ProcessLocalStorageData<wil::details_abi::ProcessLocalData>::MakeAndInitialize(
        char *a1,
        _QWORD *a2,
        wil::details **a3)
{
  wil::details *v6; // rax
  wil::details::in1diag3 *v7; // rcx
  __int64 v8; // r8
  wil::details *v9; // rdi
  unsigned int v10; // ebx
  void *v11; // rdx
  int v12; // eax
  __int64 v13; // r8
  __int64 v14; // rax
  __int64 v15; // rax
  int v17[4]; // [rsp+20h] [rbp-28h] BYREF
  wil::details::in1diag3 *retaddr; // [rsp+48h] [rbp+0h]
  wil::details *v19; // [rsp+60h] [rbp+18h] BYREF

  *a3 = 0LL;
  v6 = (wil::details *)wil::details::ProcessHeapAlloc(8u, 0x78uLL);
  v19 = v6;
  v9 = v6;
  if ( v6 )
  {
    *(_OWORD *)v17 = 0LL;
    if ( ((unsigned __int8)v6 & 3) != 0 )
      wil::details::in1diag3::_FailFastImmediate_Unexpected(v7);
    v12 = wil::details_abi::SemaphoreValue::CreateFromValueInternal(
            (wil::details_abi::SemaphoreValue *)v17,
            a1,
            v8,
            (unsigned __int64)v6 >> 2);
    v10 = v12;
    if ( v12 >= 0 )
    {
      *(_DWORD *)v9 = 1;
      *((_QWORD *)v9 + 1) = *a2;
      v14 = *(_QWORD *)v17;
      *a2 = 0LL;
      *(_QWORD *)v17 = 0LL;
      *((_QWORD *)v9 + 2) = v14;
      v15 = *(_QWORD *)&v17[2];
      *(_QWORD *)&v17[2] = 0LL;
      *((_QWORD *)v9 + 3) = v15;
      memset_0((char *)v9 + 32, 0, 0x58uLL);
      *((_WORD *)v9 + 16) = 88;
      *((_DWORD *)v9 + 9) = 1;
      memset_0((char *)v9 + 40, 0, 0x50uLL);
      v19 = 0LL;
      v10 = 0;
      *a3 = v9;
    }
    else
    {
      wil::details::in1diag3::Return_Hr(retaddr, (void *)0x145, v13, (const char *)(unsigned int)v12);
    }
    wil::details_abi::SemaphoreValue::~SemaphoreValue((wil::details_abi::SemaphoreValue *)v17);
  }
  else
  {
    v10 = -2147024882;
    wil::details::in1diag3::Return_Hr(retaddr, (void *)0x142, v8, (const char *)0x8007000ELL);
  }
  wistd::unique_ptr<wil::details_abi::ProcessLocalStorageData<wil::details_abi::ProcessLocalData>,wil::process_heap_deleter>::~unique_ptr<wil::details_abi::ProcessLocalStorageData<wil::details_abi::ProcessLocalData>,wil::process_heap_deleter>(
    &v19,
    v11);
  return v10;
}
// 18005B33B: variable 'v8' is possibly undefined
// 18005B37F: variable 'v13' is possibly undefined
// 18005B3FC: variable 'v11' is possibly undefined
// 18005B417: variable 'v7' is possibly undefined

//----- (000000018005B424) ----------------------------------------------------
__int64 __fastcall wil::details_abi::ProcessLocalStorageData<wil::details_abi::FeatureStateData>::MakeAndInitialize(
        char *a1,
        _QWORD *a2,
        __int64 *a3)
{
  unsigned __int64 v6; // rax
  wil::details::in1diag3 *v7; // rcx
  __int64 v8; // r8
  __int64 v9; // rbx
  unsigned int v10; // edi
  void *v11; // rdx
  int v12; // eax
  __int64 v13; // r8
  __int128 v15; // [rsp+20h] [rbp-18h] BYREF
  wil::details::in1diag3 *retaddr; // [rsp+38h] [rbp+0h]
  wil::details *v17; // [rsp+50h] [rbp+18h] BYREF

  *a3 = 0LL;
  v6 = (unsigned __int64)wil::details::ProcessHeapAlloc(8u, 0x130uLL);
  v17 = (wil::details *)v6;
  v9 = v6;
  if ( v6 )
  {
    v15 = 0LL;
    if ( (v6 & 3) != 0 )
      wil::details::in1diag3::_FailFastImmediate_Unexpected(v7);
    v12 = wil::details_abi::SemaphoreValue::CreateFromValueInternal(
            (wil::details_abi::SemaphoreValue *)&v15,
            a1,
            v8,
            v6 >> 2);
    v10 = v12;
    if ( v12 >= 0 )
    {
      wil::details_abi::ProcessLocalStorageData<wil::details_abi::FeatureStateData>::ProcessLocalStorageData<wil::details_abi::FeatureStateData>(
        v9,
        a2,
        &v15);
      v17 = 0LL;
      v10 = 0;
      *a3 = v9;
    }
    else
    {
      wil::details::in1diag3::Return_Hr(retaddr, (void *)0x145, v13, (const char *)(unsigned int)v12);
    }
    wil::details_abi::SemaphoreValue::~SemaphoreValue((wil::details_abi::SemaphoreValue *)&v15);
  }
  else
  {
    v10 = -2147024882;
    wil::details::in1diag3::Return_Hr(retaddr, (void *)0x142, v8, (const char *)0x8007000ELL);
  }
  wistd::unique_ptr<wil::details_abi::ProcessLocalStorageData<wil::details_abi::ProcessLocalData>,wil::process_heap_deleter>::~unique_ptr<wil::details_abi::ProcessLocalStorageData<wil::details_abi::ProcessLocalData>,wil::process_heap_deleter>(
    &v17,
    v11);
  return v10;
}
// 18005B473: variable 'v8' is possibly undefined
// 18005B4AF: variable 'v13' is possibly undefined
// 18005B4E0: variable 'v11' is possibly undefined
// 18005B4FD: variable 'v7' is possibly undefined
// 18005B424: using guessed type _OWORD var_18;

//----- (000000018005B50C) ----------------------------------------------------
__int64 __fastcall JobStore::MigrateDynamicTaskInfo(
        __int64 **this,
        const struct JobMoniker *a2,
        const struct _GUID *a3)
{
  JobStore *v6; // rcx
  int TaskIfNeeded; // ebx
  int v8; // eax
  int DynamicTaskInfo; // eax
  __int64 v10; // rax
  __int64 v11; // rax
  JobStore *v12; // rcx
  __int64 v13; // r8
  const wchar_t *Path; // rax
  _BYTE Data[36]; // [rsp+30h] [rbp-D0h] BYREF
  _BYTE v17[36]; // [rsp+58h] [rbp-A8h] BYREF
  HKEY hKey; // [rsp+80h] [rbp-80h] BYREF
  __int128 v19; // [rsp+88h] [rbp-78h] BYREF
  __int128 v20; // [rsp+98h] [rbp-68h] BYREF
  __int64 v21; // [rsp+A8h] [rbp-58h]
  UUID v22; // [rsp+B0h] [rbp-50h] BYREF
  char v23[16]; // [rsp+C0h] [rbp-40h] BYREF
  wmi::RefBase *v24; // [rsp+D0h] [rbp-30h] BYREF
  BSTR *v25[2]; // [rsp+D8h] [rbp-28h] BYREF
  char v26[16]; // [rsp+E8h] [rbp-18h] BYREF
  wmi::RefBase *v27; // [rsp+F8h] [rbp-8h] BYREF

  v21 = -2LL;
  *(_OWORD *)v17 = 3uLL;
  memset(&v17[16], 0, 20);
  *(_QWORD *)Data = 3LL;
  memset(&Data[8], 0, 28);
  hKey = 0LL;
  JobMoniker::JobMoniker((JobMoniker *)&v22, a2, (__int64)a3);
  JobMoniker::JobMoniker((JobMoniker *)v25, a2, a3);
  TaskIfNeeded = JobStore::LoadTaskIfNeeded((JobStore *)this, (struct JobMoniker *)&v22);
  if ( TaskIfNeeded >= 0 )
  {
    v8 = (*((_DWORD *)v24 + 4) & 0x2000000) != 0
       ? JobStore::GetMigratedUbpmDynamicTaskInfo(v6, &v22, (struct DynamicTaskInfo *)v17)
       : JobStore::GetDynamicTaskInfo(
           (JobStore *)this,
           (struct JobMoniker *)&v22,
           (struct DynamicTaskInfo *)v17,
           0x20019u,
           0LL);
    TaskIfNeeded = v8;
    if ( v8 >= 0 )
    {
      if ( v8 == 1 )
      {
        TaskIfNeeded = 0;
        goto LABEL_40;
      }
      TaskIfNeeded = JobStore::LoadTaskIfNeeded((JobStore *)this, (struct JobMoniker *)v25);
      if ( tsched::IsErrorNotFound((tsched *)(unsigned int)TaskIfNeeded) )
      {
        TaskIfNeeded = 1;
        goto LABEL_40;
      }
      if ( TaskIfNeeded >= 0 )
      {
        DynamicTaskInfo = JobStore::GetDynamicTaskInfo(
                            (JobStore *)this,
                            (struct JobMoniker *)v25,
                            (struct DynamicTaskInfo *)Data,
                            0x2001Bu,
                            &hKey);
        TaskIfNeeded = DynamicTaskInfo;
        if ( DynamicTaskInfo >= 0 )
        {
          if ( DynamicTaskInfo == 1 )
          {
            *(_OWORD *)Data = *(_OWORD *)v17;
            *(_OWORD *)&Data[16] = *(_OWORD *)&v17[16];
            *(_DWORD *)&Data[32] = *(_DWORD *)&v17[32];
LABEL_30:
            TaskIfNeeded = DynamicTaskInfo::StreamOut(Data, hKey);
            if ( TaskIfNeeded >= 0 )
            {
              if ( (*((_DWORD *)v24 + 4) & 0x2000000) == 0 )
                goto LABEL_38;
              TaskIfNeeded = JobStore::RemoveMigratedUbpmStatsFile(v12, &v22);
              if ( tsched::IsErrorNotFound((tsched *)(unsigned int)TaskIfNeeded) )
                TaskIfNeeded = 0;
              if ( TaskIfNeeded >= 0 )
              {
LABEL_38:
                if ( (*((_DWORD *)v27 + 4) & 0x2000000) != 0 )
                {
                  std::_Tree<std::_Tset_traits<JobMoniker,std::less<JobMoniker>,std::allocator<JobMoniker>,0>>::_Insert_nohint<JobMoniker const &,std::_Nil>(
                    this + 8,
                    (__int64)&v19,
                    v13,
                    v25);
                  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
                    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
                    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
                  {
                    Path = JobMoniker::GetPath((JobMoniker *)v25);
                    WPP_SF_SD(
                      *((_QWORD *)WPP_GLOBAL_Control + 2),
                      0x6Bu,
                      (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
                      Path);
                  }
                }
              }
            }
            goto LABEL_40;
          }
          v10 = *(_QWORD *)&v17[4];
          if ( *(_QWORD *)&v17[4] )
          {
            if ( !*(_DWORD *)&Data[8] && !*(_DWORD *)&Data[4] )
              goto LABEL_19;
            LOBYTE(v20) = 0;
            *((_QWORD *)&v20 + 1) = *(_QWORD *)&Data[4];
            LOBYTE(v19) = 0;
            *((_QWORD *)&v19 + 1) = *(_QWORD *)&v17[4];
            if ( TSTime::operator<((__int64)&v19, &v20) )
            {
              v10 = *(_QWORD *)&v17[4];
LABEL_19:
              *(_QWORD *)&Data[4] = v10;
            }
          }
          v11 = *(_QWORD *)&v17[28];
          if ( *(_DWORD *)&v17[32] || *(_DWORD *)&v17[28] )
          {
            if ( !*(_DWORD *)&Data[32] && !*(_DWORD *)&Data[28] )
              goto LABEL_26;
            LOBYTE(v19) = 0;
            *((_QWORD *)&v19 + 1) = *(_QWORD *)&Data[28];
            LOBYTE(v20) = 0;
            *((_QWORD *)&v20 + 1) = *(_QWORD *)&v17[28];
            if ( TSTime::operator<((__int64)&v20, &v19) )
            {
              v11 = *(_QWORD *)&v17[28];
LABEL_26:
              *(_QWORD *)&Data[28] = v11;
            }
          }
          if ( !*(_DWORD *)&Data[16] && !*(_DWORD *)&Data[12] )
          {
            *(_QWORD *)&Data[12] = *(_QWORD *)&v17[12];
            *(_DWORD *)&Data[20] = *(_DWORD *)&v17[20];
            *(_DWORD *)&Data[24] = *(_DWORD *)&v17[24];
          }
          goto LABEL_30;
        }
      }
    }
  }
LABEL_40:
  wmi::AutoRef<JobBucket>::Release(&v27);
  _bstr_t::_Free((_bstr_t *)v26);
  wmi::AutoRef<JobBucket>::Release(&v24);
  _bstr_t::_Free((_bstr_t *)v23);
  wmi::AutoRegKey::Close(&hKey);
  return (unsigned int)TaskIfNeeded;
}
// 18005B5C6: variable 'v6' is possibly undefined
// 18005B777: variable 'v12' is possibly undefined
// 18005B7AE: variable 'v13' is possibly undefined
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 18005B50C: using guessed type char var_48[16];
// 18005B50C: using guessed type char var_70[16];

//----- (000000018005B878) ----------------------------------------------------
__int64 __fastcall JobStore::MigrateSecurityInfoP(JobStore *this, unsigned __int16 *a2)
{
  unsigned int v4; // esi
  int Value; // eax
  HKEY v6; // rbx
  char v7; // r13
  int v8; // eax
  int XmlFileSystemPath; // r14d
  JobStore *v10; // rcx
  unsigned __int16 *v11; // rdi
  unsigned __int16 *v12; // rcx
  LSTATUS InfoKeyW; // eax
  bool v14; // cc
  DWORD v15; // edi
  DWORD i; // edx
  const unsigned __int16 *v17; // rdx
  int v18; // eax
  void *v19; // rbx
  __int64 v20; // r9
  int v21; // eax
  __int64 v22; // rcx
  __int64 v23; // r8
  __int64 v24; // r9
  DWORD Type[2]; // [rsp+68h] [rbp-A0h] BYREF
  struct _SECURITY_DESCRIPTOR *cSubKeys; // [rsp+70h] [rbp-98h] BYREF
  DWORD cchName[2]; // [rsp+78h] [rbp-90h] BYREF
  unsigned __int16 *v29; // [rsp+80h] [rbp-88h] BYREF
  void *lpMem; // [rsp+88h] [rbp-80h] BYREF
  BSTR *v31; // [rsp+90h] [rbp-78h] BYREF
  void *v32; // [rsp+98h] [rbp-70h] BYREF
  int v33; // [rsp+A0h] [rbp-68h]
  BYTE Data[4]; // [rsp+A8h] [rbp-60h] BYREF
  HKEY hKey[3]; // [rsp+B0h] [rbp-58h] BYREF
  WCHAR Name[264]; // [rsp+C8h] [rbp-40h] BYREF

  hKey[1] = HKEY_DYN_DATA|0x7FFFFFF8LL;
  v4 = 0;
  hKey[0] = 0LL;
  if ( !JobStore::GetUseXmlStore(this) )
    goto LABEL_50;
  Value = JobStore::RegTreeEntryOpen((HKEY *)this, a2, hKey);
  if ( Value < 0 )
    goto LABEL_48;
  Type[0] = 1;
  Type[1] = 0;
  v6 = hKey[0];
  Value = RegQueryValueExW(hKey[0], L"Id", 0LL, Type, 0LL, &Type[1]);
  if ( Value )
  {
    if ( Value == 2 )
    {
      v7 = 0;
      goto LABEL_14;
    }
    if ( Value > 0 )
    {
      v4 = (unsigned __int16)Value | 0x80070000;
      goto LABEL_50;
    }
LABEL_48:
    v4 = Value;
LABEL_50:
    v8 = v4;
    goto LABEL_51;
  }
  v7 = 1;
  Type[0] = 4;
  Type[1] = 4;
  v8 = RegQueryValueExW(v6, L"Index", 0LL, Type, Data, &Type[1]);
  if ( v8 )
  {
    if ( v8 > 0 )
      v8 = (unsigned __int16)v8 | 0x80070000;
    goto LABEL_51;
  }
  if ( Type[0] != 4 || Type[1] != 4 )
  {
    v8 = -2147023537;
LABEL_51:
    v4 = v8;
LABEL_52:
    XmlFileSystemPath = v4;
    goto LABEL_53;
  }
  if ( !*(_DWORD *)Data )
    goto LABEL_52;
LABEL_14:
  JobSecurity::JobSecurity((JobSecurity *)&v32);
  XmlFileSystemPath = JobSecurity::StreamIn(&v32, v6);
  if ( tsched::IsErrorNotFound((tsched *)(unsigned int)XmlFileSystemPath) )
  {
    v29 = 0LL;
    XmlFileSystemPath = JobStore::GetXmlFileSystemPath((char **)this, (char *)a2, (void **)&v29);
    v11 = v29;
    if ( XmlFileSystemPath < 0 )
    {
LABEL_18:
      v12 = v11;
LABEL_42:
      operator delete(v12);
      goto LABEL_43;
    }
    cSubKeys = 0LL;
    XmlFileSystemPath = JobStore::GetXmlFileSecurity(v10, v29, (void **)&cSubKeys);
    if ( XmlFileSystemPath < 0 )
    {
      tsched::AutoLocalPtr<unsigned short>::~AutoLocalPtr<unsigned short>((void **)&cSubKeys);
      goto LABEL_18;
    }
    JobSecurity::Attach(&v32, cSubKeys);
    XmlFileSystemPath = JobSecurity::StreamOut((JobSecurity *)&v32, v6);
    v33 = 0;
    v32 = 0LL;
    tsched::AutoLocalPtr<unsigned short>::~AutoLocalPtr<unsigned short>((void **)&cSubKeys);
    operator delete(v11);
  }
  if ( XmlFileSystemPath >= 0 )
  {
    if ( !v7 )
    {
      InfoKeyW = RegQueryInfoKeyW(v6, 0LL, 0LL, 0LL, (LPDWORD)&cSubKeys, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL);
      v14 = InfoKeyW <= 0;
      if ( InfoKeyW )
      {
LABEL_44:
        if ( v14 )
          XmlFileSystemPath = InfoKeyW;
        else
          XmlFileSystemPath = (unsigned __int16)InfoKeyW | 0x80070000;
        goto LABEL_43;
      }
      if ( (_DWORD)cSubKeys )
      {
        v15 = 0;
        for ( i = 0; ; i = v15 )
        {
          cchName[0] = 261;
          InfoKeyW = RegEnumKeyExW(v6, i, Name, cchName, 0LL, 0LL, 0LL, 0LL);
          if ( InfoKeyW == 259 )
            break;
          v14 = InfoKeyW <= 0;
          if ( InfoKeyW )
            goto LABEL_44;
          ++v15;
          _bstr_t::_bstr_t((_bstr_t *)&v29, a2);
          _bstr_t::_bstr_t((_bstr_t *)&v31, L"\\");
          _bstr_t::operator+=((OLECHAR ***)&v29, &v31);
          _bstr_t::_Free((_bstr_t *)&v31);
          _bstr_t::_bstr_t((_bstr_t *)&lpMem, Name);
          _bstr_t::operator+=((OLECHAR ***)&v29, (BSTR **)&lpMem);
          _bstr_t::_Free((_bstr_t *)&lpMem);
          if ( v29 )
            v17 = *(const unsigned __int16 **)v29;
          else
            v17 = 0LL;
          v18 = JobStore::MigrateSecurityInfoP(this, v17);
          if ( v18 < 0 && XmlFileSystemPath >= 0 )
            XmlFileSystemPath = v18;
          _bstr_t::_Free((_bstr_t *)&v29);
        }
        XmlFileSystemPath = 0;
      }
    }
    lpMem = 0LL;
    JobSecurity::StreamIn(&v32, v6);
    JobSecurity::GetSddl(&v32, 7u, (unsigned __int16 **)&lpMem);
    v19 = lpMem;
    v21 = JobStore::FileSddlSetWithRestorePrivs(this, a2, (const unsigned __int16 *)lpMem, v20);
    if ( v21 < 0 && !tsched::IsErrorNotFound((tsched *)(unsigned int)v21) )
    {
      XmlFileSystemPath = v22;
      if ( (unsigned int)dword_1800AFF68 > 4
        && (qword_1800AFF78 & 0x400000000001LL) != 0
        && (qword_1800AFF80 & 0x400000000001LL) == qword_1800AFF80 )
      {
        lpMem = v19;
        v31 = (BSTR *)a2;
        LODWORD(cSubKeys) = v22;
        _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapperByVal<4>,_tlgWrapSz<unsigned short>,_tlgWrapSz<unsigned short>>(
          v22,
          byte_18007EE73,
          v23,
          v24,
          (__int64)&cSubKeys,
          (const WCHAR **)&v31,
          (const WCHAR **)&lpMem);
      }
    }
    v12 = (unsigned __int16 *)v19;
    goto LABEL_42;
  }
LABEL_43:
  tsched::AutoLocalPtr<unsigned short>::~AutoLocalPtr<unsigned short>(&v32);
LABEL_53:
  wmi::AutoRegKey::Close(hKey);
  return (unsigned int)XmlFileSystemPath;
}
// 18005BBE4: conditional instruction was optimized away because r14d.4>=0
// 18005B9FA: variable 'v10' is possibly undefined
// 18005BBCD: variable 'v20' is possibly undefined
// 18005BBE4: variable 'v22' is possibly undefined
// 18005BC47: variable 'v23' is possibly undefined
// 18005BC47: variable 'v24' is possibly undefined
// 18007EE73: using guessed type unsigned __int8 byte_18007EE73[74];
// 1800AFF78: using guessed type __int64 qword_1800AFF78;
// 1800AFF80: using guessed type __int64 qword_1800AFF80;

//----- (000000018005BD20) ----------------------------------------------------
signed int __fastcall wil::details::NtStatusToHr(wil::details *this)
{
  int v1; // ebx
  signed int result; // eax

  v1 = (int)this;
  if ( (int)this >= 0 )
    return 0;
  if ( (_DWORD)this == -1073741801 )
    return -2147024882;
  if ( !wil::details::g_pfnRtlNtStatusToDosErrorNoTeb )
    return v1 | 0x10000000;
  result = wil::details::g_pfnRtlNtStatusToDosErrorNoTeb((int)this);
  if ( !result || result == 317 )
    return v1 | 0x10000000;
  if ( result > 0 )
    return (unsigned __int16)result | 0x80070000;
  return result;
}
// 1800B14B0: using guessed type unsigned int (__stdcall *wil::details::g_pfnRtlNtStatusToDosErrorNoTeb)(int);

//----- (000000018005BD80) ----------------------------------------------------
struct _GUID *__fastcall ATL::CDacl::CAccessObjectAce::ObjectType(
        ATL::CDacl::CAccessObjectAce *this,
        struct _GUID *__return_ptr retstr)
{
  GUID *v2; // rax
  GUID *v3; // rcx
  struct _GUID *result; // rax

  v2 = (GUID *)*((_QWORD *)this + 19);
  v3 = &GUID_NULL;
  if ( v2 )
    v3 = v2;
  result = retstr;
  *retstr = *v3;
  return result;
}

//----- (000000018005BDA8) ----------------------------------------------------
void __fastcall wil::details_abi::SubscriptionList::OnSignaled(LPCRITICAL_SECTION lpCriticalSection, PSRWLOCK SRWLock)
{
  unsigned __int64 v4; // rdi
  unsigned __int64 v5; // rbx
  void (__fastcall *v6)(__int64); // r15
  __int64 v7; // r12
  PRTL_CRITICAL_SECTION_DEBUG DebugInfo; // rdx
  WORD *v9; // rax
  unsigned __int64 v10; // rcx
  __int128 v11; // xmm0
  LPCRITICAL_SECTION v12; // [rsp+60h] [rbp+30h] BYREF
  __int64 (__fastcall *v13)(_QWORD); // [rsp+68h] [rbp+38h] BYREF

  AcquireSRWLockShared(SRWLock);
  v4 = (*(_QWORD *)&lpCriticalSection[1].LockCount - (unsigned __int64)lpCriticalSection[1].DebugInfo) >> 4;
  if ( SRWLock )
  {
    v13 = (__int64 (__fastcall *)(_QWORD))ReleaseSRWLockShared;
    v12 = (LPCRITICAL_SECTION)SRWLock;
    wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>(&v13, &v12);
  }
  v5 = 0LL;
  while ( v5 < v4 )
  {
    v6 = 0LL;
    v7 = 0LL;
    EnterCriticalSection(lpCriticalSection);
    AcquireSRWLockExclusive(SRWLock);
    if ( v5 < v4 )
    {
      DebugInfo = lpCriticalSection[1].DebugInfo;
      v9 = &DebugInfo->Type + 8 * v5;
      while ( 1 )
      {
        v10 = v5 + 1;
        if ( *(_QWORD *)v9 )
          break;
        v9 += 8;
        ++v5;
        if ( v10 >= v4 )
          goto LABEL_10;
      }
      v11 = *((_OWORD *)&DebugInfo->Type + v5++);
      v7 = *((_QWORD *)&v11 + 1);
      v6 = (void (__fastcall *)(__int64))v11;
    }
LABEL_10:
    if ( SRWLock )
    {
      v13 = (__int64 (__fastcall *)(_QWORD))ReleaseSRWLockExclusive;
      v12 = (LPCRITICAL_SECTION)SRWLock;
      wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>(&v13, &v12);
    }
    if ( v6 )
      v6(v7);
    if ( lpCriticalSection )
    {
      v13 = (__int64 (__fastcall *)(_QWORD))LeaveCriticalSection;
      v12 = lpCriticalSection;
      wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>(&v13, &v12);
    }
  }
}

//----- (000000018005BEF0) ----------------------------------------------------
void __fastcall wil::details::EnabledStateManager::OnStateChange(RTL_SRWLOCK *this)
{
  RTL_SRWLOCK *v2; // rdi
  __int64 Ptr; // r9
  __int64 v4; // r9
  __int64 v5; // rcx
  __int64 v6; // r9
  int v7; // eax
  __int64 v8; // [rsp+40h] [rbp+8h] BYREF
  PVOID v9; // [rsp+48h] [rbp+10h] BYREF
  RTL_SRWLOCK *v10; // [rsp+50h] [rbp+18h] BYREF
  void (__stdcall *v11)(PSRWLOCK); // [rsp+58h] [rbp+20h] BYREF

  if ( LOBYTE(this->Ptr) )
  {
    v2 = this + 1;
    AcquireSRWLockExclusive(this + 1);
    Ptr = (__int64)this[10].Ptr;
    v9 = this[11].Ptr;
    while ( 1 )
    {
      v8 = Ptr;
      if ( !wil::details_abi::operator!=(&v8, &v9) )
        break;
      wil::details::EnabledStateManager::InvalidateFeatureStateCache(
        v5,
        *(volatile signed __int32 **)(v6 + 8),
        *(_DWORD *)v6);
      Ptr = v4 + 16;
    }
    this[11].Ptr = this[10].Ptr;
    v7 = 1;
    if ( HIDWORD(this[3].Ptr) != -1 )
      v7 = HIDWORD(this[3].Ptr) + 1;
    HIDWORD(this[3].Ptr) = v7;
    if ( v2 )
    {
      v11 = ReleaseSRWLockExclusive;
      v10 = v2;
      wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>((__int64 (__fastcall **)(_QWORD))&v11, &v10);
    }
  }
}
// 18005BF2C: variable 'v5' is possibly undefined
// 18005BF28: variable 'v6' is possibly undefined
// 18005BF31: variable 'v4' is possibly undefined

//----- (000000018005BF98) ----------------------------------------------------
void __fastcall wil::details::FeatureStateManager::OnStateChange(wil::details::FeatureStateManager *this)
{
  if ( *(_BYTE *)this )
    wil::details_abi::SubscriptionList::OnSignaled((LPCRITICAL_SECTION)((char *)this + 72), (PSRWLOCK)this + 4);
}

//----- (000000018005BFBC) ----------------------------------------------------
void __fastcall wil::details::EnabledStateManager::OnTimer(RTL_SRWLOCK *this)
{
  RTL_SRWLOCK *v2; // rdi
  RTL_SRWLOCK *v3; // [rsp+30h] [rbp+8h] BYREF
  void (__stdcall *v4)(PSRWLOCK); // [rsp+38h] [rbp+10h] BYREF

  if ( LOBYTE(this->Ptr) )
  {
    v2 = this + 1;
    AcquireSRWLockExclusive(this + 1);
    wil::details::EnabledStateManager::RecordCachedUsageUnderLock((wil::details::EnabledStateManager *)this);
    LOBYTE(this[3].Ptr) = 0;
    if ( v2 )
    {
      v4 = ReleaseSRWLockExclusive;
      v3 = v2;
      wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>((__int64 (__fastcall **)(_QWORD))&v4, &v3);
    }
  }
}

//----- (000000018005C024) ----------------------------------------------------
__int64 __fastcall ATL::CDacl::CAccessAce::Order(
        const struct ATL::CDacl::CAccessAce *a1,
        const struct ATL::CDacl::CAccessAce *a2)
{
  char v3; // al
  char v5; // al

  v3 = *((_BYTE *)a2 + 132) & 0x10;
  if ( (*((_BYTE *)a1 + 132) & 0x10) != 0 )
  {
    if ( !v3 )
      return 0xFFFFFFFFLL;
  }
  else if ( v3 )
  {
    return 1LL;
  }
  v5 = *((_BYTE *)a2 + 144);
  if ( *((_BYTE *)a1 + 144) )
  {
    if ( !v5 )
      return 0xFFFFFFFFLL;
  }
  else if ( v5 )
  {
    return 1LL;
  }
  if ( (*(unsigned __int8 (__fastcall **)(const struct ATL::CDacl::CAccessAce *))(*(_QWORD *)a1 + 32LL))(a1)
    && !(*(unsigned __int8 (__fastcall **)(const struct ATL::CDacl::CAccessAce *))(*(_QWORD *)a2 + 32LL))(a2) )
  {
    return 0xFFFFFFFFLL;
  }
  return !(*(unsigned __int8 (__fastcall **)(const struct ATL::CDacl::CAccessAce *))(*(_QWORD *)a1 + 32LL))(a1)
      && (*(unsigned __int8 (__fastcall **)(const struct ATL::CDacl::CAccessAce *))(*(_QWORD *)a2 + 32LL))(a2);
}

//----- (000000018005C0E0) ----------------------------------------------------
void __fastcall ATL::CDacl::PrepareAcesForACL(ATL::CDacl *this)
{
  unsigned __int64 v1; // rbx
  unsigned __int64 v2; // r15
  unsigned __int64 v4; // rax
  unsigned __int64 i; // rdi
  unsigned __int64 v6; // rbp
  unsigned __int64 v7; // r14
  struct ATL::CDacl::CAccessAce *v8; // [rsp+40h] [rbp+8h] BYREF

  v8 = 0LL;
  v1 = 1LL;
  v2 = *((_QWORD *)this + 4);
  v4 = 4LL;
  if ( v2 <= 4 )
    goto LABEL_20;
  do
  {
    v1 = v4;
    v4 += 2 * v4 + 1;
  }
  while ( v4 < v2 );
  if ( v1 )
  {
LABEL_20:
    do
    {
      for ( i = v1 - 1; i < v2; ++i )
      {
        if ( i >= *((_QWORD *)this + 4) )
          goto LABEL_17;
        ATL::CAutoPtr<ATL::CDacl::CAccessAce>::operator=(
          (__int64 (__fastcall ****)(_QWORD, __int64))&v8,
          (_QWORD *)(*((_QWORD *)this + 3) + 8 * i));
        v6 = i;
        if ( i >= v1 )
        {
          while ( 1 )
          {
            v7 = v6 - v1;
            if ( v6 - v1 >= *((_QWORD *)this + 4) )
              break;
            if ( (unsigned int)ATL::CDacl::CAccessAce::Order(
                                 *(const struct ATL::CDacl::CAccessAce **)(*((_QWORD *)this + 3) + 8 * v7),
                                 v8) != -1 )
              goto LABEL_12;
            if ( v7 >= *((_QWORD *)this + 4) || v6 >= *((_QWORD *)this + 4) )
              break;
            ATL::CAutoPtr<ATL::CDacl::CAccessAce>::operator=(
              (__int64 (__fastcall ****)(_QWORD, __int64))(*((_QWORD *)this + 3) + 8 * v6),
              (_QWORD *)(*((_QWORD *)this + 3) + 8 * v7));
            v6 -= v1;
            if ( v7 < v1 )
              goto LABEL_12;
          }
LABEL_17:
          ATL::PrivateAtlThrow(-2147024809);
        }
LABEL_12:
        if ( v6 >= *((_QWORD *)this + 4) )
          goto LABEL_17;
        ATL::CAutoPtr<ATL::CDacl::CAccessAce>::operator=(
          (__int64 (__fastcall ****)(_QWORD, __int64))(*((_QWORD *)this + 3) + 8 * v6),
          &v8);
      }
      v1 /= 3uLL;
    }
    while ( v1 );
  }
  ATL::CAutoPtr<ATL::CDacl::CAccessAce>::Free((__int64 (__fastcall ****)(_QWORD, __int64))&v8);
}

//----- (000000018005C21C) ----------------------------------------------------
void __fastcall wil::details_abi::FeatureStateData::ProcessShutdown(wil::details_abi::FeatureStateData *this)
{
  __int64 v2; // rdx
  __int64 v3; // r8
  const struct wil::details_abi::RawUsageIndex *v4; // r9
  void *v5; // rdx
  char v6[200]; // [rsp+30h] [rbp-C8h] BYREF

  wil::details_abi::UsageIndexes::UsageIndexes((wil::details_abi::UsageIndexes *)v6);
  wil::details_abi::FeatureStateData::RetrieveUsageUnderLock(this, (struct wil::details_abi::UsageIndexes *)v6);
  wil::details_abi::UsageIndexes::Record((wil::details_abi::UsageIndexes *)v6, v2, v3, v4);
  wil::details_abi::UsageIndexes::~UsageIndexes((wil::details_abi::UsageIndexes *)v6, v5);
}
// 18005C24E: variable 'v2' is possibly undefined
// 18005C24E: variable 'v3' is possibly undefined
// 18005C24E: variable 'v4' is possibly undefined
// 18005C259: variable 'v5' is possibly undefined

//----- (000000018005C27C) ----------------------------------------------------
void __fastcall wil::details::FeatureStateManager::QueueBackgroundSRUMUsageReporting(
        PVOID pv,
        int a2,
        __int16 a3,
        int a4)
{
  struct _TP_TIMER *ThreadpoolTimer; // rax
  __int64 v9; // [rsp+20h] [rbp-68h] BYREF
  void (__stdcall *v10)(PSRWLOCK); // [rsp+28h] [rbp-60h] BYREF
  int v11; // [rsp+30h] [rbp-58h] BYREF
  __int16 v12; // [rsp+34h] [rbp-54h]
  __int16 v13; // [rsp+36h] [rbp-52h]
  int v14; // [rsp+38h] [rbp-50h]

  if ( *(_BYTE *)pv && !wil::ProcessShutdownInProgress((wil *)pv) )
  {
    AcquireSRWLockExclusive((PSRWLOCK)pv + 5);
    v13 = 0;
    v11 = a2;
    v12 = a3;
    v14 = a4;
    wil::details_abi::heap_buffer::push_back((void **)pv + 31, &v11, 0xCuLL);
    if ( !*((_BYTE *)pv + 64) )
    {
      if ( !*((_QWORD *)pv + 7) )
      {
        wil::last_error_context::last_error_context((wil::last_error_context *)&v9);
        ThreadpoolTimer = CreateThreadpoolTimer(
                            (PTP_TIMER_CALLBACK)lambda_5035b992506f4af81a770c5842624510_::_lambda_invoker_cdecl_,
                            pv,
                            0LL);
        wil::details::unique_storage<wil::details::resource_policy<_TP_TIMER *,void (*)(_TP_TIMER *),&public: static void wil::details::DestroyThreadPoolTimer<wil::details::SystemThreadPoolMethods,0>::Destroy(_TP_TIMER *),wistd::integral_constant<unsigned __int64,0>,_TP_TIMER *,_TP_TIMER *,0,std::nullptr_t>>::reset(
          (struct _TP_TIMER **)pv + 7,
          ThreadpoolTimer);
        wil::last_error_context::~last_error_context((wil::last_error_context *)&v9);
      }
      wil::details::EnsureCoalescedTimer_SetTimer((struct _TP_TIMER **)pv + 7, (_BYTE *)pv + 64, 5000LL);
    }
    if ( pv != (PVOID)-40LL )
    {
      v10 = ReleaseSRWLockExclusive;
      v9 = (__int64)pv + 40;
      wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>((__int64 (__fastcall **)(_QWORD))&v10, &v9);
    }
  }
}

//----- (000000018005C398) ----------------------------------------------------
bool __fastcall wil::details_abi::UsageIndexProperty::Read(
        wil::details_abi::UsageIndexProperty *this,
        unsigned __int8 **a2,
        unsigned __int8 *a3)
{
  char *v4; // r8
  char *v7; // rbp
  unsigned __int16 v8; // ax
  char *v9; // rbp
  unsigned __int8 *v10; // rcx
  bool result; // al
  unsigned __int16 v12; // [rsp+40h] [rbp+8h] BYREF

  v4 = (char *)*a2;
  if ( *((_BYTE *)this + 2) == 1 )
  {
    v7 = v4 + 2;
    if ( v4 + 2 > (char *)a3 )
      return 0;
    *((_QWORD *)this + 2) = v4;
    memcpy_s(&v12, 2uLL, v4, 2uLL);
    *((_DWORD *)this + 1) = v12;
  }
  else
  {
    if ( *((_BYTE *)this + 2) != 2 )
      goto LABEL_8;
    v7 = v4 + 4;
    if ( v4 + 4 > (char *)a3 )
      return 0;
    *((_QWORD *)this + 2) = v4;
    memcpy_s((char *)this + 4, 4uLL, v4, 4uLL);
  }
  v4 = v7;
LABEL_8:
  v8 = *(_WORD *)this;
  *((_WORD *)this + 4) = *(_WORD *)this;
  if ( v8 )
    goto LABEL_11;
  v9 = v4 + 2;
  if ( v4 + 2 > (char *)a3 )
    return 0;
  memcpy_s((char *)this + 8, 2uLL, v4, 2uLL);
  v8 = *((_WORD *)this + 4);
  v4 = v9;
LABEL_11:
  v10 = (unsigned __int8 *)&v4[v8];
  if ( v10 > a3 )
    return 0;
  *((_QWORD *)this + 3) = v4;
  result = 1;
  *a2 = v10;
  return result;
}

//----- (000000018005C498) ----------------------------------------------------
void __fastcall wil::details_abi::UsageIndexes::Record(
        wil::details_abi::UsageIndexes *this,
        __int64 a2,
        __int64 a3,
        const struct wil::details_abi::RawUsageIndex *a4)
{
  __int64 v5; // [rsp+20h] [rbp-40h] BYREF
  __int64 v6; // [rsp+28h] [rbp-38h]
  __int64 v7; // [rsp+30h] [rbp-30h]
  __int64 v8; // [rsp+38h] [rbp-28h]
  __int64 v9; // [rsp+40h] [rbp-20h]
  __int64 v10; // [rsp+48h] [rbp-18h]

  if ( *((_BYTE *)this + 56) )
  {
    v5 = 0x418A073AA3BC1C75LL;
    v6 = 0x418A073AA3BC2475LL;
    v7 = 0x418A073AA3BC2C75LL;
    wil::details_abi::RecordWnfUsageIndex(
      (wil::details_abi *)&v5,
      (const struct __WIL__WNF_STATE_NAME *)3,
      (__int64)this,
      a4);
  }
  if ( *((_BYTE *)this + 120) )
  {
    v5 = 0x418A073AA3BC3475LL;
    v6 = 0x418A073AA3BC3C75LL;
    v7 = 0x418A073AA3BC4475LL;
    wil::details_abi::RecordWnfUsageIndex(
      (wil::details_abi *)&v5,
      (const struct __WIL__WNF_STATE_NAME *)3,
      (__int64)this + 64,
      a4);
  }
  if ( *((_BYTE *)this + 184) )
  {
    v5 = 0x418A073AA3BC4C75LL;
    v6 = 0x418A073AA3BC5475LL;
    v7 = 0x418A073AA3BC5C75LL;
    v8 = 0x418A073AA3BC6475LL;
    v9 = 0x418A073AA3BC6C75LL;
    v10 = 0x418A073AA3BC7475LL;
    wil::details_abi::RecordWnfUsageIndex(
      (wil::details_abi *)&v5,
      (const struct __WIL__WNF_STATE_NAME *)6,
      (__int64)this + 128,
      a4);
  }
}
// 18005C522: variable 'a4' is possibly undefined

//----- (000000018005C5A8) ----------------------------------------------------
__int64 __fastcall wil::details::RecordException(wil::details *this)
{
  `wil::details::RecordException'::`2'::s_hrErrorLast = (int)this;
  return (unsigned int)_InterlockedIncrement(&`wil::details::RecordException'::`2'::s_cErrorCount);
}
// 1800B09B0: using guessed type int `wil::details::RecordException'::`2'::s_hrErrorLast;
// 1800B0B7C: using guessed type int `wil::details::RecordException'::`2'::s_cErrorCount;

//----- (000000018005C5C8) ----------------------------------------------------
char __fastcall wil::details_abi::FeatureStateData::RecordFeatureUsage(
        __int64 a1,
        int a2,
        unsigned int a3,
        unsigned int a4)
{
  int v9; // eax
  char v10; // bl
  __int64 v11; // [rsp+20h] [rbp-28h] BYREF
  __int64 (__fastcall *v12[4])(_QWORD); // [rsp+28h] [rbp-20h] BYREF

  v12[1] = (__int64 (__fastcall *)(_QWORD))-2LL;
  if ( a3 == 254 )
  {
    wil::details_abi::FeatureStateData::RecordUsage((RTL_SRWLOCK *)a1);
    return 1;
  }
  else if ( a3 < 0xC8 || (int)a3 >= 256 && a3 < 0x200 )
  {
    AcquireSRWLockExclusive((PSRWLOCK)a1);
    v12[0] = (__int64 (__fastcall *)(_QWORD))a1;
    if ( a3 <= 7 && (v9 = 204, _bittest(&v9, a3)) || a3 - 256 <= 0x7F )
    {
      wil::details_abi::UsageIndex<enum wil_details_ServiceReportingKind,unsigned int,0>::RecordUsage(
        (wil::details **)(a1 + 8),
        a3,
        a2);
      v10 = *(_BYTE *)(a1 + 64);
    }
    else
    {
      v10 = wil::details_abi::UsageIndex<enum wil_details_ServiceReportingKind,unsigned int,2>::RecordUsage(
              (wil::details **)(a1 + 72),
              a3,
              a2,
              a4);
    }
    if ( a1 )
    {
      v11 = a1;
      v12[0] = (__int64 (__fastcall *)(_QWORD))ReleaseSRWLockExclusive;
      wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>(v12, &v11);
    }
    return v10;
  }
  else
  {
    return 0;
  }
}
// 18005C5C8: using guessed type __int64 (__fastcall *var_20[4])(_QWORD);

//----- (000000018005C6C4) ----------------------------------------------------
void __fastcall wil::details::FeatureStateManager::RecordFeatureUsage(
        _BYTE *a1,
        int a2,
        unsigned int a3,
        unsigned int a4)
{
  wil *v8; // rcx
  struct _TP_TIMER *ThreadpoolTimer; // rax
  void (__stdcall *v10)(PSRWLOCK); // [rsp+20h] [rbp-18h] BYREF
  _BYTE *v11; // [rsp+40h] [rbp+8h] BYREF

  if ( *a1
    && wil::details::FeatureStateManager::EnsureStateData((RTL_SRWLOCK *)a1)
    && wil::details_abi::FeatureStateData::RecordFeatureUsage(*((_QWORD *)a1 + 3), a2, a3, a4)
    && !wil::ProcessShutdownInProgress(v8) )
  {
    AcquireSRWLockExclusive((PSRWLOCK)a1 + 4);
    if ( !a1[65] )
    {
      if ( !*((_QWORD *)a1 + 6) )
      {
        wil::last_error_context::last_error_context((wil::last_error_context *)&v11);
        ThreadpoolTimer = CreateThreadpoolTimer(
                            (PTP_TIMER_CALLBACK)lambda_d51448ba32f8ef42e59400edd4566183_::_lambda_invoker_cdecl_,
                            a1,
                            0LL);
        wil::details::unique_storage<wil::details::resource_policy<_TP_TIMER *,void (*)(_TP_TIMER *),&public: static void wil::details::DestroyThreadPoolTimer<wil::details::SystemThreadPoolMethods,0>::Destroy(_TP_TIMER *),wistd::integral_constant<unsigned __int64,0>,_TP_TIMER *,_TP_TIMER *,0,std::nullptr_t>>::reset(
          (struct _TP_TIMER **)a1 + 6,
          ThreadpoolTimer);
        wil::last_error_context::~last_error_context((wil::last_error_context *)&v11);
      }
      wil::details::EnsureCoalescedTimer_SetTimer((struct _TP_TIMER **)a1 + 6, a1 + 65, 300000LL);
    }
    if ( a1 != (_BYTE *)-32LL )
    {
      v10 = ReleaseSRWLockExclusive;
      v11 = a1 + 32;
      wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>((__int64 (__fastcall **)(_QWORD))&v10, &v11);
    }
  }
}
// 18005C712: variable 'v8' is possibly undefined

//----- (000000018005C7D0) ----------------------------------------------------
__int64 __fastcall wil::details::RecordLog(wil::details *this)
{
  `wil::details::RecordLog'::`2'::s_hrErrorLast = (int)this;
  return (unsigned int)_InterlockedIncrement(&`wil::details::RecordLog'::`2'::s_cErrorCount);
}
// 1800B09E4: using guessed type int `wil::details::RecordLog'::`2'::s_hrErrorLast;
// 1800B0B78: using guessed type int `wil::details::RecordLog'::`2'::s_cErrorCount;

//----- (000000018005C7F0) ----------------------------------------------------
__int64 __fastcall wil::details::RecordReturn(wil::details *this)
{
  `wil::details::RecordReturn'::`2'::s_hrErrorLast = (int)this;
  return (unsigned int)_InterlockedIncrement(&`wil::details::RecordReturn'::`2'::s_cErrorCount);
}
// 1800B09E0: using guessed type int `wil::details::RecordReturn'::`2'::s_hrErrorLast;
// 1800B0B84: using guessed type int `wil::details::RecordReturn'::`2'::s_cErrorCount;

//----- (000000018005C810) ----------------------------------------------------
void __fastcall wil::details::RecordSRUMFeatureUsage(wil::details *this)
{
  wil::details::WilApi_RecordFeatureUsage(this);
}

//----- (000000018005C824) ----------------------------------------------------
char __fastcall wil::details_abi::UsageIndex<enum wil_details_ServiceReportingKind,unsigned int,2>::RecordUsage(
        wil::details **a1,
        int a2,
        int a3,
        unsigned int a4)
{
  int v5; // [rsp+48h] [rbp+10h] BYREF
  int v6; // [rsp+50h] [rbp+18h] BYREF

  v6 = a3;
  v5 = a2;
  return wil::details_abi::RawUsageIndex::RecordUsage(a1, &v5, 4uLL, &v6, 4uLL, a4);
}

//----- (000000018005C85C) ----------------------------------------------------
char __fastcall wil::details_abi::UsageIndex<enum wil_details_ServiceReportingKind,unsigned int,0>::RecordUsage(
        wil::details **a1,
        int a2,
        int a3)
{
  int v4; // [rsp+48h] [rbp+10h] BYREF
  int v5; // [rsp+50h] [rbp+18h] BYREF

  v5 = a3;
  v4 = a2;
  return wil::details_abi::RawUsageIndex::RecordUsage(a1, &v4, 4uLL, &v5, 4uLL, 1u);
}

//----- (000000018005C894) ----------------------------------------------------
void __fastcall wil::details_abi::FeatureStateData::RecordUsage(RTL_SRWLOCK *this)
{
  __int64 v2; // rdx
  __int64 v3; // r8
  const struct wil::details_abi::RawUsageIndex *v4; // r9
  void *v5; // rdx
  char v6[200]; // [rsp+30h] [rbp-C8h] BYREF
  RTL_SRWLOCK *v7; // [rsp+100h] [rbp+8h] BYREF
  void (__stdcall *v8)(PSRWLOCK); // [rsp+108h] [rbp+10h] BYREF

  wil::details_abi::UsageIndexes::UsageIndexes((wil::details_abi::UsageIndexes *)v6);
  AcquireSRWLockExclusive(this);
  wil::details_abi::FeatureStateData::RetrieveUsageUnderLock(
    (wil::details_abi::FeatureStateData *)this,
    (struct wil::details_abi::UsageIndexes *)v6);
  if ( this )
  {
    v7 = this;
    v8 = ReleaseSRWLockExclusive;
    wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>((__int64 (__fastcall **)(_QWORD))&v8, &v7);
  }
  wil::details_abi::UsageIndexes::Record((wil::details_abi::UsageIndexes *)v6, v2, v3, v4);
  wil::details_abi::UsageIndexes::~UsageIndexes((wil::details_abi::UsageIndexes *)v6, v5);
}
// 18005C906: variable 'v2' is possibly undefined
// 18005C906: variable 'v3' is possibly undefined
// 18005C906: variable 'v4' is possibly undefined
// 18005C911: variable 'v5' is possibly undefined

//----- (000000018005C934) ----------------------------------------------------
char __fastcall wil::details_abi::RawUsageIndex::RecordUsage(
        wil::details **this,
        void *a2,
        size_t a3,
        void *a4,
        unsigned __int64 a5,
        unsigned int a6)
{
  unsigned __int64 v11; // rdx
  void *v12; // rdx
  wil::details *v13; // rdi
  wil::details *v14; // rcx
  void *v15[2]; // [rsp+38h] [rbp-40h] BYREF
  __int128 v16; // [rsp+48h] [rbp-30h]

  if ( wil::details_abi::RawUsageIndex::RecordUsageInternal((wil::details_abi::RawUsageIndex *)this, a2, a3, a4, a5, a6) )
    return 1;
  v11 = a3 + a5 + 32;
  if ( this[3] )
  {
    if ( *((_BYTE *)this + 58) )
      wil::details_abi::heap_buffer::ensure((wil::details_abi::heap_buffer *)(this + 3), v11);
  }
  else
  {
    *(_OWORD *)v15 = 0LL;
    v16 = 0LL;
    if ( wil::details_abi::heap_buffer::ensure((wil::details_abi::heap_buffer *)v15, v11 + 10) )
    {
      wil::details_abi::RawUsageIndex::SetBuffer(
        (wil::details_abi::RawUsageIndex *)this,
        (char *)v15[0],
        0LL,
        (const char *)(v16 - (unsigned __int64)v15[0]));
      v13 = 0LL;
      v14 = this[6];
      this[6] = (wil::details *)*((_QWORD *)&v16 + 1);
      if ( v14 )
        wil::details::FreeProcessHeap(v14, v12);
      *((_BYTE *)this + 58) = 1;
    }
    else
    {
      v13 = (wil::details *)*((_QWORD *)&v16 + 1);
    }
    if ( v13 )
      wil::details::FreeProcessHeap(v13, v12);
  }
  return wil::details_abi::RawUsageIndex::RecordUsageInternal(
           (wil::details_abi::RawUsageIndex *)this,
           a2,
           a3,
           a4,
           a5,
           a6);
}
// 18005C9EE: variable 'v12' is possibly undefined

//----- (000000018005CA68) ----------------------------------------------------
char __fastcall wil::details_abi::RawUsageIndex::RecordUsageInternal(
        wil::details_abi::RawUsageIndex *this,
        void *a2,
        size_t a3,
        void *a4,
        unsigned __int64 a5,
        unsigned int a6)
{
  __int64 v6; // rdi
  unsigned __int8 *v10; // rdi
  char v11; // r13
  bool v12; // al
  unsigned int v13; // r15d
  unsigned __int64 v14; // r12
  int v15; // eax
  void *v16; // rsi
  __int16 v18; // cx
  __int64 Size; // rax
  unsigned __int64 v20; // r9
  __int64 v21; // rdx
  unsigned __int64 v22; // rsi
  unsigned __int64 v23; // rdx
  char *v24; // r8
  const void *v25; // [rsp+30h] [rbp-40h] BYREF
  __int16 v26; // [rsp+38h] [rbp-38h]
  __int128 v27; // [rsp+40h] [rbp-30h]
  __int16 v28; // [rsp+50h] [rbp-20h] BYREF
  char v29; // [rsp+52h] [rbp-1Eh]
  unsigned int v30; // [rsp+54h] [rbp-1Ch]
  __int16 v31; // [rsp+58h] [rbp-18h]
  __int64 v32; // [rsp+60h] [rbp-10h]
  void *v33; // [rsp+68h] [rbp-8h]
  unsigned __int8 *InsertionPointOrIncrement; // [rsp+B0h] [rbp+40h] BYREF
  void *v35; // [rsp+C8h] [rbp+58h]

  v35 = a4;
  v6 = *((_QWORD *)this + 3);
  if ( !v6 )
    return 0;
  v10 = (unsigned __int8 *)(v6 + 10);
  LOWORD(v25) = *((_WORD *)this + 1);
  v11 = 0;
  BYTE2(v25) = *((_BYTE *)this + 4);
  InsertionPointOrIncrement = v10;
  HIDWORD(v25) = 0;
  v26 = 0;
  v27 = 0LL;
  while ( 1 )
  {
    v12 = wil::details_abi::UsageIndexProperty::Read(
            (wil::details_abi::UsageIndexProperty *)&v25,
            &InsertionPointOrIncrement,
            *((unsigned __int8 **)this + 4));
    v13 = a6;
    v14 = a5;
    if ( !v12 )
    {
      v10 = InsertionPointOrIncrement;
      *((_QWORD *)this + 4) = InsertionPointOrIncrement;
      goto LABEL_12;
    }
    v15 = wil::details_abi::UsageIndexProperty::Compare(&v25, a2, a3);
    if ( v15 < 0 )
    {
      InsertionPointOrIncrement = v10;
LABEL_12:
      *(_QWORD *)&v27 = 0LL;
      HIDWORD(v25) = 1;
      v26 = a3;
      *((_QWORD *)&v27 + 1) = a2;
      wil::details_abi::UsageIndexProperty::GetSize((wil::details_abi::UsageIndexProperty *)&v25);
      v16 = v35;
      goto LABEL_13;
    }
    if ( !v15 )
      break;
    v10 = wil::details_abi::RawUsageIndex::SkipValues(
            this,
            (struct wil::details_abi::UsageIndexProperty *)&v25,
            InsertionPointOrIncrement);
    InsertionPointOrIncrement = v10;
  }
  v16 = v35;
  InsertionPointOrIncrement = wil::details_abi::RawUsageIndex::FindInsertionPointOrIncrement(
                                this,
                                (struct wil::details_abi::UsageIndexProperty *)&v25,
                                InsertionPointOrIncrement,
                                v35,
                                v14,
                                v13);
  v10 = InsertionPointOrIncrement;
  if ( !InsertionPointOrIncrement )
    return 1;
  v11 = 1;
LABEL_13:
  v18 = *((_WORD *)this + 3);
  v32 = 0LL;
  v28 = v18;
  v29 = *((_BYTE *)this + 8);
  v30 = v13;
  v31 = v14;
  v33 = v16;
  Size = wil::details_abi::UsageIndexProperty::GetSize((wil::details_abi::UsageIndexProperty *)&v28);
  v20 = *((_QWORD *)this + 4);
  v22 = v21 + Size;
  v23 = *((_QWORD *)this + 5);
  if ( ((v23 - v20) & -(__int64)(v20 < v23)) >= v22 )
  {
    memmove_s(&v10[v22], v23 - v22 - (_QWORD)v10, v10, v20 - (_QWORD)v10);
    v24 = (char *)(v22 + *((_QWORD *)this + 4));
    *((_QWORD *)this + 4) = v24;
    if ( v11 )
    {
      if ( BYTE2(v25) )
        wil::details_abi::UsageIndexProperty::UpdateCount(
          (wil::details_abi::UsageIndexProperty *)&v25,
          HIDWORD(v25) + 1);
    }
    else
    {
      wil::details_abi::UsageIndexProperty::Write(
        (wil::details_abi::UsageIndexProperty *)&v25,
        (char **)&InsertionPointOrIncrement,
        v24);
    }
    wil::details_abi::UsageIndexProperty::Write(
      (wil::details_abi::UsageIndexProperty *)&v28,
      (char **)&InsertionPointOrIncrement,
      *((char **)this + 4));
    *((_BYTE *)this + 56) = 1;
    return 1;
  }
  return 0;
}
// 18005CB9E: variable 'v21' is possibly undefined

//----- (000000018005CC44) ----------------------------------------------------
void __fastcall wil::details_abi::RecordWnfUsageIndex(
        wil::details_abi *this,
        const struct __WIL__WNF_STATE_NAME *a2,
        __int64 a3,
        const struct wil::details_abi::RawUsageIndex *a4)
{
  wil::details_abi *v5; // rdi
  wil::details_abi *v6; // r15
  unsigned __int64 v7; // rsi
  __int64 v8; // rdx
  __int64 v9; // r8
  unsigned int WnfStateData; // ebx
  unsigned int v11; // eax
  void *v12; // rdx
  void *v13; // rdx
  char v14; // bl
  __int64 v15; // r9
  int updated; // eax
  __int64 v17; // r9
  wil::details *v18; // rcx
  wil::details *v19; // rcx
  int v20; // [rsp+20h] [rbp-E0h]
  int v21; // [rsp+20h] [rbp-E0h]
  int v22; // [rsp+40h] [rbp-C0h] BYREF
  unsigned int v23; // [rsp+48h] [rbp-B8h] BYREF
  __int64 v24; // [rsp+50h] [rbp-B0h] BYREF
  __int64 v25; // [rsp+58h] [rbp-A8h] BYREF
  __int128 v26; // [rsp+60h] [rbp-A0h]
  char *v27; // [rsp+70h] [rbp-90h]
  char v28[24]; // [rsp+80h] [rbp-80h] BYREF
  __int64 v29; // [rsp+98h] [rbp-68h]
  __int64 v30; // [rsp+A0h] [rbp-60h]
  wil::details *v31; // [rsp+B0h] [rbp-50h]
  char v32; // [rsp+B8h] [rbp-48h]
  char v33; // [rsp+B9h] [rbp-47h]
  __int64 v34; // [rsp+C0h] [rbp-40h]
  char v35[8]; // [rsp+C8h] [rbp-38h] BYREF
  void **v36; // [rsp+D0h] [rbp-30h] BYREF
  __int128 v37; // [rsp+D8h] [rbp-28h]
  char *v38; // [rsp+E8h] [rbp-18h]
  void ***v39; // [rsp+138h] [rbp+38h]
  char v40[4096]; // [rsp+140h] [rbp+40h] BYREF

  v34 = -2LL;
  v5 = this;
  v6 = (wil::details_abi *)((char *)this + 8 * (_QWORD)a2);
  v7 = 0LL;
  v25 = 0LL;
  while ( 1 )
  {
    wil::details_abi::RawUsageIndex::RawUsageIndex(
      (__int64)v28,
      *(_WORD *)a3,
      *(_WORD *)(a3 + 2),
      *(_BYTE *)(a3 + 4),
      *(_WORD *)(a3 + 6),
      *(_BYTE *)(a3 + 8));
    v23 = 4096;
    WnfStateData = wil_details_NtQueryWnfStateData((__int64)v5, v8, v9, (__int64)&v22, (__int64)v40, (__int64)&v23);
    wil::details::NtStatusToHr((wil::details *)WnfStateData);
    if ( WnfStateData )
    {
      v11 = 0;
      v23 = 0;
      v22 = 0;
    }
    else
    {
      v11 = v23;
    }
    wil::details_abi::RawUsageIndex::SetBuffer((wil::details_abi::RawUsageIndex *)v28, v40, v11, (const char *)0x1000);
    if ( v33 )
      break;
    v24 = 0LL;
    *(_QWORD *)&v26 = &v24;
    *((_QWORD *)&v26 + 1) = &v25;
    v27 = v28;
    v36 = &wistd::__function::__func<_lambda_8db0ce862824541f40dfb767113f1e28_,bool (void *,unsigned __int64,void *,unsigned __int64,unsigned int)>::`vftable';
    v37 = v26;
    v38 = v28;
    v39 = &v36;
    v14 = wil::details_abi::RawUsageIndex::Iterate(a3, (__int64)v35);
    if ( v32 )
    {
      updated = wil_details_NtUpdateWnfStateData((__int64)v5, v29, (int)v30 - (int)v29, v15, v20, v22, 1);
      if ( updated == -1073741823 )
      {
        ++v7;
        v14 = 0;
        goto LABEL_11;
      }
      if ( updated )
        wil_details_NtUpdateWnfStateData((__int64)v5, v29, v30 - v29, v17, v21, 0, 0);
    }
    v5 = (wil::details_abi *)((char *)v5 + 8);
    v25 = v24;
LABEL_11:
    v18 = v31;
    v31 = 0LL;
    if ( v18 )
      wil::details::FreeProcessHeap(v18, v13);
    if ( v14 || v5 >= v6 || v7 >= 0x32 )
      return;
  }
  v19 = v31;
  v31 = 0LL;
  if ( v19 )
    wil::details::FreeProcessHeap(v19, v12);
}
// 18005CCDF: variable 'v8' is possibly undefined
// 18005CCDF: variable 'v9' is possibly undefined
// 18005CD9D: variable 'v15' is possibly undefined
// 18005CD9D: variable 'v20' is possibly undefined
// 18005CDC5: variable 'v17' is possibly undefined
// 18005CDC5: variable 'v21' is possibly undefined
// 18005CDE6: variable 'v13' is possibly undefined
// 18005CE15: variable 'v12' is possibly undefined
// 180071718: using guessed type void *wistd::__function::__func<_lambda_8db0ce862824541f40dfb767113f1e28_,bool (void *,unsigned __int64,void *,unsigned __int64,unsigned int)>::`vftable';
// 18005CC44: using guessed type char var_10A8[8];

//----- (000000018005CE54) ----------------------------------------------------
__int64 __fastcall JobStore::RegFolderEntryCreate(
        JobStore *this,
        const unsigned __int16 *a2,
        const struct JobSecurity *a3)
{
  const unsigned __int16 *v6; // rdx
  char IsEnabled; // al
  HKEY v8; // rcx
  LSTATUS v9; // eax
  signed int v10; // ebx
  bool v11; // cc
  LPCWSTR lpSubKey[2]; // [rsp+50h] [rbp-30h] BYREF
  struct _SECURITY_ATTRIBUTES SecurityAttributes; // [rsp+60h] [rbp-20h] BYREF
  DWORD dwDisposition; // [rsp+A8h] [rbp+28h] BYREF
  HKEY phkResult; // [rsp+B8h] [rbp+38h] BYREF

  lpSubKey[1] = (LPCWSTR)-2LL;
  SecurityAttributes.nLength = 24;
  SecurityAttributes.lpSecurityDescriptor = tsched::StoreSecurity::g_pRestrictedKeySecurity;
  SecurityAttributes.bInheritHandle = 0;
  lpSubKey[0] = 0LL;
  ATL::CComBSTR::operator=(lpSubKey, L"TaskCache\\Tree\\");
  v6 = a2 + 1;
  if ( *a2 != 92 )
    v6 = a2;
  ATL::CComBSTR::operator+=(lpSubKey, v6);
  phkResult = 0LL;
  IsEnabled = wil::details::FeatureImpl<__WilFeatureTraits_Feature_2510298426>::__private_IsEnabled((__int64)&`wil::Feature<__WilFeatureTraits_Feature_2510298426>::GetImpl'::`2'::impl);
  v8 = (HKEY)*((_QWORD *)this + 2);
  if ( IsEnabled )
  {
    v9 = RegCreateKeyExW(v8, lpSubKey[0], 0, 0LL, 0, 0xF003Fu, &SecurityAttributes, &phkResult, &dwDisposition);
    v10 = v9;
    v11 = v9 <= 0;
    if ( !v9 )
    {
      if ( dwDisposition == 2 )
      {
        v10 = -2147024713;
      }
      else
      {
        v10 = JobSecurity::StreamOut(a3, phkResult);
        if ( v10 >= 0 )
          v10 = 0;
      }
      goto LABEL_15;
    }
    goto LABEL_11;
  }
  v9 = RegCreateKeyExW(v8, lpSubKey[0], 0, 0LL, 0, 0xF003Fu, &SecurityAttributes, &phkResult, 0LL);
  v10 = v9;
  v11 = v9 <= 0;
  if ( v9 )
  {
LABEL_11:
    if ( !v11 )
      v10 = (unsigned __int16)v9 | 0x80070000;
    goto LABEL_15;
  }
  v10 = JobSecurity::StreamOut(a3, phkResult);
  if ( v10 >= 0 )
    v10 = 0;
LABEL_15:
  wmi::AutoRegKey::~AutoRegKey((wmi::AutoRegKey *)&phkResult);
  ATL::CComBSTR::~CComBSTR((ATL::CComBSTR *)lpSubKey);
  return (unsigned int)v10;
}
// 18000A430: using guessed type __int64 __fastcall ATL::CComBSTR::operator=(_QWORD, _QWORD);
// 18000F738: using guessed type __int64 __fastcall ATL::CComBSTR::operator+=(_QWORD, _QWORD);

//----- (000000018005CFE8) ----------------------------------------------------
__int64 __fastcall JobStore::RegJobSecuritySet(HKEY *this, const unsigned __int16 *a2, struct JobSecurity *a3)
{
  int v4; // ebx
  HKEY v6; // [rsp+58h] [rbp+20h] BYREF

  v6 = 0LL;
  v4 = JobStore::RegTreeEntryOpen(this, a2, &v6);
  if ( v4 >= 0 )
  {
    v4 = JobSecurity::StreamOut(a3, v6);
    if ( v4 >= 0 )
      v4 = 0;
  }
  wmi::AutoRegKey::Close(&v6);
  return (unsigned int)v4;
}

//----- (000000018005D05C) ----------------------------------------------------
__int64 __fastcall JobStore::RegOpenTaskOverrideKey(
        JobStore *this,
        const unsigned __int16 *a2,
        REGSAM a3,
        int a4,
        HKEY *a5)
{
  unsigned int v8; // edi
  OLECHAR *v9; // rbx
  JobStore *v10; // rcx
  const WCHAR *v11; // rdx
  HKEY v12; // rcx
  LSTATUS v13; // eax
  BSTR v15[2]; // [rsp+50h] [rbp-28h] BYREF
  HKEY phkResult; // [rsp+80h] [rbp+8h] BYREF

  v15[1] = (BSTR)-2LL;
  v8 = 0;
  v9 = 0LL;
  v15[0] = 0LL;
  if ( *((_QWORD *)this + 3) )
  {
    ATL::CComBSTR::operator=(v15, a2);
    v9 = v15[0];
    JobStore::ReverseSlashesInString(v10, v15[0]);
    v12 = (HKEY)*((_QWORD *)this + 3);
    if ( a4 == 1 )
    {
      v13 = RegCreateKeyExW(v12, v11, 0, 0LL, 0, a3, 0LL, &phkResult, 0LL);
    }
    else
    {
      v13 = RegOpenKeyExW(v12, v11, 0, a3, &phkResult);
      if ( v13 == 161 || v13 == 2 )
      {
        phkResult = 0LL;
        goto LABEL_13;
      }
    }
    if ( v13 )
    {
      if ( v13 > 0 )
        v8 = (unsigned __int16)v13 | 0x80070000;
      else
        v8 = v13;
    }
    else
    {
      *a5 = phkResult;
    }
  }
  else
  {
    *a5 = 0LL;
  }
LABEL_13:
  SysFreeString(v9);
  return v8;
}
// 18005D0B0: variable 'v10' is possibly undefined
// 18005D0E4: variable 'v11' is possibly undefined
// 18005D05C: using guessed type BSTR var_28[2];

//----- (000000018005D180) ----------------------------------------------------
__int64 __fastcall JobStore::RegTaskEntryCreate(
        HKEY *this,
        const struct JobMoniker *a2,
        const struct JobSecurity *a3,
        const struct Triggers::Trigulator *a4,
        const struct Actions::ActionCollection *a5,
        BYTE *lpData)
{
  TSTimePeriod *Periodicity; // rax
  BOOL IsEmpty; // ecx
  int v12; // eax
  int v13; // edi
  HKEY v14; // rbx
  HKEY hKey[2]; // [rsp+30h] [rbp-28h] BYREF
  char v17[24]; // [rsp+40h] [rbp-18h] BYREF
  int v18; // [rsp+68h] [rbp+10h] BYREF
  int v19; // [rsp+6Ch] [rbp+14h]

  hKey[1] = HKEY_DYN_DATA|0x7FFFFFF8LL;
  hKey[0] = 0LL;
  v19 = 0;
  if ( Triggers::Trigulator::HasTrigger((__int64)a4, 0xFFFF) )
    v18 = 1;
  else
    v18 = 3 - (Triggers::Trigulator::HasTrigger((__int64)a4, 43690) != 0);
  Periodicity = (TSTimePeriod *)JobBucket::GetPeriodicity(*((_QWORD *)a2 + 4), (__int64)v17);
  IsEmpty = TSTimePeriod::IsEmpty(Periodicity);
  v12 = v19;
  if ( !IsEmpty )
    v12 = 4;
  v19 = v12;
  v13 = JobStore::RegTaskEntryKeyCreate(
          this,
          (GUID *)a2,
          a3,
          (const enum JobStore::TaskIndex *)&v18,
          !IsEmpty + 1,
          hKey);
  if ( v13 >= 0 )
  {
    v14 = hKey[0];
    v13 = Triggers::Trigulator::StreamOut(a4, hKey[0]);
    if ( v13 >= 0 )
    {
      v13 = Actions::ActionCollection::StreamOut(a5, v14);
      if ( v13 >= 0 )
      {
        if ( lpData )
          DynamicTaskInfo::StreamOut(lpData, v14);
      }
    }
  }
  wmi::AutoRegKey::Close(hKey);
  return (unsigned int)v13;
}
// 18005D180: using guessed type char var_18[24];
// 18005D180: using guessed type HKEY hKey[2];

//----- (000000018005D2B4) ----------------------------------------------------
__int64 __fastcall JobStore::RegTaskEntryKeyCreate(
        HKEY *this,
        GUID *a2,
        const struct JobSecurity *a3,
        const enum JobStore::TaskIndex *a4,
        int a5,
        HKEY *a6)
{
  OLECHAR *v9; // rbx
  __int64 v10; // rcx
  int v11; // edi
  const unsigned __int16 *lpData; // r14
  const unsigned __int16 *v13; // rdx
  LSTATUS v14; // eax
  const unsigned __int16 *Path; // rax
  unsigned __int16 v16; // dx
  const wchar_t *v17; // r9
  LSTATUS v18; // eax
  const BYTE *v19; // r12
  LSTATUS v20; // eax
  const wchar_t *v21; // rax
  LSTATUS v22; // eax
  const unsigned __int16 *v23; // rax
  LSTATUS v24; // eax
  LSTATUS v25; // eax
  __int64 v26; // rsi
  HKEY v27; // rax
  LPCWSTR v29; // [rsp+50h] [rbp-B0h] BYREF
  HKEY phkResult; // [rsp+58h] [rbp-A8h] BYREF
  HKEY hKey; // [rsp+60h] [rbp-A0h] BYREF
  DWORD dwDisposition; // [rsp+68h] [rbp-98h] BYREF
  LPCWSTR lpSubKey; // [rsp+70h] [rbp-90h] BYREF
  unsigned __int64 v34; // [rsp+78h] [rbp-88h] BYREF
  DWORD dwOptions[2]; // [rsp+80h] [rbp-80h]
  struct _SECURITY_ATTRIBUTES SecurityAttributes; // [rsp+88h] [rbp-78h] BYREF
  __int64 v37; // [rsp+A0h] [rbp-60h]
  GUID rguid; // [rsp+A8h] [rbp-58h] BYREF
  OLECHAR sz[40]; // [rsp+C0h] [rbp-40h] BYREF

  v37 = -2LL;
  *(_QWORD *)dwOptions = a4;
  hKey = 0LL;
  phkResult = 0LL;
  v9 = 0LL;
  lpSubKey = 0LL;
  v29 = 0LL;
  SecurityAttributes.nLength = 24;
  SecurityAttributes.lpSecurityDescriptor = tsched::StoreSecurity::g_pRestrictedKeySecurity;
  SecurityAttributes.bInheritHandle = 0;
  rguid = *a2;
  v10 = *(_QWORD *)&GUID_NULL.Data1 - *(_QWORD *)&rguid.Data1;
  if ( *(_QWORD *)&GUID_NULL.Data1 == *(_QWORD *)&rguid.Data1 )
    v10 = *(_QWORD *)GUID_NULL.Data4 - *(_QWORD *)rguid.Data4;
  if ( !v10 )
  {
    v11 = -2147024809;
    goto LABEL_67;
  }
  memset_0(sz, 0, sizeof(sz));
  if ( !StringFromGUID2(&rguid, sz, 40) )
  {
    v11 = -2147024774;
    goto LABEL_67;
  }
  ATL::CComBSTR::operator=((BSTR *)&v29, L"TaskCache\\Tasks\\");
  ATL::CComBSTR::operator+=((const void **)&v29, sz);
  v34 = 0LL;
  lpData = JobMoniker::GetPath((JobMoniker *)a2);
  v11 = StringCchLengthW(lpData, 0x104uLL, &v34);
  if ( v11 < 0 )
    goto LABEL_67;
  ATL::CComBSTR::operator=((BSTR *)&lpSubKey, L"TaskCache\\Tree\\");
  v13 = lpData + 1;
  if ( *lpData != 92 )
    v13 = lpData;
  ATL::CComBSTR::operator+=((const void **)&lpSubKey, v13);
  v9 = (OLECHAR *)lpSubKey;
  v14 = RegCreateKeyExW(this[2], lpSubKey, 0, 0LL, 0, 0xF003Fu, &SecurityAttributes, &hKey, 0LL);
  v11 = v14;
  if ( v14 )
  {
    if ( v14 > 0 )
      v11 = (unsigned __int16)v14 | 0x80070000;
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      Path = JobMoniker::GetPath((JobMoniker *)a2);
      v16 = 37;
      v17 = v9;
LABEL_59:
      WPP_SF_SSD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        v16,
        (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
        v17,
        (__int64)Path);
    }
  }
  else
  {
    v11 = JobSecurity::StreamOut(a3, hKey);
    if ( v11 < 0 )
      goto LABEL_67;
    v18 = RegSetValueExW(hKey, L"Id", 0, 1u, (const BYTE *)sz, 0x50u);
    v11 = v18;
    if ( v18 )
    {
      if ( v18 > 0 )
        v11 = (unsigned __int16)v18 | 0x80070000;
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        Path = JobMoniker::GetPath((JobMoniker *)a2);
        v16 = 38;
        v17 = L"Id";
        goto LABEL_59;
      }
    }
    else
    {
      v19 = *(const BYTE **)dwOptions;
      v20 = RegSetValueExW(hKey, L"Index", 0, 4u, *(const BYTE **)dwOptions, 4u);
      v11 = v20;
      if ( v20 )
      {
        if ( v20 > 0 )
          v11 = (unsigned __int16)v20 | 0x80070000;
        if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
          && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
          && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
        {
          v21 = JobMoniker::GetPath((JobMoniker *)a2);
          WPP_SF_SD(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x27u,
            (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
            v21);
        }
      }
      else
      {
        v22 = RegCreateKeyExW(this[2], v29, 0, 0LL, 0, 0xF003Fu, &SecurityAttributes, &phkResult, &dwDisposition);
        v11 = v22;
        if ( v22 )
        {
          if ( v22 > 0 )
            v11 = (unsigned __int16)v22 | 0x80070000;
          if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
            && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
            && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
          {
            Path = JobMoniker::GetPath((JobMoniker *)a2);
            v16 = 40;
            v17 = v29;
            goto LABEL_59;
          }
        }
        else if ( dwDisposition == 1 )
        {
          v24 = RegSetValueExW(phkResult, L"Path", 0, 1u, (const BYTE *)lpData, 2 * v34 + 2);
          v11 = v24;
          if ( v24 )
          {
            if ( v24 > 0 )
              v11 = (unsigned __int16)v24 | 0x80070000;
            if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
              && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
              && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
            {
              Path = JobMoniker::GetPath((JobMoniker *)a2);
              v16 = 42;
              v17 = L"Path";
              goto LABEL_59;
            }
          }
          else
          {
            v25 = RegSetValueExW(
                    phkResult,
                    L"Hash",
                    0,
                    3u,
                    (const BYTE *)((*(_QWORD *)&a2[2].Data1 + 28LL) & -(__int64)(*(_DWORD *)(*(_QWORD *)&a2[2].Data1
                                                                                           + 60LL) != 0)),
                    0x20u);
            v11 = v25;
            if ( v25 )
            {
              if ( v25 > 0 )
                v11 = (unsigned __int16)v25 | 0x80070000;
              if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
                && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
                && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
              {
                Path = JobMoniker::GetPath((JobMoniker *)a2);
                v16 = 43;
                v17 = L"Hash";
                goto LABEL_59;
              }
            }
            else if ( a5 <= 0 )
            {
LABEL_64:
              if ( a6 )
              {
                v27 = phkResult;
                phkResult = 0LL;
                *a6 = v27;
              }
              v11 = 0;
            }
            else
            {
              v26 = 0LL;
              while ( 1 )
              {
                v11 = JobStore::CreateIndexEntryP((__int64)this, *(_DWORD *)&v19[4 * v26], sz, &SecurityAttributes);
                if ( v11 < 0 )
                  break;
                if ( ++v26 >= a5 )
                  goto LABEL_64;
              }
            }
          }
        }
        else
        {
          if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
            && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
            && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
          {
            v23 = JobMoniker::GetPath((JobMoniker *)a2);
            WPP_SF_SSD(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              0x29u,
              (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
              v29,
              (__int64)v23);
          }
          v11 = -2147024713;
        }
      }
    }
  }
LABEL_67:
  SysFreeString((BSTR)v29);
  SysFreeString(v9);
  wmi::AutoRegKey::Close(&phkResult);
  wmi::AutoRegKey::Close(&hKey);
  return (unsigned int)v11;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018005D8F4) ----------------------------------------------------
__int64 __fastcall PlugIn::RegisterTask(
        PlugIn *this,
        const unsigned __int16 *a2,
        const unsigned __int16 *a3,
        const unsigned __int16 *a4,
        unsigned int a5,
        unsigned __int16 *a6)
{
  __int64 (__fastcall *v6)(const unsigned __int16 *, const unsigned __int16 *, const unsigned __int16 *, _QWORD, unsigned __int16 *); // rax

  v6 = (__int64 (__fastcall *)(const unsigned __int16 *, const unsigned __int16 *, const unsigned __int16 *, _QWORD, unsigned __int16 *))*((_QWORD *)this + 9);
  if ( v6 )
    return v6(a2, a3, a4, a5, a6);
  else
    return 1LL;
}

//----- (000000018005D940) ----------------------------------------------------
__int64 __fastcall wil::details_abi::ProcessLocalStorageData<wil::details_abi::ProcessLocalData>::Release(
        HANDLE *lpMem)
{
  __int64 result; // rax
  HANDLE ProcessHeap; // rax
  __int64 v5; // [rsp+48h] [rbp+10h] BYREF
  __int64 v6; // [rsp+50h] [rbp+18h] BYREF
  void (__fastcall *v7)(wil::details *, void *); // [rsp+58h] [rbp+20h] BYREF

  if ( wil::ProcessShutdownInProgress((wil *)lpMem) )
  {
    result = (unsigned int)(*(_DWORD *)lpMem - 1);
    *(_DWORD *)lpMem = result;
  }
  else
  {
    wil::mutex_t<wil::details::unique_storage<wil::details::resource_policy<void *,void (*)(void *),&void wil::details::CloseHandle(void *),wistd::integral_constant<unsigned __int64,0>,void *,void *,0,std::nullptr_t>>,wil::err_returncode_policy>::acquire(
      lpMem + 1,
      &v5);
    if ( (*(_DWORD *)lpMem)-- == 1 )
    {
      wil::details_abi::SemaphoreValue::Destroy((wil::details_abi::SemaphoreValue *)(lpMem + 2));
      wil::details::unique_storage<wil::details::resource_policy<void *,void (*)(void *),&void wil::details::ReleaseMutex(void *),wistd::integral_constant<unsigned __int64,2>,void *,void *,0,std::nullptr_t>>::reset(
        &v5,
        0LL);
      wil::details_abi::ProcessLocalStorageData<wil::details_abi::ProcessLocalData>::~ProcessLocalStorageData<wil::details_abi::ProcessLocalData>(lpMem);
      ProcessHeap = GetProcessHeap();
      HeapFree(ProcessHeap, 0, lpMem);
    }
    result = v5;
    if ( v5 )
    {
      v6 = v5;
      v7 = wil::details::ReleaseMutex;
      return wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>((__int64 (__fastcall **)(_QWORD))&v7, &v6);
    }
  }
  return result;
}

//----- (000000018005D9E8) ----------------------------------------------------
void __fastcall wil::details_abi::ProcessLocalStorageData<wil::details_abi::FeatureStateData>::Release(HANDLE *lpMem)
{
  bool v2; // zf
  HANDLE ProcessHeap; // rax
  __int64 v4; // [rsp+48h] [rbp+10h] BYREF
  __int64 v5; // [rsp+50h] [rbp+18h] BYREF
  void (__fastcall *v6)(wil::details *, void *); // [rsp+58h] [rbp+20h] BYREF

  if ( wil::ProcessShutdownInProgress((wil *)lpMem) )
  {
    v2 = (*(_DWORD *)lpMem)-- == 1;
    if ( v2 )
      wil::details_abi::FeatureStateData::ProcessShutdown((wil::details_abi::FeatureStateData *)(lpMem + 4));
  }
  else
  {
    wil::mutex_t<wil::details::unique_storage<wil::details::resource_policy<void *,void (*)(void *),&void wil::details::CloseHandle(void *),wistd::integral_constant<unsigned __int64,0>,void *,void *,0,std::nullptr_t>>,wil::err_returncode_policy>::acquire(
      lpMem + 1,
      &v4);
    v2 = (*(_DWORD *)lpMem)-- == 1;
    if ( v2 )
    {
      wil::details_abi::SemaphoreValue::Destroy((wil::details_abi::SemaphoreValue *)(lpMem + 2));
      wil::details::unique_storage<wil::details::resource_policy<void *,void (*)(void *),&void wil::details::ReleaseMutex(void *),wistd::integral_constant<unsigned __int64,2>,void *,void *,0,std::nullptr_t>>::reset(
        &v4,
        0LL);
      wil::details_abi::ProcessLocalStorageData<wil::details_abi::FeatureStateData>::~ProcessLocalStorageData<wil::details_abi::FeatureStateData>((__int64)lpMem);
      ProcessHeap = GetProcessHeap();
      HeapFree(ProcessHeap, 0, lpMem);
    }
    if ( v4 )
    {
      v5 = v4;
      v6 = wil::details::ReleaseMutex;
      wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>((__int64 (__fastcall **)(_QWORD))&v6, &v5);
    }
  }
}

//----- (000000018005DAA0) ----------------------------------------------------
void __fastcall wil::details::ReleaseMutex(wil::details *this, void *a2)
{
  __int64 v2; // r8
  const char *v3; // r9
  wil::details::in1diag3 *retaddr; // [rsp+28h] [rbp+0h]

  if ( !ReleaseMutex(this) )
  {
    wil::details::in1diag3::_FailFast_GetLastError(retaddr, (void *)0x930, v2, v3);
    __debugbreak();
  }
}
// 18005DABE: variable 'v2' is possibly undefined
// 18005DABE: variable 'v3' is possibly undefined

//----- (000000018005DAD0) ----------------------------------------------------
void __fastcall ATL::CDacl::RemoveAce(ATL::CDacl *this, unsigned int a2)
{
  ATL::CAtlArray<ATL::CAutoPtr<ATL::CDacl::CAccessAce>,ATL::CAutoPtrElementTraits<ATL::CDacl::CAccessAce>>::RemoveAt(
    (_QWORD *)this + 3,
    a2);
}

//----- (000000018005DAE4) ----------------------------------------------------
int __fastcall ATL::CAtlArray<ATL::CAutoPtr<ATL::CDacl::CAccessAce>,ATL::CAutoPtrElementTraits<ATL::CDacl::CAccessAce>>::RemoveAt(
        _QWORD *a1,
        unsigned __int64 a2)
{
  unsigned __int64 v2; // rdi
  unsigned __int64 v5; // rbp
  int result; // eax
  unsigned __int64 v7; // rbp

  v2 = a2 + 1;
  if ( a2 + 1 < a2 )
    goto LABEL_13;
  if ( a2 == -1LL )
    goto LABEL_13;
  v5 = a1[1];
  if ( v2 > v5 )
    goto LABEL_13;
  result = ATL::CAtlArray<ATL::CAutoPtr<ATL::CDacl::CAccessAce>,ATL::CAutoPtrElementTraits<ATL::CDacl::CAccessAce>>::CallDestructors(
             (__int64 (__fastcall ****)(_QWORD, __int64))(*a1 + 8 * a2),
             1LL);
  v7 = v5 - v2;
  if ( !v7 )
    goto LABEL_12;
  result = memmove_s((void *const)(*a1 + 8 * a2), 8 * v7, (const void *const)(*a1 + 8 * v2), 8 * v7);
  switch ( result )
  {
    case 0:
      goto LABEL_12;
    case 12:
      ATL::PrivateAtlThrow(-2147024882);
    case 22:
    case 34:
LABEL_13:
      ATL::PrivateAtlThrow(-2147024809);
  }
  if ( result != 80 )
    ATL::PrivateAtlThrow(-2147467259);
LABEL_12:
  --a1[1];
  return result;
}

//----- (000000018005DBB0) ----------------------------------------------------
__int64 __fastcall JobStore::RemoveMigratedUbpmStatsFile(JobStore *this, UUID *a2)
{
  JobStore *v3; // rcx
  int UbpmStatsFileName; // ebx
  tsched *v5; // rcx
  const wchar_t *Path; // rax
  WCHAR FileName[264]; // [rsp+30h] [rbp-228h] BYREF

  memset_0(FileName, 0, 0x208uLL);
  UbpmStatsFileName = JobStore::GetUbpmStatsFileName(v3, a2, FileName);
  if ( UbpmStatsFileName >= 0 && !DeleteFileW(FileName) )
  {
    UbpmStatsFileName = tsched::GetLastHrError(v5);
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      Path = JobMoniker::GetPath((JobMoniker *)a2);
      WPP_SF_SD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x71u,
        (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
        Path);
    }
  }
  return (unsigned int)UbpmStatsFileName;
}
// 18005DBEC: variable 'v3' is possibly undefined
// 18005DC0C: variable 'v5' is possibly undefined
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018005DC8C) ----------------------------------------------------
LSTATUS __fastcall JobStore::RemoveTaskEntry(HKEY *this, const struct JobMoniker *a2)
{
  LSTATUS result; // eax
  JobStore *v4; // rcx

  result = JobStore::RemoveTaskEntryP((__int64)this, a2, 0);
  if ( result >= 0 )
    return JobStore::FlushTaskEntryP(v4, this[2]);
  return result;
}
// 18005DCA5: variable 'v4' is possibly undefined

//----- (000000018005DCB8) ----------------------------------------------------
__int64 __fastcall JobStore::RemoveTaskEntryP(__int64 a1, JobMoniker *a2, int a3)
{
  HKEY *v5; // r15
  int v6; // r14d
  int v7; // r12d
  const unsigned __int16 *Path; // rbx
  OLECHAR *v9; // rdi
  int v10; // r9d
  int TaskIdWithRecovery; // eax
  unsigned int v12; // esi
  WCHAR *v13; // rbx
  HKEY v14; // r8
  int i; // r15d
  int v16; // eax
  int v17; // eax
  int v18; // r12d
  LSTATUS v19; // eax
  const wchar_t *v20; // rax
  unsigned __int16 v21; // dx
  LSTATUS v22; // eax
  const unsigned __int16 *v23; // rax
  unsigned __int16 v24; // dx
  OLECHAR *v25; // r9
  HKEY *p_hKey; // rcx
  LSTATUS v27; // eax
  LSTATUS v28; // eax
  HKEY *p_Data; // rcx
  wchar_t *v30; // r15
  LSTATUS v31; // eax
  const wchar_t *v32; // rax
  LSTATUS v33; // eax
  const unsigned __int16 *v34; // rax
  __int64 v35; // r15
  const OLECHAR *v36; // rax
  JobStore *v37; // rcx
  LPCWSTR v38; // rdx
  LSTATUS v39; // eax
  const wchar_t *v40; // rax
  HKEY hKey; // [rsp+38h] [rbp-89h] BYREF
  HKEY Data; // [rsp+40h] [rbp-81h] BYREF
  int v44; // [rsp+48h] [rbp-79h] BYREF
  HKEY *v45; // [rsp+50h] [rbp-71h]
  LPCWSTR lpSubKey; // [rsp+58h] [rbp-69h] BYREF
  unsigned __int16 *v47[2]; // [rsp+60h] [rbp-61h] BYREF
  GUID rguid; // [rsp+70h] [rbp-51h] BYREF
  OLECHAR sz[40]; // [rsp+88h] [rbp-39h] BYREF

  v47[1] = (unsigned __int16 *)-2LL;
  LODWORD(Data) = a3;
  v5 = (HKEY *)a1;
  v45 = (HKEY *)a1;
  v6 = 1;
  v7 = 1;
  rguid = 0LL;
  Path = JobMoniker::GetPath(a2);
  v9 = 0LL;
  v44 = 0;
  ATL::CComBSTR::CComBSTR((ATL::CComBSTR *)&lpSubKey, L"TaskCache\\Tree\\");
  v47[0] = 0LL;
  if ( *Path == 92 )
    ++Path;
  ATL::CComBSTR::operator+=((const void **)&lpSubKey, Path);
  LODWORD(hKey) = 1;
  v10 = 2;
  if ( a3 != 2 )
    v10 = 0;
  TaskIdWithRecovery = JobStore::RegGetTaskIdWithRecovery(v5, a2, &rguid, v10, &v44);
  v12 = TaskIdWithRecovery;
  v13 = (WCHAR *)lpSubKey;
  if ( TaskIdWithRecovery >= 0 )
  {
    if ( !StringFromGUID2(&rguid, sz, 40) )
    {
      v12 = -2147024774;
      goto LABEL_108;
    }
    for ( i = 1; i < 5; ++i )
    {
      v16 = JobStore::RemoveIndexEntryP((__int64)v45, i, sz);
      v12 = v16;
      v14 = 0LL;
      if ( v16 >= 0 )
      {
        if ( v44 == i )
          v6 = 0;
        if ( (unsigned int)(i - 1) <= 2 )
          v7 = 0;
      }
      else if ( !tsched::IsErrorNotFound((tsched *)(unsigned int)v16) )
      {
        goto LABEL_108;
      }
    }
    v5 = v45;
  }
  else
  {
    if ( !tsched::IsErrorNotFound((tsched *)(unsigned int)TaskIdWithRecovery) )
      goto LABEL_108;
    LODWORD(hKey) = (_DWORD)v14;
  }
  if ( (_DWORD)Data == 2 )
  {
    if ( v7 )
      v7 = v6;
    v6 = v7;
    if ( v44 == (_DWORD)v14 )
    {
      v17 = JobStore::FileRemoveTaskXml((JobStore *)v5, a2);
      v12 = v17;
      v14 = 0LL;
      if ( v17 >= 0 )
      {
        v6 = 0;
      }
      else if ( !tsched::IsErrorNotFound((tsched *)(unsigned int)v17) )
      {
        goto LABEL_108;
      }
    }
  }
  v18 = (int)hKey;
  if ( (_DWORD)hKey )
  {
    hKey = v14;
    v19 = RegOpenKeyExW(v5[2], L"TaskCache\\Tasks", 0, 0x20019u, &hKey);
    if ( v19 )
    {
      if ( v19 > 0 )
        v12 = (unsigned __int16)v19 | 0x80070000;
      else
        v12 = v19;
      if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
        || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) == 0
        || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
      {
        goto LABEL_48;
      }
      v20 = JobMoniker::GetPath(a2);
      v21 = 51;
      goto LABEL_37;
    }
    v22 = RegDeleteKeyExW(hKey, sz, 0, 0);
    if ( v22 )
    {
      if ( v22 != 2 )
      {
        if ( v22 > 0 )
          v12 = (unsigned __int16)v22 | 0x80070000;
        else
          v12 = v22;
        if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
          || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) == 0
          || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
        {
          goto LABEL_48;
        }
        v23 = JobMoniker::GetPath(a2);
        v24 = 52;
        v25 = sz;
        goto LABEL_47;
      }
    }
    else
    {
      v6 = 0;
    }
    wmi::AutoRegKey::Close(&hKey);
    v14 = 0LL;
  }
  if ( (_DWORD)Data == 1 )
  {
    LODWORD(Data) = (_DWORD)v14;
    hKey = v14;
    v27 = RegOpenKeyExW(v5[2], v13, 0, 2u, &hKey);
    if ( v27 )
    {
      if ( v27 > 0 )
        v12 = (unsigned __int16)v27 | 0x80070000;
      else
        v12 = v27;
      if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
        || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) == 0
        || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
      {
        goto LABEL_48;
      }
      v23 = JobMoniker::GetPath(a2);
      v24 = 53;
      v25 = v13;
LABEL_47:
      WPP_SF_SSD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        v24,
        (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
        v25,
        (__int64)v23);
      goto LABEL_48;
    }
    v28 = RegSetValueExW(hKey, L"Index", 0, 4u, (const BYTE *)&Data, 4u);
    if ( v28 )
    {
      if ( v28 > 0 )
        v12 = (unsigned __int16)v28 | 0x80070000;
      else
        v12 = v28;
      if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
        || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) == 0
        || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
      {
        goto LABEL_48;
      }
      v20 = JobMoniker::GetPath(a2);
      v21 = 54;
LABEL_37:
      WPP_SF_SD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        v21,
        (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
        v20);
LABEL_48:
      p_hKey = &hKey;
LABEL_49:
      wmi::AutoRegKey::Close(p_hKey);
      goto LABEL_108;
    }
    p_Data = &hKey;
    goto LABEL_96;
  }
  if ( !(_DWORD)Data )
  {
    v30 = wcsrchr(v13, 0x5Cu);
    if ( !v30 )
    {
      v12 = -2147418113;
      goto LABEL_108;
    }
    *v30 = 0;
    Data = 0LL;
    v31 = RegOpenKeyExW(v45[2], v13, 0, 0x20019u, &Data);
    if ( v31 )
    {
      if ( v31 != 2 )
      {
        if ( v31 > 0 )
          v12 = (unsigned __int16)v31 | 0x80070000;
        else
          v12 = v31;
        if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
          && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
          && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
        {
          v32 = JobMoniker::GetPath(a2);
          WPP_SF_SD(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x37u,
            (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
            v32);
        }
LABEL_93:
        p_hKey = &Data;
        goto LABEL_49;
      }
    }
    else
    {
      v6 = 0;
    }
    if ( Data )
    {
      v33 = RegDeleteKeyExW(Data, v30 + 1, 0, 0);
      if ( v33 )
      {
        if ( v33 != 2 )
        {
          if ( v33 > 0 )
            v12 = (unsigned __int16)v33 | 0x80070000;
          else
            v12 = v33;
          if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
            && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
            && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
          {
            v34 = JobMoniker::GetPath(a2);
            WPP_SF_SSD(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              0x38u,
              (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
              v30 + 1,
              (__int64)v34);
          }
          goto LABEL_93;
        }
      }
      else
      {
        v6 = 0;
      }
    }
    p_Data = &Data;
LABEL_96:
    wmi::AutoRegKey::Close(p_Data);
    v14 = 0LL;
  }
  v35 = (__int64)v45;
  if ( v45[3] != v14 )
  {
    v36 = JobMoniker::GetPath(a2);
    ATL::CComBSTR::operator=(v47, v36);
    v9 = v47[0];
    JobStore::ReverseSlashesInString(v37, v47[0]);
    v39 = RegDeleteKeyExW(*(HKEY *)(v35 + 24), v38, 0, 0);
    LODWORD(v14) = 0;
    if ( v39 == 2 )
      v39 = 0;
    if ( v39
      && WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      v40 = JobMoniker::GetPath(a2);
      WPP_SF_SD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x39u,
        (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
        v40);
      LODWORD(v14) = 0;
    }
  }
  if ( !v18 || (v12 = (unsigned int)v14, v6) )
    v12 = -2147024894;
LABEL_108:
  SysFreeString(v9);
  SysFreeString(v13);
  return v12;
}
// 18005DD9C: variable 'v14' is possibly undefined
// 18005E28B: variable 'v37' is possibly undefined
// 18005E29A: variable 'v38' is possibly undefined
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018005E380) ----------------------------------------------------
__int64 __fastcall JobStore::RemoveTaskFolderEntry(HKEY *this, const unsigned __int16 *a2)
{
  wchar_t *v4; // rax
  const WCHAR *v5; // rsi
  int v6; // eax
  unsigned int v7; // edi
  _QWORD *v8; // rcx
  unsigned __int16 v9; // dx
  LSTATUS v10; // eax
  HKEY hKey; // [rsp+70h] [rbp+18h] BYREF
  wchar_t *Str; // [rsp+78h] [rbp+20h] BYREF

  ATL::CComBSTR::CComBSTR((ATL::CComBSTR *)&Str, a2);
  v4 = wcsrchr(Str, 0x5Cu);
  v5 = v4;
  if ( v4 )
  {
    *v4 = 0;
    v5 = v4 + 1;
  }
  hKey = 0LL;
  v6 = JobStore::RegTreeEntryOpen(this, Str, &hKey);
  v7 = v6;
  if ( v6 >= 0 )
  {
    v10 = RegDeleteKeyExW(hKey, v5, 0x20006u, 0);
    if ( !v10 )
    {
      v7 = 0;
      goto LABEL_20;
    }
    if ( v10 > 0 )
      v7 = (unsigned __int16)v10 | 0x80070000;
    else
      v7 = v10;
    if ( !tsched::IsErrorNotFound((tsched *)v7) )
    {
      v8 = WPP_GLOBAL_Control;
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        v9 = 33;
        goto LABEL_18;
      }
    }
  }
  else if ( !tsched::IsErrorNotFound((tsched *)(unsigned int)v6) )
  {
    v8 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      v9 = 32;
LABEL_18:
      WPP_SF_SD(v8[2], v9, (__int64)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids, a2);
    }
  }
LABEL_20:
  wmi::AutoRegKey::Close(&hKey);
  SysFreeString(Str);
  return v7;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018005E508) ----------------------------------------------------
__int64 __fastcall JobStore::RemoveTaskOrFolder(JobStore *this, unsigned __int16 *a2, int *a3, struct JobMoniker *a4)
{
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
  {
    WPP_SF_S(*((_QWORD *)WPP_GLOBAL_Control + 2), 77LL, &WPP_0fa9442aab3237762f9b607a66102705_Traceguids, a2);
  }
  return JobStore::RemoveTaskOrFolderP(this, a2, 1, 1, 0, a3, a4);
}
// 18004ED5C: using guessed type __int64 __fastcall WPP_SF_S(_QWORD, _QWORD, _QWORD, _QWORD);
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018005E5A4) ----------------------------------------------------
__int64 __fastcall JobStore::RemoveTaskOrFolderP(
        JobStore *this,
        unsigned __int16 *a2,
        int a3,
        int a4,
        int a5,
        int *a6,
        struct JobMoniker *a7)
{
  unsigned __int16 *v11; // rbx
  bool v12; // r15
  const unsigned __int16 *v13; // r8
  int TreeInfo; // edi
  JobMoniker *v15; // rax
  const unsigned __int16 *v16; // rdx
  const unsigned __int16 *Path; // rax
  const unsigned __int16 *v18; // rax
  JobMoniker *v19; // rax
  int v20; // edx
  int v21; // r13d
  int v22; // edx
  __int64 v23; // rcx
  int v24; // ecx
  int v25; // edx
  bool v26; // r8
  int v27; // eax
  EventManager *v28; // rcx
  __int64 DomainAccount; // rax
  const unsigned __int16 *v30; // r9
  const unsigned __int16 *v31; // rax
  char v32; // si
  unsigned int v33; // eax
  __int64 v34; // rcx
  int v35; // eax
  int v36; // edx
  struct Actions::ActionCollection *v38; // [rsp+28h] [rbp-E0h]
  BYTE *lpData; // [rsp+30h] [rbp-D8h]
  const unsigned __int16 **v40; // [rsp+38h] [rbp-D0h] BYREF
  __int64 v41; // [rsp+40h] [rbp-C8h] BYREF
  LPCWSTR StringSecurityDescriptor; // [rsp+48h] [rbp-C0h] BYREF
  void *lpMem; // [rsp+50h] [rbp-B8h] BYREF
  unsigned __int16 *v44; // [rsp+58h] [rbp-B0h] BYREF
  char v45[8]; // [rsp+60h] [rbp-A8h] BYREF
  unsigned __int16 *v46; // [rsp+70h] [rbp-98h] BYREF
  struct JobMoniker *v47; // [rsp+78h] [rbp-90h]
  int *v48; // [rsp+80h] [rbp-88h]
  char v49[24]; // [rsp+88h] [rbp-80h] BYREF
  __int64 v50; // [rsp+A0h] [rbp-68h]
  __int64 v51; // [rsp+A8h] [rbp-60h]
  char v52[56]; // [rsp+B0h] [rbp-58h] BYREF
  char v53[16]; // [rsp+E8h] [rbp-20h] BYREF
  char v54[16]; // [rsp+F8h] [rbp-10h] BYREF
  __int64 v55; // [rsp+108h] [rbp+0h] BYREF
  char v56[16]; // [rsp+110h] [rbp+8h] BYREF
  char v57[16]; // [rsp+120h] [rbp+18h] BYREF
  char v58[8]; // [rsp+130h] [rbp+28h] BYREF
  struct _GUID v59; // [rsp+138h] [rbp+30h] BYREF
  unsigned __int16 v60[264]; // [rsp+148h] [rbp+40h] BYREF
  unsigned __int16 v61[264]; // [rsp+358h] [rbp+250h] BYREF

  v50 = -2LL;
  v44 = a2;
  v48 = a6;
  v47 = a7;
  JobMoniker::JobMoniker((JobMoniker *)v53, 0LL, 0LL);
  JobSecurity::JobSecurity((JobSecurity *)v45);
  memset_0(v60, 0, 0x20AuLL);
  LODWORD(v40) = a5 != 0;
  v11 = 0LL;
  v46 = 0LL;
  v51 = 0LL;
  Triggers::Trigulator::Trigulator((Triggers::Trigulator *)v52);
  Actions::ActionCollection::ActionCollection((Actions::ActionCollection *)v49);
  v12 = 0;
  LODWORD(v41) = 0;
  TreeInfo = tsched::TaskPathCanonicalize((tsched *)v60, a2, v13);
  if ( TreeInfo >= 0 )
  {
    v15 = JobMoniker::JobMoniker((JobMoniker *)v56, v60, 0LL);
    JobMoniker::operator=(v53, v15);
    wmi::AutoRef<JobBucket>::Release(v58);
    _bstr_t::_Free((_bstr_t *)v57);
    if ( tsched::IsRoot((tsched *)v60, v16) )
    {
      TreeInfo = -2147024891;
      goto LABEL_76;
    }
    TreeInfo = JobStore::RegJobSecurityQuery(this, v60, (struct JobSecurity *)v45);
    if ( TreeInfo < 0 )
      goto LABEL_76;
    Path = JobMoniker::GetPath((JobMoniker *)v53);
    TreeInfo = JobStore::RegGetTreeInfo(this, Path, &v59, 0LL);
    if ( TreeInfo >= 0 )
    {
      v18 = JobMoniker::GetPath((JobMoniker *)v53);
      v19 = JobMoniker::JobMoniker((JobMoniker *)v56, v18, &v59);
      JobMoniker::operator=(v53, v19);
      wmi::AutoRef<JobBucket>::Release(v58);
      _bstr_t::_Free((_bstr_t *)v57);
      StringSecurityDescriptor = 0LL;
      TreeInfo = JobStore::RegOpenTaskKey(this, (struct JobMoniker *)v53, (HKEY *)&StringSecurityDescriptor, 0x20019u);
      v21 = 1;
      if ( TreeInfo >= 0 )
      {
        if ( (int)Triggers::Trigulator::StreamIn((Triggers::Trigulator *)v52, (HKEY)StringSecurityDescriptor, 0xFu, 0LL) >= 0 )
          v12 = (int)Triggers::Trigulator::GetBucket((Triggers::Trigulator *)v52, (struct JobMoniker *)v53) >= 0;
        LODWORD(v41) = (int)Actions::ActionCollection::StreamIn(
                              (Actions::ActionCollection *)v49,
                              (HKEY)StringSecurityDescriptor,
                              0LL) >= 0;
      }
      if ( tsched::IsErrorNotFound((tsched *)(unsigned int)TreeInfo, v20) )
        TreeInfo = 0;
      if ( TreeInfo == -2147216607 || TreeInfo == -2147216621 )
        TreeInfo = 0;
      if ( TreeInfo >= 0 )
      {
        if ( qword_1800B0D30 )
          v23 = (unsigned int)qword_1800B0D30(v60);
        else
          v23 = 1LL;
        TreeInfo = 0;
        if ( !tsched::IsErrorNotFound((tsched *)v23, v22) )
          TreeInfo = v24;
        if ( TreeInfo >= 0 )
        {
          RpcAutoImpersonate::RpcAutoImpersonate((RpcAutoImpersonate *)&lpMem, L"JobStore::RemoveTaskOrFolderP", a4);
          TreeInfo = JobStore::FileRemoveTaskXml(this, (const struct JobMoniker *)v53);
          if ( (_DWORD)lpMem )
            RpcRevertToSelf();
          if ( tsched::IsErrorNotFound((tsched *)(unsigned int)TreeInfo, v25) )
            TreeInfo = 0;
          if ( TreeInfo >= 0 )
          {
            TreeInfo = JobStore::RemoveTaskEntryP(this, v53, (unsigned int)v40);
            if ( TreeInfo >= 0 )
            {
              if ( v12 )
              {
                if ( (((*(_DWORD *)(v55 + 16) & 0xFC000) - 0x40000) & 0xFFFBFFFF) == 0 )
                {
                  v27 = CredStore::DeleteNtCredential(
                          (CredStore *)CredStore::g_pCommonStore,
                          (const struct User *)(v55 + 64),
                          v26);
                  if ( v27 < 0
                    && WPP_GLOBAL_Control != &WPP_GLOBAL_Control
                    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
                    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 3u )
                  {
                    WPP_SF_SD(
                      *((_QWORD *)WPP_GLOBAL_Control + 2),
                      78,
                      (unsigned int)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
                      (_DWORD)v44,
                      v27);
                  }
                }
                TreeInfo = 0;
                _bstr_t::_bstr_t((_bstr_t *)&v40, L"SYSTEM");
                if ( a4 )
                {
                  RpcAutoImpersonate::RpcAutoImpersonate(
                    (RpcAutoImpersonate *)&v41,
                    L"JobStore::RemoveTaskOrFolderP",
                    a4);
                  lpMem = 0LL;
                  TreeInfo = RpcAutoImpersonate::GetClientUser((RpcAutoImpersonate *)&v41, (struct User *)&lpMem);
                  if ( TreeInfo >= 0 )
                  {
                    DomainAccount = User::GetDomainAccount(&lpMem, &v44);
                    _bstr_t::operator=(&v40, DomainAccount);
                    _bstr_t::_Free((_bstr_t *)&v44);
                  }
                  else
                  {
                    TreeInfo = 0;
                    _bstr_t::operator=(&v40, L"N/A");
                  }
                  wmi::AutoRef<User::UserEntry>::Release(&lpMem);
                  if ( (_DWORD)v41 )
                    RpcRevertToSelf();
                }
                if ( v40 )
                  v30 = *v40;
                else
                  v30 = 0LL;
                EventManager::EvtReport(v28, &TASK_DELETED, v60, v30, v38, (const struct _GUID *)lpData);
                _bstr_t::_Free((_bstr_t *)&v40);
              }
              if ( a4 )
              {
                v31 = JobMoniker::GetPath((JobMoniker *)v53);
                v32 = Auditor::AuditJobOperation(g_pAuditor, 1LL, v31, 0LL);
                if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
                  && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x40000) != 0
                  && *((unsigned __int8 *)WPP_GLOBAL_Control + 25) >= (int)(((TreeInfo >> 31) & 0xFFFFFFFE) + 4) )
                {
                  v33 = (unsigned int)JobMoniker::GetPath((JobMoniker *)v53);
                  WPP_SF_SD(
                    *((_QWORD *)WPP_GLOBAL_Control + 2),
                    79,
                    (unsigned int)&WPP_0fa9442aab3237762f9b607a66102705_Traceguids,
                    v33,
                    v32);
                }
              }
              wmi::AutoRegKey::Close((wmi::AutoRegKey *)&StringSecurityDescriptor);
              goto LABEL_71;
            }
          }
          if ( v12 && (_BYTE)v41 )
          {
            lpMem = 0LL;
            if ( JobSecurity::GetSddl((JobSecurity *)v45, 7u, (unsigned __int16 **)&lpMem) >= 0 )
            {
              if ( (*(_DWORD *)(v55 + 16) & 0x200000) != 0
                && !PlugIn::IsRegistering((PlugIn *)&PlugIn::s_singleton, v44, 0LL) )
              {
                memset_0(v61, 0, 0x20AuLL);
                PlugIn::RegisterTask((PlugIn *)&PlugIn::s_singleton, v60, 0LL, 0LL, 2u, v61);
              }
              v35 = JobStore::GenerateTaskXmlFromCollections(v34, v53, v52, v49, &v46);
              v11 = v46;
              if ( v35 >= 0 && (int)JobStore::ComputeHash((struct JobMoniker *)v53, v46) >= 0 )
              {
                RpcAutoImpersonate::RpcAutoImpersonate((RpcAutoImpersonate *)&v40, L"JobStore::RemoveTaskOrFolderP", a4);
                JobStore::XmlSaveTaskFile(this, (const struct JobMoniker *)v53, v11, (LPCWSTR)lpMem);
                if ( (_DWORD)v40 )
                  RpcRevertToSelf();
              }
              JobStore::RegTaskEntryCreate(
                this,
                (const struct JobMoniker *)v53,
                (const struct JobSecurity *)v45,
                (const struct Triggers::Trigulator *)v52,
                (const struct Actions::ActionCollection *)v49,
                0LL);
            }
            operator delete(lpMem);
          }
        }
      }
      wmi::AutoRegKey::Close((wmi::AutoRegKey *)&StringSecurityDescriptor);
      goto LABEL_76;
    }
    if ( !a3 )
      goto LABEL_76;
    RpcAutoImpersonate::RpcAutoImpersonate((RpcAutoImpersonate *)&v40, L"JobStore::RemoveTaskOrFolderP", a4);
    TreeInfo = JobStore::FileTaskFolderRemove(this, v60);
    if ( (_DWORD)v40 )
      RpcRevertToSelf();
    if ( tsched::IsErrorNotFound((tsched *)(unsigned int)TreeInfo, v36) )
      TreeInfo = 0;
    if ( TreeInfo >= 0 )
    {
      TreeInfo = JobStore::RemoveTaskFolderEntry(this, v60);
      v21 = 0;
      if ( TreeInfo >= 0 )
      {
LABEL_71:
        JobMoniker::operator=(v47, v53);
        *v48 = v21;
        goto LABEL_76;
      }
    }
    StringSecurityDescriptor = 0LL;
    if ( JobSecurity::GetSddl((JobSecurity *)v45, 7u, (unsigned __int16 **)&StringSecurityDescriptor) >= 0 )
    {
      RpcAutoImpersonate::RpcAutoImpersonate((RpcAutoImpersonate *)&v40, L"JobStore::RemoveTaskOrFolderP", a4);
      JobStore::CreateXmlFolder(this, v60, StringSecurityDescriptor);
      if ( (_DWORD)v40 )
        RpcRevertToSelf();
    }
    JobStore::RegFolderEntryCreate(this, v60, (const struct JobSecurity *)v45);
    operator delete((void *)StringSecurityDescriptor);
  }
LABEL_76:
  Actions::ActionCollection::~ActionCollection((Actions::ActionCollection *)v49);
  Triggers::Trigulator::~Trigulator((Triggers::Trigulator *)v52);
  operator delete(0LL);
  operator delete(v11);
  tsched::AutoLocalPtr<unsigned short>::~AutoLocalPtr<unsigned short>(v45);
  wmi::AutoRef<JobBucket>::Release(&v55);
  _bstr_t::_Free((_bstr_t *)v54);
  return (unsigned int)TreeInfo;
}
// 18005E675: variable 'v13' is possibly undefined
// 18005E6B6: variable 'v16' is possibly undefined
// 18005E7B7: variable 'v20' is possibly undefined
// 18005E7FD: variable 'v22' is possibly undefined
// 18005E807: variable 'v24' is possibly undefined
// 18005E84E: variable 'v25' is possibly undefined
// 18005E8AB: variable 'v26' is possibly undefined
// 18005E9B9: variable 'v28' is possibly undefined
// 18005E9B9: variable 'v38' is possibly undefined
// 18005E9B9: variable 'lpData' is possibly undefined
// 18005EB0B: variable 'v34' is possibly undefined
// 18005EBE7: variable 'v36' is possibly undefined
// 180002A4C: using guessed type __int64 __fastcall tsched::AutoLocalPtr<unsigned short>::~AutoLocalPtr<unsigned short>(_QWORD);
// 180006240: using guessed type __int64 __fastcall User::GetDomainAccount(_QWORD, _QWORD);
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);
// 180009500: using guessed type __int64 __fastcall Auditor::AuditJobOperation(_QWORD, _QWORD, _QWORD, _QWORD);
// 1800106A4: using guessed type __int64 __fastcall JobMoniker::operator=(_QWORD, _QWORD);
// 18001306C: using guessed type __int64 __fastcall wmi::AutoRef<JobBucket>::Release(_QWORD);
// 180013464: using guessed type __int64 __fastcall _bstr_t::operator=(_QWORD, _QWORD);
// 180014914: using guessed type __int64 __fastcall _bstr_t::operator=(_QWORD, _QWORD);
// 1800320D4: using guessed type __int64 __fastcall JobStore::GenerateTaskXmlFromCollections(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 18004B3B4: using guessed type __int64 __fastcall WPP_SF_SD(_DWORD, _DWORD, _DWORD, _DWORD, char);
// 18005DCB8: using guessed type __int64 __fastcall JobStore::RemoveTaskEntryP(_QWORD, _QWORD, _QWORD);
// 180080418: using guessed type wchar_t aNA[4];
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 1800B0CE0: using guessed type _RTL_CRITICAL_SECTION PlugIn::s_singleton;
// 1800B0D30: using guessed type __int64 (__fastcall *qword_1800B0D30)(_QWORD);
// 18005E5A4: using guessed type char var_478[8];
// 18005E5A4: using guessed type char var_4B0[16];
// 18005E5A4: using guessed type char var_548[8];

//----- (000000018005EDC8) ----------------------------------------------------
void __fastcall wil::details::ReportFailure(
        __int64 a1,
        unsigned int a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        int a7,
        unsigned int a8)
{
  bool v8; // bl
  const struct wil::FailureInfo *v9; // rdx
  __int64 v10; // [rsp+48h] [rbp-14F0h]
  __int64 v11; // [rsp+58h] [rbp-14E0h]
  __int64 v12; // [rsp+68h] [rbp-14D0h]
  char v13[144]; // [rsp+80h] [rbp-14B8h] BYREF
  char v14[1024]; // [rsp+110h] [rbp-1428h] BYREF
  WCHAR v15[2048]; // [rsp+510h] [rbp-1028h] BYREF

  v8 = !a7 && g_pfnThrowPlatformException;
  wil::details::LogFailure(a1, a2, a3, a4, a5, a6, a7, a8, 0LL, v10, v15, v11, v14, v12, (__int64)v13);
  if ( a7 == 3 )
LABEL_11:
    wil::details::WilFailFast((wil::details *)v13, v9);
  if ( !a7 )
  {
    if ( v8 )
      ((void (__fastcall *)(char *, WCHAR *))g_pfnThrowPlatformException)(v13, v15);
    if ( wil::details::g_pfnThrowResultException )
      wil::details::g_pfnThrowResultException((const struct wil::FailureInfo *)v13);
    goto LABEL_11;
  }
}
// 18005EE5B: variable 'v10' is possibly undefined
// 18005EE5B: variable 'v11' is possibly undefined
// 18005EE5B: variable 'v12' is possibly undefined
// 18005EEAC: variable 'v9' is possibly undefined
// 1800B09A8: using guessed type void (__stdcall *wil::details::g_pfnThrowResultException)(const struct wil::FailureInfo *);
// 1800B1540: using guessed type __int64 g_pfnThrowPlatformException;
// 18005EDC8: using guessed type char var_1428[1024];
// 18005EDC8: using guessed type WCHAR var_1028[2048];

//----- (000000018005EED4) ----------------------------------------------------
__int64 __fastcall wil::details::ReportFailure_GetLastError(
        wil::details *a1,
        void *a2,
        __int64 a3,
        const char *a4,
        __int64 a5,
        const char *a6)
{
  unsigned int v6; // edi
  signed int LastErrorFail; // eax
  unsigned int v9; // ebx
  unsigned int v10; // edx
  const char *v12; // [rsp+20h] [rbp-38h]

  v6 = (unsigned int)a2;
  LastErrorFail = wil::details::GetLastErrorFail(
                    a1,
                    a2,
                    (__int64)"onecore\\internal\\sdk\\inc\\wil\\opensource\\wil\\resource.h",
                    a4,
                    v12,
                    a6);
  v9 = LastErrorFail;
  if ( LastErrorFail > 0 )
    v10 = (unsigned __int16)LastErrorFail | 0x80070000;
  else
    v10 = LastErrorFail;
  wil::details::ReportFailure(
    (__int64)a1,
    v6,
    (__int64)"onecore\\internal\\sdk\\inc\\wil\\opensource\\wil\\resource.h",
    0LL,
    0LL,
    (__int64)a6,
    3,
    v10);
  return v9;
}
// 18005EF00: variable 'v12' is possibly undefined

//----- (000000018005EF64) ----------------------------------------------------
__int64 __fastcall wil::details::ReportFailure_GetLastErrorHr(
        wil::details *a1,
        void *a2,
        __int64 a3,
        const char *a4,
        __int64 a5,
        const char *a6)
{
  unsigned int v6; // edi
  signed int LastErrorFail; // eax
  unsigned int v9; // ebx
  const char *v11; // [rsp+20h] [rbp-38h]

  v6 = (unsigned int)a2;
  LastErrorFail = wil::details::GetLastErrorFail(a1, a2, (__int64)"wil", a4, v11, a6);
  v9 = LastErrorFail;
  if ( LastErrorFail > 0 )
    v9 = (unsigned __int16)LastErrorFail | 0x80070000;
  wil::details::ReportFailure((__int64)a1, v6, (__int64)"wil", 0LL, 0LL, (__int64)a6, 1, v9);
  return v9;
}
// 18005EF90: variable 'v11' is possibly undefined

//----- (000000018005EFF0) ----------------------------------------------------
void __fastcall wil::details::ReportFailure_Hr(
        __int64 a1,
        unsigned int a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        int a7,
        unsigned int a8)
{
  wil::details::ReportFailure(a1, a2, a3, a4, a5, a6, a7, a8);
}

//----- (000000018005F038) ----------------------------------------------------
__int64 __fastcall wil::details::ResultStringSize(wil::details *this, const char *a2)
{
  __int64 v4; // rcx

  if ( !this )
    return 1LL;
  v4 = -1LL;
  do
    ++v4;
  while ( *((_BYTE *)this + v4) );
  return v4 + 1;
}

//----- (000000018005F064) ----------------------------------------------------
__int64 __fastcall wil::details::ResultStringSize(wil::details *this, const unsigned __int16 *a2)
{
  __int64 v3; // rax

  if ( !this )
    return 2LL;
  v3 = -1LL;
  do
    ++v3;
  while ( *((_WORD *)this + v3) );
  return 2 * v3 + 2;
}

//----- (000000018005F090) ----------------------------------------------------
void __fastcall __noreturn wil::details::Rethrow(wil::details *this)
{
  CxxThrowException_0(0LL, 0LL);
}

//----- (000000018005F0A4) ----------------------------------------------------
void __fastcall wil::details_abi::FeatureStateData::RetrieveUsageUnderLock(
        wil::details_abi::FeatureStateData *this,
        struct wil::details_abi::UsageIndexes *a2)
{
  if ( *((_BYTE *)this + 64) )
    wil::details_abi::RawUsageIndex::Swap(a2, (wil::details_abi::FeatureStateData *)((char *)this + 8));
  if ( *((_BYTE *)this + 128) )
    wil::details_abi::RawUsageIndex::Swap(
      (struct wil::details_abi::UsageIndexes *)((char *)a2 + 64),
      (wil::details_abi::FeatureStateData *)((char *)this + 72));
  if ( *((_BYTE *)this + 192) )
    wil::details_abi::RawUsageIndex::Swap(
      (struct wil::details_abi::UsageIndexes *)((char *)a2 + 128),
      (wil::details_abi::FeatureStateData *)((char *)this + 136));
}

//----- (000000018005F10C) ----------------------------------------------------
__int64 __fastcall wil::details::in1diag3::Return_GetLastError(
        wil::details::in1diag3 *this,
        void *a2,
        __int64 a3,
        const char *a4)
{
  __int64 v5; // [rsp+20h] [rbp-28h]
  const char *retaddr; // [rsp+48h] [rbp+0h]

  return wil::details::ReportFailure_GetLastErrorHr(this, a2, a3, a4, v5, retaddr);
}
// 18005F11A: variable 'v5' is possibly undefined

//----- (000000018005F12C) ----------------------------------------------------
void __fastcall wil::details::in1diag3::Return_Hr(wil::details::in1diag3 *this, void *a2, __int64 a3, const char *a4)
{
  __int64 retaddr; // [rsp+48h] [rbp+0h]

  wil::details::ReportFailure_Hr(
    (__int64)this,
    (unsigned int)a2,
    (__int64)"wil",
    0LL,
    0LL,
    retaddr,
    1,
    (unsigned int)a4);
}

//----- (000000018005F168) ----------------------------------------------------
void __fastcall JobStore::ReverseSlashesInString(JobStore *this, unsigned __int16 *a2)
{
  unsigned __int16 v2; // ax
  __int64 v3; // r8
  unsigned __int16 *v4; // rcx

  v2 = *a2;
  LODWORD(v3) = 0;
  if ( *a2 )
  {
    v4 = a2;
    do
    {
      if ( v2 == 92 )
        *v4 = 47;
      v3 = (unsigned int)(v3 + 1);
      v4 = &a2[v3];
      v2 = *v4;
    }
    while ( *v4 );
  }
}

//----- (000000018005F1A0) ----------------------------------------------------
__int64 __fastcall wil::details::RtlNtStatusToDosErrorNoTeb(wil::details *this)
{
  FARPROC ProcAddress; // rax
  unsigned int v2; // ebx
  unsigned int v3; // edi
  HMODULE NtDllModuleHandle; // rax

  ProcAddress = (FARPROC)`wil::details::RtlNtStatusToDosErrorNoTeb'::`2'::s_pfnRtlNtStatusToDosErrorNoTeb;
  v2 = 0;
  v3 = (unsigned int)this;
  if ( `wil::details::RtlNtStatusToDosErrorNoTeb'::`2'::s_pfnRtlNtStatusToDosErrorNoTeb )
    return ((unsigned int (__fastcall *)(_QWORD))ProcAddress)(v3);
  NtDllModuleHandle = wil_details_GetNtDllModuleHandle();
  ProcAddress = GetProcAddress(NtDllModuleHandle, "RtlNtStatusToDosErrorNoTeb");
  `wil::details::RtlNtStatusToDosErrorNoTeb'::`2'::s_pfnRtlNtStatusToDosErrorNoTeb = (__int64)ProcAddress;
  if ( ProcAddress )
    return ((unsigned int (__fastcall *)(_QWORD))ProcAddress)(v3);
  return v2;
}
// 1800747C8: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 1800B15C8: using guessed type __int64 `wil::details::RtlNtStatusToDosErrorNoTeb'::`2'::s_pfnRtlNtStatusToDosErrorNoTeb;

//----- (000000018005F200) ----------------------------------------------------
void __fastcall wil::details_abi::ThreadLocalFailureInfo::Set(
        wil::details_abi::ThreadLocalFailureInfo *this,
        const struct wil::FailureInfo *a2,
        int a3)
{
  char **v3; // r14
  int v4; // eax
  char **v5; // r15
  unsigned __int16 **v6; // r12
  __int64 v9; // rax
  __int64 v10; // rdi
  const char *v11; // rdx
  __int64 v12; // rdi
  const char *v13; // rdx
  SIZE_T v14; // rdi
  LPVOID v15; // rbp
  HANDLE ProcessHeap; // rax
  char *v17; // rcx
  const char *v18; // rbx
  char *v19; // rax
  unsigned __int16 *v20; // rax
  char *v21; // rax

  *((_DWORD *)this + 1) = a3;
  v3 = (char **)((char *)this + 16);
  v4 = *((_DWORD *)a2 + 1);
  v5 = (char **)((char *)this + 32);
  *((_QWORD *)this + 2) = 0LL;
  v6 = (unsigned __int16 **)((char *)this + 56);
  *((_DWORD *)this + 2) = v4;
  *((_WORD *)this + 12) = *((_WORD *)a2 + 28);
  LOBYTE(v4) = *(_BYTE *)a2;
  *((_QWORD *)this + 4) = 0LL;
  *((_BYTE *)this + 26) = v4;
  *((_QWORD *)this + 5) = *((_QWORD *)a2 + 16);
  v9 = *((_QWORD *)a2 + 17);
  *((_QWORD *)this + 7) = 0LL;
  *((_QWORD *)this + 6) = v9;
  v10 = wil::details::ResultStringSize(*((wil::details **)a2 + 2), (const unsigned __int16 *)a2);
  v12 = wil::details::ResultStringSize(*((wil::details **)a2 + 6), v11) + v10;
  v14 = wil::details::ResultStringSize(*((wil::details **)a2 + 15), v13) + v12;
  if ( !*((_QWORD *)this + 8) || *((_QWORD *)this + 9) < v14 )
  {
    v15 = wil::details::ProcessHeapAlloc(8u, v14);
    if ( v15 )
    {
      ProcessHeap = GetProcessHeap();
      HeapFree(ProcessHeap, 0, *((LPVOID *)this + 8));
      *((_QWORD *)this + 8) = v15;
      *((_QWORD *)this + 9) = v14;
    }
  }
  v17 = (char *)*((_QWORD *)this + 8);
  if ( v17 )
  {
    v18 = &v17[*((_QWORD *)this + 9)];
    v19 = wil::details::WriteResultString<char const *>(v17, v18, *((wil::details **)a2 + 6), v3);
    v20 = (unsigned __int16 *)wil::details::WriteResultString<char const *>(v19, v18, *((wil::details **)a2 + 15), v5);
    v21 = wil::details::WriteResultString<unsigned short const *>(
            v20,
            (const unsigned __int16 *)v18,
            *((wil::details **)a2 + 2),
            v6);
    memset_0(v21, 0, v18 - v21);
  }
}
// 18005F279: variable 'v11' is possibly undefined
// 18005F285: variable 'v13' is possibly undefined

//----- (000000018005F354) ----------------------------------------------------
void __fastcall wil::details_abi::RawUsageIndex::SetBuffer(
        wil::details_abi::RawUsageIndex *this,
        char *a2,
        unsigned __int64 a3,
        const char *a4)
{
  wil::details *v8; // rcx
  char v9; // al
  wil::details::in1diag3 *retaddr; // [rsp+28h] [rbp+0h]

  if ( (unsigned __int64)a4 < 0xA )
  {
    wil::details::in1diag3::_FailFast_Unexpected(retaddr, a2, a3, a4);
    __debugbreak();
  }
  v8 = (wil::details *)*((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = 0LL;
  if ( v8 )
    wil::details::FreeProcessHeap(v8, a2);
  *((_QWORD *)this + 3) = a2;
  *((_QWORD *)this + 4) = &a2[a3];
  *((_QWORD *)this + 5) = &a4[(_QWORD)a2];
  *((_BYTE *)this + 57) = 0;
  if ( a3 < 0xA )
    goto LABEL_15;
  if ( *(_WORD *)a2 || (v9 = 0, *((_WORD *)a2 + 1) > *(_WORD *)this) )
    v9 = 1;
  *((_BYTE *)this + 57) = v9;
  if ( *(_WORD *)a2
    || *((_WORD *)a2 + 1) != *(_WORD *)this
    || *((_WORD *)a2 + 2) != *((_WORD *)this + 1)
    || a2[8] != *((_BYTE *)this + 4)
    || *((_WORD *)a2 + 3) != *((_WORD *)this + 3)
    || a2[9] != *((_BYTE *)this + 8) )
  {
LABEL_15:
    *(_WORD *)a2 = 0;
    *((_WORD *)a2 + 1) = *(_WORD *)this;
    *((_WORD *)a2 + 2) = *((_WORD *)this + 1);
    a2[8] = *((_BYTE *)this + 4);
    *((_WORD *)a2 + 3) = *((_WORD *)this + 3);
    a2[9] = *((_BYTE *)this + 8);
    *((_QWORD *)this + 4) = *((_QWORD *)this + 3) + 10LL;
  }
}

//----- (000000018005F45C) ----------------------------------------------------
void __fastcall wil::StoredFailureInfo::SetFailureInfo(wil::StoredFailureInfo *this, const struct wil::FailureInfo *a2)
{
  __int64 v4; // rbx
  const unsigned __int16 *v5; // rdx
  __int64 v6; // rbx
  const unsigned __int16 *v7; // rdx
  __int64 v8; // rbx
  const char *v9; // rdx
  __int64 v10; // rbx
  const char *v11; // rdx
  __int64 v12; // rbx
  const char *v13; // rdx
  __int64 v14; // rbx
  const char *v15; // rdx
  __int64 v16; // rbx
  const char *v17; // rdx
  __int64 v18; // rbx
  const char *v19; // rdx
  __int64 v20; // rbx
  const char *v21; // rdx
  void *v22; // rbx
  _QWORD *v23; // rdi
  _DWORD *v24; // rax
  __int64 v25; // rcx
  __int64 v26; // r10
  const unsigned __int16 *v27; // rbx
  char *v28; // rax
  char *v29; // rax
  char *v30; // rax
  char *v31; // rax
  char *v32; // rax
  char *v33; // rax
  unsigned __int16 *v34; // rax
  char *v35; // rax
  unsigned __int16 *v36; // rax
  char *v37; // rax

  *(_OWORD *)this = *(_OWORD *)a2;
  *((_OWORD *)this + 1) = *((_OWORD *)a2 + 1);
  *((_OWORD *)this + 2) = *((_OWORD *)a2 + 2);
  *((_OWORD *)this + 3) = *((_OWORD *)a2 + 3);
  *((_OWORD *)this + 4) = *((_OWORD *)a2 + 4);
  *((_OWORD *)this + 5) = *((_OWORD *)a2 + 5);
  *((_OWORD *)this + 6) = *((_OWORD *)a2 + 6);
  *((_OWORD *)this + 7) = *((_OWORD *)a2 + 7);
  *((_OWORD *)this + 8) = *((_OWORD *)a2 + 8);
  v4 = wil::details::ResultStringSize(*((wil::details **)a2 + 14), (const unsigned __int16 *)a2);
  v6 = wil::details::ResultStringSize(*((wil::details **)a2 + 11), v5) + v4;
  v8 = wil::details::ResultStringSize(*((wil::details **)a2 + 2), v7) + v6;
  v10 = wil::details::ResultStringSize(*((wil::details **)a2 + 13), v9) + v8;
  v12 = wil::details::ResultStringSize(*((wil::details **)a2 + 10), v11) + v10;
  v14 = wil::details::ResultStringSize(*((wil::details **)a2 + 8), v13) + v12;
  v16 = wil::details::ResultStringSize(*((wil::details **)a2 + 6), v15) + v14;
  v18 = wil::details::ResultStringSize(*((wil::details **)a2 + 5), v17) + v16;
  v20 = wil::details::ResultStringSize(*((wil::details **)a2 + 4), v19) + v18;
  v22 = (void *)(wil::details::ResultStringSize(*((wil::details **)a2 + 15), v21) + v20);
  v23 = (_QWORD *)((char *)this + 144);
  v24 = (_DWORD *)*((_QWORD *)this + 18);
  if ( !v24 || *v24 != 1 || *((_QWORD *)this + 19) < (unsigned __int64)v22 )
  {
    wil::details::shared_buffer::reset((LPVOID *)this + 18);
    wil::details::shared_buffer::create((LPVOID *)this + 18, 0LL, v22);
  }
  v25 = *v23 + 4LL;
  v26 = v25 & -(__int64)(*v23 != 0LL);
  if ( v26 )
    v27 = (const unsigned __int16 *)(*((_QWORD *)this + 19) + v26);
  else
    v27 = 0LL;
  if ( v26 )
  {
    v28 = wil::details::WriteResultString<unsigned short const *>(
            (unsigned __int16 *)(v25 & -(__int64)(*v23 != 0LL)),
            v27,
            *((wil::details **)a2 + 2),
            (unsigned __int16 **)this + 2);
    v29 = wil::details::WriteResultString<char const *>(
            v28,
            (const char *)v27,
            *((wil::details **)a2 + 4),
            (char **)this + 4);
    v30 = wil::details::WriteResultString<char const *>(
            v29,
            (const char *)v27,
            *((wil::details **)a2 + 5),
            (char **)this + 5);
    v31 = wil::details::WriteResultString<char const *>(
            v30,
            (const char *)v27,
            *((wil::details **)a2 + 6),
            (char **)this + 6);
    v32 = wil::details::WriteResultString<char const *>(
            v31,
            (const char *)v27,
            *((wil::details **)a2 + 8),
            (char **)this + 8);
    v33 = wil::details::WriteResultString<char const *>(
            v32,
            (const char *)v27,
            *((wil::details **)a2 + 15),
            (char **)this + 15);
    v34 = (unsigned __int16 *)wil::details::WriteResultString<char const *>(
                                v33,
                                (const char *)v27,
                                *((wil::details **)a2 + 13),
                                (char **)this + 13);
    v35 = wil::details::WriteResultString<unsigned short const *>(
            v34,
            v27,
            *((wil::details **)a2 + 14),
            (unsigned __int16 **)this + 14);
    v36 = (unsigned __int16 *)wil::details::WriteResultString<char const *>(
                                v35,
                                (const char *)v27,
                                *((wil::details **)a2 + 10),
                                (char **)this + 10);
    v37 = wil::details::WriteResultString<unsigned short const *>(
            v36,
            v27,
            *((wil::details **)a2 + 11),
            (unsigned __int16 **)this + 11);
    memset_0(v37, 0, (char *)v27 - v37);
  }
}
// 18005F4D3: variable 'v5' is possibly undefined
// 18005F4DF: variable 'v7' is possibly undefined
// 18005F4EB: variable 'v9' is possibly undefined
// 18005F4F7: variable 'v11' is possibly undefined
// 18005F503: variable 'v13' is possibly undefined
// 18005F50F: variable 'v15' is possibly undefined
// 18005F51B: variable 'v17' is possibly undefined
// 18005F527: variable 'v19' is possibly undefined
// 18005F533: variable 'v21' is possibly undefined

//----- (000000018005F680) ----------------------------------------------------
void __fastcall wil::details_abi::ThreadLocalData::SetLastError(
        wil::details_abi::ThreadLocalData *this,
        const struct wil::FailureInfo *a2)
{
  _WORD *v2; // r8
  int v4; // edi
  _WORD *v6; // rax
  _WORD *v7; // rax
  _DWORD *v8; // rcx
  _DWORD *v9; // r8
  volatile signed __int32 *v10; // rax

  v2 = (_WORD *)*((_QWORD *)this + 3);
  v4 = *((_DWORD *)this + 4);
  if ( v2 )
    goto LABEL_17;
  if ( v4 )
  {
    v6 = wil::details::ProcessHeapAlloc(8u, 0x190uLL);
    *((_QWORD *)this + 3) = v6;
    v2 = v6;
    if ( v6 )
    {
      v7 = v6 + 200;
      *((_DWORD *)this + 8) = 5;
      if ( v2 != v7 )
      {
        do
        {
          *v2 = 80;
          v2 += 40;
        }
        while ( v2 != v7 );
        v2 = (_WORD *)*((_QWORD *)this + 3);
      }
      if ( v2 )
      {
LABEL_17:
        if ( !v4 || (v8 = &v2[40 * *((unsigned __int16 *)this + 16)], v2 == (_WORD *)v8) )
        {
LABEL_14:
          v10 = (volatile signed __int32 *)*((_QWORD *)this + 1);
          *((_WORD *)this + 17) = ((unsigned int)*((unsigned __int16 *)this + 17) + 1)
                                % *((unsigned __int16 *)this + 16);
          wil::details_abi::ThreadLocalFailureInfo::Set(
            (wil::details_abi::ThreadLocalFailureInfo *)(*((_QWORD *)this + 3) + 80LL * *((unsigned __int16 *)this + 17)),
            a2,
            _InterlockedIncrement(v10));
        }
        else
        {
          v9 = v2 + 4;
          while ( *(v9 - 1) <= *((_DWORD *)this + 4) || *v9 != *((_DWORD *)a2 + 1) )
          {
            v9 += 20;
            if ( v9 - 2 == v8 )
              goto LABEL_14;
          }
        }
      }
    }
  }
}

//----- (000000018005F798) ----------------------------------------------------
unsigned __int8 *__fastcall wil::details_abi::RawUsageIndex::SkipValues(
        wil::details_abi::RawUsageIndex *this,
        struct wil::details_abi::UsageIndexProperty *a2,
        unsigned __int8 *a3)
{
  unsigned __int64 v4; // rcx
  unsigned __int8 *v5; // rbx
  unsigned __int64 v7; // rax
  unsigned __int64 v8; // rdx
  unsigned int v9; // ebp
  __int16 v11; // [rsp+20h] [rbp-38h] BYREF
  char v12; // [rsp+22h] [rbp-36h]
  int v13; // [rsp+24h] [rbp-34h]
  __int16 v14; // [rsp+28h] [rbp-30h]
  __int128 v15; // [rsp+30h] [rbp-28h]
  unsigned __int8 *v16; // [rsp+70h] [rbp+18h] BYREF

  v16 = a3;
  v4 = *((_QWORD *)this + 2);
  v5 = a3;
  if ( v4 )
  {
    v7 = (*((_QWORD *)this + 4) - *((_QWORD *)this + 3)) / v4;
    v8 = *((unsigned int *)a2 + 1);
    if ( v8 > v7 )
    {
      wil::details_abi::UsageIndexProperty::UpdateCount(a2, v7);
      LODWORD(v8) = *((_DWORD *)a2 + 1);
      v4 = *((_QWORD *)this + 2);
    }
    v5 += v4 * (unsigned int)v8;
  }
  else
  {
    v9 = 0;
    v11 = *((_WORD *)this + 3);
    v12 = *((_BYTE *)this + 8);
    v13 = 0;
    v14 = 0;
    v15 = 0LL;
    if ( *((_DWORD *)a2 + 1) )
    {
      do
      {
        if ( !wil::details_abi::UsageIndexProperty::Read(
                (wil::details_abi::UsageIndexProperty *)&v11,
                &v16,
                *((unsigned __int8 **)this + 4)) )
          break;
        ++v9;
      }
      while ( v9 < *((_DWORD *)a2 + 1) );
      v5 = v16;
    }
    wil::details_abi::UsageIndexProperty::UpdateCount(a2, v9);
  }
  return v5;
}

//----- (000000018005F86C) ----------------------------------------------------
__int64 wil::details::StringCchPrintfA(wil::details *this, char *a2, const char *a3, const char *a4, ...)
{
  int v4; // r9d
  const char *v6; // [rsp+58h] [rbp+20h] BYREF

  v6 = a4;
  v4 = 0;
  if ( (unsigned __int64)(a2 - 1) > 0x7FFFFFFE )
    v4 = -2147024809;
  if ( v4 < 0 )
  {
    if ( a2 )
      *(_BYTE *)this = 0;
  }
  else
  {
    return (unsigned int)wil::details::WilStringVPrintfWorkerA((char *)this, (size_t)a2, (__int64)a3, a3, (va_list)&v6);
  }
  return (unsigned int)v4;
}

//----- (000000018005F8C4) ----------------------------------------------------
void __fastcall wil::details::FeatureStateManager::SubscribeToEnabledStateChanges(
        RTL_SRWLOCK *this,
        struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ **a2,
        void (__stdcall *a3)(void *),
        __int64 a4)
{
  RTL_SRWLOCK *v8; // rbx
  __int64 v9; // rdx
  __int64 v10; // r8
  RTL_SRWLOCK *v11; // [rsp+50h] [rbp+8h] BYREF
  void (__stdcall *v12)(PSRWLOCK); // [rsp+58h] [rbp+10h] BYREF

  *a2 = 0LL;
  if ( LOBYTE(this->Ptr) )
  {
    v8 = this + 4;
    AcquireSRWLockExclusive(this + 4);
    v11 = v8;
    if ( wil::details::FeatureStateManager::EnsureSubscribedToStateChangesUnderLock(
           (wil::details::FeatureStateManager *)this,
           v9,
           v10) )
    {
      wil::details_abi::SubscriptionList::SubscribeUnderLock((wil::details_abi::SubscriptionList *)&this[9], a2, a3, a4);
    }
    if ( v8 )
    {
      v11 = v8;
      v12 = ReleaseSRWLockExclusive;
      wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>((__int64 (__fastcall **)(_QWORD))&v12, &v11);
    }
  }
}
// 18005F910: variable 'v9' is possibly undefined
// 18005F910: variable 'v10' is possibly undefined

//----- (000000018005F978) ----------------------------------------------------
void __fastcall wil::details::FeatureStateManager::SubscribeToUsageFlush(
        RTL_SRWLOCK *this,
        struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ **a2,
        void (__stdcall *a3)(void *))
{
  RTL_SRWLOCK *v6; // [rsp+50h] [rbp+8h] BYREF
  void (__stdcall *v7)(PSRWLOCK); // [rsp+58h] [rbp+10h] BYREF

  *a2 = 0LL;
  if ( LOBYTE(this->Ptr)
    && !wil::ProcessShutdownInProgress((wil *)this)
    && wil::details::FeatureStateManager::EnsureStateData(this) )
  {
    AcquireSRWLockExclusive(this + 4);
    v6 = this + 4;
    wil::details::FeatureStateManager::EnsureSubscribedToProcessWideUsageFlushUnderLock((wil::details::FeatureStateManager *)this);
    wil::details_abi::SubscriptionList::SubscribeUnderLock((wil::details_abi::SubscriptionList *)&this[21], a2, a3, 0LL);
    if ( *a2 )
      *a2 = (struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ *)((unsigned __int64)*a2 | 0x80000000);
    if ( this != (RTL_SRWLOCK *)-32LL )
    {
      v6 = this + 4;
      v7 = ReleaseSRWLockExclusive;
      wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>((__int64 (__fastcall **)(_QWORD))&v7, &v6);
    }
  }
}

//----- (000000018005FA48) ----------------------------------------------------
void __fastcall wil::details_abi::SubscriptionList::SubscribeUnderLock(
        wil::details_abi::SubscriptionList *this,
        struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ **a2,
        void (__stdcall *a3)(void *),
        __int64 a4)
{
  char *v4; // rbx
  _QWORD *v5; // rcx
  __int64 v6; // rax
  unsigned __int64 v9; // r10
  _QWORD *v10; // rdx
  struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ *v11; // r8
  __int64 v12; // rax
  __int64 v13[3]; // [rsp+20h] [rbp-18h] BYREF

  *a2 = 0LL;
  v4 = (char *)this + 40;
  v5 = (_QWORD *)*((_QWORD *)this + 5);
  v6 = 0LL;
  v9 = (*((_QWORD *)v4 + 1) - (_QWORD)v5) >> 4;
  if ( v9 )
  {
    v10 = v5;
    while ( 1 )
    {
      v11 = (struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ *)(v6 + 1);
      if ( !*v10 )
        break;
      v10 += 2;
      ++v6;
      if ( (unsigned __int64)v11 >= v9 )
        goto LABEL_5;
    }
    v12 = 2 * v6;
    v5[v12] = a3;
    v5[v12 + 1] = a4;
    *a2 = v11;
  }
  else
  {
LABEL_5:
    v13[0] = (__int64)a3;
    v13[1] = a4;
    if ( wil::details_abi::heap_buffer::push_back((void **)v4, v13, 0x10uLL) )
      *a2 = (struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ *)((*((_QWORD *)v4 + 1) - *(_QWORD *)v4) >> 4);
  }
}

//----- (000000018005FAE0) ----------------------------------------------------
void __fastcall wil::details_abi::RawUsageIndex::Swap(
        wil::details_abi::RawUsageIndex *this,
        struct wil::details_abi::RawUsageIndex *a2)
{
  __int64 v4; // rsi
  __int64 v5; // rax
  wil::details *v6; // rcx
  wil::details *v7; // rcx
  char v8; // cl
  char v9; // al
  char v10; // cl
  __int128 v11; // [rsp+20h] [rbp-18h]
  __int64 v12; // [rsp+40h] [rbp+8h]

  v11 = *(_OWORD *)((char *)this + 24);
  v12 = *((_QWORD *)this + 5);
  v4 = *((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = 0LL;
  *(_OWORD *)((char *)this + 24) = *(_OWORD *)((char *)a2 + 24);
  *((_QWORD *)this + 5) = *((_QWORD *)a2 + 5);
  v5 = *((_QWORD *)a2 + 6);
  *((_QWORD *)a2 + 6) = 0LL;
  v6 = (wil::details *)*((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = v5;
  if ( v6 )
    wil::details::FreeProcessHeap(v6, a2);
  *(_OWORD *)((char *)a2 + 24) = v11;
  *((_QWORD *)a2 + 5) = v12;
  v7 = (wil::details *)*((_QWORD *)a2 + 6);
  *((_QWORD *)a2 + 6) = v4;
  if ( v7 )
    wil::details::FreeProcessHeap(v7, a2);
  v8 = *((_BYTE *)this + 56);
  *((_BYTE *)this + 56) = *((_BYTE *)a2 + 56);
  v9 = *((_BYTE *)a2 + 57);
  *((_BYTE *)a2 + 56) = v8;
  v10 = *((_BYTE *)this + 57);
  *((_BYTE *)this + 57) = v9;
  *((_BYTE *)a2 + 57) = v10;
}
// 18005FB5F: variable 'a2' is possibly undefined

//----- (000000018005FB94) ----------------------------------------------------
__int64 __fastcall JobStore::TakeBackupRestorePermissions(JobStore *this, unsigned __int8 *a2, unsigned __int8 *a3)
{
  NTSTATUS v5; // ebx
  char v6; // al
  char v8; // al
  unsigned __int8 OldValue; // [rsp+30h] [rbp-29h] BYREF
  char v10; // [rsp+31h] [rbp-28h] BYREF
  char v11; // [rsp+32h] [rbp-27h] BYREF
  unsigned __int8 v12; // [rsp+33h] [rbp-26h] BYREF
  int v13[3]; // [rsp+34h] [rbp-25h] BYREF
  struct _EVENT_DATA_DESCRIPTOR v14; // [rsp+40h] [rbp-19h] BYREF
  int *v15; // [rsp+60h] [rbp+7h]
  int v16; // [rsp+68h] [rbp+Fh]
  int v17; // [rsp+6Ch] [rbp+13h]
  char *v18; // [rsp+70h] [rbp+17h]
  int v19; // [rsp+78h] [rbp+1Fh]
  int v20; // [rsp+7Ch] [rbp+23h]
  char *v21; // [rsp+80h] [rbp+27h]
  int v22; // [rsp+88h] [rbp+2Fh]
  int v23; // [rsp+8Ch] [rbp+33h]

  v5 = RtlAdjustPrivilege(0x11u, 1u, 0, &OldValue);
  if ( v5 < 0 )
  {
    if ( (unsigned int)dword_1800AFF68 > 4
      && (qword_1800AFF78 & 0x400000000001LL) != 0
      && (qword_1800AFF80 & 0x400000000001LL) == qword_1800AFF80 )
    {
      v6 = *a2;
      v20 = 0;
      v17 = 0;
      v10 = v6;
      v18 = &v10;
      v15 = v13;
      v16 = 4;
      v13[0] = v5;
      v19 = 1;
      tlgWriteTransfer_EventWriteTransfer(
        (__int64)&dword_1800AFF68,
        (unsigned __int8 *)dword_18007EFF7,
        0LL,
        0LL,
        4u,
        &v14);
    }
    return v5 | 0x10000000u;
  }
  v5 = RtlAdjustPrivilege(0x12u, 1u, 0, &v12);
  if ( v5 < 0 )
  {
    if ( (unsigned int)dword_1800AFF68 > 4
      && (qword_1800AFF78 & 0x400000000001LL) != 0
      && (qword_1800AFF80 & 0x400000000001LL) == qword_1800AFF80 )
    {
      v8 = *a3;
      v23 = 0;
      v20 = 0;
      v17 = 0;
      v10 = v8;
      v11 = *a2;
      v21 = &v10;
      v18 = &v11;
      v15 = v13;
      v16 = 4;
      v13[0] = v5;
      v22 = 1;
      v19 = 1;
      tlgWriteTransfer_EventWriteTransfer(
        (__int64)&dword_1800AFF68,
        (unsigned __int8 *)dword_18007ECB2,
        0LL,
        0LL,
        5u,
        &v14);
    }
    RtlAdjustPrivilege(0x11u, OldValue, 0, &OldValue);
    return v5 | 0x10000000u;
  }
  *a2 = OldValue;
  *a3 = v12;
  return 0LL;
}
// 18007ECB2: using guessed type int dword_18007ECB2[22];
// 18007EFF7: using guessed type int dword_18007EFF7[16];
// 1800AFF78: using guessed type __int64 qword_1800AFF78;
// 1800AFF80: using guessed type __int64 qword_1800AFF80;

//----- (000000018005FD90) ----------------------------------------------------
void __fastcall __noreturn wil::details::ThrowResultExceptionInternal(
        wil::details *this,
        const struct wil::FailureInfo *a2)
{
  __int64 pExceptionObject[3]; // [rsp+20h] [rbp-D8h] BYREF
  char v4[144]; // [rsp+38h] [rbp-C0h] BYREF
  __int128 v5; // [rsp+C8h] [rbp-30h]
  __int128 v6; // [rsp+D8h] [rbp-20h]

  exception::exception((exception *)pExceptionObject);
  pExceptionObject[0] = (__int64)&wil::ResultException::`vftable';
  v5 = 0LL;
  wil::StoredFailureInfo::SetFailureInfo((wil::StoredFailureInfo *)v4, this);
  v6 = 0LL;
  CxxThrowException_0(pExceptionObject, (_ThrowInfo *)&TI2_AVResultException_wil__);
}
// 180073800: using guessed type void *wil::ResultException::`vftable';
// 18005FD90: using guessed type char var_C0[144];

//----- (000000018005FDF0) ----------------------------------------------------
__int64 __fastcall wil::details_abi::SemaphoreValue::TryGetPointer(char *a1, void **a2, __int64 a3, bool *a4)
{
  unsigned __int64 v4; // rdi
  int ValueInternal; // eax
  __int64 v7; // r8
  int v8; // ebx
  wil::details::in1diag3 *retaddr; // [rsp+28h] [rbp+0h]
  unsigned __int64 v11; // [rsp+38h] [rbp+10h] BYREF

  *a2 = 0LL;
  v4 = 0LL;
  v11 = 0LL;
  ValueInternal = wil::details_abi::SemaphoreValue::TryGetValueInternal(a1, (__int64)a2, &v11, a4);
  v8 = ValueInternal;
  if ( ValueInternal >= 0 )
  {
    v4 = v11;
    v8 = 0;
  }
  else
  {
    wil::details::in1diag3::Return_Hr(retaddr, (void *)0x62, v7, (const char *)(unsigned int)ValueInternal);
  }
  if ( v8 >= 0 )
  {
    *a2 = (void *)(4 * v4);
    return 0LL;
  }
  else
  {
    wil::details::in1diag3::Return_Hr(retaddr, (void *)0x6B, v7, (const char *)(unsigned int)v8);
    return (unsigned int)v8;
  }
}
// 18005FE27: variable 'v7' is possibly undefined

//----- (000000018005FE74) ----------------------------------------------------
__int64 __fastcall wil::details_abi::SemaphoreValue::TryGetValueInternal(
        char *a1,
        __int64 a2,
        unsigned __int64 *a3,
        bool *a4)
{
  __int64 v5; // rcx
  WCHAR *v6; // rax
  __int64 v7; // rax
  WCHAR *v8; // rcx
  __int64 v9; // rdx
  __int64 v10; // r8
  char *v11; // rax
  WCHAR v12; // r9
  WCHAR *v13; // rax
  void (__fastcall *v14)(wil::details *, void *); // rax
  void (__fastcall *v15)(wil::details *, void *); // rdi
  __int64 v16; // r8
  const char *v17; // r9
  __int64 v18; // rdx
  unsigned int LastError; // esi
  int ValueFromSemaphore; // eax
  __int64 v21; // r8
  __int64 v22; // rax
  WCHAR *v23; // rcx
  __int64 v24; // rcx
  WCHAR *v25; // rdx
  __int64 v26; // rbx
  __int64 v27; // rax
  char *v28; // r8
  WCHAR v29; // cx
  WCHAR *v30; // rax
  void (__fastcall *v31)(wil::details *, void *); // rax
  void (__fastcall *v32)(wil::details *, void *); // rbx
  int v33; // eax
  __int64 v34; // r8
  int v36[2]; // [rsp+20h] [rbp-E0h] BYREF
  int v37[2]; // [rsp+28h] [rbp-D8h] BYREF
  void (__fastcall *v38)(wil::details *, void *); // [rsp+30h] [rbp-D0h] BYREF
  void (__fastcall *v39)(wil::details *, void *); // [rsp+38h] [rbp-C8h] BYREF
  WCHAR Name[264]; // [rsp+40h] [rbp-C0h] BYREF
  wil::details::in1diag3 *retaddr; // [rsp+288h] [rbp+188h]

  *a3 = 0LL;
  StringCchCopyW((char *)Name, 260LL, a1);
  v5 = 260LL;
  v6 = Name;
  do
  {
    if ( !*v6 )
      break;
    ++v6;
    --v5;
  }
  while ( v5 );
  if ( v5 )
    v7 = 260 - v5;
  else
    v7 = 0LL;
  if ( v5 )
  {
    v8 = &Name[v7];
    v9 = 260 - v7;
    if ( v7 != 260 )
    {
      v10 = 2147483646LL;
      v11 = (char *)((char *)L"_p0" - (char *)v8);
      do
      {
        if ( !v10 )
          break;
        v12 = *(WCHAR *)((char *)v8 + (_QWORD)v11);
        if ( !v12 )
          break;
        *v8 = v12;
        --v10;
        ++v8;
        --v9;
      }
      while ( v9 );
    }
    v13 = v8 - 1;
    if ( v9 )
      v13 = v8;
    *v13 = 0;
  }
  v14 = (void (__fastcall *)(wil::details *, void *))OpenSemaphoreW(0x1F0003u, 0, Name);
  v15 = v14;
  if ( v14 )
  {
    v37[0] = 0;
    v36[0] = 0;
    ValueFromSemaphore = wil::details_abi::SemaphoreValue::GetValueFromSemaphore(v14, v37);
    LastError = ValueFromSemaphore;
    if ( ValueFromSemaphore < 0 )
    {
      wil::details::in1diag3::Return_Hr(retaddr, (void *)0xCF, v21, (const char *)(unsigned int)ValueFromSemaphore);
      goto LABEL_43;
    }
    v22 = 260LL;
    v23 = Name;
    do
    {
      if ( !*v23 )
        break;
      ++v23;
      --v22;
    }
    while ( v22 );
    if ( v22 )
      v24 = 260 - v22;
    else
      v24 = 0LL;
    if ( v22 )
    {
      v25 = &Name[v24];
      v26 = 260 - v24;
      if ( 260 != v24 )
      {
        v27 = 2147483646LL;
        v28 = (char *)((char *)L"h" - (char *)v25);
        do
        {
          if ( !v27 )
            break;
          v29 = *(WCHAR *)((char *)v25 + (_QWORD)v28);
          if ( !v29 )
            break;
          *v25 = v29;
          --v27;
          ++v25;
          --v26;
        }
        while ( v26 );
      }
      v30 = v25 - 1;
      if ( v26 )
        v30 = v25;
      *v30 = 0;
    }
    v31 = (void (__fastcall *)(wil::details *, void *))OpenSemaphoreW(0x1F0003u, 0, Name);
    v32 = v31;
    if ( !v31 )
    {
      v18 = 213LL;
      goto LABEL_19;
    }
    v33 = wil::details_abi::SemaphoreValue::GetValueFromSemaphore(v31, v36);
    LastError = v33;
    if ( v33 < 0 )
    {
      wil::details::in1diag3::Return_Hr(retaddr, (void *)0xD7, v34, (const char *)(unsigned int)v33);
      *(_QWORD *)v37 = v32;
      *(_QWORD *)v36 = wil::details::CloseHandle;
      wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>((__int64 (__fastcall **)(_QWORD))v36, v37);
      goto LABEL_43;
    }
    v38 = v32;
    v39 = wil::details::CloseHandle;
    wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>((__int64 (__fastcall **)(_QWORD))&v39, &v38);
    *a3 = ((__int64)v36[0] << 31) | v37[0];
  }
  else if ( GetLastError() != 2 )
  {
    v18 = 201LL;
LABEL_19:
    LastError = wil::details::in1diag3::Return_GetLastError(retaddr, (void *)v18, v16, v17);
    goto LABEL_43;
  }
  LastError = 0;
LABEL_43:
  if ( v15 )
  {
    v39 = v15;
    v38 = wil::details::CloseHandle;
    wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>((__int64 (__fastcall **)(_QWORD))&v38, &v39);
  }
  return LastError;
}
// 18005FF8C: variable 'v16' is possibly undefined
// 18005FF8C: variable 'v17' is possibly undefined
// 18005FFC4: variable 'v21' is possibly undefined
// 180060097: variable 'v34' is possibly undefined
// 1800803C0: using guessed type wchar_t aP0[4];
// 1800803C8: using guessed type wchar_t asc_1800803C8[2];
// 18005FE74: using guessed type WCHAR Name[264];

//----- (000000018006013C) ----------------------------------------------------
void __fastcall wil::details_abi::SubscriptionList::Unsubscribe(
        struct _RTL_CRITICAL_SECTION *this,
        RTL_SRWLOCK *a2,
        struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ *a3)
{
  PRTL_CRITICAL_SECTION_DEBUG DebugInfo; // rdx
  struct _RTL_CRITICAL_SECTION *v7; // [rsp+40h] [rbp+18h] BYREF
  __int64 (__fastcall *v8)(_QWORD); // [rsp+48h] [rbp+20h] BYREF

  if ( a3 )
  {
    EnterCriticalSection(this);
    AcquireSRWLockExclusive(a2);
    DebugInfo = this[1].DebugInfo;
    if ( (unsigned __int64)a3 - 1 < (*(_QWORD *)&this[1].LockCount - (_QWORD)DebugInfo) >> 4 )
      *((_OWORD *)&DebugInfo->Type + (unsigned __int64)a3 - 1) = 0LL;
    if ( a2 )
    {
      v8 = (__int64 (__fastcall *)(_QWORD))ReleaseSRWLockExclusive;
      v7 = (struct _RTL_CRITICAL_SECTION *)a2;
      wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>(&v8, &v7);
    }
    if ( this )
    {
      v8 = (__int64 (__fastcall *)(_QWORD))LeaveCriticalSection;
      v7 = this;
      wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>(&v8, &v7);
    }
  }
}

//----- (0000000180060200) ----------------------------------------------------
void __fastcall wil::details::UnsubscribeProcessWideUsageFlush(
        struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ *this,
        struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ *a2)
{
  if ( this )
  {
    if ( qword_1800B0D98 )
      wil::details_abi::SubscriptionList::Unsubscribe(
        (struct _RTL_CRITICAL_SECTION *)qword_1800B0D98 + 5,
        (RTL_SRWLOCK *)qword_1800B0D98,
        this);
  }
}

//----- (0000000180060230) ----------------------------------------------------
void __fastcall wil::details::UnsubscribeWilWnf(wil::details *this, struct __WIL__WNF_USER_SUBSCRIPTION *a2)
{
  FARPROC ProcAddress; // rax
  HMODULE NtDllModuleHandle; // rax

  ProcAddress = (FARPROC)g_wil_details_pfnRtlUnsubscribeWnfNotificationWaitForCompletion;
  if ( g_wil_details_pfnRtlUnsubscribeWnfNotificationWaitForCompletion
    || (NtDllModuleHandle = wil_details_GetNtDllModuleHandle(),
        ProcAddress = GetProcAddress(NtDllModuleHandle, "RtlUnsubscribeWnfNotificationWaitForCompletion"),
        (g_wil_details_pfnRtlUnsubscribeWnfNotificationWaitForCompletion = (__int64)ProcAddress) != 0) )
  {
    ((void (__fastcall *)(wil::details *, struct __WIL__WNF_USER_SUBSCRIPTION *))ProcAddress)(this, a2);
  }
}
// 18006026F: variable 'a2' is possibly undefined
// 1800B09D0: using guessed type __int64 g_wil_details_pfnRtlUnsubscribeWnfNotificationWaitForCompletion;

//----- (0000000180060284) ----------------------------------------------------
void __fastcall wil::details_abi::UsageIndexProperty::UpdateCount(wil::details_abi::UsageIndexProperty *this, int a2)
{
  __int16 *v2; // r8
  char v3; // al
  rsize_t v4; // r9
  rsize_t v5; // rdx
  __int16 v6; // [rsp+38h] [rbp+10h] BYREF

  v2 = (__int16 *)((char *)this + 4);
  if ( *((_DWORD *)this + 1) != a2 )
  {
    v3 = *((_BYTE *)this + 2);
    *(_DWORD *)v2 = a2;
    if ( v3 == 1 )
    {
      v4 = 2LL;
      v6 = a2;
      v5 = 2LL;
      v2 = &v6;
    }
    else
    {
      if ( v3 != 2 )
        return;
      v5 = 4LL;
      v4 = 4LL;
    }
    memcpy_s(*((void *const *)this + 2), v5, v2, v4);
  }
}

//----- (00000001800602E0) ----------------------------------------------------
void __fastcall wil::details::WilApiImpl_RecordFeatureUsage(wil::details *this, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // esi
  int v4; // ebx
  unsigned int v5; // edi

  v3 = a2 >> 31;
  v4 = a2 & 0x7FFFFFFF;
  v5 = (unsigned int)this;
  if ( (_DWORD)this || a3 || v4 )
  {
    if ( (a2 & 0x40000000) != 0 )
    {
      wil::details::FeatureStateManager::QueueBackgroundSRUMUsageReporting(
        &wil::details::g_featureStateManager,
        (int)this,
        a2,
        a3);
    }
    else if ( a3 || v4 == 254 )
    {
      wil::details::FeatureStateManager::RecordFeatureUsage(&wil::details::g_featureStateManager, (int)this, v4, a3);
    }
    else if ( (unsigned int)wil_RtlStagingConfig_RecordFeatureUsage((int)this, a2, v3) )
    {
      wil_StagingConfig_RecordFeatureUsage(v5, v4, v3);
    }
  }
  else
  {
    wil::details::FeatureStateManager::FlushUsage((wil::details::FeatureStateManager *)&wil::details::g_featureStateManager);
  }
}

//----- (0000000180060390) ----------------------------------------------------
void __fastcall wil::details::WilApiImpl_SubscribeFeatureStateChangeNotification(
        struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ **this,
        struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ **a2,
        void (__stdcall *a3)(void *),
        void *a4)
{
  if ( a3 == (void (__stdcall *)(void *))-1LL )
    wil::details::FeatureStateManager::SubscribeToUsageFlush(
      (RTL_SRWLOCK *)&wil::details::g_featureStateManager,
      this,
      (void (__stdcall *)(void *))a2);
  else
    wil::details::FeatureStateManager::SubscribeToEnabledStateChanges(
      (RTL_SRWLOCK *)&wil::details::g_featureStateManager,
      this,
      (void (__stdcall *)(void *))a2,
      (__int64)a3);
}

//----- (00000001800603D0) ----------------------------------------------------
void __fastcall wil::details::WilApiImpl_UnsubscribeFeatureStateChangeNotification(
        struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ *this,
        struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ *a2)
{
  struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ *v2; // r8
  struct _RTL_CRITICAL_SECTION *v3; // rcx

  if ( ((unsigned int)this & 0x80000000) != 0 )
  {
    if ( !wil::details::g_featureStateManager )
      return;
    v2 = (struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ *)((unsigned __int64)this & 0xFFFFFFFF7FFFFFFFuLL);
    v3 = (struct _RTL_CRITICAL_SECTION *)&unk_1800B0E28;
  }
  else
  {
    if ( !wil::details::g_featureStateManager )
      return;
    v2 = this;
    v3 = (struct _RTL_CRITICAL_SECTION *)&unk_1800B0DC8;
  }
  wil::details_abi::SubscriptionList::Unsubscribe(v3, (RTL_SRWLOCK *)&unk_1800B0DA0, v2);
}

//----- (0000000180060428) ----------------------------------------------------
void __fastcall wil::details::WilApi_RecordFeatureUsage(wil::details *this)
{
  void (__fastcall *v1)(wil::details *); // rax

  v1 = (void (__fastcall *)(wil::details *))g_wil_details_internalRecordFeatureUsage;
  if ( g_wil_details_internalRecordFeatureUsage
    || (v1 = (void (__fastcall *)(wil::details *))g_wil_details_apiRecordFeatureUsage) != 0LL )
  {
    v1(this);
  }
}
// 1800B14B8: using guessed type __int64 g_wil_details_internalRecordFeatureUsage;
// 1800B1578: using guessed type __int64 g_wil_details_apiRecordFeatureUsage;

//----- (0000000180060458) ----------------------------------------------------
void __fastcall wil::details::WilApi_SubscribeFeatureStateChangeNotification(
        wil::details *this,
        struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ **a2,
        void (__stdcall *a3)(void *),
        void *a4)
{
  void (__fastcall *v4)(wil::details *, struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ **, void (__stdcall *)(void *), void *); // rax

  v4 = (void (__fastcall *)(wil::details *, struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ **, void (__stdcall *)(void *), void *))g_wil_details_internalSubscribeFeatureStateChangeNotification;
  if ( g_wil_details_internalSubscribeFeatureStateChangeNotification
    || (v4 = (void (__fastcall *)(wil::details *, struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ **, void (__stdcall *)(void *), void *))g_wil_details_apiSubscribeFeatureStateChangeNotification) != 0LL )
  {
    v4(this, a2, a3, a4);
  }
  else
  {
    *(_QWORD *)this = 0LL;
  }
}
// 1800B1570: using guessed type __int64 g_wil_details_internalSubscribeFeatureStateChangeNotification;
// 1800B15C0: using guessed type __int64 g_wil_details_apiSubscribeFeatureStateChangeNotification;

//----- (0000000180060490) ----------------------------------------------------
void __fastcall wil::details::WilApi_UnsubscribeFeatureStateChangeNotification(
        wil::details *this,
        struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ *a2)
{
  void (__fastcall *v2)(wil::details *, struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ *); // rax

  v2 = (void (__fastcall *)(wil::details *, struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ *))g_wil_details_internalUnsubscribeFeatureStateChangeNotification;
  if ( g_wil_details_internalUnsubscribeFeatureStateChangeNotification
    || (v2 = (void (__fastcall *)(wil::details *, struct FEATURE_STATE_CHANGE_SUBSCRIPTION__ *))g_wil_details_apiUnsubscribeFeatureStateChangeNotification) != 0LL )
  {
    v2(this, a2);
  }
}
// 1800B15D8: using guessed type __int64 g_wil_details_internalUnsubscribeFeatureStateChangeNotification;
// 1800B15E0: using guessed type __int64 g_wil_details_apiUnsubscribeFeatureStateChangeNotification;

//----- (00000001800604C0) ----------------------------------------------------
void __fastcall wil::details::WilDynamicLoadRaiseFailFastException(
        wil::details *this,
        struct _EXCEPTION_RECORD *a2,
        struct _CONTEXT *a3)
{
  unsigned int v4; // ebx
  HMODULE ModuleHandleW; // rax
  FARPROC ProcAddress; // rax

  v4 = (unsigned int)a3;
  ModuleHandleW = GetModuleHandleW(L"kernelbase.dll");
  ProcAddress = GetProcAddress(ModuleHandleW, "RaiseFailFastException");
  if ( ProcAddress )
    ((void (__fastcall *)(wil::details *, struct _EXCEPTION_RECORD *, _QWORD))ProcAddress)(this, a2, v4);
}

//----- (000000018006052C) ----------------------------------------------------
void __fastcall __noreturn wil::details::WilFailFast(wil::details *this, const struct wil::FailureInfo *a2)
{
  struct _EXCEPTION_RECORD *v3; // rdx
  void *v4; // rcx
  ULONG_PTR v5; // rax
  struct _EXCEPTION_RECORD v6; // [rsp+20h] [rbp-A8h] BYREF

  if ( wil::g_pfnWilFailFast )
    wil::g_pfnWilFailFast(this);
  memset_0(&v6, 0, sizeof(v6));
  v4 = (void *)*((_QWORD *)this + 16);
  v6.NumberParameters = 1;
  v6.ExceptionCode = -1073740791;
  v6.ExceptionFlags = 1;
  v6.ExceptionInformation[0] = 7LL;
  if ( !v4 )
    wil::details::WilRaiseFailFastException(&v6, v3, (struct _CONTEXT *)1);
  v6.ExceptionInformation[1] = *((int *)this + 1);
  v5 = *((unsigned int *)this + 14);
  v6.ExceptionAddress = v4;
  v6.ExceptionInformation[2] = v5;
  v6.NumberParameters = 3;
  wil::details::WilRaiseFailFastException(&v6, v3, 0LL);
}
// 18006058E: variable 'v3' is possibly undefined
// 1800B1558: using guessed type bool (__stdcall *wil::g_pfnWilFailFast)(const struct wil::FailureInfo *);

//----- (00000001800605C8) ----------------------------------------------------
void __fastcall __noreturn wil::details::WilRaiseFailFastException(
        struct _EXCEPTION_RECORD *this,
        struct _EXCEPTION_RECORD *a2,
        struct _CONTEXT *a3)
{
  if ( wil::details::g_pfnRaiseFailFastException )
    wil::details::g_pfnRaiseFailFastException(this, 0LL, (unsigned int)a3);
  __fastfail(7u);
}
// 1800B14A8: using guessed type void (__stdcall *wil::details::g_pfnRaiseFailFastException)(struct _EXCEPTION_RECORD *, struct _CONTEXT *, unsigned int);

//----- (00000001800605F4) ----------------------------------------------------
bool __fastcall wil::details_abi::UsageIndexProperty::Write(
        wil::details_abi::UsageIndexProperty *this,
        char **a2,
        char *a3)
{
  char *v4; // rbx
  char *v7; // r14
  __int16 *v8; // r8
  rsize_t v9; // r9
  rsize_t v10; // rdx
  rsize_t v11; // r9
  bool result; // al
  __int16 v13; // [rsp+40h] [rbp+8h] BYREF

  v4 = *a2;
  if ( *((_BYTE *)this + 2) == 1 )
  {
    v7 = v4 + 2;
    if ( v4 + 2 > a3 )
      return 0;
    v8 = &v13;
    v9 = 2LL;
    v13 = *((_WORD *)this + 2);
    v10 = 2LL;
  }
  else
  {
    if ( *((_BYTE *)this + 2) != 2 )
      goto LABEL_8;
    v7 = v4 + 4;
    if ( v4 + 4 > a3 )
      return 0;
    v10 = 4LL;
    v8 = (__int16 *)((char *)this + 4);
    v9 = 4LL;
  }
  memcpy_s(v4, v10, v8, v9);
  v4 = v7;
LABEL_8:
  if ( *(_WORD *)this )
    goto LABEL_11;
  if ( v4 + 2 > a3 )
    return 0;
  memcpy_s(v4, a3 - v4, (char *)this + 8, 2uLL);
  v4 += 2;
LABEL_11:
  v11 = *((unsigned __int16 *)this + 4);
  if ( &v4[v11] > a3 )
    return 0;
  memcpy_s(v4, a3 - v4, *((const void *const *)this + 3), v11);
  result = 1;
  *a2 = &v4[*((unsigned __int16 *)this + 4)];
  return result;
}

//----- (00000001800606F0) ----------------------------------------------------
_QWORD *__fastcall std::_Tree_buy<JobMoniker>::_Buynode0(_QWORD *a1)
{
  _QWORD *result; // rax

  result = operator new(0x48uLL);
  if ( !result )
    std::_Xbad_alloc();
  *result = *a1;
  result[1] = *a1;
  result[2] = *a1;
  return result;
}

//----- (0000000180060764) ----------------------------------------------------
void __fastcall wil::details::in1diag3::_FailFast_GetLastError(
        wil::details::in1diag3 *this,
        void *a2,
        __int64 a3,
        const char *a4)
{
  __int64 v4; // [rsp+20h] [rbp-28h]
  const char *retaddr; // [rsp+48h] [rbp+0h]

  wil::details::ReportFailure_GetLastError(this, a2, a3, a4, v4, retaddr);
}
// 180060772: variable 'v4' is possibly undefined

//----- (0000000180060784) ----------------------------------------------------
void __fastcall wil::details::in1diag3::_FailFast_Unexpected(
        wil::details::in1diag3 *this,
        void *a2,
        __int64 a3,
        const char *a4)
{
  __int64 retaddr; // [rsp+48h] [rbp+0h]

  wil::details::ReportFailure_Hr(
    (__int64)this,
    0x133Au,
    (__int64)"onecore\\internal\\sdk\\inc\\wil\\Staging.h",
    0LL,
    0LL,
    retaddr,
    3,
    0x8000FFFF);
}

//----- (00000001800607D0) ----------------------------------------------------
void **__fastcall wistd::__function::__func<_lambda_8db0ce862824541f40dfb767113f1e28_,bool (void *,unsigned __int64,void *,unsigned __int64,unsigned int)>::__move(
        __int64 a1,
        __int64 a2)
{
  void **result; // rax

  result = &wistd::__function::__func<_lambda_8db0ce862824541f40dfb767113f1e28_,bool (void *,unsigned __int64,void *,unsigned __int64,unsigned int)>::`vftable';
  *(_QWORD *)a2 = &wistd::__function::__func<_lambda_8db0ce862824541f40dfb767113f1e28_,bool (void *,unsigned __int64,void *,unsigned __int64,unsigned int)>::`vftable';
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  return result;
}
// 180071718: using guessed type void *wistd::__function::__func<_lambda_8db0ce862824541f40dfb767113f1e28_,bool (void *,unsigned __int64,void *,unsigned __int64,unsigned int)>::`vftable';

//----- (00000001800607F4) ----------------------------------------------------
_QWORD *__fastcall wil::mutex_t<wil::details::unique_storage<wil::details::resource_policy<void *,void (*)(void *),&void wil::details::CloseHandle(void *),wistd::integral_constant<unsigned __int64,0>,void *,void *,0,std::nullptr_t>>,wil::err_returncode_policy>::acquire(
        HANDLE *a1,
        _QWORD *a2)
{
  HANDLE v2; // rdi
  DWORD v4; // eax
  void *v5; // rdx
  __int64 v6; // r8
  const char *v7; // r9
  HANDLE v8; // rcx
  wil::details::in1diag3 *retaddr; // [rsp+28h] [rbp+0h]

  v2 = *a1;
  v4 = WaitForSingleObjectEx(*a1, 0xFFFFFFFF, 0);
  v8 = 0LL;
  if ( v4 != 258 )
  {
    if ( !v4 )
    {
LABEL_6:
      v8 = v2;
      goto LABEL_7;
    }
    if ( v4 != 128 )
    {
      wil::details::in1diag3::FailFast_Unexpected(retaddr, v5, v6, v7);
      __debugbreak();
    }
  }
  if ( (v4 & 0xFFFFFF7F) == 0 )
    goto LABEL_6;
LABEL_7:
  *a2 = v8;
  return a2;
}
// 180060832: variable 'v5' is possibly undefined
// 180060832: variable 'v6' is possibly undefined
// 180060832: variable 'v7' is possibly undefined

//----- (000000018006085C) ----------------------------------------------------
void __fastcall wil::details::shared_buffer::assign(LPVOID *this, int *a2, void *a3)
{
  wil::details::shared_buffer::reset(this);
  if ( a2 )
  {
    *this = a2;
    this[1] = a3;
    _InterlockedIncrement(a2);
  }
}

//----- (00000001800608A0) ----------------------------------------------------
bool __fastcall wil::details::shared_buffer::create(LPVOID *this, const void *Source, void *a3)
{
  HANDLE ProcessHeap; // rax
  int *v7; // rax
  int *v8; // rbx

  if ( !a3 )
  {
    wil::details::shared_buffer::reset(this);
LABEL_7:
    LOBYTE(v7) = 1;
    return (char)v7;
  }
  ProcessHeap = GetProcessHeap();
  v7 = (int *)HeapAlloc(ProcessHeap, 0, (SIZE_T)a3 + 4);
  v8 = v7;
  if ( v7 )
  {
    *v7 = 0;
    if ( Source )
      memcpy_s(v7 + 1, (const rsize_t)a3, Source, (const rsize_t)a3);
    wil::details::shared_buffer::assign(this, v8, a3);
    goto LABEL_7;
  }
  return (char)v7;
}

//----- (0000000180060940) ----------------------------------------------------
char __fastcall wil::details_abi::heap_buffer::ensure(wil::details_abi::heap_buffer *this, unsigned __int64 a2)
{
  unsigned __int64 v2; // r8

  v2 = *((_QWORD *)this + 2) - *(_QWORD *)this;
  if ( a2 + *((_QWORD *)this + 1) - *(_QWORD *)this < v2 )
    return 1;
  if ( a2 < 2 * v2 )
    a2 = 2 * v2;
  return wil::details_abi::heap_buffer::reserve(this, a2);
}

//----- (0000000180060970) ----------------------------------------------------
RTL_SRWLOCK **__fastcall wil::srwlock::lock_exclusive(RTL_SRWLOCK *a1, RTL_SRWLOCK **a2)
{
  AcquireSRWLockExclusive(a1);
  *a2 = a1;
  return a2;
}

//----- (00000001800609A4) ----------------------------------------------------
char __fastcall wil::details_abi::heap_buffer::push_back(void **this, const void *a2, unsigned __int64 a3)
{
  char result; // al

  result = wil::details_abi::heap_buffer::ensure((wil::details_abi::heap_buffer *)this, a3);
  if ( result )
  {
    memcpy_s(this[1], ((_BYTE *)this[2] - (_BYTE *)this[1]) & -(__int64)(this[1] < this[2]), a2, a3);
    this[1] = (char *)this[1] + a3;
    return 1;
  }
  return result;
}

//----- (0000000180060A0C) ----------------------------------------------------
char __fastcall wil::details_abi::heap_buffer::reserve(wil::details_abi::heap_buffer *this, unsigned __int64 a2)
{
  unsigned __int64 v4; // rdi
  char *v5; // rax
  char *v6; // rsi
  rsize_t v8; // r14
  void *v9; // rdx
  wil::details *v10; // rcx
  char v11; // [rsp+40h] [rbp+8h] BYREF

  if ( *((_QWORD *)this + 2) - *(_QWORD *)this < a2 )
  {
    wil::last_error_context::last_error_context((wil::last_error_context *)&v11);
    v4 = (a2 & 0xFFFFFFFFFFFFFFC0uLL) + 64;
    v5 = (char *)wil::details::ProcessHeapAlloc(0, v4);
    v6 = v5;
    if ( !v5 )
    {
      wil::last_error_context::~last_error_context((wil::last_error_context *)&v11);
      return 0;
    }
    v8 = *((_QWORD *)this + 1) - *(_QWORD *)this;
    memcpy_s(v5, v4, *(const void *const *)this, v8);
    v10 = (wil::details *)*((_QWORD *)this + 3);
    *((_QWORD *)this + 3) = v6;
    if ( v10 )
      wil::details::FreeProcessHeap(v10, v9);
    *(_QWORD *)this = v6;
    *((_QWORD *)this + 1) = &v6[v8];
    *((_QWORD *)this + 2) = &v6[v4];
    wil::last_error_context::~last_error_context((wil::last_error_context *)&v11);
  }
  return 1;
}
// 180060A9D: variable 'v9' is possibly undefined

//----- (0000000180060AEC) ----------------------------------------------------
void __fastcall wil::details::unique_storage<wil::details::resource_policy<_TP_TIMER *,void (*)(_TP_TIMER *),&public: static void wil::details::DestroyThreadPoolTimer<wil::details::SystemThreadPoolMethods,0>::Destroy(_TP_TIMER *),wistd::integral_constant<unsigned __int64,0>,_TP_TIMER *,_TP_TIMER *,0,std::nullptr_t>>::reset(
        struct _TP_TIMER **a1,
        struct _TP_TIMER *a2)
{
  struct _TP_TIMER *v2; // rsi
  DWORD LastError; // ebx

  v2 = *a1;
  if ( *a1 )
  {
    LastError = GetLastError();
    wil::details::DestroyThreadPoolTimer<wil::details::SystemThreadPoolMethods,0>::Destroy(v2);
    SetLastError(LastError);
  }
  *a1 = a2;
}

//----- (0000000180060B54) ----------------------------------------------------
void __fastcall wil::details::unique_storage<wil::details::resource_policy<void *,void (*)(void *),&void wil::details::CloseHandle(void *),wistd::integral_constant<unsigned __int64,0>,void *,void *,0,std::nullptr_t>>::reset(
        __int64 *a1,
        __int64 a2)
{
  DWORD LastError; // ebx
  __int64 v5; // [rsp+30h] [rbp+8h] BYREF
  void (__fastcall *v6)(wil::details *, void *); // [rsp+38h] [rbp+10h] BYREF

  if ( *a1 )
  {
    v5 = *a1;
    LastError = GetLastError();
    v6 = wil::details::CloseHandle;
    wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>((__int64 (__fastcall **)(_QWORD))&v6, &v5);
    SetLastError(LastError);
  }
  *a1 = a2;
}

//----- (0000000180060BC8) ----------------------------------------------------
void __fastcall wil::details::unique_storage<wil::details::resource_policy<void *,void (*)(void *),&void wil::details::ReleaseMutex(void *),wistd::integral_constant<unsigned __int64,2>,void *,void *,0,std::nullptr_t>>::reset(
        __int64 *a1,
        __int64 a2)
{
  DWORD LastError; // ebx
  __int64 v5; // [rsp+30h] [rbp+8h] BYREF
  void (__fastcall *v6)(wil::details *, void *); // [rsp+38h] [rbp+10h] BYREF

  if ( *a1 )
  {
    v5 = *a1;
    LastError = GetLastError();
    v6 = wil::details::ReleaseMutex;
    wistd::invoke<void (*)(_RTL_SRWLOCK *),_RTL_SRWLOCK * &>((__int64 (__fastcall **)(_QWORD))&v6, &v5);
    SetLastError(LastError);
  }
  *a1 = a2;
}

//----- (0000000180060C3C) ----------------------------------------------------
void __fastcall wil::details::shared_buffer::reset(LPVOID *this)
{
  volatile signed __int32 *v2; // rcx
  HANDLE ProcessHeap; // rax

  v2 = (volatile signed __int32 *)*this;
  if ( v2 )
  {
    if ( _InterlockedExchangeAdd(v2, 0xFFFFFFFF) == 1 )
    {
      ProcessHeap = GetProcessHeap();
      HeapFree(ProcessHeap, 0, *this);
    }
    *this = 0LL;
    this[1] = 0LL;
  }
}

//----- (0000000180060C90) ----------------------------------------------------
const char *__fastcall wil::ResultException::what(
        wil::ResultException *this,
        __int64 a2,
        __int64 a3,
        const struct wil::FailureInfo *a4)
{
  LPVOID *v4; // rbx
  LPVOID v5; // rax
  __int64 v6; // r8
  char Source[1024]; // [rsp+20h] [rbp-1418h] BYREF
  wchar_t pszDest[2048]; // [rsp+420h] [rbp-1018h] BYREF

  v4 = (LPVOID *)((char *)this + 184);
  v5 = (LPVOID)*((_QWORD *)this + 23);
  if ( !v5 )
  {
    wil::GetFailureLogString(pszDest, (unsigned __int16 *)0x800, (__int64)this + 24, a4);
    wil::details::StringCchPrintfA((wil::details *)Source, (char *)0x400, "%ws", (const char *)pszDest);
    v6 = -1LL;
    do
      ++v6;
    while ( Source[v6] );
    wil::details::shared_buffer::create(v4, Source, (void *)(v6 + 1));
    v5 = *v4;
  }
  return (const char *)(((unsigned __int64)v5 + 4) & -(__int64)(v5 != 0LL));
}
// 180060C90: using guessed type char Source[1024];

//----- (0000000180060D48) ----------------------------------------------------
__int64 __fastcall wil_details_WriteSRUMWnfUsageBuffer(__int64 *a1, __int64 a2, __int64 a3)
{
  unsigned int WnfStateData; // ebx
  unsigned int updated; // edi
  int v6; // esi
  __int64 v7; // r9
  __int64 v8; // r8
  __int64 v9; // rcx
  unsigned int v10; // r10d
  __int64 v11; // rdi
  _DWORD *v12; // rdx
  _DWORD *v13; // rcx
  int v15; // [rsp+20h] [rbp-E0h]
  unsigned int v16; // [rsp+40h] [rbp-C0h] BYREF
  int v17[3]; // [rsp+44h] [rbp-BCh] BYREF
  _DWORD v18[1024]; // [rsp+50h] [rbp-B0h] BYREF

  WnfStateData = 0;
  updated = 0;
  if ( (unsigned __int64)(a1[1] - *a1) >= 0xC )
  {
    v6 = 0;
    do
    {
      v16 = 4096;
      WnfStateData = wil_details_NtQueryWnfStateData(
                       (__int64)&unk_1800805B0,
                       a2,
                       a3,
                       (__int64)v17,
                       (__int64)v18,
                       (__int64)&v16);
      if ( !WnfStateData )
      {
        v7 = v16;
        v8 = *a1;
        if ( v16 != 12 * (v16 / 0xCuLL) )
          v7 = 0LL;
        v9 = a1[1];
        v16 = v7;
        v10 = (unsigned int)v7 / 0xC;
        v11 = v8 + 12 * ((v9 - v8) / 0xCuLL);
        while ( v8 != v11 )
        {
          v12 = &v18[3 * v10];
          if ( v18 == v12 )
          {
LABEL_12:
            if ( (unsigned __int64)(unsigned int)v7 + 12 <= 0x1000 )
            {
              v7 = (unsigned int)(v7 + 12);
              *(_QWORD *)v12 = *(_QWORD *)v8;
              ++v10;
              v12[2] = *(_DWORD *)(v8 + 8);
              v16 = v7;
            }
          }
          else
          {
            v13 = v18;
            while ( *v13 != *(_DWORD *)v8 || *((_WORD *)v13 + 2) != *(_WORD *)(v8 + 4) )
            {
              v13 += 3;
              if ( v13 == v12 )
                goto LABEL_12;
            }
            v13[2] += *(_DWORD *)(v8 + 8);
            v7 = v16;
          }
          v8 += 12LL;
        }
        updated = wil_details_NtUpdateWnfStateData((__int64)&unk_1800805B0, (__int64)v18, v7, v7, v15, v17[0], 1);
      }
      ++v6;
    }
    while ( updated == -1073741823 && v6 < 100 && !WnfStateData );
  }
  if ( !WnfStateData )
    return updated;
  return WnfStateData;
}
// 180060DD7: variable 'a2' is possibly undefined
// 180060DD7: variable 'a3' is possibly undefined
// 180060EC4: variable 'v15' is possibly undefined
// 180060D48: using guessed type int var_102C[3];

//----- (0000000180060F34) ----------------------------------------------------
__int64 __fastcall WPP_SF_S_guid_(__int64 a1, __int64 a2, __int64 a3, const wchar_t *a4)
{
  __int64 v4; // rax

  if ( a4 )
  {
    v4 = -1LL;
    do
      ++v4;
    while ( a4[v4] );
  }
  if ( !a4 )
    a4 = L"NULL";
  return EtwTraceMessage(a1, 43LL, &WPP_0fa9442aab3237762f9b607a66102705_Traceguids, 105LL, a4);
}
// 1800747B0: using guessed type __int64 __fastcall EtwTraceMessage(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 18007F5B8: using guessed type wchar_t aNull_1[5];

//----- (0000000180060FC4) ----------------------------------------------------
__int64 __fastcall WPP_SF_dD(__int64 a1, unsigned __int16 a2, __int64 a3, int a4)
{
  int v5; // [rsp+78h] [rbp+20h] BYREF

  v5 = a4;
  return EtwTraceMessage(a1, 43LL, &WPP_0fa9442aab3237762f9b607a66102705_Traceguids, a2, &v5);
}
// 1800747B0: using guessed type __int64 __fastcall EtwTraceMessage(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180061028) ----------------------------------------------------
__int64 __fastcall CredStore::AddrefUserRecord(LPCRITICAL_SECTION lpCriticalSection, User *this, void **a3)
{
  signed int SidString; // ebx
  const WCHAR *v7; // rdx
  LSTATUS v8; // eax
  bool v9; // cc
  bool v10; // sf
  void *v11; // rax
  char *v12; // rcx
  __int64 v13; // r8
  signed __int64 v14; // rdx
  __int16 v15; // ax
  char *v16; // rax
  DWORD cbData; // [rsp+50h] [rbp-B0h] BYREF
  BYTE v19[4]; // [rsp+54h] [rbp-ACh] BYREF
  BSTR *Data; // [rsp+58h] [rbp-A8h] BYREF
  HKEY hKey; // [rsp+60h] [rbp-A0h] BYREF
  const WCHAR **v22; // [rsp+68h] [rbp-98h] BYREF
  BSTR *v23; // [rsp+70h] [rbp-90h] BYREF
  DWORD dwDisposition; // [rsp+78h] [rbp-88h] BYREF
  __int64 v25; // [rsp+80h] [rbp-80h]
  char pExceptionObject[56]; // [rsp+88h] [rbp-78h] BYREF
  GUID pguid; // [rsp+C0h] [rbp-40h] BYREF
  OLECHAR sz[40]; // [rsp+D0h] [rbp-30h] BYREF

  v25 = -2LL;
  v23 = 0LL;
  memset_0(sz, 0, sizeof(sz));
  SidString = User::GetSidString(this, (struct _bstr_t *)&v23);
  if ( SidString >= 0 )
  {
    hKey = 0LL;
    _bstr_t::_bstr_t((_bstr_t *)&v22, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Schedule\\CredWom");
    _bstr_t::_bstr_t((_bstr_t *)&Data, L"\\");
    _bstr_t::operator+=((OLECHAR ***)&v22, &Data);
    _bstr_t::~_bstr_t((_bstr_t *)&Data);
    _bstr_t::operator+=((OLECHAR ***)&v22, &v23);
    CredStore::Lock(lpCriticalSection);
    if ( v22 )
      v7 = *v22;
    else
      v7 = 0LL;
    v8 = RegCreateKeyExW(HKEY_LOCAL_MACHINE, v7, 0, 0LL, 0, 0x2001Fu, 0LL, &hKey, &dwDisposition);
    SidString = v8;
    v9 = v8 <= 0;
    if ( v8 )
      goto LABEL_6;
    if ( dwDisposition == 1 )
    {
      LODWORD(Data) = 1;
      SidString = CoCreateGuid(&pguid);
      if ( SidString >= 0 )
      {
        StringFromGUID2(&pguid, sz, 39);
        SidString = RegSetValueExW(hKey, L"Count", 0, 4u, (const BYTE *)&Data, 4u);
        if ( !SidString )
        {
          SidString = RegSetValueExW(hKey, L"Index", 0, 1u, (const BYTE *)sz, 0x4Eu);
          if ( !SidString )
          {
LABEL_23:
            v11 = operator new(0x74uLL);
            wmi::AutoVectorPtr<unsigned char>::operator=(a3, v11);
            v12 = (char *)*a3;
            if ( !*a3 )
            {
              wmi::OutOfMemoryException::OutOfMemoryException((wmi::OutOfMemoryException *)pExceptionObject);
              CxxThrowException_0(pExceptionObject, (_ThrowInfo *)&TI4_AVOutOfMemoryException_wmi__);
            }
            v13 = 58LL;
            v14 = (char *)L"TaskScheduler:Task:" - v12;
            do
            {
              if ( v13 == -2147483588 )
                break;
              v15 = *(_WORD *)&v12[v14];
              if ( !v15 )
                break;
              *(_WORD *)v12 = v15;
              v12 += 2;
              --v13;
            }
            while ( v13 );
            v16 = v12 - 2;
            if ( v13 )
              v16 = v12;
            *(_WORD *)v16 = 0;
            SidString = v13 == 0 ? 0x8007007A : 0;
            if ( v13 )
              SidString = StringCchCopyW((char *)*a3 + 38, 39LL, (char *)sz);
            goto LABEL_32;
          }
        }
LABEL_20:
        v10 = SidString < 0;
        if ( SidString > 0 )
        {
          SidString = (unsigned __int16)SidString | 0x80070000;
          v10 = SidString < 0;
        }
        if ( v10 )
          goto LABEL_32;
        goto LABEL_23;
      }
    }
    else
    {
      cbData = 78;
      v8 = RegQueryValueExW(hKey, L"Index", 0LL, (LPDWORD)&Data, (LPBYTE)sz, &cbData);
      SidString = v8;
      v9 = v8 <= 0;
      if ( v8 )
      {
LABEL_6:
        if ( !v9 )
          SidString = (unsigned __int16)v8 | 0x80070000;
        goto LABEL_32;
      }
      cbData = 4;
      SidString = RegQueryValueExW(hKey, L"Count", 0LL, (LPDWORD)&Data, v19, &cbData);
      if ( SidString )
        goto LABEL_20;
      if ( (_DWORD)Data == 4 )
      {
        if ( *(_DWORD *)v19 != -1 )
        {
          ++*(_DWORD *)v19;
          SidString = RegSetValueExW(hKey, L"Count", 0, 4u, v19, 4u);
          goto LABEL_20;
        }
        SidString = -2147024362;
      }
      else
      {
        SidString = -2147216623;
      }
    }
LABEL_32:
    CredStore::Unlock(lpCriticalSection);
    _bstr_t::~_bstr_t((_bstr_t *)&v22);
    wmi::AutoRegKey::~AutoRegKey((wmi::AutoRegKey *)&hKey);
  }
  _bstr_t::~_bstr_t((_bstr_t *)&v23);
  return (unsigned int)SidString;
}

//----- (0000000180061434) ----------------------------------------------------
__int64 __fastcall CredStore::DeleteNtCredential(struct _RTL_CRITICAL_SECTION *this, const struct User *a2)
{
  unsigned int v2; // ebx
  signed int LastError; // eax
  LPCWSTR TargetName; // [rsp+58h] [rbp+20h] BYREF

  TargetName = 0LL;
  v2 = CredStore::ReleaseRefUserRecord(this, a2, (void **)&TargetName);
  if ( !v2 && !CredDeleteW(TargetName, 2u, 0x4004u) && GetLastError() != 1168 )
  {
    LastError = GetLastError();
    v2 = LastError;
    if ( LastError > 0 )
      v2 = (unsigned __int16)LastError | 0x80070000;
  }
  operator delete((void *)TargetName);
  return v2;
}

//----- (00000001800614CC) ----------------------------------------------------
__int64 __fastcall CredStore::GetAliasCredId(char *a1, void **a2)
{
  __int64 v3; // rbx
  unsigned __int64 v5; // rbx
  void *v6; // rax
  char *v7; // rdx
  signed int v8; // ecx
  unsigned __int64 v9; // rcx
  signed __int64 v10; // r9
  __int16 v11; // ax
  char *v12; // rax
  void **pExceptionObject; // [rsp+20h] [rbp-48h] BYREF
  char v15; // [rsp+28h] [rbp-40h]
  const unsigned __int16 *v16; // [rsp+30h] [rbp-38h]
  __int64 v17; // [rsp+38h] [rbp-30h]
  __int64 v18; // [rsp+40h] [rbp-28h]
  int v19; // [rsp+48h] [rbp-20h]
  int v20; // [rsp+4Ch] [rbp-1Ch]
  int v21; // [rsp+50h] [rbp-18h]

  v3 = -1LL;
  do
    ++v3;
  while ( *(_WORD *)&a1[2 * v3] );
  v5 = v3 + 21;
  v6 = operator new(saturated_mul(v5, 2uLL));
  wmi::AutoVectorPtr<unsigned char>::operator=(a2, v6);
  v7 = (char *)*a2;
  if ( !*a2 )
  {
    v20 = -1;
    v16 = &word_18007630E;
    v15 = 0;
    pExceptionObject = &wmi::OutOfMemoryException::`vftable';
    v17 = 0LL;
    v18 = 0LL;
    v19 = 14;
    v21 = -1;
    CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI4_AVOutOfMemoryException_wmi__);
  }
  v8 = 0;
  if ( v5 - 1 > 0x7FFFFFFE )
    v8 = -2147024809;
  if ( v8 < 0 )
  {
    if ( v5 )
      *(_WORD *)v7 = 0;
  }
  else
  {
    v9 = v5;
    if ( v5 )
    {
      v10 = (char *)L"TaskScheduler:Alias:" - v7;
      do
      {
        if ( !(2147483646 - v5 + v9) )
          break;
        v11 = *(_WORD *)&v7[v10];
        if ( !v11 )
          break;
        *(_WORD *)v7 = v11;
        v7 += 2;
        --v9;
      }
      while ( v9 );
    }
    v12 = v7 - 2;
    if ( v9 )
      v12 = v7;
    v8 = v9 == 0 ? 0x8007007A : 0;
    *(_WORD *)v12 = 0;
  }
  if ( v8 >= 0 )
    return StringCchCatW((unsigned __int16 *)*a2, v5, a1);
  else
    return (unsigned int)v8;
}
// 180073740: using guessed type void *wmi::OutOfMemoryException::`vftable';
// 180080640: using guessed type wchar_t aTaskschedulerA[21];

//----- (0000000180061624) ----------------------------------------------------
__int64 __fastcall CredStore::GetCredId(User *this, void **a2)
{
  CredStore *v4; // rcx
  signed int SidString; // ebx
  const WCHAR *v6; // rdx
  LSTATUS v7; // eax
  LSTATUS v8; // eax
  bool v9; // sf
  void *v10; // rax
  char *v11; // rcx
  __int64 v12; // rdx
  signed __int64 v13; // r8
  __int16 v14; // ax
  char *v15; // rax
  HKEY phkResult; // [rsp+38h] [rbp-79h] BYREF
  HKEY hKey; // [rsp+40h] [rbp-71h] BYREF
  const WCHAR **v19; // [rsp+48h] [rbp-69h] BYREF
  DWORD cbData; // [rsp+50h] [rbp-61h] BYREF
  DWORD Type; // [rsp+54h] [rbp-5Dh] BYREF
  void **pExceptionObject; // [rsp+58h] [rbp-59h] BYREF
  char v23; // [rsp+60h] [rbp-51h]
  const unsigned __int16 *v24; // [rsp+68h] [rbp-49h]
  __int64 v25; // [rsp+70h] [rbp-41h]
  __int64 v26; // [rsp+78h] [rbp-39h]
  int v27; // [rsp+80h] [rbp-31h]
  int v28; // [rsp+84h] [rbp-2Dh]
  int v29; // [rsp+88h] [rbp-29h]
  __int64 v30; // [rsp+90h] [rbp-21h]
  BYTE Data[80]; // [rsp+98h] [rbp-19h] BYREF

  v30 = -2LL;
  v19 = 0LL;
  memset_0(Data, 0, 0x4EuLL);
  SidString = User::GetSidString(this, (struct _bstr_t *)&v19);
  if ( SidString >= 0 )
  {
    hKey = 0LL;
    SidString = CredStore::OpenCredManagerKey(v4, &hKey);
    if ( SidString >= 0 )
    {
      phkResult = 0LL;
      if ( v19 )
        v6 = *v19;
      else
        v6 = 0LL;
      v7 = RegOpenKeyExW(hKey, v6, 0, 0x20019u, &phkResult);
      SidString = v7;
      if ( v7 > 0 )
        SidString = (unsigned __int16)v7 | 0x80070000;
      if ( SidString >= 0 )
      {
        cbData = 78;
        v8 = RegQueryValueExW(phkResult, L"Index", 0LL, &Type, Data, &cbData);
        v9 = v8 < 0;
        if ( v8 > 0 )
          v9 = 1;
        if ( v9 || Type == 1 )
        {
          v10 = operator new(0x74uLL);
          wmi::AutoVectorPtr<unsigned char>::operator=(a2, v10);
          v11 = (char *)*a2;
          if ( !*a2 )
          {
            v23 = 0;
            v24 = &word_18007630E;
            v25 = 0LL;
            v26 = 0LL;
            v27 = 14;
            v28 = -1;
            v29 = -1;
            pExceptionObject = &wmi::OutOfMemoryException::`vftable';
            CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI4_AVOutOfMemoryException_wmi__);
          }
          v12 = 58LL;
          v13 = (char *)L"TaskScheduler:Task:" - v11;
          do
          {
            if ( v12 == -2147483588 )
              break;
            v14 = *(_WORD *)&v11[v13];
            if ( !v14 )
              break;
            *(_WORD *)v11 = v14;
            v11 += 2;
            --v12;
          }
          while ( v12 );
          v15 = v11 - 2;
          if ( v12 )
            v15 = v11;
          *(_WORD *)v15 = 0;
          SidString = v12 == 0 ? 0x8007007A : 0;
          if ( v12 )
            SidString = StringCchCopyW((char *)*a2 + 38, 39LL, (char *)Data);
        }
        else
        {
          SidString = -2147216623;
        }
      }
      wmi::AutoRegKey::Close(&phkResult);
    }
    wmi::AutoRegKey::Close(&hKey);
  }
  _bstr_t::_Free((_bstr_t *)&v19);
  return (unsigned int)SidString;
}
// 180061688: variable 'v4' is possibly undefined
// 180073740: using guessed type void *wmi::OutOfMemoryException::`vftable';

//----- (0000000180061870) ----------------------------------------------------
__int64 __fastcall CredStore::InitAliasesKey(CredStore *this)
{
  HKEY *phkResult; // rdi
  struct _RTL_CRITICAL_SECTION *v3; // rbx
  LSTATUS v4; // eax
  unsigned int v5; // edi
  struct _SECURITY_ATTRIBUTES SecurityAttributes; // [rsp+50h] [rbp-28h] BYREF

  phkResult = (HKEY *)((char *)this + 40);
  if ( *((_QWORD *)this + 5) )
    return 0LL;
  v3 = (struct _RTL_CRITICAL_SECTION *)((char *)this + 48);
  EnterCriticalSection((LPCRITICAL_SECTION)((char *)this + 48));
  if ( *phkResult
    || (SecurityAttributes.bInheritHandle = 0,
        SecurityAttributes.lpSecurityDescriptor = tsched::StoreSecurity::g_pRestrictedKeySecurity,
        SecurityAttributes.nLength = 24,
        v4 = RegCreateKeyExW(
               HKEY_LOCAL_MACHINE,
               L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Schedule\\Aliases",
               0,
               0LL,
               0,
               0x2001Fu,
               &SecurityAttributes,
               phkResult,
               0LL),
        (v5 = v4) == 0) )
  {
    v5 = 0;
  }
  else if ( v4 > 0 )
  {
    v5 = (unsigned __int16)v4 | 0x80070000;
  }
  LeaveCriticalSection(v3);
  return v5;
}

//----- (000000018006193C) ----------------------------------------------------
__int64 __fastcall NotifyLsaOfPasswordChange(char *a1, char *a2, char *a3)
{
  WCHAR *v4; // rsi
  NTSTATUS v7; // eax
  NTSTATUS v8; // ecx
  ULONG v9; // ebx
  __int64 v10; // rcx
  __int64 v11; // rax
  __int64 v12; // rdx
  __int64 v13; // rax
  unsigned __int64 v14; // r15
  HANDLE ProcessHeap; // rax
  WCHAR *v16; // rax
  unsigned int v17; // edi
  const WCHAR *v18; // r14
  __int64 v19; // rax
  WCHAR *v20; // r14
  unsigned int v21; // edi
  __int64 v22; // rax
  WCHAR *v23; // r14
  unsigned int v24; // edi
  HANDLE v25; // rax
  ULONG AuthenticationPackage; // [rsp+40h] [rbp-30h] BYREF
  ULONG ReturnBufferLength; // [rsp+44h] [rbp-2Ch] BYREF
  void *LsaHandle; // [rsp+48h] [rbp-28h] BYREF
  PVOID Buffer; // [rsp+50h] [rbp-20h] BYREF
  struct _STRING DestinationString; // [rsp+58h] [rbp-18h] BYREF
  NTSTATUS Status; // [rsp+C8h] [rbp+58h] BYREF

  LsaHandle = 0LL;
  v4 = 0LL;
  Buffer = 0LL;
  v7 = LsaConnectUntrusted(&LsaHandle);
  if ( v7 )
    goto LABEL_2;
  RtlInitString(&DestinationString, "MICROSOFT_AUTHENTICATION_PACKAGE_V1_0");
  v7 = LsaLookupAuthenticationPackage(LsaHandle, (PLSA_STRING)&DestinationString, &AuthenticationPackage);
  if ( v7 )
    goto LABEL_2;
  v10 = -1LL;
  v11 = -1LL;
  do
    ++v11;
  while ( *(_WORD *)&a1[2 * v11] );
  v12 = -1LL;
  do
    ++v12;
  while ( *(_WORD *)&a2[2 * v12] );
  v13 = v12 + v11;
  do
    ++v10;
  while ( *(_WORD *)&a3[2 * v10] );
  v14 = 2 * (v10 + v13) + 86;
  if ( v14 > 0xFFFFFFFF )
  {
    v9 = 534;
    goto LABEL_24;
  }
  ProcessHeap = GetProcessHeap();
  v9 = 8;
  v16 = (WCHAR *)HeapAlloc(ProcessHeap, 8u, (unsigned int)v14);
  v4 = v16;
  if ( v16 )
  {
    v17 = v14 - 80;
    *(_DWORD *)v16 = 6;
    v18 = v16 + 40;
    if ( (unsigned int)(v14 - 80) >= 2 && (int)StringCbCopyW((char *)v16 + 80, v17, a2) >= 0 )
    {
      RtlInitUnicodeString((PUNICODE_STRING)(v4 + 4), v18);
      v19 = v4[5];
      v20 = (WCHAR *)((char *)v18 + v19);
      v21 = v17 - v19;
      if ( v21 >= 2 && (int)StringCbCopyW((char *)v20, v21, a1) >= 0 )
      {
        RtlInitUnicodeString((PUNICODE_STRING)(v4 + 12), v20);
        v22 = v4[13];
        v23 = (WCHAR *)((char *)v20 + v22);
        v24 = v21 - v22;
        if ( v24 >= 2 && (int)StringCbCopyW((char *)v23, v24, a3) >= 0 )
        {
          RtlInitUnicodeString((PUNICODE_STRING)(v4 + 28), v23);
          v7 = LsaCallAuthenticationPackage(
                 LsaHandle,
                 AuthenticationPackage,
                 v4,
                 v14,
                 &Buffer,
                 &ReturnBufferLength,
                 &Status);
          if ( !v7 )
          {
            if ( RtlNtStatusToDosError(Status) )
            {
              v8 = Status;
              goto LABEL_3;
            }
            v9 = 0;
            goto LABEL_24;
          }
LABEL_2:
          v8 = v7;
LABEL_3:
          v9 = RtlNtStatusToDosError(v8);
        }
      }
    }
  }
LABEL_24:
  if ( LsaHandle )
    LsaDeregisterLogonProcess(LsaHandle);
  if ( v4 )
  {
    v25 = GetProcessHeap();
    HeapFree(v25, 0, v4);
  }
  if ( Buffer )
    LsaFreeReturnBuffer(Buffer);
  return v9;
}

//----- (0000000180061BC0) ----------------------------------------------------
int __fastcall CredStore::ResolveAlias(HKEY *this, const unsigned __int16 *a2, User::UserEntry **a3)
{
  int result; // eax
  DWORD v7; // ecx
  unsigned __int64 v8; // r15
  __int64 v9; // rsi
  _WORD *v10; // rax
  _WORD *lpData; // rbx
  int v12; // edi
  signed int LastError; // eax
  bool v14; // cc
  __int64 v15; // rax
  unsigned __int64 v16; // rax
  const wchar_t *v17; // rcx
  __int64 v18; // rdx
  const WCHAR *v19; // rdi
  __int64 v20; // rax
  int v21; // r14d
  PSID v22; // rsi
  User::UserEntry **v23; // rax
  PSID Sid; // [rsp+30h] [rbp-40h] BYREF
  WCHAR **v25; // [rsp+38h] [rbp-38h] BYREF
  char v26[8]; // [rsp+40h] [rbp-30h] BYREF
  __int64 v27; // [rsp+48h] [rbp-28h]
  _WORD *v28; // [rsp+50h] [rbp-20h]
  char v29; // [rsp+58h] [rbp-18h]
  HLOCAL (__stdcall *v30)(HLOCAL); // [rsp+60h] [rbp-10h]
  PSID v31; // [rsp+68h] [rbp-8h]
  DWORD cbData; // [rsp+B8h] [rbp+48h] BYREF
  DWORD Type; // [rsp+C8h] [rbp+58h] BYREF

  v27 = -2LL;
  if ( !a2 )
    return -2147024809;
  result = CredStore::InitAliasesKey((CredStore *)this);
  if ( result >= 0 )
  {
    Type = 0;
    cbData = 0;
    result = RegQueryValueExW(this[5], a2, 0LL, &Type, 0LL, &cbData);
    if ( result )
    {
      if ( result > 0 )
        return (unsigned __int16)result | 0x80070000;
      return result;
    }
    if ( Type != 7 )
      return -2147418113;
    v7 = cbData;
    if ( !cbData )
      return -2147418113;
    cbData += 2;
    v8 = (unsigned __int64)(v7 + 2) >> 1;
    v9 = -1LL;
    v10 = operator new(saturated_mul(v8, 2uLL));
    lpData = v10;
    v28 = v10;
    if ( !v10 )
    {
      v12 = -2147024882;
LABEL_46:
      operator delete(lpData);
      return v12;
    }
    memset_0(v10, 0, cbData);
    LastError = RegQueryValueExW(this[5], a2, 0LL, &Type, (LPBYTE)lpData, &cbData);
    v12 = LastError;
    v14 = LastError <= 0;
    if ( LastError )
    {
LABEL_36:
      if ( !v14 )
        v12 = (unsigned __int16)LastError | 0x80070000;
      goto LABEL_46;
    }
    if ( Type != 7 )
      goto LABEL_30;
    if ( !*lpData )
      goto LABEL_17;
    v15 = -1LL;
    do
      ++v15;
    while ( lpData[v15] );
    v16 = v15 + 1;
    if ( v16 >= v8 )
    {
LABEL_17:
      v12 = -2147467259;
      goto LABEL_46;
    }
    v17 = &lpData[v16];
    if ( *v17 )
    {
      v18 = -1LL;
      do
        ++v18;
      while ( v17[v18] );
      v16 += v18 + 1;
    }
    else
    {
      v17 = 0LL;
    }
    v19 = &lpData[v16];
    if ( v16 < v8 && *v19 )
    {
      do
        ++v9;
      while ( v19[v9] );
      v16 += v9 + 1;
    }
    else
    {
      v19 = 0LL;
    }
    v20 = 2 * v16;
    if ( v20 != cbData && v20 + 2 != cbData )
    {
LABEL_30:
      v12 = -2147418113;
      goto LABEL_46;
    }
    v21 = 8;
    if ( v17 )
      v21 = _wtoi(v17);
    v22 = 0LL;
    Sid = 0LL;
    if ( v19 )
    {
      if ( !ConvertStringSidToSidW(v19, &Sid) )
      {
        LastError = GetLastError();
        v12 = LastError;
        v14 = LastError <= 0;
        goto LABEL_36;
      }
      v22 = Sid;
    }
    v29 = 0;
    v30 = LocalFree;
    v31 = v22;
    if ( v22 )
    {
      if ( !IsValidSid(v22) )
      {
        v12 = -2147024809;
LABEL_45:
        LocalFree(v22);
        goto LABEL_46;
      }
      if ( Sid )
      {
        _bstr_t::_bstr_t((_bstr_t *)&v25, lpData);
        v23 = (User::UserEntry **)User::CreateUser((User::UserEntry *)v26, &v25, (enum _SID_NAME_USE)v21, Sid, 0);
        wmi::AutoRef<User::UserEntry>::operator=(a3, *v23);
        wmi::AutoRef<User::UserEntry>::Release(v26);
        _bstr_t::_Free((_bstr_t *)&v25);
        v12 = 0;
        goto LABEL_45;
      }
    }
    v12 = User::FromUsername(a3, lpData);
    goto LABEL_45;
  }
  return result;
}
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);
// 180061BC0: using guessed type char var_30[8];

//----- (0000000180061EC8) ----------------------------------------------------
__int64 __fastcall CredStore::StoreNtCredential(
        LPCRITICAL_SECTION lpCriticalSection,
        const struct User *this,
        unsigned __int16 *a3)
{
  unsigned int v6; // esi
  char v7; // bl
  __int64 v8; // rcx
  __int64 *Domain; // rax
  __int64 *Account; // rax
  char v11; // di
  int LastError; // eax
  WCHAR *v13; // rbx
  WCHAR **v14; // rax
  WCHAR *v15; // rax
  __int64 *v16; // rdi
  __int64 *v17; // rax
  char *v18; // rdx
  char **v19; // rax
  char *v20; // rcx
  void *v22[2]; // [rsp+20h] [rbp-60h] BYREF
  struct _CREDENTIALW Credential; // [rsp+30h] [rbp-50h] BYREF
  void *lpMem; // [rsp+C8h] [rbp+48h] BYREF
  __int64 v25; // [rsp+D0h] [rbp+50h] BYREF
  int v26; // [rsp+D8h] [rbp+58h]

  v22[1] = (void *)-2LL;
  v6 = 0;
  v7 = 0;
  v26 = 0;
  v22[0] = a3;
  if ( !*(_QWORD *)this
    || User::IsAlias(this)
    || (Domain = User::GetDomain(v8, &v25), v7 = 1, _bstr_t::operator!(Domain))
    || (Account = User::GetAccount((__int64)this, (__int64 *)&lpMem), v7 = 3, v11 = 0, _bstr_t::operator!(Account)) )
  {
    v11 = 1;
  }
  if ( (v7 & 2) != 0 )
  {
    v7 &= ~2u;
    _bstr_t::_Free((_bstr_t *)&lpMem);
  }
  if ( (v7 & 1) != 0 )
    _bstr_t::_Free((_bstr_t *)&v25);
  if ( v11 || !a3 )
  {
    v6 = -2147024809;
    goto LABEL_32;
  }
  lpMem = 0LL;
  LastError = CredStore::AddrefUserRecord(lpCriticalSection, this, &lpMem);
  v13 = (WCHAR *)lpMem;
  if ( LastError >= 0 )
  {
    lpMem = 0LL;
    LastError = StringCchLengthW(a3, 0x101uLL, (unsigned __int64 *)&lpMem);
    if ( LastError >= 0 )
    {
      memset_0(&Credential, 0, sizeof(Credential));
      Credential.Flags = 16388;
      Credential.Type = 2;
      Credential.TargetName = v13;
      Credential.CredentialBlob = (LPBYTE)a3;
      Credential.Persist = 2;
      v14 = (WCHAR **)*User::GetDomainAccount(this, &v25);
      if ( v14 )
        v15 = *v14;
      else
        v15 = 0LL;
      Credential.UserName = v15;
      _bstr_t::_Free((_bstr_t *)&v25);
      if ( (unsigned __int64)(2LL * (_QWORD)lpMem) > 0xFFFFFFFF )
      {
        Credential.CredentialBlobSize = -1;
        LastError = -2147024362;
      }
      else
      {
        Credential.CredentialBlobSize = 2 * (_DWORD)lpMem;
        if ( CredWriteW(&Credential, 0) )
        {
          v16 = User::GetDomain((__int64)this, &v25);
          v17 = User::GetAccount((__int64)this, (__int64 *)&lpMem);
          if ( *v16 )
            v18 = *(char **)*v16;
          else
            v18 = 0LL;
          v19 = (char **)*v17;
          if ( v19 )
            v20 = *v19;
          else
            v20 = 0LL;
          NotifyLsaOfPasswordChange(v20, v18, (char *)a3);
          _bstr_t::_Free((_bstr_t *)&lpMem);
          _bstr_t::_Free((_bstr_t *)&v25);
          goto LABEL_30;
        }
        LastError = GetLastError();
        if ( LastError > 0 )
          LastError = (unsigned __int16)LastError | 0x80070000;
      }
    }
  }
  v6 = LastError;
LABEL_30:
  operator delete(v13);
LABEL_32:
  tsched::SecretGuard::Erase(v22);
  return v6;
}
// 180061F0E: variable 'v8' is possibly undefined

//----- (00000001800620FC) ----------------------------------------------------
__int64 __fastcall StringCbCopyW(char *a1, unsigned __int64 a2, char *a3)
{
  unsigned __int64 v3; // rdx
  signed int v4; // r9d
  unsigned __int64 v5; // r10
  signed __int64 v6; // r8
  unsigned __int16 v7; // ax
  unsigned __int16 *v8; // rax

  v3 = a2 >> 1;
  v4 = 0;
  if ( v3 - 1 > 0x7FFFFFFE )
    v4 = -2147024809;
  if ( v4 < 0 )
  {
    if ( v3 )
      *(_WORD *)a1 = 0;
  }
  else
  {
    if ( v3 )
    {
      v5 = 2147483646 - v3;
      v6 = a3 - a1;
      do
      {
        if ( !(v5 + v3) )
          break;
        v7 = *(_WORD *)&a1[v6];
        if ( !v7 )
          break;
        *(_WORD *)a1 = v7;
        a1 += 2;
        --v3;
      }
      while ( v3 );
    }
    v8 = (unsigned __int16 *)(a1 - 2);
    if ( v3 )
      v8 = (unsigned __int16 *)a1;
    v4 = v3 == 0 ? 0x8007007A : 0;
    *v8 = 0;
  }
  return (unsigned int)v4;
}

//----- (0000000180062188) ----------------------------------------------------
__int64 CredStore::Uninit(void)
{
  LPCRITICAL_SECTION v0; // rbx

  LocalFree(tsched::StoreSecurity::g_pRestrictedKeySecurity);
  tsched::StoreSecurity::g_pRestrictedKeySecurity = 0LL;
  LocalFree(tsched::StoreSecurity::g_pConfigKeySecurity);
  tsched::StoreSecurity::g_pConfigKeySecurity = 0LL;
  v0 = CredStore::g_pCommonStore;
  if ( CredStore::g_pCommonStore )
  {
    DeleteCriticalSection(CredStore::g_pCommonStore);
    DeleteCriticalSection((LPCRITICAL_SECTION)((char *)v0 + 48));
    wmi::AutoRegKey::Close((HKEY *)&v0[1]);
    operator delete(v0);
  }
  CredStore::g_pCommonStore = 0LL;
  return 0LL;
}

//----- (0000000180062218) ----------------------------------------------------
__int64 __fastcall CredStore::UpgradeCred(
        LPCRITICAL_SECTION lpCriticalSection,
        HKEY hKey,
        char *a3,
        const unsigned __int16 *a4,
        const unsigned __int16 *lpAccountName)
{
  unsigned int v8; // ebx
  BOOL v9; // esi
  unsigned __int64 v10; // rdi
  const WCHAR *v11; // rdx
  BYTE *v12; // rax
  int v13; // r8d
  int v14; // ecx
  BYTE v16[4]; // [rsp+50h] [rbp-B0h] BYREF
  BYTE Data[4]; // [rsp+54h] [rbp-ACh] BYREF
  HKEY hKeya; // [rsp+58h] [rbp-A8h] BYREF
  DWORD cbData; // [rsp+60h] [rbp-A0h] BYREF
  DWORD dwDisposition; // [rsp+64h] [rbp-9Ch] BYREF
  User::UserEntry *v21; // [rsp+68h] [rbp-98h] BYREF
  const WCHAR **v22; // [rsp+70h] [rbp-90h] BYREF
  LPCWSTR TargetName; // [rsp+78h] [rbp-88h]
  __int64 v24; // [rsp+80h] [rbp-80h]
  BYTE v25[80]; // [rsp+90h] [rbp-70h] BYREF
  BYTE v26[80]; // [rsp+E0h] [rbp-20h] BYREF

  v24 = -2LL;
  TargetName = a4;
  v8 = 0;
  v9 = 0;
  v22 = 0LL;
  v21 = 0LL;
  v10 = -1LL;
  do
    ++v10;
  while ( *(_WORD *)&a3[2 * v10] );
  if ( v10 < 0x13 )
    goto LABEL_28;
  memset_0(v25, 0, 0x4EuLL);
  StringCchCopyNW((char *)v25, 39LL, a3 + 38, v10 - 19);
  if ( (int)User::FromUsername(&v21, lpAccountName) < 0
    || (int)User::GetSidString((User *)&v21, (struct _bstr_t *)&v22) < 0 )
  {
    goto LABEL_28;
  }
  CredStore::Lock(lpCriticalSection);
  hKeya = 0LL;
  if ( v22 )
    v11 = *v22;
  else
    v11 = 0LL;
  if ( RegCreateKeyExW(hKey, v11, 0, 0LL, 0, 0xF003Fu, 0LL, &hKeya, &dwDisposition) )
  {
LABEL_27:
    CredStore::Unlock(lpCriticalSection);
    wmi::AutoRegKey::Close(&hKeya);
LABEL_28:
    v8 = v9;
    goto LABEL_29;
  }
  if ( dwDisposition == 1 )
  {
    *(_DWORD *)Data = 1;
    if ( RegSetValueExW(hKeya, L"Count", 0, 4u, Data, 4u) || RegSetValueExW(hKeya, L"Index", 0, 1u, v25, 0x4Eu) )
    {
      v9 = 0;
      RegDeleteKeyExW(hKey, 0LL, 0xF003Fu, 0);
      goto LABEL_27;
    }
LABEL_19:
    v9 = 1;
    goto LABEL_27;
  }
  memset_0(v26, 0, 0x4EuLL);
  cbData = 78;
  if ( RegQueryValueExW(hKeya, L"Index", 0LL, (LPDWORD)Data, v26, &cbData) )
    goto LABEL_27;
  v12 = v26;
  do
  {
    v13 = *((unsigned __int16 *)v12 - 40);
    v14 = *(unsigned __int16 *)v12 - v13;
    if ( v14 )
      break;
    v12 += 2;
  }
  while ( v13 );
  if ( !v14 )
    goto LABEL_19;
  v9 = 0;
  cbData = 4;
  if ( RegQueryValueExW(hKeya, L"Count", 0LL, (LPDWORD)Data, v16, &cbData) || *(_DWORD *)Data != 4 )
    goto LABEL_27;
  if ( *(_DWORD *)v16 != -1 )
  {
    ++*(_DWORD *)v16;
    if ( !RegSetValueExW(hKeya, L"Count", 0, 4u, v16, 4u) )
    {
      v9 = CredDeleteW(TargetName, 2u, 0);
      if ( !v9 )
      {
        --*(_DWORD *)v16;
        RegSetValueExW(hKeya, L"Count", 0, 4u, v16, 4u);
      }
    }
    goto LABEL_27;
  }
  wmi::AutoRegKey::Close(&hKeya);
LABEL_29:
  std::pair<User const,LogonJob *>::~pair<User const,LogonJob *>(&v21);
  _bstr_t::~_bstr_t((_bstr_t *)&v22);
  return v8;
}
// 180021628: using guessed type __int64 __fastcall std::pair<User const,LogonJob *>::~pair<User const,LogonJob *>(_QWORD);

//----- (00000001800625B0) ----------------------------------------------------
void __fastcall CredStore::WipeoutStore(CredStore *this, HKEY *a2)
{
  _QWORD *v3; // rcx
  __int64 v4; // rbx
  PVOID v5; // rsi
  __int64 v6; // rbp
  CredStore *v7; // rcx
  CredStore *v8; // [rsp+40h] [rbp+8h] BYREF
  PVOID Buffer; // [rsp+48h] [rbp+10h] BYREF

  v8 = this;
  Buffer = 0LL;
  if ( CredEnumerateW(0LL, 1u, (DWORD *)&v8, (PCREDENTIALW **)&Buffer) )
  {
    v3 = Buffer;
    v4 = 0LL;
    v5 = Buffer;
    if ( (_DWORD)v8 )
    {
      while ( 1 )
      {
        v6 = v3[v4];
        if ( wcsstr(*(const wchar_t **)(v6 + 8), L"TaskScheduler:Task:") )
          CredDeleteW(*(LPCWSTR *)(v6 + 8), 2u, 0);
        v4 = (unsigned int)(v4 + 1);
        if ( (unsigned int)v4 >= (unsigned int)v8 )
          break;
        v3 = Buffer;
      }
    }
    CredFree(v5);
  }
  RegCloseKey(*a2);
  RegDeleteTreeW(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Schedule\\CredWom");
  CredStore::OpenCredManagerKey(v7, a2);
}
// 18006267A: variable 'v7' is possibly undefined

//----- (0000000180062694) ----------------------------------------------------
__int64 __fastcall JobStore::MarkHashingCompletion(JobStore *this)
{
  HKEY v1; // rcx
  unsigned int v2; // ebx
  LSTATUS v3; // eax
  bool v4; // zf
  bool v5; // sf
  int Data; // [rsp+60h] [rbp+8h] BYREF
  HKEY hKey; // [rsp+68h] [rbp+10h] BYREF

  v1 = (HKEY)*((_QWORD *)this + 2);
  v2 = 0;
  Data = 1;
  hKey = 0LL;
  v3 = RegCreateKeyExW(v1, &ChannelPath, 0, 0LL, 0, 2u, 0LL, &hKey, 0LL);
  v4 = v3 == 0;
  v5 = v3 < 0;
  if ( v3
    || (v3 = RegSetValueExW(hKey, L"HashingCompleted", 0, 4u, (const BYTE *)&Data, 4u), v4 = v3 == 0, v5 = v3 < 0, v3) )
  {
    if ( v5 || v4 )
      v2 = v3;
    else
      v2 = (unsigned __int16)v3 | 0x80070000;
  }
  wmi::AutoRegKey::Close(&hKey);
  return v2;
}

//----- (0000000180062744) ----------------------------------------------------
__int64 __fastcall JobStore::MarkMTRCompletion(JobStore *this)
{
  HKEY v1; // rcx
  unsigned int v2; // ebx
  LSTATUS v3; // eax
  bool v4; // cc
  int Data; // [rsp+60h] [rbp+8h] BYREF
  HKEY hKey; // [rsp+68h] [rbp+10h] BYREF

  v1 = (HKEY)*((_QWORD *)this + 2);
  v2 = 0;
  Data = 1;
  hKey = 0LL;
  v3 = RegCreateKeyExW(v1, &ChannelPath, 0, 0LL, 0, 2u, 0LL, &hKey, 0LL);
  v4 = v3 <= 0;
  if ( v3 || (v3 = RegSetValueExW(hKey, L"MTRCompleted", 0, 4u, (const BYTE *)&Data, 4u), v4 = v3 <= 0, v3) )
  {
    if ( v4 )
      v2 = v3;
    else
      v2 = (unsigned __int16)v3 | 0x80070000;
  }
  else
  {
    dword_1800B0B68 = 1;
  }
  wmi::AutoRegKey::Close(&hKey);
  return v2;
}
// 1800B0B68: using guessed type int dword_1800B0B68;

//----- (0000000180062800) ----------------------------------------------------
__int64 __fastcall JobStore::MarkMigrationCleanupCompletion(JobStore *this)
{
  HKEY v1; // rcx
  unsigned int v2; // ebx
  LSTATUS v3; // eax
  bool v4; // zf
  bool v5; // sf
  int Data; // [rsp+60h] [rbp+8h] BYREF
  HKEY hKey; // [rsp+68h] [rbp+10h] BYREF

  v1 = (HKEY)*((_QWORD *)this + 2);
  v2 = 0;
  Data = 1;
  hKey = 0LL;
  v3 = RegCreateKeyExW(v1, &ChannelPath, 0, 0LL, 0, 2u, 0LL, &hKey, 0LL);
  v4 = v3 == 0;
  v5 = v3 < 0;
  if ( v3
    || (v3 = RegSetValueExW(hKey, L"MigrationCleanupCompleted", 0, 4u, (const BYTE *)&Data, 4u),
        v4 = v3 == 0,
        v5 = v3 < 0,
        v3) )
  {
    if ( v5 || v4 )
      v2 = v3;
    else
      v2 = (unsigned __int16)v3 | 0x80070000;
  }
  wmi::AutoRegKey::Close(&hKey);
  return v2;
}

//----- (00000001800628B0) ----------------------------------------------------
__int64 __fastcall JobStore::MarkPermissionsRestoreCompletion(JobStore *this)
{
  HKEY v1; // rcx
  unsigned int v2; // ebx
  LSTATUS v3; // eax
  bool v4; // zf
  bool v5; // sf
  int Data; // [rsp+60h] [rbp+8h] BYREF
  HKEY hKey; // [rsp+68h] [rbp+10h] BYREF

  v1 = (HKEY)*((_QWORD *)this + 2);
  v2 = 0;
  Data = 1;
  hKey = 0LL;
  v3 = RegCreateKeyExW(v1, &ChannelPath, 0, 0LL, 0, 2u, 0LL, &hKey, 0LL);
  v4 = v3 == 0;
  v5 = v3 < 0;
  if ( v3
    || (v3 = RegSetValueExW(hKey, L"OwnUpdateCompleted", 0, 4u, (const BYTE *)&Data, 4u), v4 = v3 == 0, v5 = v3 < 0, v3) )
  {
    if ( v5 || v4 )
      v2 = v3;
    else
      v2 = (unsigned __int16)v3 | 0x80070000;
  }
  wmi::AutoRegKey::Close(&hKey);
  return v2;
}

//----- (0000000180062960) ----------------------------------------------------
__int64 __fastcall JobStore::StreamInDWORD(unsigned int *a1, unsigned int **a2, unsigned __int8 *a3)
{
  __int64 result; // rax

  *a1 = 0;
  if ( *a2 + 1 > (unsigned int *)a3 )
    return 2147549183LL;
  *a1 = **a2;
  result = 0LL;
  ++*a2;
  return result;
}

//----- (000000018006298C) ----------------------------------------------------
__int64 __fastcall JobStore::StreamOutDWORD(int a1, unsigned __int8 **a2, unsigned __int8 *a3)
{
  __int64 result; // rax

  if ( *a2 + 4 > a3 )
    return 2147549183LL;
  *(_DWORD *)*a2 = a1;
  result = 0LL;
  *a2 += 4;
  return result;
}

//----- (00000001800629B0) ----------------------------------------------------
_QWORD *__fastcall std::_Tree_buy<std::pair<_bstr_t const,_bstr_t>>::_Buynode<std::pair<_bstr_t const,_bstr_t> &>(
        _QWORD *a1,
        __int64 *a2)
{
  _QWORD *result; // rax
  __int64 v4; // rcx
  __int64 v5; // rcx

  result = std::_Tree_buy<std::pair<_bstr_t const,void *>>::_Buynode0(a1);
  *((_WORD *)result + 12) = 0;
  v4 = *a2;
  result[4] = *a2;
  if ( v4 )
    _InterlockedIncrement((volatile signed __int32 *)(v4 + 16));
  v5 = a2[1];
  result[5] = v5;
  if ( v5 )
    _InterlockedIncrement((volatile signed __int32 *)(v5 + 16));
  return result;
}

//----- (0000000180062A20) ----------------------------------------------------
__int64 *__fastcall std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::_Insert_at<std::pair<_bstr_t const,_bstr_t> &,std::_Tree_node<std::pair<_bstr_t const,_bstr_t>,void *> *>(
        __int64 *a1,
        __int64 *a2,
        char a3,
        _QWORD *a4,
        int a5,
        __int64 a6)
{
  unsigned __int64 v6; // rax
  __int64 *v7; // r11
  __int64 v9; // r10
  __int64 v10; // rax
  __int64 v11; // rax
  __int64 v12; // r9
  __int64 v13; // rax
  __int64 *v14; // rdx
  __int64 v15; // rcx
  __int64 v16; // rax
  __int64 v17; // rcx
  __int64 *result; // rax

  v6 = a1[1];
  v7 = a1;
  if ( v6 >= 0x555555555555554LL )
  {
    std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::_Destroy_if_not_nil(
      0x555555555555554LL,
      a6);
    std::_Xlength_error("map/set<T> too long");
  }
  v9 = a6;
  a1[1] = v6 + 1;
  *(_QWORD *)(a6 + 8) = a4;
  if ( a4 == (_QWORD *)*a1 )
  {
    *(_QWORD *)(*a1 + 8) = a6;
    *(_QWORD *)*a1 = a6;
    v10 = *a1;
LABEL_9:
    *(_QWORD *)(v10 + 16) = a6;
    goto LABEL_10;
  }
  if ( a3 )
  {
    *a4 = a6;
    if ( a4 == *(_QWORD **)*a1 )
      *(_QWORD *)*a1 = a6;
    goto LABEL_10;
  }
  a4[2] = a6;
  v10 = *a1;
  if ( a4 == *(_QWORD **)(*a1 + 16) )
    goto LABEL_9;
LABEL_10:
  v11 = *(_QWORD *)(a6 + 8);
  v12 = a6;
  while ( !*(_BYTE *)(v11 + 24) )
  {
    v13 = *(_QWORD *)(v12 + 8);
    v14 = *(__int64 **)(v13 + 8);
    v15 = *v14;
    if ( v13 == *v14 )
    {
      v15 = v14[2];
      if ( !*(_BYTE *)(v15 + 24) )
        goto LABEL_17;
      if ( v12 == *(_QWORD *)(v13 + 16) )
        std::_Tree<std::_Tmap_traits<User,LogonJob *,User::less,std::allocator<std::pair<User const,LogonJob *>>,1>>::_Lrotate(
          (__int64)v7,
          *(_QWORD *)(v12 + 8));
      *(_BYTE *)(*(_QWORD *)(v12 + 8) + 24LL) = 1;
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v12 + 8) + 8LL) + 24LL) = 0;
      std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::_Rrotate(
        (__int64)v7,
        *(_QWORD **)(*(_QWORD *)(v12 + 8) + 8LL));
    }
    else
    {
      if ( !*(_BYTE *)(v15 + 24) )
      {
LABEL_17:
        *(_BYTE *)(v13 + 24) = 1;
        *(_BYTE *)(v15 + 24) = 1;
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v12 + 8) + 8LL) + 24LL) = 0;
        v12 = *(_QWORD *)(*(_QWORD *)(v12 + 8) + 8LL);
        goto LABEL_21;
      }
      if ( v12 == *(_QWORD *)v13 )
        std::_Tree<std::_Tmap_traits<User,SessionChangeJob *,User::less,std::allocator<std::pair<User const,SessionChangeJob *>>,1>>::_Rrotate(
          (__int64)v7,
          *(_QWORD **)(v12 + 8));
      *(_BYTE *)(*(_QWORD *)(v12 + 8) + 24LL) = 1;
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v12 + 8) + 8LL) + 24LL) = 0;
      std::_Tree<std::_Tmap_traits<User,LogonJob *,User::less,std::allocator<std::pair<User const,LogonJob *>>,1>>::_Lrotate(
        (__int64)v7,
        *(_QWORD *)(*(_QWORD *)(v12 + 8) + 8LL));
    }
LABEL_21:
    v11 = *(_QWORD *)(v12 + 8);
  }
  v16 = *v7;
  *a2 = v9;
  v17 = *(_QWORD *)(v16 + 8);
  result = a2;
  *(_BYTE *)(v17 + 24) = 1;
  return result;
}
// 180062AAF: variable 'v12' is possibly undefined
// 180062AD8: variable 'v7' is possibly undefined
// 180062B6F: variable 'v9' is possibly undefined

//----- (0000000180062B8C) ----------------------------------------------------
__int64 __fastcall std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::_Insert_nohint<std::pair<_bstr_t const,_bstr_t> &,std::_Tree_node<std::pair<_bstr_t const,_bstr_t>,void *> *>(
        __int64 *a1,
        __int64 a2,
        __int64 a3,
        BSTR **a4,
        void *lpMem)
{
  __int64 v8; // rdi
  __int64 v9; // rbx
  char v10; // si
  __int64 v11; // rbx
  __int64 i; // rax
  char *v14; // rsi
  int v15; // [rsp+20h] [rbp-38h]
  __int64 v16; // [rsp+60h] [rbp+8h] BYREF

  v8 = *a1;
  v9 = *(_QWORD *)(*a1 + 8);
  v10 = 1;
  while ( !*(_BYTE *)(v9 + 25) )
  {
    v8 = v9;
    if ( (int)_bstr_t::_Compare(a4, (BSTR **)(v9 + 32)) >= 0 )
    {
      v10 = 0;
      v9 = *(_QWORD *)(v9 + 16);
    }
    else
    {
      v10 = 1;
      v9 = *(_QWORD *)v9;
    }
  }
  v11 = v8;
  if ( v10 )
  {
    if ( v8 == *(_QWORD *)*a1 )
    {
      *(_QWORD *)a2 = *std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::_Insert_at<std::pair<_bstr_t const,_bstr_t> &,std::_Tree_node<std::pair<_bstr_t const,_bstr_t>,void *> *>(
                         a1,
                         &v16,
                         1,
                         (_QWORD *)v8,
                         v15,
                         (__int64)lpMem);
      *(_BYTE *)(a2 + 8) = 1;
      return a2;
    }
    if ( *(_BYTE *)(v8 + 25) )
    {
      v11 = *(_QWORD *)(v8 + 16);
    }
    else if ( *(_BYTE *)(*(_QWORD *)v8 + 25LL) )
    {
      for ( i = *(_QWORD *)(v8 + 8); !*(_BYTE *)(i + 25) && v11 == *(_QWORD *)i; i = *(_QWORD *)(i + 8) )
        v11 = i;
      if ( !*(_BYTE *)(v11 + 25) )
        v11 = i;
    }
    else
    {
      v11 = std::_Tree_val<std::_Tree_simple_types<std::pair<_bstr_t const,_bstr_t>>>::_Max(*(_QWORD *)v8);
    }
  }
  if ( (int)_bstr_t::_Compare((BSTR **)(v11 + 32), a4) >= 0 )
  {
    v14 = (char *)lpMem;
    _bstr_t::_Free((_bstr_t *)((char *)lpMem + 40));
    _bstr_t::_Free((_bstr_t *)(v14 + 32));
    operator delete(v14);
    *(_QWORD *)a2 = v11;
    *(_BYTE *)(a2 + 8) = 0;
  }
  else
  {
    *(_QWORD *)a2 = *std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::_Insert_at<std::pair<_bstr_t const,_bstr_t> &,std::_Tree_node<std::pair<_bstr_t const,_bstr_t>,void *> *>(
                       a1,
                       &v16,
                       v10,
                       (_QWORD *)v8,
                       v15,
                       (__int64)lpMem);
    *(_BYTE *)(a2 + 8) = 1;
  }
  return a2;
}
// 180062C15: variable 'v15' is possibly undefined

//----- (0000000180062D20) ----------------------------------------------------
__int64 __fastcall std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::insert<std::pair<_bstr_t,_bstr_t>>(
        __int64 *a1,
        __int64 a2,
        __int64 *a3)
{
  BSTR **v5; // rax
  __int64 v6; // r8

  v5 = (BSTR **)std::_Tree_buy<std::pair<_bstr_t const,_bstr_t>>::_Buynode<std::pair<_bstr_t const,_bstr_t> &>(a1, a3);
  std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::_Insert_nohint<std::pair<_bstr_t const,_bstr_t> &,std::_Tree_node<std::pair<_bstr_t const,_bstr_t>,void *> *>(
    a1,
    a2,
    v6,
    v5 + 4,
    v5);
  return a2;
}
// 180062D47: variable 'v6' is possibly undefined

//----- (0000000180062D64) ----------------------------------------------------
void __fastcall Triggers::GenericTrigger::~GenericTrigger(Triggers::GenericTrigger *this)
{
  _bstr_t::_Free((Triggers::GenericTrigger *)((char *)this + 80));
  *(_QWORD *)this = &Triggers::Trigger::`vftable';
}
// 180070988: using guessed type void *Triggers::Trigger::`vftable';

//----- (0000000180062D90) ----------------------------------------------------
void __fastcall Triggers::TriggerBase::~TriggerBase(Triggers::TriggerBase *this)
{
  *(_QWORD *)this = &Triggers::Trigger::`vftable';
}
// 180070988: using guessed type void *Triggers::Trigger::`vftable';

//----- (0000000180062DB0) ----------------------------------------------------
Triggers::Trigger *__fastcall Triggers::Trigger::`vector deleting destructor'(Triggers::Trigger *this, char a2)
{
  *(_QWORD *)this = &Triggers::Trigger::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 180070988: using guessed type void *Triggers::Trigger::`vftable';

//----- (0000000180062DE0) ----------------------------------------------------
__int64 __fastcall Triggers::EventTrigger::GetStorageSize(BSTR **this)
{
  int StorageSize; // eax
  BSTR *v3; // rcx
  int v4; // ebx
  BSTR v5; // rcx
  unsigned __int64 v6; // rax
  BSTR *v7; // rax
  int v8; // ebx
  UINT v9; // eax
  unsigned int v10; // ebx
  BSTR *v11; // r8
  BSTR *v12; // rax
  __int64 *v13; // rcx
  unsigned int v14; // ebx
  __int64 v15; // rdx
  unsigned __int64 v16; // rcx
  __int64 *v17; // rcx
  __int64 v18; // rdx
  unsigned __int64 v19; // rcx
  BSTR v20; // rcx
  BSTR i; // rcx
  void **pExceptionObject; // [rsp+20h] [rbp-40h] BYREF
  char v24; // [rsp+28h] [rbp-38h]
  const unsigned __int16 *v25; // [rsp+30h] [rbp-30h]
  __int64 v26; // [rsp+38h] [rbp-28h]
  __int64 v27; // [rsp+40h] [rbp-20h]
  int v28; // [rsp+48h] [rbp-18h]
  int v29; // [rsp+4Ch] [rbp-14h]
  int v30; // [rsp+50h] [rbp-10h]

  StorageSize = Triggers::GenericTrigger::GetStorageSize((Triggers::GenericTrigger *)this);
  v3 = this[11];
  v4 = StorageSize + 8;
  if ( v3 )
    v5 = *v3;
  else
    v5 = 0LL;
  v6 = -1LL;
  do
    ++v6;
  while ( v5[v6] );
  if ( v6 > 0xFFFFFFFF )
  {
    v24 = 0;
    pExceptionObject = &wmi::GenericException::`vftable';
    v26 = 0LL;
    v25 = &word_18007630E;
    v27 = 0LL;
    v28 = 534;
    v29 = -1;
    v30 = -1;
    CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
  }
  if ( (_DWORD)v6 )
  {
    v4 += 2 * v6 + 2;
    if ( (v4 & 7) != 0 )
      v4 += 8 - (v4 & 7);
  }
  v7 = this[13];
  v8 = v4 + 16;
  if ( v7 && *v7 )
    v9 = SysStringLen(*v7);
  else
    v9 = 0;
  if ( v9 )
  {
    v8 += 2 * v9 + 2;
    if ( (v8 & 7) != 0 )
      v8 += 8 - (v8 & 7);
  }
  v10 = v8 + 8;
  if ( this[15] )
  {
    v11 = this[14];
    v12 = (BSTR *)*v11;
    while ( v12 != v11 )
    {
      v13 = (__int64 *)v12[4];
      v14 = v10 + 8;
      if ( v13 )
        v15 = *v13;
      else
        v15 = 0LL;
      v16 = -1LL;
      do
        ++v16;
      while ( *(_WORD *)(v15 + 2 * v16) );
      if ( v16 > 0xFFFFFFFF )
      {
        v24 = 0;
        pExceptionObject = &wmi::GenericException::`vftable';
        v26 = 0LL;
        v25 = &word_18007630E;
        v27 = 0LL;
        v28 = 534;
        v29 = -1;
        v30 = -1;
        CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
      }
      if ( (_DWORD)v16 )
      {
        v14 += 2 * v16 + 2;
        if ( (v14 & 7) != 0 )
          v14 += 8 - (v14 & 7);
      }
      v17 = (__int64 *)v12[5];
      v10 = v14 + 8;
      if ( v17 )
        v18 = *v17;
      else
        v18 = 0LL;
      v19 = -1LL;
      do
        ++v19;
      while ( *(_WORD *)(v18 + 2 * v19) );
      if ( v19 > 0xFFFFFFFF )
      {
        v24 = 0;
        pExceptionObject = &wmi::GenericException::`vftable';
        v26 = 0LL;
        v25 = &word_18007630E;
        v27 = 0LL;
        v28 = 534;
        v29 = -1;
        v30 = -1;
        CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
      }
      if ( (_DWORD)v19 )
      {
        v10 += 2 * v19 + 2;
        if ( (v10 & 7) != 0 )
          v10 += 8 - (v10 & 7);
      }
      if ( !*((_BYTE *)v12 + 25) )
      {
        v20 = v12[2];
        if ( *((_BYTE *)v20 + 25) )
        {
          for ( i = v12[1]; !*((_BYTE *)i + 25) && v12 == *((BSTR **)i + 2); i = (BSTR)*((_QWORD *)i + 1) )
            v12 = (BSTR *)i;
          v12 = (BSTR *)i;
        }
        else
        {
          v12 = (BSTR *)std::_Tree_val<std::_Tree_simple_types<std::pair<_bstr_t const,std::list<_FILETIME> *>>>::_Min(v20);
        }
      }
    }
  }
  return v10;
}
// 180062EAE: variable 'v11' is possibly undefined
// 1800716D8: using guessed type void *wmi::GenericException::`vftable';

//----- (0000000180063070) ----------------------------------------------------
__int64 __fastcall Triggers::LogXTrigger::GetStorageSize(Triggers::LogXTrigger *this)
{
  int StorageSize; // edi

  StorageSize = User::GetStorageSize((Triggers::LogXTrigger *)((char *)this + 88));
  return StorageSize + (unsigned int)Triggers::GenericTrigger::GetStorageSize(this);
}

//----- (00000001800630B0) ----------------------------------------------------
const unsigned __int16 *__fastcall Triggers::GenericTrigger::GetTriggerId(Triggers::GenericTrigger *this)
{
  __int64 v1; // rdx
  const unsigned __int16 *result; // rax

  v1 = *((_QWORD *)this + 10);
  result = 0LL;
  if ( v1 )
    return *(const unsigned __int16 **)v1;
  return result;
}

//----- (00000001800630D0) ----------------------------------------------------
const unsigned __int16 *__fastcall Triggers::TimeTrigger::GetTriggerId(Triggers::TimeTrigger *this)
{
  __int64 v1; // rdx
  const unsigned __int16 *result; // rax

  v1 = *((_QWORD *)this + 12);
  result = 0LL;
  if ( v1 )
    return *(const unsigned __int16 **)v1;
  return result;
}

//----- (00000001800630E8) ----------------------------------------------------
__int64 __fastcall Triggers::Trigulator::RegisterAll(
        Triggers::Trigulator *a1,
        struct JobMoniker *a2,
        __int128 *a3,
        __int128 *a4,
        int a5)
{
  char v9; // r15
  __int64 result; // rax
  int v11; // ebp
  __int64 v12; // rax
  _QWORD *v13; // rbx
  __int64 v14; // rsi
  __int64 v15; // rax
  int v16[2]; // [rsp+20h] [rbp-68h] BYREF
  char v17[16]; // [rsp+28h] [rbp-60h] BYREF
  char v18[16]; // [rsp+38h] [rbp-50h] BYREF
  char v19[24]; // [rsp+48h] [rbp-40h] BYREF

  v9 = 1;
  result = Triggers::Trigulator::GetBucket(a1, a2);
  v11 = result;
  if ( (int)result >= 0 )
  {
    Triggers::Trigulator::ScheduleExpiredTaskDeletion(a1, a2);
    v12 = *((_QWORD *)a2 + 4);
    if ( (*(_DWORD *)(v12 + 16) & 0x400000) == 0 || (*(_DWORD *)(v12 + 16) & 0x2000000) != 0 )
    {
      return 1LL;
    }
    else
    {
      v16[0] = a5;
      v16[1] = 0;
      if ( *((_QWORD *)a1 + 5) && TSTime::operator>=((__int64)a1 + 16, a3) && TSTime::operator<=((__int64)a1, a4) )
      {
        v13 = (_QWORD *)*((_QWORD *)a1 + 4);
        while ( 1 )
        {
          v13 = (_QWORD *)*v13;
          if ( v13 == *((_QWORD **)a1 + 4) || v11 < 0 )
            break;
          v14 = v13[2];
          if ( v14 )
          {
            (*(void (__fastcall **)(_QWORD, char *))(*(_QWORD *)v14 + 8LL))(v13[2], v17);
            (*(void (__fastcall **)(__int64, char *))(*(_QWORD *)v14 + 16LL))(v14, v18);
            if ( (*(unsigned __int8 (__fastcall **)(__int64))(*(_QWORD *)v14 + 24LL))(v14) )
            {
              if ( TSTime::operator<=((__int64)v17, a4) && TSTime::operator>=((__int64)v18, a3) )
              {
                if ( (a5 & 4) != 0
                  && (v15 = (*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v14 + 8LL))(v14, v19),
                      TSTime::operator<=(v15, a3)) )
                {
                  v13[2] = 0LL;
                  (**(void (__fastcall ***)(__int64, __int64))v14)(v14, 1LL);
                }
                else
                {
                  if ( v9 )
                  {
                    if ( (int)JobStore::SetTaskCreationTime(JobStore::m_pCommonStore, a2, 0LL) >= 0 )
                      v9 = 0;
                  }
                  v13[2] = 0LL;
                  v11 = (*(__int64 (__fastcall **)(__int64, struct JobMoniker *, int *))(*(_QWORD *)v14 + 56LL))(
                          v14,
                          a2,
                          v16);
                }
              }
            }
          }
        }
      }
      return (unsigned int)v11;
    }
  }
  return result;
}
// 1800630E8: using guessed type char var_40[24];

//----- (00000001800632E0) ----------------------------------------------------
__int64 __fastcall Triggers::RegistrationTrigger::RegisterThyself(
        Triggers::RegistrationTrigger *this,
        struct JobMoniker *a2,
        struct Triggers::TriggerOptions *a3)
{
  if ( this )
    (**(void (__fastcall ***)(Triggers::RegistrationTrigger *, __int64, struct Triggers::TriggerOptions *))this)(
      this,
      1LL,
      a3);
  return 2147500033LL;
}

//----- (0000000180063310) ----------------------------------------------------
__int64 __fastcall Triggers::IdleTrigger::RegisterThyself(
        Triggers::IdleTrigger *this,
        struct JobMoniker *a2,
        struct Triggers::TriggerOptions *a3)
{
  return PseudoEventTrap::RegisterIdleJob(this, a2, this);
}

//----- (0000000180063320) ----------------------------------------------------
__int64 __fastcall Triggers::LogonTrigger::RegisterThyself(
        Triggers::LogonTrigger *this,
        struct JobMoniker *a2,
        struct Triggers::TriggerOptions *a3)
{
  return PseudoEventTrap::RegisterLogonJob(this, a2, this);
}

//----- (0000000180063330) ----------------------------------------------------
__int64 __fastcall Triggers::SessionChangeTrigger::RegisterThyself(
        Triggers::SessionChangeTrigger *this,
        struct JobMoniker *a2,
        struct Triggers::TriggerOptions *a3)
{
  return PseudoEventTrap::RegisterSessionChangeJob(this, a2, this);
}

//----- (0000000180063340) ----------------------------------------------------
__int64 __fastcall Triggers::TimeTrigger::RegisterThyself(
        Triggers::TimeTrigger *this,
        struct JobMoniker *a2,
        struct Triggers::TriggerOptions *a3)
{
  int v4; // edi

  v4 = Scheduler::AddJobSchedule(g_pScheduler, (Triggers::TimeTrigger *)((char *)this + 8), a2, (unsigned int *)a3 + 1);
  if ( v4 >= 0 )
    v4 = 0;
  if ( this )
    (**(void (__fastcall ***)(Triggers::TimeTrigger *, __int64))this)(this, 1LL);
  return (unsigned int)v4;
}
// 1800747C8: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();

//----- (00000001800633A0) ----------------------------------------------------
__int64 __fastcall Triggers::Trigulator::ScheduleExpiredTaskDeletion(
        Triggers::Trigulator *this,
        const struct JobMoniker *a2)
{
  int v3; // edi
  volatile signed __int32 *v4; // rbx
  __int64 v5; // rdx
  __int128 v7; // [rsp+38h] [rbp-38h] BYREF
  char v8[8]; // [rsp+48h] [rbp-28h] BYREF
  __int64 v9; // [rsp+50h] [rbp-20h]
  char v10[8]; // [rsp+58h] [rbp-18h] BYREF
  __int64 v11; // [rsp+60h] [rbp-10h]
  wmi::RefBase *v12; // [rsp+98h] [rbp+28h] BYREF
  __int64 v13; // [rsp+A0h] [rbp+30h] BYREF

  v3 = 1;
  v4 = (volatile signed __int32 *)*((_QWORD *)a2 + 4);
  v12 = (wmi::RefBase *)v4;
  if ( v4 )
  {
    _InterlockedAdd(v4 + 2, 1u);
    v4 = (volatile signed __int32 *)v12;
  }
  if ( (unsigned int)JobBucket::GetExpiration((JobBucket *)v4) != -1 )
  {
    v7 = *(_OWORD *)(v5 + 16);
    v8[0] = 0;
    v9 = 0LL;
    if ( TSTime::operator!=((__int64)v8, &v7) )
    {
      v10[0] = 0;
      v11 = -1LL;
      if ( TSTime::operator!=((__int64)v10, &v7) )
      {
        v13 = 10000000LL * (unsigned int)JobBucket::GetExpiration((JobBucket *)v4);
        TSTime::operator+=((__int64)&v7, &v13);
        v3 = Scheduler::EnqueueExpiredTaskDeletion(g_pScheduler, (const wchar_t **)a2, (const struct TSTime *)&v7);
        if ( v3 < 0
          && WPP_GLOBAL_Control != &WPP_GLOBAL_Control
          && (*((_BYTE *)WPP_GLOBAL_Control + 28) & 8) != 0
          && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
        {
          WPP_SF_SD(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x16u,
            (__int64)&WPP_9c6330531b9f37c0b720c7be8cd79119_Traceguids,
            *((const wchar_t **)a2 + 3));
        }
      }
    }
  }
  wmi::AutoRef<JobBucket>::Release(&v12);
  return (unsigned int)v3;
}
// 1800633EA: variable 'v5' is possibly undefined
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 1800633A0: using guessed type char var_28[8];
// 1800633A0: using guessed type char var_18[8];

//----- (00000001800634E0) ----------------------------------------------------
__int64 __fastcall Triggers::EventTrigger::StreamOutImpl(
        Triggers::EventTrigger *this,
        __int64 a2,
        unsigned __int8 **a3,
        unsigned __int8 *a4)
{
  __int64 result; // rax
  __int64 *v8; // rax
  __int64 v9; // rcx
  unsigned __int64 v10; // rbx
  unsigned __int8 *v11; // rcx
  char **v12; // rax
  char *v13; // r8
  unsigned __int8 *v14; // rdx
  BSTR *v15; // rax
  UINT v16; // eax
  UINT v17; // ebx
  unsigned __int8 *v18; // rcx
  char **v19; // rax
  char *v20; // r8
  int v21; // ebx
  unsigned __int64 v22; // rdx
  char *v23; // r8
  _QWORD *v24; // rbx
  __int64 *v25; // rax
  __int64 v26; // rcx
  unsigned __int64 v27; // rsi
  unsigned __int8 *v28; // rcx
  char **v29; // rax
  char *v30; // r8
  __int64 *v31; // rax
  __int64 v32; // rdx
  unsigned __int64 v33; // rsi
  unsigned __int8 *v34; // rcx
  char **v35; // rax
  unsigned __int8 *v36; // r9
  __int64 v37; // rcx
  _QWORD *i; // rax

  result = Triggers::GenericTrigger::StreamOutImpl(this, a2, a3, a4);
  if ( (int)result < 0 )
    return result;
  v8 = (__int64 *)*((_QWORD *)this + 11);
  if ( v8 )
    v9 = *v8;
  else
    v9 = 0LL;
  v10 = -1LL;
  do
    ++v10;
  while ( *(_WORD *)(v9 + 2 * v10) );
  if ( v10 > 0xFFFFFFFF )
    return 2147942934LL;
  if ( (unsigned __int64)(a4 - *a3) < 8 )
    return 2147549183LL;
  *(_DWORD *)*a3 = v10;
  *a3 += 4;
  *(_DWORD *)*a3 = 0;
  v11 = *a3 + 4;
  *a3 = v11;
  if ( (_DWORD)v10 )
  {
    v12 = (char **)*((_QWORD *)this + 11);
    if ( v12 )
      v13 = *v12;
    else
      v13 = 0LL;
    result = StringCbCopyW((char *)v11, a4 - v11, v13);
    if ( (int)result < 0 )
      return result;
    v11 = &(*a3)[2 * (unsigned int)(v10 + 1)];
    *a3 = v11;
    if ( ((2 * (_BYTE)v10 + 2) & 7) != 0 )
    {
      v11 += 8 - ((2 * (_BYTE)v10 + 2) & 7u);
      *a3 = v11;
    }
  }
  if ( v11 + 8 > a4 )
    return 2147549183LL;
  *(_DWORD *)v11 = *((_DWORD *)this + 24);
  *a3 += 4;
  *(_DWORD *)*a3 = *((_DWORD *)this + 25);
  v14 = *a3 + 4;
  *a3 = v14;
  if ( (unsigned __int64)(a4 - v14) < 8 )
    return 2147549183LL;
  v15 = (BSTR *)*((_QWORD *)this + 13);
  if ( v15 && *v15 )
  {
    v16 = SysStringLen(*v15);
    v14 = *a3;
    v17 = v16;
  }
  else
  {
    v17 = 0;
  }
  *(_DWORD *)v14 = v17;
  *a3 += 4;
  *(_DWORD *)*a3 = 0;
  v18 = *a3 + 4;
  *a3 = v18;
  if ( v17 )
  {
    v19 = (char **)*((_QWORD *)this + 13);
    if ( v19 )
      v20 = *v19;
    else
      v20 = 0LL;
    result = StringCbCopyW((char *)v18, a4 - v18, v20);
    if ( (int)result < 0 )
      return result;
    v18 = &(*a3)[2 * v17 + 2];
    *a3 = v18;
    v21 = (2 * (_BYTE)v17 + 2) & 7;
    if ( v21 )
    {
      v18 += (unsigned int)(8 - v21);
      *a3 = v18;
    }
  }
  v22 = *((_QWORD *)this + 15);
  if ( v22 > 0xFFFFFFFF )
    return 2147942934LL;
  LODWORD(v23) = 0;
  if ( (unsigned __int64)(a4 - v18) < 8 )
    return 2147549183LL;
  *(_DWORD *)v18 = v22;
  *a3 += 4;
  *(_DWORD *)*a3 = 0;
  *a3 += 4;
  if ( *((_QWORD *)this + 15) )
  {
    v24 = (_QWORD *)**((_QWORD **)this + 14);
    while ( v24 != *((_QWORD **)this + 14) )
    {
      v25 = (__int64 *)v24[4];
      if ( v25 )
        v26 = *v25;
      else
        v26 = 0LL;
      v27 = -1LL;
      do
        ++v27;
      while ( *(_WORD *)(v26 + 2 * v27) );
      if ( v27 > 0xFFFFFFFF )
        return 2147942934LL;
      if ( (unsigned __int64)(a4 - *a3) < 8 )
        return 2147549183LL;
      *(_DWORD *)*a3 = v27;
      *a3 += 4;
      *(_DWORD *)*a3 = 0;
      v28 = *a3 + 4;
      *a3 = v28;
      if ( (_DWORD)v27 )
      {
        v29 = (char **)v24[4];
        if ( v29 )
          v30 = *v29;
        else
          v30 = 0LL;
        result = StringCbCopyW((char *)v28, a4 - v28, v30);
        if ( (int)result < 0 )
          return result;
        v28 = &(*a3)[2 * (unsigned int)(v27 + 1)];
        *a3 = v28;
        if ( ((2 * (_BYTE)v27 + 2) & 7) != 0 )
        {
          v28 += 8 - ((2 * (_BYTE)v27 + 2) & 7u);
          *a3 = v28;
        }
      }
      v31 = (__int64 *)v24[5];
      if ( v31 )
        v32 = *v31;
      else
        v32 = 0LL;
      v33 = -1LL;
      do
        ++v33;
      while ( *(_WORD *)(v32 + 2 * v33) );
      if ( v33 > 0xFFFFFFFF )
        return 2147942934LL;
      v23 = 0LL;
      if ( (unsigned __int64)(a4 - v28) < 8 )
        return 2147549183LL;
      *(_DWORD *)v28 = v33;
      *a3 += 4;
      *(_DWORD *)*a3 = 0;
      v34 = *a3 + 4;
      *a3 = v34;
      if ( (_DWORD)v33 )
      {
        v35 = (char **)v24[5];
        if ( v35 )
          v23 = *v35;
        LODWORD(v23) = StringCbCopyW((char *)v34, a4 - v34, v23);
        v36 = &(*a3)[2 * (unsigned int)(v33 + 1)];
        *a3 = v36;
        if ( ((2 * (_BYTE)v33 + 2) & 7) != 0 )
          *a3 = &v36[8 - ((2 * (_BYTE)v33 + 2) & 7)];
      }
      if ( !*((_BYTE *)v24 + 25) )
      {
        v37 = v24[2];
        if ( *(_BYTE *)(v37 + 25) )
        {
          for ( i = (_QWORD *)v24[1]; !*((_BYTE *)i + 25) && v24 == (_QWORD *)i[2]; i = (_QWORD *)i[1] )
            v24 = i;
        }
        else
        {
          i = std::_Tree_val<std::_Tree_simple_types<std::pair<_bstr_t const,std::list<_FILETIME> *>>>::_Min((_QWORD *)v37);
        }
        v24 = i;
      }
    }
  }
  return (unsigned int)v23;
}
// 180063839: variable 'v23' is possibly undefined

//----- (0000000180063870) ----------------------------------------------------
__int64 __fastcall Triggers::LogXTrigger::StreamOutImpl(
        Triggers::LogXTrigger *this,
        __int64 a2,
        unsigned __int8 **a3,
        unsigned __int8 *a4)
{
  __int64 result; // rax
  __int64 v8; // rdx

  result = Triggers::GenericTrigger::StreamOutImpl(this, a2, a3, a4);
  if ( (int)result >= 0 )
    return User::StreamOutImpl((Triggers::LogXTrigger *)((char *)this + 88), v8, a3, a4);
  return result;
}
// 18006389B: variable 'v8' is possibly undefined

//----- (00000001800638C0) ----------------------------------------------------
__int64 __fastcall Triggers::IdleTrigger::WriteXml(Triggers::IdleTrigger *this, struct TaskXmlWriter *a2)
{
  BSTR *v2; // rax
  UINT v5; // eax
  __int64 result; // rax
  __int64 *v7; // rax
  __int64 v8; // r9

  v2 = (BSTR *)*((_QWORD *)this + 10);
  if ( v2 && *v2 )
    v5 = SysStringLen(*v2);
  else
    v5 = 0;
  if ( v5 )
  {
    v7 = (__int64 *)*((_QWORD *)this + 10);
    if ( v7 )
      v8 = *v7;
    else
      v8 = 0LL;
    result = TaskXmlWriter::StartElementWithAttribute((__int64)a2, 24, 109, v8);
  }
  else
  {
    result = TaskXmlWriter::StartElement((int *)a2, 24);
  }
  if ( (int)result >= 0 )
  {
    result = Triggers::GenericTrigger::WriteInnerXml(this, a2);
    if ( (int)result >= 0 )
      return TaskXmlWriter::EndElement((__int64)a2);
  }
  return result;
}

//----- (0000000180063954) ----------------------------------------------------
void __fastcall std::_Tree<std::_Tmap_traits<_bstr_t,_bstr_t,std::less<_bstr_t>,std::allocator<std::pair<_bstr_t const,_bstr_t>>,0>>::_Destroy_if_not_nil(
        __int64 a1,
        __int64 a2)
{
  _bstr_t::_Free((_bstr_t *)(a2 + 40));
  _bstr_t::_Free((_bstr_t *)(a2 + 32));
  operator delete((void *)a2);
}

//----- (000000018006398C) ----------------------------------------------------
__int64 __fastcall WPP_SF_Sdd(__int64 a1)
{
  return EtwTraceMessage(a1, 43LL, &WPP_9c6330531b9f37c0b720c7be8cd79119_Traceguids, 14LL, L"Triggers");
}
// 1800747B0: using guessed type __int64 __fastcall EtwTraceMessage(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180063A00) ----------------------------------------------------
struct _RTL_CRITICAL_SECTION *__fastcall HashCompute::`vector deleting destructor'(
        struct _RTL_CRITICAL_SECTION *this,
        char a2)
{
  HashCompute::~HashCompute(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (0000000180063A38) ----------------------------------------------------
signed int __fastcall DynamicTaskInfo::StreamOut(BYTE *lpData, HKEY hKey)
{
  signed int result; // eax

  result = RegSetValueExW(hKey, L"DynamicInfo", 0, 3u, lpData, 0x24u);
  if ( result > 0 )
    return (unsigned __int16)result | 0x80070000;
  return result;
}

//----- (0000000180063A84) ----------------------------------------------------
void __fastcall MessageBoxTask::~MessageBoxTask(void **this)
{
  *this = &MessageBoxTask::`vftable';
  wmi::AutoHandle::Close(this + 8);
  _bstr_t::_Free((_bstr_t *)(this + 6));
  _bstr_t::_Free((_bstr_t *)(this + 5));
  Task::~Task((Task *)this);
}
// 180073810: using guessed type void *MessageBoxTask::`vftable';

//----- (0000000180063AD0) ----------------------------------------------------
void **__fastcall MessageBoxTask::`scalar deleting destructor'(void **this, char a2)
{
  MessageBoxTask::~MessageBoxTask(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (0000000180063B08) ----------------------------------------------------
char *__fastcall wmi::AutoVectorPtr<JobMoniker>::~AutoVectorPtr<JobMoniker>(JobMoniker **a1)
{
  JobMoniker *v1; // rcx
  char *result; // rax

  v1 = *a1;
  if ( v1 )
    return JobMoniker::`vector deleting destructor'(v1);
  return result;
}

//----- (0000000180063B30) ----------------------------------------------------
DWORD __fastcall ItSpBatteryRemainingCallback(struct _ITSRV_GLOBAL_CONTEXT *a1, int a2, _DWORD *a3)
{
  int v4; // ebx
  void (__stdcall *v5)(struct _TP_CALLBACK_INSTANCE *, void *, struct _TP_WORK *); // r8
  unsigned __int32 v6; // ebx
  unsigned __int32 v7; // eax
  unsigned int v9; // [rsp+48h] [rbp+10h]

  if ( a2 != 32787 || a3[4] != 4 )
    return 87;
  v4 = a3[5];
  v9 = v4;
  EventManager::EvtReport(a1, &ItSpEvt_PowerNotificationReceived, L"BatteryRemaining", v4);
  v6 = _InterlockedExchange((volatile __int32 *)a1 + 208, v4);
  v7 = _InterlockedCompareExchange((volatile signed __int32 *)a1 + 204, 0, 0);
  if ( v6 < v7 )
  {
    if ( v9 < v7 )
      return 0;
  }
  else if ( v9 >= v7 )
  {
    return 0;
  }
  return ItSpSubmitThreadpoolWork(0LL, a1, v5);
}
// 180063B93: variable 'v5' is possibly undefined

//----- (0000000180063BB4) ----------------------------------------------------
void __fastcall ItSpCleanupGlobalContext(struct _ITSRV_GLOBAL_CONTEXT *a1)
{
  void *v1; // rbx
  HANDLE ProcessHeap; // rax
  struct _LIST_ENTRY *Flink; // rbx
  struct _LIST_ENTRY *v4; // rax
  HANDLE v5; // rax
  struct _LIST_ENTRY *v6; // rbx
  struct _LIST_ENTRY *v7; // rax
  HANDLE v8; // rax
  wchar_t *v9; // rbx
  HANDLE v10; // rax

  if ( !Timer && (((_DWORD)ItSrvGlobalContext - 1147547697) & 0xFFFFFFFB) == 0 )
  {
    DeleteCriticalSection(&stru_1800B0F18);
    DeleteCriticalSection(&stru_1800B0F90);
    DeleteCriticalSection(&stru_1800B0F60);
    if ( hObject )
      CloseHandle(hObject);
    if ( hEvent )
      CloseHandle(hEvent);
    if ( hHandle )
      CloseHandle(hHandle);
    if ( qword_1800B1050 )
      CloseHandle(qword_1800B1050);
    if ( qword_1800B11D0 )
      CloseHandle(qword_1800B11D0);
    if ( qword_1800B11C8 )
      CloseHandle(qword_1800B11C8);
    if ( qword_1800B1058 )
      CloseHandle(qword_1800B1058);
    if ( qword_1800B0F50 )
      CloseHandle(qword_1800B0F50);
    if ( qword_1800B10A0 )
      WmiCloseBlock();
    v1 = lpMem;
    if ( lpMem )
    {
      ProcessHeap = GetProcessHeap();
      HeapFree(ProcessHeap, 0, v1);
    }
    if ( qword_1800B10B8 )
      CloseHandle(qword_1800B10B8);
    ItSpCleanupSystemSnapshot((struct _ITSRV_SYSTEM_SNAPSHOT *)&dword_1800B10C0);
    ItSpCleanupSystemSnapshot((struct _ITSRV_SYSTEM_SNAPSHOT *)&dword_1800B1118);
    while ( 1 )
    {
      Flink = stru_1800B0F40.Flink;
      if ( stru_1800B0F40.Flink == &stru_1800B0F40 )
        break;
      --dword_1800B0F58;
      if ( stru_1800B0F40.Flink->Blink != &stru_1800B0F40
        || (v4 = stru_1800B0F40.Flink->Flink, stru_1800B0F40.Flink->Flink->Blink != stru_1800B0F40.Flink) )
      {
LABEL_34:
        __fastfail(3u);
      }
      stru_1800B0F40.Flink = stru_1800B0F40.Flink->Flink;
      v4->Blink = &stru_1800B0F40;
      ItSpCleanupIdleTask((struct _ITSRV_IDLE_TASK_CONTEXT *)Flink);
      v5 = GetProcessHeap();
      HeapFree(v5, 0, Flink);
    }
    while ( 1 )
    {
      v6 = stru_1800B0FB8.Flink;
      if ( stru_1800B0FB8.Flink == &stru_1800B0FB8 )
        break;
      --dword_1800B0FC8;
      if ( stru_1800B0FB8.Flink->Blink != &stru_1800B0FB8 )
        goto LABEL_34;
      v7 = stru_1800B0FB8.Flink->Flink;
      if ( stru_1800B0FB8.Flink->Flink->Blink != stru_1800B0FB8.Flink )
        goto LABEL_34;
      stru_1800B0FB8.Flink = stru_1800B0FB8.Flink->Flink;
      v7->Blink = &stru_1800B0FB8;
      ItSpCleanupIdleTask((struct _ITSRV_IDLE_TASK_CONTEXT *)v6);
      v8 = GetProcessHeap();
      HeapFree(v8, 0, v6);
    }
    v9 = String1;
    if ( String1 )
    {
      v10 = GetProcessHeap();
      HeapFree(v10, 0, v9);
      String1 = 0LL;
      dword_1800B1094 = 0;
    }
    if ( BindingVector )
      RpcBindingVectorFree(&BindingVector);
    ItSpUpdateStatus((unsigned int *)&ItSrvGlobalContext, 0x44663036u);
  }
}
// 1800B0EF0: using guessed type struct _ITSRV_GLOBAL_CONTEXT near *ItSrvGlobalContext;
// 1800B0F58: using guessed type int dword_1800B0F58;
// 1800B0FC8: using guessed type int dword_1800B0FC8;
// 1800B1094: using guessed type int dword_1800B1094;
// 1800B10A0: using guessed type __int64 qword_1800B10A0;
// 1800B10C0: using guessed type int dword_1800B10C0;
// 1800B1118: using guessed type int dword_1800B1118;
// 1800B9098: using guessed type __int64 WmiCloseBlock(void);

//----- (0000000180063E94) ----------------------------------------------------
void __fastcall ItSpCleanupIdleTask(struct _ITSRV_IDLE_TASK_CONTEXT *a1)
{
  void *v2; // rcx
  void *v3; // rcx

  v2 = (void *)*((_QWORD *)a1 + 7);
  if ( v2 )
  {
    CloseHandle(v2);
    *((_QWORD *)a1 + 7) = 0LL;
  }
  v3 = (void *)*((_QWORD *)a1 + 8);
  if ( v3 )
  {
    CloseHandle(v3);
    *((_QWORD *)a1 + 8) = 0LL;
  }
}

//----- (0000000180063EE0) ----------------------------------------------------
DWORD __fastcall ItSpConstrainedModeDetectionCallback(
        struct _WNF_STATE_NAME a1,
        __int64 a2,
        struct _WNF_TYPE_ID *a3,
        volatile __int32 *a4,
        _QWORD *a5,
        unsigned int a6)
{
  __int64 v7; // rax
  struct _TP_WORK **v8; // rcx

  if ( a6 != 8 )
    return 87;
  v7 = *a5 & 1LL;
  v8 = (struct _TP_WORK **)(unsigned int)_InterlockedExchange(a4 + 194, *a5 & 1);
  if ( (_DWORD)v8 == (_DWORD)v7 )
    return 0;
  else
    return ItSpSubmitThreadpoolWork(
             v8,
             (struct _ITSRV_GLOBAL_CONTEXT *)a4,
             (void (__stdcall *)(struct _TP_CALLBACK_INSTANCE *, void *, struct _TP_WORK *))a3);
}

//----- (0000000180063F20) ----------------------------------------------------
struct _ITSRV_IDLE_TASK_CONTEXT *__fastcall ItSpFindIdleTask(struct _LIST_ENTRY *a1, int *a2)
{
  struct _LIST_ENTRY *Flink; // rax
  __int64 v3; // r8
  int *v4; // r9

  Flink = a1->Flink;
  v3 = 0LL;
  while ( Flink != a1 )
  {
    v4 = (int *)Flink;
    Flink = Flink->Flink;
    if ( v4 == a2 )
      return (struct _ITSRV_IDLE_TASK_CONTEXT *)v4;
  }
  return (struct _ITSRV_IDLE_TASK_CONTEXT *)v3;
}

//----- (0000000180063F50) ----------------------------------------------------
void __fastcall ItSpIdleCancellationCallback(PTP_CALLBACK_INSTANCE Instance, char *Context, PTP_TIMER Timer)
{
  if ( Timer == (PTP_TIMER)_InterlockedCompareExchange64(
                             (volatile signed __int64 *)Context + 40,
                             0LL,
                             (signed __int64)Timer) )
  {
    SetEvent(*((HANDLE *)Context + 91));
    RtlAcquireSRWLockShared(Context + 408);
    ChangeTimerQueueTimer(0LL, *((HANDLE *)Context + 28), 0x32u, *((_DWORD *)Context + 94));
    RtlReleaseSRWLockShared(Context + 408);
  }
  if ( Timer )
    CloseThreadpoolTimer(Timer);
}
// 180074650: using guessed type __int64 __fastcall RtlReleaseSRWLockShared(_QWORD);
// 180074658: using guessed type __int64 __fastcall RtlAcquireSRWLockShared(_QWORD);

//----- (0000000180064004) ----------------------------------------------------
void ItSpNotifyProcessIdleTasks(void)
{
  EventManager *v0; // rcx
  struct _LIST_ENTRY *Flink; // rdi
  struct _ITSRV_IDLE_TASK_CONTEXT *v2; // rbx
  struct _LIST_ENTRY *v3; // rsi
  DWORD v4; // ebp
  struct _LIST_ENTRY *Blink; // rcx
  EventManager *v6; // rcx
  __int64 v7; // rax
  struct _ITSRV_IDLE_TASK_CONTEXT **v8; // rcx
  HANDLE ProcessHeap; // rax
  HANDLE Handles[3]; // [rsp+30h] [rbp-18h] BYREF

  EnterCriticalSection(&stru_1800B0F90);
  Flink = stru_1800B0FB8.Flink;
  Handles[0] = hObject;
  do
  {
    if ( Flink == &stru_1800B0FB8 )
      break;
    v2 = (struct _ITSRV_IDLE_TASK_CONTEXT *)Flink;
    EventManager::EvtReport(v0, &ItSpEvt_NotifyIdleTask_Start, HIDWORD(Flink[1].Blink), LODWORD(Flink[2].Flink));
    ResetEvent(Flink[4].Flink);
    SetEvent(Flink[3].Blink);
    v3 = Flink + 1;
    Handles[1] = Flink[4].Flink;
    LODWORD(Flink[1].Flink) |= 2u;
    LeaveCriticalSection(&stru_1800B0F90);
    v4 = WaitForMultipleObjectsEx(2u, Handles, 0, 0x36EE80u, 0);
    EnterCriticalSection(&stru_1800B0F90);
    Blink = Flink[3].Blink;
    LODWORD(Flink[1].Flink) &= ~2u;
    ResetEvent(Blink);
    EventManager::EvtReport(v6, &ItSpEvt_NotifyIdleTask_Stop, HIDWORD(Flink[1].Blink), LODWORD(Flink[2].Flink));
    Flink = Flink->Flink;
    if ( v4 == 258 || ((__int64)v3->Flink & 4) != 0 )
    {
      --dword_1800B0FC8;
      v7 = *(_QWORD *)v2;
      if ( *(struct _ITSRV_IDLE_TASK_CONTEXT **)(*(_QWORD *)v2 + 8LL) != v2
        || (v8 = (struct _ITSRV_IDLE_TASK_CONTEXT **)*((_QWORD *)v2 + 1), *v8 != v2) )
      {
        __fastfail(3u);
      }
      *v8 = (struct _ITSRV_IDLE_TASK_CONTEXT *)v7;
      *(_QWORD *)(v7 + 8) = v8;
      ItSpCleanupIdleTask(v2);
      ProcessHeap = GetProcessHeap();
      HeapFree(ProcessHeap, 0, v2);
    }
  }
  while ( v4 );
  LeaveCriticalSection(&stru_1800B0F90);
}
// 180064061: variable 'v0' is possibly undefined
// 180064103: variable 'v6' is possibly undefined
// 1800B0FC8: using guessed type int dword_1800B0FC8;

//----- (00000001800641A8) ----------------------------------------------------
bool __fastcall ItSpResumeTimeoutIsOver(struct _ITSRV_GLOBAL_CONTEXT *a1, struct _FILETIME *a2)
{
  FILETIME FileTime1; // [rsp+30h] [rbp+8h] BYREF

  if ( !*((_DWORD *)a1 + 93) )
    return 0;
  FileTime1 = (FILETIME)_InterlockedCompareExchange64((volatile signed __int64 *)a1 + 108, 0LL, 0LL);
  return CompareFileTime(&FileTime1, a2) == -1;
}

//----- (00000001800641FC) ----------------------------------------------------
void __fastcall ItSpSendIdleExitPerftrackNotification(struct _ITSRV_GLOBAL_CONTEXT *a1)
{
  if ( _InterlockedCompareExchange((volatile signed __int32 *)a1 + 200, 0, 0) )
    EventManager::EvtReport(
      *((_BYTE *)a1 + 668) != 0 ? (EventManager *)0x10000000 : 0,
      &ItSpEvt_PerfTrack_IdleExitStats,
      *((unsigned int *)a1 + 165),
      *((unsigned __int8 *)a1 + 664) | (*((_BYTE *)a1 + 668) != 0 ? 0x10000000 : 0) | ((*((unsigned __int8 *)a1 + 652) | (((unsigned __int8)*((_DWORD *)a1 + 165) | ((*((_DWORD *)a1 + 168) & 0xFu) << 8)) << 8)) << 8));
}

//----- (0000000180064278) ----------------------------------------------------
void __fastcall ItSpStopIdleDetection(struct _ITSRV_GLOBAL_CONTEXT *a1)
{
  ResetEvent(hHandle);
  if ( hEvent )
    SetEvent(hEvent);
  if ( RegistrationHandle )
  {
    PowerSettingUnregisterNotification(RegistrationHandle);
    RegistrationHandle = 0LL;
  }
  if ( qword_1800B11E0 )
  {
    PowerSettingUnregisterNotification(qword_1800B11E0);
    qword_1800B11E0 = 0LL;
  }
  if ( qword_1800B11E8 )
  {
    RtlUnsubscribeWnfNotificationWaitForCompletion();
    qword_1800B11E8 = 0LL;
  }
  if ( qword_1800B1228 )
  {
    PowerSettingUnregisterNotification(qword_1800B1228);
    qword_1800B1228 = 0LL;
  }
  if ( qword_1800B1218 )
  {
    PowerSettingUnregisterNotification(qword_1800B1218);
    qword_1800B1218 = 0LL;
  }
  if ( qword_1800B1208 )
  {
    PowerSettingUnregisterNotification(qword_1800B1208);
    qword_1800B1208 = 0LL;
  }
  if ( qword_1800B1238 )
  {
    PowerSettingUnregisterNotification(qword_1800B1238);
    qword_1800B1238 = 0LL;
  }
  if ( ptpcg )
  {
    RtlAcquireSRWLockExclusive(&stru_1800B1028);
    CloseThreadpoolCleanupGroupMembers(ptpcg, 1, 0LL);
    RtlReleaseSRWLockExclusive(&stru_1800B1028);
    if ( ptpcg )
      CloseThreadpoolCleanupGroup(ptpcg);
  }
  DeleteTimerQueueTimer(0LL, Timer, hHandle);
  Timer = 0LL;
}
// 180074648: using guessed type __int64 RtlUnsubscribeWnfNotificationWaitForCompletion(void);
// 180074660: using guessed type __int64 __fastcall RtlAcquireSRWLockExclusive(_QWORD);
// 180074670: using guessed type __int64 __fastcall RtlReleaseSRWLockExclusive(_QWORD);
// 1800B11E8: using guessed type __int64 qword_1800B11E8;

//----- (000000018006441C) ----------------------------------------------------
__int64 __fastcall ItSpStoreDetectionOverrides(struct _IT_IDLE_DETECTION_PARAMETERS *a1)
{
  unsigned int v2; // ebx
  int Data; // [rsp+78h] [rbp+28h] BYREF
  HKEY hKey; // [rsp+80h] [rbp+30h] BYREF

  hKey = 0LL;
  v2 = RegCreateKeyExW(
         HKEY_LOCAL_MACHINE,
         L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\IdleService",
         0,
         0LL,
         0,
         0xF003Fu,
         0LL,
         &hKey,
         0LL);
  if ( !v2 )
  {
    Data = *((_DWORD *)a1 + 2);
    v2 = RegSetValueExW(hKey, L"IdleCheckTimeout", 0, 4u, (const BYTE *)&Data, 4u);
    if ( !v2 )
    {
      Data = *((_DWORD *)a1 + 3);
      v2 = RegSetValueExW(hKey, L"IdleEndTimeout", 0, 4u, (const BYTE *)&Data, 4u);
      if ( !v2 )
      {
        v2 = ItSpStoreOverrideValue(hKey, L"UserInput", *(_BYTE *)a1);
        if ( !v2 )
        {
          Data = *((_DWORD *)a1 + 4);
          v2 = RegSetValueExW(hKey, L"SamplingInterval", 0, 4u, (const BYTE *)&Data, 4u);
          if ( !v2 )
          {
            Data = *((_DWORD *)a1 + 5);
            v2 = RegSetValueExW(hKey, L"SamplingNumber", 0, 4u, (const BYTE *)&Data, 4u);
            if ( !v2 )
            {
              Data = *((_DWORD *)a1 + 6);
              v2 = RegSetValueExW(hKey, L"CPUThreshold", 0, 4u, (const BYTE *)&Data, 4u);
              if ( !v2 )
              {
                Data = *((_DWORD *)a1 + 7);
                v2 = RegSetValueExW(hKey, L"IOThreshold", 0, 4u, (const BYTE *)&Data, 4u);
              }
            }
          }
        }
      }
    }
  }
  if ( hKey )
    RegCloseKey(hKey);
  return v2;
}

//----- (0000000180064620) ----------------------------------------------------
__int64 __fastcall ItSpStoreOverrideValue(HKEY a1, const unsigned __int16 *a2, const BYTE *lpData, DWORD cbData)
{
  unsigned int v4; // ecx

  if ( cbData && lpData )
  {
    return (unsigned int)RegSetValueExW(a1, L"ExemptRegistrationList", 0, 7u, lpData, cbData);
  }
  else
  {
    v4 = RegDeleteValueW(a1, L"ExemptRegistrationList");
    if ( v4 - 2 <= 1 )
      return 0;
  }
  return v4;
}

//----- (0000000180064688) ----------------------------------------------------
LSTATUS __fastcall ItSpStoreOverrideValue(HKEY a1, const unsigned __int16 *a2, char a3)
{
  BOOL Data; // [rsp+50h] [rbp+18h] BYREF

  Data = a3 != 0;
  return RegSetValueExW(a1, a2, 0, 4u, (const BYTE *)&Data, 4u);
}

//----- (00000001800646C8) ----------------------------------------------------
__int64 __fastcall ItSpStoreRuntimeOverrides(struct _IT_IDLE_RUNTIME_PARAMETERS *a1)
{
  unsigned int v2; // ebx
  const unsigned __int16 *v3; // rdx
  HKEY hKey; // [rsp+68h] [rbp+10h] BYREF

  hKey = 0LL;
  v2 = RegCreateKeyExW(
         HKEY_LOCAL_MACHINE,
         L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\IdleService",
         0,
         0LL,
         0,
         0xF003Fu,
         0LL,
         &hKey,
         0LL);
  if ( !v2 )
  {
    v2 = ItSpStoreOverrideValue(hKey, L"SkipNotification", *(_BYTE *)a1);
    if ( !v2 )
      v2 = ItSpStoreOverrideValue(hKey, v3, *((const BYTE **)a1 + 1), *((_DWORD *)a1 + 1));
  }
  if ( hKey )
    RegCloseKey(hKey);
  return v2;
}
// 180064748: variable 'v3' is possibly undefined

//----- (000000018006477C) ----------------------------------------------------
DWORD __fastcall ItSpSubmitThreadpoolTimer(
        struct _TP_TIMER **a1,
        struct _ITSRV_GLOBAL_CONTEXT *a2,
        void (__stdcall *a3)(struct _TP_CALLBACK_INSTANCE *, void *, struct _TP_TIMER *),
        unsigned int a4)
{
  char *v4; // rdi
  __int64 v5; // rbp
  struct _TP_TIMER *ThreadpoolTimer; // rbx
  struct _FILETIME pftDueTime; // [rsp+40h] [rbp+18h] BYREF

  pftDueTime = (struct _FILETIME)a3;
  v4 = (char *)a2 + 312;
  v5 = a4;
  RtlAcquireSRWLockExclusive((char *)a2 + 312);
  ThreadpoolTimer = CreateThreadpoolTimer(
                      (PTP_TIMER_CALLBACK)ItSpIdleCancellationCallback,
                      a2,
                      (PTP_CALLBACK_ENVIRON)((char *)a2 + 232));
  if ( ThreadpoolTimer )
  {
    pftDueTime = (struct _FILETIME)(-10000 * v5);
    SetThreadpoolTimer(ThreadpoolTimer, &pftDueTime, 0, 0);
    RtlReleaseSRWLockExclusive(v4);
    if ( a1 )
      *a1 = ThreadpoolTimer;
    return 0;
  }
  else
  {
    RtlReleaseSRWLockExclusive(v4);
    return GetLastError();
  }
}
// 180074660: using guessed type __int64 __fastcall RtlAcquireSRWLockExclusive(_QWORD);
// 180074670: using guessed type __int64 __fastcall RtlReleaseSRWLockExclusive(_QWORD);

//----- (0000000180064858) ----------------------------------------------------
void __fastcall ItSpUnregisterIdleTask(unsigned __int16 *a1, int **a2, char a3)
{
  struct _ITSRV_IDLE_TASK_CONTEXT *IdleTask; // rax
  struct _ITSRV_IDLE_TASK_CONTEXT *v6; // rbx
  EventManager *v7; // rcx
  int v8; // eax
  __int64 v9; // rdx
  struct _ITSRV_IDLE_TASK_CONTEXT **v10; // rax
  HANDLE v11; // rax
  struct _RTL_CRITICAL_SECTION *v12; // rcx
  struct _ITSRV_IDLE_TASK_CONTEXT *v13; // rax
  EventManager *v14; // rcx
  struct _ITSRV_IDLE_TASK_CONTEXT *v15; // rbx
  HANDLE v16; // rax
  __int64 v17; // rcx
  struct _ITSRV_IDLE_TASK_CONTEXT **v18; // rax
  HANDLE ProcessHeap; // rax

  EnterCriticalSection(&stru_1800B0F90);
  IdleTask = ItSpFindIdleTask(&stru_1800B0FB8, *a2);
  v6 = IdleTask;
  if ( !IdleTask )
  {
    LeaveCriticalSection(&stru_1800B0F90);
    EnterCriticalSection(&stru_1800B0F18);
    if ( (_DWORD)ItSrvGlobalContext == 1147547701 )
      goto LABEL_14;
    v13 = ItSpFindIdleTask(&stru_1800B0F40, *a2);
    v15 = v13;
    if ( !v13 )
      goto LABEL_14;
    EventManager::EvtReport(v14, &ItSpEvt_UnregisterIdleTask, *((unsigned int *)v13 + 7), *((unsigned int *)v13 + 8));
    if ( !a3 )
    {
      if ( RpcImpersonateClient(0LL) )
        goto LABEL_14;
      v16 = OpenProcess(0x1FFFFFu, 0, *((_DWORD *)v15 + 8));
      if ( !v16 )
      {
        GetLastError();
        RpcRevertToSelf();
        goto LABEL_14;
      }
      CloseHandle(v16);
      RpcRevertToSelf();
    }
    --dword_1800B0F58;
    v17 = *(_QWORD *)v15;
    if ( *(struct _ITSRV_IDLE_TASK_CONTEXT **)(*(_QWORD *)v15 + 8LL) != v15 )
      goto LABEL_23;
    v18 = (struct _ITSRV_IDLE_TASK_CONTEXT **)*((_QWORD *)v15 + 1);
    if ( *v18 != v15 )
      goto LABEL_23;
    *v18 = (struct _ITSRV_IDLE_TASK_CONTEXT *)v17;
    *(_QWORD *)(v17 + 8) = v18;
    ResetEvent(*((HANDLE *)v15 + 8));
    SetEvent(*((HANDLE *)v15 + 7));
    if ( *((_DWORD *)v15 + 5) == 2 )
      SetEvent(qword_1800B1058);
    ItSpCleanupIdleTask(v15);
    ProcessHeap = GetProcessHeap();
    HeapFree(ProcessHeap, 0, v15);
    if ( stru_1800B0F40.Flink == &stru_1800B0F40 )
      SetEvent(qword_1800B0F50);
LABEL_14:
    v12 = &stru_1800B0F18;
    goto LABEL_15;
  }
  SetEvent(*((HANDLE *)IdleTask + 8));
  ResetEvent(*((HANDLE *)v6 + 7));
  EventManager::EvtReport(v7, &ItSpEvt_UnregisterIdleTask, *((unsigned int *)v6 + 7), *((unsigned int *)v6 + 8));
  v8 = *((_DWORD *)v6 + 4);
  if ( (v8 & 2) == 0 )
  {
    --dword_1800B0FC8;
    v9 = *(_QWORD *)v6;
    if ( *(struct _ITSRV_IDLE_TASK_CONTEXT **)(*(_QWORD *)v6 + 8LL) == v6 )
    {
      v10 = (struct _ITSRV_IDLE_TASK_CONTEXT **)*((_QWORD *)v6 + 1);
      if ( *v10 == v6 )
      {
        *v10 = (struct _ITSRV_IDLE_TASK_CONTEXT *)v9;
        *(_QWORD *)(v9 + 8) = v10;
        ItSpCleanupIdleTask(v6);
        v11 = GetProcessHeap();
        HeapFree(v11, 0, v6);
        goto LABEL_7;
      }
    }
LABEL_23:
    __fastfail(3u);
  }
  *((_DWORD *)v6 + 4) = v8 | 4;
LABEL_7:
  v12 = &stru_1800B0F90;
LABEL_15:
  LeaveCriticalSection(v12);
  *a2 = 0LL;
}
// 1800648D2: variable 'v7' is possibly undefined
// 180064994: variable 'v14' is possibly undefined
// 1800B0EF0: using guessed type struct _ITSRV_GLOBAL_CONTEXT near *ItSrvGlobalContext;
// 1800B0F58: using guessed type int dword_1800B0F58;
// 1800B0FC8: using guessed type int dword_1800B0FC8;

//----- (0000000180064AF0) ----------------------------------------------------
void __fastcall IT_HANDLE_rundown(int *a1)
{
  int *v1; // [rsp+30h] [rbp+8h] BYREF

  v1 = a1;
  ItSpUnregisterIdleTask((unsigned __int16 *)a1, &v1, 1);
}

//----- (0000000180064B20) ----------------------------------------------------
__int64 __fastcall ItSrvProcessIdleTasks(EventManager *a1, __int64 a2, void *a3, const struct _GUID *a4)
{
  char v4; // si
  int v5; // ebx
  EventManager *v6; // rcx
  void *v7; // r8
  const struct _GUID *v8; // r9
  char v9; // di
  DWORD LastError; // ebx
  int v11; // eax
  EventManager *v12; // rcx
  void *v13; // r8
  const struct _GUID *v14; // r9
  HANDLE Handles[3]; // [rsp+30h] [rbp-18h] BYREF

  v4 = 0;
  v5 = _InterlockedIncrement(&dword_1800B0F88);
  EventManager::EvtReport(a1, &ItSpEvt_ExplicitProcessing_Start, a3, a4);
  if ( v5 > 1 )
    EventManager::EvtReport(v6, &ItSpEvt_ExplicitProcessing_Active, v7, v8);
  EnterCriticalSection(&stru_1800B0F60);
  ResetEvent(qword_1800B1050);
  ItSpNotifyProcessIdleTasks();
  EnterCriticalSection(&stru_1800B0F18);
  v9 = 1;
  if ( (_DWORD)ItSrvGlobalContext != 1147547701 )
  {
    if ( TSchedStartEvent )
    {
      ItSpStartScheduledIdleTasks();
      v4 = 1;
    }
    dword_1800B11B4 = 55;
    if ( stru_1800B0F40.Flink == &stru_1800B0F40
      || ChangeTimerQueueTimer(0LL, Timer, 0x32u, Period)
      && (LeaveCriticalSection(&stru_1800B0F18),
          Handles[0] = qword_1800B0F50,
          v9 = 0,
          Handles[1] = hObject,
          WaitForMultipleObjectsEx(2u, Handles, 0, 0xFFFFFFFF, 0) <= 1) )
    {
      LastError = 0;
    }
    else
    {
      LastError = GetLastError();
    }
    if ( v4 )
    {
      v11 = ItSpWaitForScheduledIdleTasks();
      if ( v11 < 0 )
        LastError = v11;
      if ( v9 )
        goto LABEL_19;
      EnterCriticalSection(&stru_1800B0F18);
      v9 = 1;
    }
    if ( !v9 )
      EnterCriticalSection(&stru_1800B0F18);
LABEL_19:
    dword_1800B11B4 = 0;
    goto LABEL_20;
  }
  dword_1800B11B4 = 0;
  LastError = 21;
LABEL_20:
  LeaveCriticalSection(&stru_1800B0F18);
  SetEvent(qword_1800B1050);
  LeaveCriticalSection(&stru_1800B0F60);
  EventManager::EvtReport(v12, &ItSpEvt_ExplicitProcessing_Stop, v13, v14);
  _InterlockedDecrement(&dword_1800B0F88);
  return LastError;
}
// 180064CC0: conditional instruction was optimized away because di.1==1
// 180064B5F: variable 'v6' is possibly undefined
// 180064B5F: variable 'v7' is possibly undefined
// 180064B5F: variable 'v8' is possibly undefined
// 180064CFE: variable 'v12' is possibly undefined
// 180064CFE: variable 'v13' is possibly undefined
// 180064CFE: variable 'v14' is possibly undefined
// 1800B0EF0: using guessed type struct _ITSRV_GLOBAL_CONTEXT near *ItSrvGlobalContext;
// 1800B0F88: using guessed type int dword_1800B0F88;
// 1800B11B4: using guessed type int dword_1800B11B4;

//----- (0000000180064D30) ----------------------------------------------------
__int64 __fastcall ItSrvSetDetectionParameters(__int64 a1, __int64 a2)
{
  unsigned int LastError; // ebx

  EnterCriticalSection(&stru_1800B0F18);
  LastError = ItSpStoreDetectionOverrides((struct _IT_IDLE_DETECTION_PARAMETERS *)a2);
  if ( !LastError )
  {
    RtlAcquireSRWLockExclusive(&unk_1800B1088);
    unk_1800B1060 = *(_OWORD *)a2;
    *(_OWORD *)&xmmword_1800B1070 = *(_OWORD *)(a2 + 16);
    dword_1800B1080 = *(_DWORD *)(a2 + 32);
    RtlReleaseSRWLockExclusive(&unk_1800B1088);
    if ( !ChangeTimerQueueTimer(0LL, Timer, 0x32u, Period) )
      LastError = GetLastError();
  }
  LeaveCriticalSection(&stru_1800B0F18);
  return LastError;
}
// 180074660: using guessed type __int64 __fastcall RtlAcquireSRWLockExclusive(_QWORD);
// 180074670: using guessed type __int64 __fastcall RtlReleaseSRWLockExclusive(_QWORD);
// 1800B1080: using guessed type int dword_1800B1080;

//----- (0000000180064E00) ----------------------------------------------------
__int64 __fastcall ItSrvSetRuntimeOverrides(__int64 a1, __int64 a2)
{
  unsigned int v3; // esi
  void *v4; // rbx
  HANDLE ProcessHeap; // rax
  unsigned int v6; // ebx
  HANDLE v7; // rax

  EnterCriticalSection(&stru_1800B0F18);
  v3 = ItSpStoreRuntimeOverrides((struct _IT_IDLE_RUNTIME_PARAMETERS *)a2);
  if ( !v3 )
  {
    v4 = *(void **)((char *)&qword_1800B1094 + 4);
    if ( *(__int64 *)((char *)&qword_1800B1094 + 4) )
    {
      ProcessHeap = GetProcessHeap();
      HeapFree(ProcessHeap, 0, v4);
      *(__int64 *)((char *)&qword_1800B1094 + 4) = 0LL;
      qword_1800B1094 = 0LL;
    }
    if ( *(_DWORD *)(a2 + 4) && *(_QWORD *)(a2 + 8) )
    {
      v6 = *(_DWORD *)(a2 + 4);
      v7 = GetProcessHeap();
      *(__int64 *)((char *)&qword_1800B1094 + 4) = (__int64)HeapAlloc(v7, 0, v6);
      if ( !*(__int64 *)((char *)&qword_1800B1094 + 4) )
      {
        v3 = 8;
        goto LABEL_10;
      }
      LODWORD(qword_1800B1094) = *(_DWORD *)(a2 + 4);
      memcpy_0(*(void **)((char *)&qword_1800B1094 + 4), *(const void **)(a2 + 8), *(unsigned int *)(a2 + 4));
    }
    byte_1800B1090 = *(_BYTE *)a2;
  }
LABEL_10:
  LeaveCriticalSection(&stru_1800B0F18);
  return v3;
}
// 1800B1094: using guessed type __int64 qword_1800B1094;

//----- (0000000180064F00) ----------------------------------------------------
void ItSrvUninitialize()
{
  struct _ITSRV_GLOBAL_CONTEXT *v0; // rcx
  struct _ITSRV_GLOBAL_CONTEXT *v1; // rcx

  SetEvent(hObject);
  EnterCriticalSection(&stru_1800B0F18);
  ItSpUpdateStatus((unsigned int *)&ItSrvGlobalContext, 0x44663035u);
  if ( Timer )
    ItSpStopIdleDetection(v0);
  LeaveCriticalSection(&stru_1800B0F18);
  if ( byte_1800B11C0 )
    RpcEpUnregister(&unk_1800702F0, BindingVector, 0LL);
  if ( byte_1800B11C1 )
    RpcServerUnregisterIfEx(&unk_1800702F0, 0LL, 1);
  WaitForSingleObject(hHandle, 0xFFFFFFFF);
  WaitForSingleObject(qword_1800B1050, 0xFFFFFFFF);
  if ( TSchedStartEvent )
  {
    CloseHandle(TSchedStartEvent);
    TSchedStartEvent = 0LL;
  }
  v1 = (struct _ITSRV_GLOBAL_CONTEXT *)TSchedStopEvent;
  if ( TSchedStopEvent )
  {
    CloseHandle(TSchedStopEvent);
    TSchedStopEvent = 0LL;
  }
  ItSpCleanupGlobalContext(v1);
}
// 180064F45: variable 'v0' is possibly undefined
// 180065015: variable 'v1' is possibly undefined
// 1800B0EF0: using guessed type struct _ITSRV_GLOBAL_CONTEXT near *ItSrvGlobalContext;
// 1800B11C0: using guessed type char byte_1800B11C0;
// 1800B11C1: using guessed type char byte_1800B11C1;

//----- (0000000180065020) ----------------------------------------------------
void __fastcall ItSrvUnregisterIdleTask(unsigned __int16 *a1, int **a2)
{
  ItSpUnregisterIdleTask(a1, a2, 0);
}

//----- (0000000180065030) ----------------------------------------------------
__int64 __fastcall ItSpScheduledTaskIsIdleStarted(struct ITaskService *a1, unsigned __int16 *const a2, int *a3)
{
  BSTR v6; // rax
  OLECHAR *v7; // r14
  int v8; // ebx
  unsigned int v9; // edi
  __int64 v10; // rcx
  __int64 v12; // [rsp+20h] [rbp-50h] BYREF
  int v13; // [rsp+28h] [rbp-48h] BYREF
  __int64 v14; // [rsp+30h] [rbp-40h] BYREF
  __int64 v15; // [rsp+38h] [rbp-38h] BYREF
  __int64 v16; // [rsp+40h] [rbp-30h] BYREF
  int v17; // [rsp+48h] [rbp-28h] BYREF
  __int64 v18; // [rsp+50h] [rbp-20h] BYREF
  __int64 v19; // [rsp+58h] [rbp-18h] BYREF
  __int64 v20; // [rsp+60h] [rbp-10h] BYREF
  __int64 v21; // [rsp+68h] [rbp-8h] BYREF
  __int16 v22; // [rsp+B0h] [rbp+40h] BYREF
  __int16 v23; // [rsp+B8h] [rbp+48h] BYREF

  v21 = 0LL;
  v20 = 0LL;
  v16 = 0LL;
  v15 = 0LL;
  v19 = 0LL;
  v18 = 0LL;
  v14 = 0LL;
  v12 = 0LL;
  *a3 = 0;
  v6 = SysAllocString(L"\\");
  v7 = v6;
  if ( !v6 )
  {
    v8 = -2147024882;
    goto LABEL_28;
  }
  v8 = ((__int64 (__fastcall *)(struct ITaskService *, BSTR, __int64 *))a1->lpVtbl->GetFolder)(a1, v6, &v21);
  if ( v8 >= 0 )
  {
    v8 = (*(__int64 (__fastcall **)(__int64, unsigned __int16 *const, __int64 *))(*(_QWORD *)v21 + 104LL))(
           v21,
           a2,
           &v20);
    if ( v8 >= 0 )
    {
      v8 = (*(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v20 + 152LL))(v20, &v16);
      if ( v8 >= 0 )
      {
        v8 = (*(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v16 + 88LL))(v16, &v15);
        if ( v8 >= 0 )
        {
          v8 = (*(__int64 (__fastcall **)(__int64, __int16 *))(*(_QWORD *)v15 + 328LL))(v15, &v22);
          if ( v8 >= 0 )
          {
            if ( v22 != -1 )
            {
              v8 = (**(__int64 (__fastcall ***)(__int64, GUID *, __int64 *))v15)(
                     v15,
                     &GUID_0ad9d0d7_0c7f_4ebb_9a5f_d1c648dca528,
                     &v19);
              if ( v8 < 0 )
                goto LABEL_27;
              v8 = (*(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v19 + 408LL))(v19, &v18);
              if ( v8 < 0 )
                goto LABEL_27;
              if ( !v18 )
              {
                v8 = (*(__int64 (__fastcall **)(__int64, __int64 *))(*(_QWORD *)v16 + 72LL))(v16, &v14);
                if ( v8 >= 0 )
                {
                  v8 = (*(__int64 (__fastcall **)(__int64, int *))(*(_QWORD *)v14 + 56LL))(v14, &v13);
                  if ( v8 >= 0 )
                  {
                    v9 = 1;
                    if ( v13 < 1 )
                    {
LABEL_26:
                      v8 = 0;
                    }
                    else
                    {
                      while ( 1 )
                      {
                        v10 = v12;
                        if ( v12 )
                        {
                          v12 = 0LL;
                          (*(void (__fastcall **)(__int64))(*(_QWORD *)v10 + 16LL))(v10);
                        }
                        v8 = (*(__int64 (__fastcall **)(__int64, _QWORD, __int64 *))(*(_QWORD *)v14 + 64LL))(
                               v14,
                               v9,
                               &v12);
                        if ( v8 < 0 )
                          break;
                        v8 = (*(__int64 (__fastcall **)(__int64, __int16 *))(*(_QWORD *)v12 + 144LL))(v12, &v23);
                        if ( v8 < 0 )
                          break;
                        if ( v23 )
                        {
                          v8 = (*(__int64 (__fastcall **)(__int64, int *))(*(_QWORD *)v12 + 56LL))(v12, &v17);
                          if ( v8 < 0 )
                            goto LABEL_27;
                          if ( v17 == 6 )
                          {
                            *a3 = 1;
                            goto LABEL_26;
                          }
                        }
                        if ( (int)++v9 > v13 )
                          goto LABEL_26;
                      }
                    }
                  }
                }
                goto LABEL_27;
              }
            }
            *a3 = 1;
          }
        }
      }
    }
  }
LABEL_27:
  SysFreeString(v7);
LABEL_28:
  if ( v12 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v12 + 16LL))(v12);
  if ( v14 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v14 + 16LL))(v14);
  if ( v18 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v18 + 16LL))(v18);
  if ( v19 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v19 + 16LL))(v19);
  if ( v15 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v15 + 16LL))(v15);
  if ( v16 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v16 + 16LL))(v16);
  if ( v20 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v20 + 16LL))(v20);
  if ( v21 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v21 + 16LL))(v21);
  return (unsigned int)v8;
}

//----- (0000000180065358) ----------------------------------------------------
__int64 ItSpStartScheduledIdleTasks(void)
{
  HRESULT Instance; // ebx
  struct ITaskServiceVtbl *lpVtbl; // rax
  HRESULT (__stdcall *Connect)(ITaskService *, VARIANT, VARIANT, VARIANT, VARIANT); // rax
  __int128 v4; // [rsp+30h] [rbp-29h] BYREF
  __int64 v5; // [rsp+40h] [rbp-19h]
  __int128 v6; // [rsp+50h] [rbp-9h] BYREF
  __int64 v7; // [rsp+60h] [rbp+7h]
  __int128 v8; // [rsp+70h] [rbp+17h] BYREF
  __int64 v9; // [rsp+80h] [rbp+27h]
  __int128 v10; // [rsp+90h] [rbp+37h] BYREF
  __int64 v11; // [rsp+A0h] [rbp+47h]
  struct ITaskService *ppv; // [rsp+C0h] [rbp+67h] BYREF
  struct ITaskFolder *v13; // [rsp+C8h] [rbp+6Fh] BYREF

  ppv = 0LL;
  v13 = 0LL;
  LOWORD(v4) = 1;
  Instance = CoCreateInstance(
               &CLSID_TaskScheduler,
               0LL,
               0x17u,
               &GUID_2faba4c7_4da9_4013_9697_20cc3fd40f85,
               (LPVOID *)&ppv);
  if ( Instance >= 0 )
  {
    v6 = v4;
    lpVtbl = ppv->lpVtbl;
    v7 = v5;
    Connect = lpVtbl->Connect;
    v8 = v4;
    v9 = v5;
    v10 = v4;
    v11 = v5;
    Instance = ((__int64 (__fastcall *)(struct ITaskService *, __int128 *, __int128 *, __int128 *, __int128 *))Connect)(
                 ppv,
                 &v10,
                 &v8,
                 &v4,
                 &v6);
    if ( Instance >= 0 )
    {
      Instance = ((__int64 (__fastcall *)(struct ITaskService *, _QWORD, struct ITaskFolder **))ppv->lpVtbl->GetFolder)(
                   ppv,
                   0LL,
                   &v13);
      if ( Instance >= 0 )
        Instance = ItSpStartScheduledIdleTasksInFolder(ppv, v13);
    }
  }
  if ( v13 )
    ((void (__fastcall *)(struct ITaskFolder *))v13->lpVtbl->Release)(v13);
  if ( ppv )
    ((void (__fastcall *)(struct ITaskService *))ppv->lpVtbl->Release)(ppv);
  return (unsigned int)Instance;
}
// 1800747C8: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();

//----- (000000018006547C) ----------------------------------------------------
__int64 __fastcall ItSpStartScheduledIdleTasksInFolder(struct ITaskService *a1, struct ITaskFolder *a2)
{
  struct ITaskFolderVtbl *lpVtbl; // rax
  HRESULT (__stdcall *GetTasks)(ITaskFolder *, LONG, IRegisteredTaskCollection **); // rax
  int v6; // ebx
  int i; // ebx
  __int64 v8; // rcx
  __int64 v9; // rax
  __int64 v10; // rax
  int j; // ebx
  struct ITaskFolder *v12; // rcx
  __int64 v13; // rax
  BSTR bstrString; // [rsp+40h] [rbp-69h] BYREF
  struct ITaskFolder *v16; // [rsp+48h] [rbp-61h] BYREF
  __int64 *v17; // [rsp+50h] [rbp-59h] BYREF
  __int64 *v18; // [rsp+58h] [rbp-51h] BYREF
  __int64 v19; // [rsp+60h] [rbp-49h] BYREF
  __int128 v20; // [rsp+68h] [rbp-41h]
  __int64 v21; // [rsp+78h] [rbp-31h]
  __int128 v22; // [rsp+80h] [rbp-29h] BYREF
  __int64 v23; // [rsp+90h] [rbp-19h]
  __int128 v24; // [rsp+A0h] [rbp-9h] BYREF
  __int64 v25; // [rsp+B0h] [rbp+7h]
  __int128 v26; // [rsp+C0h] [rbp+17h]
  __int64 v27; // [rsp+D0h] [rbp+27h]
  int v28; // [rsp+118h] [rbp+6Fh] BYREF
  int v29; // [rsp+120h] [rbp+77h] BYREF
  __int64 *v30; // [rsp+128h] [rbp+7Fh] BYREF

  lpVtbl = a2->lpVtbl;
  v18 = 0LL;
  v17 = 0LL;
  v30 = 0LL;
  GetTasks = lpVtbl->GetTasks;
  v16 = 0LL;
  v19 = 0LL;
  bstrString = 0LL;
  LOWORD(v26) = 1;
  v6 = ((__int64 (__fastcall *)(struct ITaskFolder *, __int64, __int64 **))GetTasks)(a2, 1LL, &v18);
  if ( v6 >= 0 )
  {
    v6 = (*(__int64 (__fastcall **)(__int64 *, int *))(*v18 + 56))(v18, &v28);
    if ( v6 >= 0 )
    {
      for ( i = 1; i <= v28; ++i )
      {
        v8 = (__int64)v30;
        LOWORD(v20) = 3;
        DWORD2(v20) = i;
        if ( v30 )
        {
          v30 = 0LL;
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v8 + 16LL))(v8);
        }
        v24 = v20;
        v9 = *v18;
        v25 = v21;
        if ( (*(int (__fastcall **)(__int64 *, __int128 *, __int64 **))(v9 + 64))(v18, &v24, &v30) >= 0 )
        {
          if ( bstrString )
          {
            SysFreeString(bstrString);
            bstrString = 0LL;
          }
          if ( (*(int (__fastcall **)(__int64 *, BSTR *))(*v30 + 64))(v30, &bstrString) >= 0
            && (int)ItSpScheduledTaskIsIdleStarted(a1, bstrString, &v29) >= 0
            && v29 )
          {
            ATL::CComPtrBase<IRunningTask>::Release(&v19);
            v22 = v26;
            v10 = *v30;
            v23 = v27;
            (*(void (__fastcall **)(__int64 *, __int128 *, __int64))(v10 + 104))(v30, &v22, 2LL);
          }
        }
      }
      v6 = ((__int64 (__fastcall *)(struct ITaskFolder *, _QWORD, __int64 **))a2->lpVtbl->GetFolders)(a2, 0LL, &v17);
      if ( v6 >= 0 )
      {
        v6 = (*(__int64 (__fastcall **)(__int64 *, int *))(*v17 + 56))(v17, &v28);
        if ( v6 >= 0 )
        {
          for ( j = 1; j <= v28; ++j )
          {
            v12 = v16;
            LOWORD(v20) = 3;
            DWORD2(v20) = j;
            if ( v16 )
            {
              v16 = 0LL;
              ((void (__fastcall *)(struct ITaskFolder *))v12->lpVtbl->Release)(v12);
            }
            v22 = v20;
            v13 = *v17;
            v23 = v21;
            if ( (*(int (__fastcall **)(__int64 *, __int128 *, struct ITaskFolder **))(v13 + 64))(v17, &v22, &v16) >= 0 )
              ItSpStartScheduledIdleTasksInFolder(a1, v16);
          }
          v6 = 0;
        }
      }
    }
  }
  if ( bstrString )
    SysFreeString(bstrString);
  if ( v19 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v19 + 16LL))(v19);
  if ( v16 )
    ((void (__fastcall *)(struct ITaskFolder *))v16->lpVtbl->Release)(v16);
  if ( v30 )
    (*(void (__fastcall **)(__int64 *))(*v30 + 16))(v30);
  if ( v17 )
    (*(void (__fastcall **)(__int64 *))(*v17 + 16))(v17);
  if ( v18 )
    (*(void (__fastcall **)(__int64 *))(*v18 + 16))(v18);
  return (unsigned int)v6;
}
// 1800747C8: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();

//----- (0000000180065758) ----------------------------------------------------
__int64 ItSpWaitForScheduledIdleTasks(void)
{
  HRESULT Instance; // ebx
  struct ITaskServiceVtbl *lpVtbl; // rax
  HRESULT (__stdcall *Connect)(ITaskService *, VARIANT, VARIANT, VARIANT, VARIANT); // rax
  int v3; // edi
  int v4; // r13d
  __int64 v5; // rcx
  int v6; // esi
  int v7; // r15d
  int v8; // r14d
  int v9; // ebx
  __int64 v10; // rax
  int IsIdleStarted; // eax
  EventManager *v12; // rcx
  void *v13; // r9
  int v14; // r12d
  DWORD v15; // eax
  BSTR bstrString; // [rsp+30h] [rbp-89h] BYREF
  __int64 *v18; // [rsp+38h] [rbp-81h] BYREF
  struct ITaskService *ppv; // [rsp+40h] [rbp-79h] BYREF
  __int64 v20; // [rsp+48h] [rbp-71h] BYREF
  struct _GUID v21; // [rsp+50h] [rbp-69h] BYREF
  __int64 v22; // [rsp+60h] [rbp-59h]
  struct _GUID v23; // [rsp+70h] [rbp-49h] BYREF
  __int64 v24; // [rsp+80h] [rbp-39h]
  struct _GUID v25; // [rsp+90h] [rbp-29h] BYREF
  __int64 v26; // [rsp+A0h] [rbp-19h]
  struct _GUID v27; // [rsp+B0h] [rbp-9h] BYREF
  __int64 v28; // [rsp+C0h] [rbp+7h]
  int v29; // [rsp+120h] [rbp+67h] BYREF
  unsigned int v30; // [rsp+128h] [rbp+6Fh]
  int v31; // [rsp+130h] [rbp+77h]
  int v32; // [rsp+138h] [rbp+7Fh] BYREF

  ppv = 0LL;
  v18 = 0LL;
  v20 = 0LL;
  bstrString = 0LL;
  LOWORD(v21.Data1) = 1;
  Instance = CoCreateInstance(
               &CLSID_TaskScheduler,
               0LL,
               0x17u,
               &GUID_2faba4c7_4da9_4013_9697_20cc3fd40f85,
               (LPVOID *)&ppv);
  if ( Instance >= 0 )
  {
    v25 = v21;
    lpVtbl = ppv->lpVtbl;
    v26 = v22;
    Connect = lpVtbl->Connect;
    v27 = v21;
    v28 = v22;
    v23 = v21;
    v24 = v22;
    Instance = ((__int64 (__fastcall *)(struct ITaskService *, struct _GUID *, struct _GUID *, struct _GUID *, struct _GUID *))Connect)(
                 ppv,
                 &v23,
                 &v27,
                 &v21,
                 &v25);
    if ( Instance >= 0 )
    {
      v3 = 0;
      v30 = 0;
      v4 = 0;
      v31 = 0;
      while ( 1 )
      {
        v5 = (__int64)v18;
        if ( v18 )
        {
          v18 = 0LL;
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v5 + 16LL))(v5);
        }
        Instance = ((__int64 (__fastcall *)(struct ITaskService *, __int64, __int64 **))ppv->lpVtbl->GetRunningTasks)(
                     ppv,
                     1LL,
                     &v18);
        if ( Instance < 0 )
          break;
        Instance = (*(__int64 (__fastcall **)(__int64 *, int *))(*v18 + 56))(v18, &v29);
        if ( Instance < 0 )
          break;
        v6 = 0;
        v7 = 0;
        v8 = 0;
        v9 = 1;
        if ( v29 < 1 )
          goto LABEL_27;
        do
        {
          LOWORD(v21.Data1) = 3;
          *(_DWORD *)v21.Data4 = v9;
          ATL::CComPtrBase<IRunningTask>::Release(&v20);
          v23 = v21;
          v10 = *v18;
          v24 = v22;
          IsIdleStarted = (*(__int64 (__fastcall **)(__int64 *, struct _GUID *, __int64 *))(v10 + 64))(v18, &v23, &v20);
          if ( IsIdleStarted < 0 )
            goto LABEL_17;
          if ( bstrString )
          {
            SysFreeString(bstrString);
            bstrString = 0LL;
          }
          IsIdleStarted = (*(__int64 (__fastcall **)(__int64, BSTR *))(*(_QWORD *)v20 + 72LL))(v20, &bstrString);
          if ( IsIdleStarted < 0
            || (IsIdleStarted = ItSpScheduledTaskIsIdleStarted(ppv, bstrString, &v32), IsIdleStarted < 0) )
          {
LABEL_17:
            if ( IsIdleStarted == -2147216629 )
              ++v8;
            else
              ++v7;
          }
          else if ( v32 )
          {
            ++v6;
            if ( v4 )
              break;
            EventManager::EvtReport(v12, &JOB_COMPLETION_PENDING, bstrString, v13);
          }
          ++v9;
        }
        while ( v9 <= v29 );
        if ( (v14 = v31, v6) || v8 && (++v30, v30 < 0x3C) || v7 && (++v31, (unsigned int)(v14 + 1) < 0xF) )
        {
          v3 = 0;
        }
        else
        {
LABEL_27:
          if ( (unsigned int)++v3 >= 3 )
          {
            Instance = 0;
            break;
          }
        }
        v15 = WaitForSingleObject(hObject, 0x2710u);
        if ( !v15 )
        {
          Instance = -2147023641;
          break;
        }
        if ( v15 != 258 )
        {
          Instance = -2147467259;
          break;
        }
        ++v4;
      }
    }
  }
  if ( bstrString )
    SysFreeString(bstrString);
  CoFreeUnusedLibraries();
  if ( v20 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v20 + 16LL))(v20);
  if ( v18 )
    (*(void (__fastcall **)(__int64 *))(*v18 + 16))(v18);
  if ( ppv )
    ((void (__fastcall *)(struct ITaskService *))ppv->lpVtbl->Release)(ppv);
  return (unsigned int)Instance;
}
// 18006594C: variable 'v12' is possibly undefined
// 18006594C: variable 'v13' is possibly undefined
// 1800747C8: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();

//----- (0000000180065A70) ----------------------------------------------------
_QWORD *__fastcall ATL::CComPtrBase<IRunningTask>::Release(_QWORD *a1)
{
  _QWORD *result; // rax
  __int64 v2; // rcx

  result = a1;
  v2 = *a1;
  if ( v2 )
  {
    *result = 0LL;
    return (_QWORD *)(*(__int64 (__fastcall **)(__int64))(*(_QWORD *)v2 + 16LL))(v2);
  }
  return result;
}

//----- (0000000180065A9C) ----------------------------------------------------
_QWORD *__fastcall std::_List_buy<_GUID>::_Buynode<_GUID const &>(__int64 a1, _QWORD *a2, _QWORD *a3, _OWORD *a4)
{
  _QWORD *result; // rax

  result = std::_List_alloc<0,std::_List_base_types<_GUID>>::_Buynode0(a1, a2, a3);
  *((_OWORD *)result + 1) = *a4;
  return result;
}

//----- (0000000180065AF4) ----------------------------------------------------
TaskAccessChecker *__fastcall TaskAccessChecker::TaskAccessChecker(TaskAccessChecker *this)
{
  struct User *v2; // rdi
  int v3; // eax
  tsched *v4; // rcx
  bool v5; // zf
  char v6; // al
  HANDLE CurrentThread; // rax
  void **pExceptionObject; // [rsp+28h] [rbp-38h] BYREF
  char v10; // [rsp+30h] [rbp-30h]
  const unsigned __int16 *v11; // [rsp+38h] [rbp-28h]
  __int64 v12; // [rsp+40h] [rbp-20h]
  __int64 v13; // [rsp+48h] [rbp-18h]
  DWORD LastError; // [rsp+50h] [rbp-10h]
  int v15; // [rsp+54h] [rbp-Ch]
  int v16; // [rsp+58h] [rbp-8h]
  int v17; // [rsp+88h] [rbp+28h] BYREF

  *(_BYTE *)this = 0;
  v2 = (TaskAccessChecker *)((char *)this + 8);
  *((_QWORD *)this + 1) = 0LL;
  *((_QWORD *)this + 2) = 0LL;
  RpcAutoImpersonate::RpcAutoImpersonate((RpcAutoImpersonate *)&v17, L"TaskAccessChecker::TaskAccessChecker", 1);
  v3 = User::FromImpersonationToken(v2, 0LL);
  if ( v3 < 0 )
  {
    v10 = 0;
    pExceptionObject = &wmi::GenericException::`vftable';
    v11 = &word_18007630E;
    v12 = 0LL;
    v13 = 0LL;
    LastError = (unsigned __int16)v3;
    v15 = -1;
    v16 = -1;
    CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
  }
  if ( (unsigned int)tsched::IsUserAdmin(v4) || (v5 = !User::IsLocalSystem(v2), v6 = 0, !v5) )
    v6 = 1;
  *(_BYTE *)this = v6;
  CurrentThread = GetCurrentThread();
  if ( !OpenThreadToken(CurrentThread, 8u, 1, (PHANDLE)this + 2) )
  {
    v10 = 0;
    pExceptionObject = &wmi::GenericException::`vftable';
    v11 = &word_18007630E;
    v12 = 0LL;
    v13 = 0LL;
    LastError = GetLastError();
    v15 = -1;
    v16 = -1;
    CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
  }
  if ( v17 )
    RpcRevertToSelf();
  return this;
}
// 180065B8E: variable 'v4' is possibly undefined
// 1800716D8: using guessed type void *wmi::GenericException::`vftable';

//----- (0000000180065C80) ----------------------------------------------------
void __fastcall std::list<UbpmInstance>::~list<UbpmInstance>(void **a1)
{
  std::list<UbpmInstance>::clear((__int64)a1);
  operator delete(*a1);
}

//----- (0000000180065CA4) ----------------------------------------------------
void __fastcall std::list<_GUID>::~list<_GUID>(__int64 a1)
{
  _QWORD *v2; // rdx
  _QWORD *v3; // rcx
  _QWORD *v4; // rbx

  v2 = **(_QWORD ***)a1;
  **(_QWORD **)a1 = *(_QWORD *)a1;
  *(_QWORD *)(*(_QWORD *)a1 + 8LL) = *(_QWORD *)a1;
  *(_QWORD *)(a1 + 8) = 0LL;
  v3 = *(_QWORD **)a1;
  if ( v2 != v3 )
  {
    do
    {
      v4 = (_QWORD *)*v2;
      operator delete(v2);
      v3 = *(_QWORD **)a1;
      v2 = v4;
    }
    while ( v4 != *(_QWORD **)a1 );
  }
  operator delete(v3);
}

//----- (0000000180065CFC) ----------------------------------------------------
void __fastcall tsched::SrwLockSharedScope::~SrwLockSharedScope(PSRWLOCK *this)
{
  ReleaseSRWLockShared(*this);
}

//----- (0000000180065D14) ----------------------------------------------------
void __fastcall TaskAccessChecker::~TaskAccessChecker(void **this)
{
  wmi::AutoHandle::Close(this + 2);
  wmi::AutoRef<User::UserEntry>::Release(this + 1);
}
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);

//----- (0000000180065D3C) ----------------------------------------------------
_QWORD *__fastcall tsched::SecretGuard::operator=(void **a1)
{
  _QWORD *v1; // r10
  _QWORD *result; // rax
  __int64 v3; // r9

  tsched::SecretGuard::Erase(a1);
  result = v1;
  *v1 = v3;
  return result;
}
// 180065D4B: variable 'v1' is possibly undefined
// 180065D4E: variable 'v3' is possibly undefined

//----- (0000000180065D60) ----------------------------------------------------
__int64 __fastcall RpcServer::AcquireStateChangeNotification(RTL_SRWLOCK *this, char *a2, union _LARGE_INTEGER **a3)
{
  const unsigned __int16 *v6; // r8
  __int64 result; // rax
  const unsigned __int16 *v8; // rdx
  int CallerToken; // edi
  _QWORD *v10; // rcx
  unsigned __int16 v11; // dx
  union _LARGE_INTEGER *v12; // rcx
  signed int LastError; // eax
  HANDLE ClientToken[3]; // [rsp+38h] [rbp-D0h] BYREF
  LONGLONG v15; // [rsp+50h] [rbp-B8h] BYREF
  char v16[16]; // [rsp+58h] [rbp-B0h] BYREF
  char v17[16]; // [rsp+68h] [rbp-A0h] BYREF
  wmi::RefBase *v18; // [rsp+78h] [rbp-90h] BYREF
  unsigned __int16 v19[264]; // [rsp+88h] [rbp-80h] BYREF

  ClientToken[1] = (HANDLE)-2LL;
  if ( a2 && a3 )
  {
    *a3 = 0LL;
    memset_0(v19, 0, 0x20AuLL);
    result = tsched::TaskPathCanonicalize((tsched *)v19, a2, v6);
    if ( (int)result < 0 )
      return result;
    if ( !tsched::IsRoot((tsched *)v19, v8) )
    {
      ClientToken[0] = 0LL;
      CallerToken = GetCallerToken(L"AcquireStateChangeNotification", ClientToken);
      if ( CallerToken < 0 )
      {
LABEL_30:
        wmi::AutoHandle::Close(ClientToken);
        return (unsigned int)CallerToken;
      }
      ClientToken[2] = &this[2];
      AcquireSRWLockShared(this + 2);
      CallerToken = TaskAccessCheck(ClientToken[0], v19, 1u);
      if ( CallerToken < 0 )
      {
        if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
          && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x200) != 0
          && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
        {
          WPP_SF_SD(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x51u,
            (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids,
            v19);
        }
        goto LABEL_29;
      }
      JobMoniker::JobMoniker((JobMoniker *)v16, v19, 0LL);
      CallerToken = JobStore::LoadBucketFromRegistry((HKEY *)JobStore::m_pCommonStore, v19, 2, (__int64)v16, 0LL, 0LL);
      if ( CallerToken < 0 )
      {
        v10 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
          || (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x200) == 0
          || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
        {
          goto LABEL_28;
        }
        v11 = 82;
        goto LABEL_23;
      }
      if ( (*((_DWORD *)v18 + 4) & 0x2000000) != 0 )
      {
        CallerToken = (*((__int64 (__fastcall **)(void ***, char *, LONGLONG *))UbpmProxySingleton::s_singleton[0] + 3))(
                        UbpmProxySingleton::s_singleton,
                        v16,
                        &v15);
        if ( CallerToken >= 0 )
        {
          v12 = (union _LARGE_INTEGER *)HeapAlloc(g_PrivateHeap, 0, 8uLL);
          if ( v12 )
          {
            v12->QuadPart = v15;
            *a3 = v12;
          }
          else
          {
            LastError = GetLastError();
            CallerToken = LastError;
            if ( LastError > 0 )
              CallerToken = (unsigned __int16)LastError | 0x80070000;
          }
          goto LABEL_28;
        }
        v10 = WPP_GLOBAL_Control;
        if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
          && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x200) != 0
          && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
        {
          v11 = 83;
LABEL_23:
          WPP_SF_SD(v10[2], v11, (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids, v19);
        }
      }
      else
      {
        CallerToken = -2147024846;
      }
LABEL_28:
      wmi::AutoRef<JobBucket>::Release(&v18);
      _bstr_t::_Free((_bstr_t *)v17);
LABEL_29:
      ReleaseSRWLockShared(this + 2);
      goto LABEL_30;
    }
  }
  return 2147942487LL;
}
// 180065DCE: variable 'v6' is possibly undefined
// 180065DDF: variable 'v8' is possibly undefined
// 1800747C8: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 1800AFFB0: using guessed type void **UbpmProxySingleton::s_singleton[2];
// 180065D60: using guessed type char var_250[16];

//----- (0000000180066058) ----------------------------------------------------
__int64 __fastcall TaskAccessChecker::AllowEnumInstance(TaskAccessChecker *this, const struct JobMoniker *a2)
{
  void *v2; // rbx
  const unsigned __int16 *Path; // rax
  __int64 result; // rax

  if ( *(_BYTE *)this )
    return 0LL;
  v2 = (void *)*((_QWORD *)this + 2);
  Path = JobMoniker::GetPath(a2);
  result = TaskAccessCheck(v2, Path, 1u);
  if ( (int)result >= 0 )
    return 0LL;
  return result;
}

//----- (0000000180066094) ----------------------------------------------------
__int64 __fastcall TaskAccessChecker::AllowStopInstance(TaskAccessChecker *this, const struct JobMoniker *a2)
{
  User::UserEntry *v4; // rcx
  void *v5; // rbx
  const unsigned __int16 *Path; // rdx
  int v7; // ebx
  User::UserEntry *v9; // [rsp+40h] [rbp+8h] BYREF

  if ( !*(_BYTE *)this )
  {
    v4 = *(User::UserEntry **)(*((_QWORD *)a2 + 4) + 64LL);
    v9 = v4;
    if ( v4 )
      User::UserEntry::AddRef(v4);
    if ( !User::operator==((TaskAccessChecker *)((char *)this + 8), (User *)&v9) )
    {
      v5 = (void *)*((_QWORD *)this + 2);
      Path = JobMoniker::GetPath(a2);
      v7 = TaskAccessCheck(v5, Path, 0x20u);
      if ( v7 < 0 )
      {
        wmi::AutoRef<User::UserEntry>::Release(&v9);
        return (unsigned int)v7;
      }
    }
    wmi::AutoRef<User::UserEntry>::Release(&v9);
  }
  return 0LL;
}
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);

//----- (0000000180066138) ----------------------------------------------------
__int64 __fastcall RpcServer::CreateFolder(RTL_SRWLOCK *this, unsigned __int16 *a2, const unsigned __int16 *a3, int a4)
{
  const unsigned __int16 *v7; // r8
  __int64 result; // rax
  const unsigned __int16 *v9; // rdx
  int CallerToken; // edi
  RTL_SRWLOCK *v11; // rbx
  JobStore *v12; // rsi
  RpcServer *v13; // rcx
  __int64 v14; // [rsp+38h] [rbp-D0h] BYREF
  HANDLE ClientToken; // [rsp+40h] [rbp-C8h] BYREF
  PSECURITY_DESCRIPTOR NewDescriptor[2]; // [rsp+48h] [rbp-C0h] BYREF
  PSECURITY_DESCRIPTOR pSecurityDescriptor[4]; // [rsp+58h] [rbp-B0h] BYREF
  unsigned __int16 v18[264]; // [rsp+78h] [rbp-90h] BYREF

  pSecurityDescriptor[2] = (PSECURITY_DESCRIPTOR)-2LL;
  if ( !a2 || a4 )
    return 2147942487LL;
  memset_0(v18, 0, 0x20AuLL);
  result = tsched::TaskPathCanonicalize((tsched *)v18, a2, v7);
  if ( (int)result < 0 )
    return result;
  if ( tsched::IsRoot((tsched *)v18, v9) )
    return 2147942487LL;
  ClientToken = 0LL;
  CallerToken = GetCallerToken(L"CreateFolder", &ClientToken);
  if ( CallerToken >= 0 )
  {
    v11 = this + 2;
    pSecurityDescriptor[3] = &this[2];
    AcquireSRWLockExclusive(this + 2);
    v12 = JobStore::m_pCommonStore;
    JobSecurity::JobSecurity((JobSecurity *)pSecurityDescriptor);
    CallerToken = RpcServer::CreateRegistrationPath(v13, v18, (struct JobSecurity *)pSecurityDescriptor, ClientToken);
    if ( CallerToken >= 0 )
    {
      CallerToken = JobAccessCheck(ClientToken, pSecurityDescriptor[0], 4u);
      if ( CallerToken >= 0 )
      {
        JobSecurity::JobSecurity((JobSecurity *)NewDescriptor);
        CallerToken = JobStore::GenerateJobSecurity(v12, v18, a3, 1u, ClientToken, NewDescriptor);
        if ( CallerToken >= 0 )
        {
          CallerToken = JobStore::RegFolderEntryCreate(v12, v18, (const struct JobSecurity *)NewDescriptor);
          if ( CallerToken >= 0 )
          {
            RpcAutoImpersonate::RpcAutoImpersonate((RpcAutoImpersonate *)&v14, L"RpcServer::CreateFolder", 1);
            CallerToken = JobStore::CreateXmlFolder(v12, v18, a3);
            if ( CallerToken >= 0 )
            {
              if ( (_DWORD)v14 )
                RpcRevertToSelf();
              CallerToken = 0;
            }
            else if ( (_DWORD)v14 )
            {
              RpcRevertToSelf();
            }
          }
        }
        tsched::AutoLocalPtr<unsigned short>::~AutoLocalPtr<unsigned short>(NewDescriptor);
      }
    }
    tsched::AutoLocalPtr<unsigned short>::~AutoLocalPtr<unsigned short>(pSecurityDescriptor);
    ReleaseSRWLockExclusive(v11);
  }
  wmi::AutoHandle::Close((wmi::AutoHandle *)&ClientToken);
  return (unsigned int)CallerToken;
}
// 1800661A4: variable 'v7' is possibly undefined
// 1800661B6: variable 'v9' is possibly undefined
// 18006621E: variable 'v13' is possibly undefined
// 180002A4C: using guessed type __int64 __fastcall tsched::AutoLocalPtr<unsigned short>::~AutoLocalPtr<unsigned short>(_QWORD);

//----- (0000000180066398) ----------------------------------------------------
__int64 __fastcall RpcServer::CreateRegistrationPath(
        RpcServer *this,
        const unsigned __int16 *a2,
        struct JobSecurity *a3,
        void *a4)
{
  JobSecurity *v4; // rbx
  HKEY *v5; // r15
  char v6; // r12
  char v7; // r13
  wchar_t *v8; // rdi
  wchar_t *v9; // rax
  wchar_t *v10; // rax
  unsigned __int16 *v11; // r14
  int XmlFileSystemPath; // esi
  WCHAR *v13; // rbx
  struct _SECURITY_DESCRIPTOR *v14; // rdx
  wchar_t *v15; // rax
  wchar_t *v16; // rax
  LPCWSTR pszPath; // [rsp+30h] [rbp-30h] BYREF
  wchar_t *Str; // [rsp+38h] [rbp-28h] BYREF
  wchar_t *v20; // [rsp+40h] [rbp-20h]
  __int64 v21; // [rsp+48h] [rbp-18h]
  PSECURITY_DESCRIPTOR NewDescriptor; // [rsp+50h] [rbp-10h] BYREF
  int v23; // [rsp+58h] [rbp-8h]
  RpcServer *v24; // [rsp+A0h] [rbp+40h] BYREF
  JobSecurity *v25; // [rsp+B0h] [rbp+50h]
  HANDLE ClientToken; // [rsp+B8h] [rbp+58h]

  ClientToken = a4;
  v25 = a3;
  v24 = this;
  v21 = -2LL;
  v4 = a3;
  v5 = (HKEY *)JobStore::m_pCommonStore;
  v6 = 0;
  v7 = 0;
  ATL::CComBSTR::CComBSTR((ATL::CComBSTR *)&Str, a2);
  v8 = Str;
  wcschr(Str, 0);
  v9 = wcsrchr(v8, 0x5Cu);
  if ( v9 )
    *v9 = 0;
  v20 = wcschr(v8, 0);
  v10 = wcschr(v8, 0x5Cu);
  if ( v10 )
    *v10 = 0;
  v11 = v8;
  while ( 1 )
  {
    XmlFileSystemPath = JobStore::RegJobSecurityQuery(v5, v11, (void **)v4);
    if ( tsched::IsErrorNotFound((tsched *)(unsigned int)XmlFileSystemPath) )
    {
      v6 = 1;
    }
    else if ( XmlFileSystemPath < 0 )
    {
      goto LABEL_34;
    }
    v13 = 0LL;
    pszPath = 0LL;
    if ( JobStore::GetUseXmlStore((JobStore *)v5) )
    {
      XmlFileSystemPath = JobStore::GetXmlFileSystemPath((char **)v5, (char *)v11, (void **)&pszPath);
      v13 = (WCHAR *)pszPath;
      if ( XmlFileSystemPath >= 0 && !PathFileExistsW(pszPath) )
        XmlFileSystemPath = -2147024893;
    }
    else
    {
      XmlFileSystemPath = 0;
    }
    operator delete(v13);
    if ( tsched::IsErrorNotFound((tsched *)(unsigned int)XmlFileSystemPath) )
    {
      v7 = 1;
    }
    else if ( XmlFileSystemPath < 0 )
    {
      goto LABEL_34;
    }
    XmlFileSystemPath = 0;
    v4 = v25;
    if ( v6 )
    {
      XmlFileSystemPath = JobAccessCheck(ClientToken, *(PSECURITY_DESCRIPTOR *)v25, 4u);
      if ( XmlFileSystemPath < 0 )
        goto LABEL_34;
      JobSecurity::JobSecurity((JobSecurity *)&NewDescriptor);
      XmlFileSystemPath = JobStore::GenerateJobSecurity(v5, (tsched *)v11, 0LL, 1u, ClientToken, &NewDescriptor);
      if ( XmlFileSystemPath < 0
        || (XmlFileSystemPath = JobStore::RegFolderEntryCreate(
                                  (JobStore *)v5,
                                  v11,
                                  (const struct JobSecurity *)&NewDescriptor),
            XmlFileSystemPath < 0) )
      {
        tsched::AutoLocalPtr<unsigned short>::~AutoLocalPtr<unsigned short>(&NewDescriptor);
        goto LABEL_34;
      }
      XmlFileSystemPath = 0;
      v23 = 0;
      v14 = (struct _SECURITY_DESCRIPTOR *)NewDescriptor;
      NewDescriptor = 0LL;
      JobSecurity::Attach((void **)v4, v14);
      tsched::AutoLocalPtr<unsigned short>::~AutoLocalPtr<unsigned short>(&NewDescriptor);
    }
    if ( v7 )
      break;
LABEL_26:
    v15 = wcschr(v8, 0);
    if ( v20 != v15 )
    {
      *v15 = 92;
      v16 = wcschr(v15 + 1, 0x5Cu);
      if ( v16 )
        *v16 = 0;
      v11 = v8;
      if ( v8 )
        continue;
    }
    goto LABEL_34;
  }
  RpcAutoImpersonate::RpcAutoImpersonate((RpcAutoImpersonate *)&v24, L"RpcServer::CreateRegistrationPath", 1);
  XmlFileSystemPath = JobStore::CreateXmlFolder((JobStore *)v5, (char *)v11, 0LL);
  if ( XmlFileSystemPath >= 0 )
  {
    XmlFileSystemPath = 0;
    if ( (_DWORD)v24 )
      RpcRevertToSelf();
    goto LABEL_26;
  }
  if ( (_DWORD)v24 )
    RpcRevertToSelf();
LABEL_34:
  SysFreeString(v8);
  return (unsigned int)XmlFileSystemPath;
}

//----- (000000018006667C) ----------------------------------------------------
__int64 __fastcall RpcServer::EnumIndex(
        RpcServer *this,
        int a2,
        unsigned int *a3,
        unsigned int a4,
        unsigned int *a5,
        unsigned __int16 ***a6)
{
  int v8; // edx
  int v9; // edx
  int v10; // edx
  int v11; // ebx
  unsigned int v12; // r15d
  int CallerToken; // esi
  RTL_SRWLOCK *v14; // rdi
  unsigned int v15; // ecx
  __int64 v16; // r14
  _QWORD *v17; // rbx
  unsigned __int16 *v18; // r12
  unsigned __int64 v19; // r14
  int Next; // eax
  const unsigned __int16 *Path; // rax
  const unsigned __int16 *v22; // rsi
  unsigned __int64 v23; // r9
  unsigned __int16 *v24; // r8
  unsigned __int64 v25; // rax
  unsigned __int16 **v26; // rax
  int v28; // [rsp+38h] [rbp-79h]
  unsigned __int16 *v29; // [rsp+40h] [rbp-71h] BYREF
  IndexEnumerator *v30; // [rsp+48h] [rbp-69h] BYREF
  unsigned __int64 v31; // [rsp+50h] [rbp-61h] BYREF
  HANDLE ClientToken; // [rsp+58h] [rbp-59h] BYREF
  unsigned int *v33; // [rsp+60h] [rbp-51h]
  unsigned __int16 ***v34; // [rsp+68h] [rbp-49h]
  unsigned int *v35; // [rsp+70h] [rbp-41h]
  __int64 v36; // [rsp+78h] [rbp-39h]
  RTL_SRWLOCK *v37; // [rsp+80h] [rbp-31h]
  _QWORD *v38; // [rsp+88h] [rbp-29h]
  char v39[16]; // [rsp+90h] [rbp-21h] BYREF
  char v40[16]; // [rsp+A0h] [rbp-11h] BYREF
  wmi::RefBase *v41; // [rsp+B0h] [rbp-1h] BYREF

  v36 = -2LL;
  v33 = a3;
  v35 = a5;
  v34 = a6;
  if ( !a5 || !a6 || !a3 )
    return 2147942487LL;
  v8 = a2 - 1;
  if ( !v8 )
  {
    v11 = 1;
    goto LABEL_12;
  }
  v9 = v8 - 1;
  if ( !v9 )
  {
    v11 = 2;
    goto LABEL_12;
  }
  v10 = v9 - 1;
  if ( !v10 )
  {
    v11 = 3;
    goto LABEL_12;
  }
  if ( v10 != 1 )
    return 2147942487LL;
  v11 = 4;
LABEL_12:
  *a5 = 0;
  *a6 = 0LL;
  v30 = 0LL;
  v28 = 0;
  v12 = 0;
  ClientToken = 0LL;
  CallerToken = GetCallerToken(L"EnumIndex", &ClientToken);
  if ( CallerToken >= 0 )
  {
    v14 = (RTL_SRWLOCK *)((char *)this + 16);
    v37 = v14;
    AcquireSRWLockShared(v14);
    CallerToken = JobStore::EnumStoredTasks((__int64)JobStore::m_pCommonStore, v11, &v30);
    if ( CallerToken >= 0 )
    {
      if ( a4 - 1 > 0x1FF )
        a4 = 512;
      v15 = 0x10000;
      if ( 528 * (unsigned __int64)a4 <= 0x10000 )
        v15 = 528 * a4;
      v16 = v15;
      v17 = operator new(v15);
      v38 = v17;
      if ( v17 )
      {
        v18 = (unsigned __int16 *)&v17[a4];
        v29 = v18;
        v19 = (v16 - 8 * (unsigned __int64)a4) >> 1;
        v31 = v19;
        if ( a4 )
        {
          do
          {
            Next = IndexEnumerator::FindNext(v30);
            if ( Next < 0 || Next == 1 )
              break;
            JobMoniker::JobMoniker((JobMoniker *)v39, 0LL, 0LL);
            CallerToken = IndexEnumerator::GetMoniker(v30, (struct JobMoniker *)v39);
            if ( CallerToken < 0 )
              goto LABEL_40;
            Path = JobMoniker::GetPath((JobMoniker *)v39);
            v22 = Path;
            if ( !Path )
            {
              CallerToken = -2147418113;
LABEL_40:
              wmi::AutoRef<JobBucket>::Release(&v41);
              _bstr_t::_Free((_bstr_t *)v40);
              goto LABEL_43;
            }
            if ( (int)TaskAccessCheck(ClientToken, Path, 1u) >= 0 && ++v28 >= *v33 )
            {
              if ( (int)StringCchCopyExW(v18, v19, v22, &v29, &v31) < 0 )
              {
                wmi::AutoRef<JobBucket>::Release(&v41);
                _bstr_t::_Free((_bstr_t *)v40);
                break;
              }
              v17[v12++] = v18;
              v23 = v31;
              v24 = v29;
              if ( v31 )
              {
                v24 = v29 + 1;
                v23 = v31 - 1;
              }
              v25 = 4 * ((v24 - v18 + 3) / 4) - (v24 - v18);
              if ( v25 >= v23 )
              {
                v19 = 0LL;
                v18 = &v24[v23];
              }
              else
              {
                v19 = v23 - v25;
                v18 = &v24[v25];
              }
              v29 = v18;
              v31 = v19;
            }
            wmi::AutoRef<JobBucket>::Release(&v41);
            _bstr_t::_Free((_bstr_t *)v40);
          }
          while ( v12 < a4 );
          if ( !v12 )
            goto LABEL_41;
          v26 = (unsigned __int16 **)v17;
          v17 = 0LL;
        }
        else
        {
LABEL_41:
          v26 = 0LL;
        }
        *v34 = v26;
        *v35 = v12;
        *v33 += v12;
        CallerToken = 0;
      }
      else
      {
        CallerToken = -2147024882;
      }
LABEL_43:
      operator delete(v17);
    }
    ReleaseSRWLockShared(v14);
  }
  wmi::AutoHandle::Close(&ClientToken);
  wmi::AutoRef<FolderEnumerator>::~AutoRef<FolderEnumerator>(&v30);
  return (unsigned int)CallerToken;
}
// 1800090EC: using guessed type __int64 __fastcall wmi::AutoRef<FolderEnumerator>::~AutoRef<FolderEnumerator>(_QWORD);

//----- (00000001800669FC) ----------------------------------------------------
__int64 __fastcall RpcServer::EnumInstances(RpcServer *this, char *a2, int a3, unsigned int *a4, struct _GUID **a5)
{
  unsigned int v7; // esi
  int BucketFromRegistry; // r15d
  __int64 v10; // rcx
  const unsigned __int16 *v11; // r8
  unsigned __int64 v12; // r12
  struct _GUID *v13; // r14
  RTL_SRWLOCK *v14; // rdi
  __int64 v15; // rcx
  BSTR **v16; // rbx
  __int64 v17; // rcx
  _QWORD *v18; // rax
  struct _GUID *v19; // rax
  struct _GUID *i; // rcx
  struct _GUID *v21; // rcx
  struct _GUID *v22; // rbx
  void *lpMem[2]; // [rsp+38h] [rbp-D0h] BYREF
  __int64 v24; // [rsp+48h] [rbp-C0h]
  struct _GUID **v25; // [rsp+50h] [rbp-B8h]
  unsigned int *v26; // [rsp+58h] [rbp-B0h]
  char v27[8]; // [rsp+60h] [rbp-A8h] BYREF
  char v28[8]; // [rsp+68h] [rbp-A0h] BYREF
  void *v29[2]; // [rsp+70h] [rbp-98h] BYREF
  unsigned __int64 v30; // [rsp+80h] [rbp-88h]
  __int64 v31; // [rsp+88h] [rbp-80h]
  RTL_SRWLOCK *v32; // [rsp+90h] [rbp-78h]
  _bstr_t::Data_t *v33[2]; // [rsp+98h] [rbp-70h] BYREF
  BSTR *v34[2]; // [rsp+A8h] [rbp-60h] BYREF
  wmi::RefBase *v35; // [rsp+B8h] [rbp-50h] BYREF
  unsigned __int16 v36[264]; // [rsp+C8h] [rbp-40h] BYREF

  v31 = -2LL;
  v26 = a4;
  LODWORD(v24) = a3;
  v25 = a5;
  v7 = 0;
  *a4 = 0;
  *a5 = 0LL;
  if ( (a3 & 0xFFFFFFFE) != 0 )
    return 2147942487LL;
  BucketFromRegistry = 0;
  TaskAccessChecker::TaskAccessChecker((TaskAccessChecker *)v27);
  JobMoniker::JobMoniker((JobMoniker *)v33, 0LL, 0LL);
  if ( a2 )
  {
    memset_0(v36, 0, 0x20AuLL);
    BucketFromRegistry = tsched::TaskPathCanonicalize((tsched *)v36, a2, v11);
    if ( BucketFromRegistry < 0 )
      goto LABEL_34;
    JobMoniker::_SetPath(v33, v36);
    BucketFromRegistry = TaskAccessChecker::AllowEnumInstance((TaskAccessChecker *)v27, (const struct JobMoniker *)v33);
    if ( BucketFromRegistry < 0 )
      goto LABEL_34;
    BucketFromRegistry = JobStore::LoadBucketFromRegistry(
                           (HKEY *)JobStore::m_pCommonStore,
                           v36,
                           2,
                           (__int64)v33,
                           0LL,
                           0LL);
    if ( BucketFromRegistry < 0 )
      goto LABEL_34;
  }
  v12 = 0LL;
  v30 = 0LL;
  v13 = (struct _GUID *)std::_List_alloc<0,std::_List_base_types<_GUID>>::_Buynode0(v10, 0LL, 0LL);
  v29[1] = v13;
  if ( a2 && (*((_DWORD *)v35 + 4) & 0x2000000) == 0 )
    goto LABEL_31;
  v14 = (RTL_SRWLOCK *)((char *)this + 16);
  v32 = v14;
  AcquireSRWLockShared(v14);
  lpMem[1] = 0LL;
  lpMem[0] = std::_List_alloc<0,std::_List_base_types<UbpmInstance>>::_Buynode0(v15, 0LL, 0LL);
  if ( a2 )
  {
    BucketFromRegistry = (*((__int64 (__fastcall **)(void ***, _bstr_t::Data_t **, void **))UbpmProxySingleton::s_singleton[0]
                          + 8))(
                           UbpmProxySingleton::s_singleton,
                           v33,
                           lpMem);
    if ( tsched::IsErrorNotFound((tsched *)(unsigned int)BucketFromRegistry) )
      BucketFromRegistry = 0;
  }
  else
  {
    BucketFromRegistry = (*((__int64 (__fastcall **)(void ***, void **))UbpmProxySingleton::s_singleton[0] + 9))(
                           UbpmProxySingleton::s_singleton,
                           lpMem);
  }
  if ( BucketFromRegistry < 0 )
  {
    std::list<UbpmInstance>::clear((__int64)lpMem);
    operator delete(lpMem[0]);
    ReleaseSRWLockShared(v14);
    goto LABEL_31;
  }
  v16 = (BSTR **)lpMem[0];
  while ( 1 )
  {
    v16 = (BSTR **)*v16;
    if ( v16 == lpMem[0] )
      break;
    if ( (v24 & 1) != 0 || ((_DWORD)v16[6][2] & 0x800000) == 0 )
    {
      if ( a2 )
      {
        if ( !(unsigned int)_bstr_t::_Compare(v34, v16 + 4) )
        {
LABEL_23:
          v18 = std::_List_buy<_GUID>::_Buynode<_GUID const &>(v17, v13, *(_QWORD **)v13->Data4, v16 + 7);
          if ( v12 == 0x7FFFFFFFFFFFFFELL )
            std::_Xlength_error("list<T> too long");
          v30 = ++v12;
          *(_QWORD *)v13->Data4 = v18;
          *(_QWORD *)v18[1] = v18;
        }
      }
      else if ( (int)TaskAccessChecker::AllowEnumInstance(
                       (TaskAccessChecker *)v27,
                       (const struct JobMoniker *)(v16 + 2)) >= 0 )
      {
        goto LABEL_23;
      }
    }
  }
  std::list<UbpmInstance>::clear((__int64)lpMem);
  operator delete(lpMem[0]);
  ReleaseSRWLockShared(v14);
  if ( v12 )
  {
    v19 = (struct _GUID *)operator new(saturated_mul(v12, 0x10uLL));
    for ( i = *(struct _GUID **)&v13->Data1; i != v13; i = *(struct _GUID **)&i->Data1 )
      v19[v7++] = i[1];
    *v25 = v19;
    *v26 = v7;
    operator delete(0LL);
  }
LABEL_31:
  v21 = *(struct _GUID **)&v13->Data1;
  *(_QWORD *)&v13->Data1 = v13;
  *(_QWORD *)v13->Data4 = v13;
  if ( v21 != v13 )
  {
    do
    {
      v22 = *(struct _GUID **)&v21->Data1;
      operator delete(v21);
      v21 = v22;
    }
    while ( v22 != v13 );
  }
  operator delete(v13);
LABEL_34:
  wmi::AutoRef<JobBucket>::Release(&v35);
  _bstr_t::_Free((_bstr_t *)v34);
  wmi::AutoHandle::Close(v29);
  wmi::AutoRef<User::UserEntry>::Release(v28);
  return (unsigned int)BucketFromRegistry;
}
// 180066AA6: variable 'v11' is possibly undefined
// 180066B18: variable 'v10' is possibly undefined
// 180066B62: variable 'v15' is possibly undefined
// 180066C40: variable 'v17' is possibly undefined
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);
// 1800747C8: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 1800AFFB0: using guessed type void **UbpmProxySingleton::s_singleton[2];
// 1800669FC: using guessed type char var_2B0[8];
// 1800669FC: using guessed type char var_2B8[8];

//----- (0000000180066DB4) ----------------------------------------------------
__int64 __fastcall RpcServer::GetBasicInstanceInfo(
        RpcServer *this,
        struct _GUID *a2,
        struct JobMoniker *a3,
        enum tsched::InternalTaskState *a4,
        struct _bstr_t *a5,
        unsigned int *a6)
{
  tsched *v9; // rcx
  bool v10; // si
  int CallerToken; // ebx
  int v12; // eax
  HANDLE v13; // rbx
  const unsigned __int16 *Path; // rax
  int v16; // [rsp+40h] [rbp-58h] BYREF
  HANDLE ClientToken[10]; // [rsp+48h] [rbp-50h] BYREF

  ClientToken[1] = (HANDLE)-2LL;
  RpcAutoImpersonate::RpcAutoImpersonate((RpcAutoImpersonate *)&v16, L"GetBasicInstanceInfo", 1);
  v10 = (unsigned int)tsched::IsUserAdmin(v9) || IsImpersonatedAsLocalSystem();
  if ( v16 )
    RpcRevertToSelf();
  ClientToken[0] = 0LL;
  CallerToken = GetCallerToken(L"GetBasicInstanceInfo", ClientToken);
  if ( CallerToken >= 0 )
  {
    *(_DWORD *)a4 = 0;
    v12 = (*((__int64 (__fastcall **)(void ***, struct _GUID *, enum tsched::InternalTaskState *, struct JobMoniker *, struct _bstr_t *, unsigned int *))UbpmProxySingleton::s_singleton[0]
           + 10))(
            UbpmProxySingleton::s_singleton,
            a2,
            a4,
            a3,
            a5,
            a6);
    CallerToken = v12;
    if ( v12 == -2147023728 )
      goto LABEL_14;
    if ( v12 < 0 )
      goto LABEL_16;
    if ( v10 )
      goto LABEL_13;
    if ( !*(_DWORD *)a4 )
    {
LABEL_14:
      CallerToken = -2147216629;
      goto LABEL_16;
    }
    v13 = ClientToken[0];
    Path = JobMoniker::GetPath(a3);
    CallerToken = TaskAccessCheck(v13, Path, 1u);
    if ( CallerToken >= 0 )
    {
LABEL_13:
      if ( *(_DWORD *)a4 )
      {
        CallerToken = 0;
        goto LABEL_16;
      }
      goto LABEL_14;
    }
  }
LABEL_16:
  wmi::AutoHandle::Close(ClientToken);
  return (unsigned int)CallerToken;
}
// 180066DFD: variable 'v9' is possibly undefined
// 1800747C8: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 1800AFFB0: using guessed type void **UbpmProxySingleton::s_singleton[2];

//----- (0000000180066EF8) ----------------------------------------------------
__int64 __fastcall RpcServer::GetInstanceInfo(
        RpcServer *this,
        struct _GUID *a2,
        unsigned __int16 **a3,
        unsigned int *a4,
        unsigned __int16 **a5,
        unsigned __int16 **a6,
        unsigned int *a7,
        struct _GUID **a8,
        unsigned int *a9)
{
  RTL_SRWLOCK *v13; // rbx
  RpcServer *v14; // rcx
  int BasicInstanceInfo; // edi
  tsched *Path; // rcx
  const unsigned __int16 *v17; // rdx
  char *v18; // rax
  UINT v19; // eax
  _QWORD *v20; // rsi
  __int64 v21; // rdi
  char *v22; // rcx
  BSTR v23; // r8
  BSTR *v25; // [rsp+38h] [rbp-69h] BYREF
  int v26; // [rsp+40h] [rbp-61h] BYREF
  unsigned int v27; // [rsp+44h] [rbp-5Dh] BYREF
  struct _GUID v28; // [rsp+48h] [rbp-59h] BYREF
  unsigned __int16 **v29; // [rsp+58h] [rbp-49h]
  unsigned int *v30; // [rsp+60h] [rbp-41h]
  __int64 v31; // [rsp+68h] [rbp-39h]
  RTL_SRWLOCK *v32; // [rsp+70h] [rbp-31h]
  char v33[16]; // [rsp+78h] [rbp-29h] BYREF
  char v34[16]; // [rsp+88h] [rbp-19h] BYREF
  wmi::RefBase *v35; // [rsp+98h] [rbp-9h] BYREF

  v31 = -2LL;
  v29 = a5;
  v30 = a9;
  if ( a3 )
    *a3 = 0LL;
  if ( a5 )
    *a5 = 0LL;
  if ( a6 )
    *a6 = 0LL;
  if ( a7 )
    *a7 = 0;
  if ( a8 )
    *a8 = 0LL;
  JobMoniker::JobMoniker((JobMoniker *)v33, 0LL, 0LL);
  v25 = 0LL;
  v13 = (RTL_SRWLOCK *)((char *)this + 16);
  v32 = v13;
  AcquireSRWLockShared(v13);
  v28 = *a2;
  BasicInstanceInfo = RpcServer::GetBasicInstanceInfo(
                        v14,
                        &v28,
                        (struct JobMoniker *)v33,
                        (enum tsched::InternalTaskState *)&v26,
                        (struct _bstr_t *)&v25,
                        &v27);
  if ( BasicInstanceInfo >= 0 )
  {
    if ( a3 )
    {
      *(_QWORD *)&v28.Data1 = 0LL;
      Path = (tsched *)JobMoniker::GetPath((JobMoniker *)v33);
      v18 = tsched::PathCopy(Path, v17);
      wmi::AutoVectorPtr<unsigned char>::operator=((void **)&v28, v18);
      *a3 = *(unsigned __int16 **)&v28.Data1;
      operator delete(0LL);
    }
    if ( a4 )
    {
      if ( v26 == 1 )
      {
        *a4 = 2;
      }
      else if ( v26 == 2 )
      {
        *a4 = 4;
      }
    }
    if ( v25 && *v25 )
      v19 = SysStringLen(*v25);
    else
      v19 = 0;
    v20 = v29;
    if ( v29 && v19 )
    {
      v21 = v19 + 1LL;
      v22 = (char *)operator new(saturated_mul(v21, 2uLL));
      *v20 = v22;
      if ( v25 )
        v23 = *v25;
      else
        v23 = 0LL;
      StringCchCopyW(v22, v21, (char *)v23);
    }
    if ( a6 )
      *a6 = 0LL;
    if ( a7 )
      *a7 = 0;
    if ( a8 )
      *a8 = 0LL;
    if ( v30 )
      *v30 = v27;
    BasicInstanceInfo = 0;
  }
  ReleaseSRWLockShared(v13);
  _bstr_t::_Free((_bstr_t *)&v25);
  wmi::AutoRef<JobBucket>::Release(&v35);
  _bstr_t::_Free((_bstr_t *)v34);
  return (unsigned int)BasicInstanceInfo;
}
// 180066FD3: variable 'v14' is possibly undefined
// 180066FF8: variable 'v17' is possibly undefined
// 180066EF8: using guessed type char var_50[16];

//----- (0000000180067164) ----------------------------------------------------
__int64 __fastcall RpcServer::GetLastRunInfo(RTL_SRWLOCK *this, char *a2, struct _SYSTEMTIME *a3, unsigned int *a4)
{
  const unsigned __int16 *v8; // r8
  __int64 result; // rax
  int CallerToken; // edi
  int v11; // eax
  __int64 v12; // rax
  unsigned int v13; // [rsp+40h] [rbp-C0h] BYREF
  __int64 v14; // [rsp+48h] [rbp-B8h] BYREF
  HANDLE ClientToken; // [rsp+50h] [rbp-B0h] BYREF
  __int128 v16; // [rsp+58h] [rbp-A8h] BYREF
  _DWORD v17[5]; // [rsp+68h] [rbp-98h] BYREF
  __int64 v18; // [rsp+7Ch] [rbp-84h]
  __int64 v19; // [rsp+84h] [rbp-7Ch]
  __int64 v20; // [rsp+90h] [rbp-70h] BYREF
  __int64 v21[2]; // [rsp+98h] [rbp-68h] BYREF
  struct _SYSTEMTIME v22; // [rsp+A8h] [rbp-58h] BYREF
  char v23[16]; // [rsp+B8h] [rbp-48h] BYREF
  char v24[16]; // [rsp+C8h] [rbp-38h] BYREF
  wmi::RefBase *v25; // [rsp+D8h] [rbp-28h] BYREF
  unsigned __int16 v26[264]; // [rsp+E0h] [rbp-20h] BYREF

  v21[1] = -2LL;
  if ( a2 && a3 && a4 )
  {
    *a3 = 0LL;
    *a4 = 267011;
    memset_0(v26, 0, 0x20AuLL);
    result = tsched::TaskPathCanonicalize((tsched *)v26, a2, v8);
    if ( (int)result < 0 )
      return result;
    ClientToken = 0LL;
    CallerToken = GetCallerToken(L"GetLastRunInfo", &ClientToken);
    if ( CallerToken < 0 )
      goto LABEL_19;
    JobMoniker::JobMoniker((JobMoniker *)v23, v26, 0LL);
    *(_QWORD *)&v22.wYear = this + 2;
    AcquireSRWLockShared(this + 2);
    CallerToken = TaskAccessCheck(ClientToken, v26, 1u);
    if ( CallerToken < 0
      || (CallerToken = JobStore::LoadBucketFromRegistry(
                          (HKEY *)JobStore::m_pCommonStore,
                          v26,
                          2,
                          (__int64)v23,
                          0LL,
                          0LL),
          CallerToken < 0) )
    {
      ReleaseSRWLockShared(this + 2);
      goto LABEL_18;
    }
    ReleaseSRWLockShared(this + 2);
    v14 = 0LL;
    v21[0] = 0LL;
    v20 = 0LL;
    v13 = 0;
    if ( (*((_DWORD *)v25 + 4) & 0x2000000) != 0 )
    {
      v11 = (*((__int64 (__fastcall **)(void ***, char *, __int64 *, __int64 *, __int64 *, unsigned int *))UbpmProxySingleton::s_singleton[0]
             + 12))(
              UbpmProxySingleton::s_singleton,
              v23,
              &v14,
              v21,
              &v20,
              &v13);
      CallerToken = v11;
      if ( v11 == -2147023728 )
      {
LABEL_15:
        CallerToken = 267011;
        goto LABEL_18;
      }
      if ( v11 >= 0 )
      {
        v12 = v14;
        goto LABEL_14;
      }
    }
    else
    {
      *(_QWORD *)v17 = 3LL;
      v18 = 0LL;
      memset(&v17[2], 0, 12);
      v19 = 0LL;
      CallerToken = JobStore::GetDynamicTaskInfo(
                      JobStore::m_pCommonStore,
                      (struct JobMoniker *)v23,
                      (struct DynamicTaskInfo *)v17,
                      0x20019u,
                      0LL);
      if ( CallerToken >= 0 )
      {
        v12 = *(_QWORD *)&v17[3];
        v14 = *(_QWORD *)&v17[3];
        v13 = v18;
LABEL_14:
        LOBYTE(v16) = 0;
        *((_QWORD *)&v16 + 1) = v12;
        LOBYTE(v22.wYear) = 0;
        *(_QWORD *)&v22.wHour = 0LL;
        if ( !TSTime::operator==((__int64)&v22, &v16) )
        {
          v16 = *TSTime::ToLocal(&v16, &v22);
          *a3 = *TSTime::ToSYSTEMTIME((TSTime *)&v16, &v22);
          *a4 = v13;
          goto LABEL_18;
        }
        goto LABEL_15;
      }
    }
LABEL_18:
    wmi::AutoRef<JobBucket>::Release(&v25);
    _bstr_t::_Free((_bstr_t *)v24);
LABEL_19:
    wmi::AutoHandle::Close(&ClientToken);
    return (unsigned int)CallerToken;
  }
  return 2147942487LL;
}
// 1800671E8: variable 'v8' is possibly undefined
// 1800747C8: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 1800AFFB0: using guessed type void **UbpmProxySingleton::s_singleton[2];
// 180067164: using guessed type char var_268[16];

//----- (0000000180067440) ----------------------------------------------------
__int64 __fastcall RpcServer::GetSecurity(RTL_SRWLOCK *this, char *a2, SECURITY_INFORMATION a3, unsigned __int16 **a4)
{
  unsigned int v8; // esi
  __int64 result; // rax
  const unsigned __int16 *v10; // r8
  RTL_SRWLOCK *v11; // rbx
  HKEY *v12; // rdi
  int Sddl; // eax
  void *v14[4]; // [rsp+20h] [rbp-268h] BYREF
  unsigned __int16 v15[264]; // [rsp+40h] [rbp-248h] BYREF

  v14[2] = (void *)-2LL;
  v8 = 0;
  if ( !a4 )
    return 2147942487LL;
  *a4 = 0LL;
  memset_0(v15, 0, 0x20AuLL);
  result = tsched::TaskPathCanonicalize((tsched *)v15, a2, v10);
  if ( (int)result >= 0 )
  {
    v11 = this + 2;
    v14[3] = &this[2];
    AcquireSRWLockShared(this + 2);
    v12 = (HKEY *)JobStore::m_pCommonStore;
    JobSecurity::JobSecurity((JobSecurity *)v14);
    Sddl = JobStore::RegJobSecurityQuery(v12, v15, v14);
    if ( Sddl < 0 || (Sddl = JobSecurity::GetSddl(v14, a3, a4), Sddl < 0) )
      v8 = Sddl;
    tsched::AutoLocalPtr<unsigned short>::~AutoLocalPtr<unsigned short>(v14);
    ReleaseSRWLockShared(v11);
    return v8;
  }
  return result;
}
// 1800674A3: variable 'v10' is possibly undefined

//----- (000000018006755C) ----------------------------------------------------
__int64 __fastcall RpcServer::GetTaskDynamicData(RTL_SRWLOCK *this, char *a2, struct _SCHRPC_TASK_INFO_OUT_2 **a3)
{
  int v6; // esi
  const unsigned __int16 *v7; // r8
  __int64 result; // rax
  const unsigned __int16 *v9; // rdx
  int CallerToken; // edi
  RTL_SRWLOCK *v11; // rbx
  int v12; // r15d
  __int64 v13; // rax
  char *v14; // rax
  signed int LastError; // eax
  __int64 v16; // [rsp+48h] [rbp-C0h] BYREF
  __int64 v17; // [rsp+50h] [rbp-B8h] BYREF
  __int64 v18; // [rsp+58h] [rbp-B0h] BYREF
  __int128 v19; // [rsp+60h] [rbp-A8h] BYREF
  __int64 v20; // [rsp+70h] [rbp-98h] BYREF
  __int64 v21; // [rsp+78h] [rbp-90h] BYREF
  HANDLE ClientToken; // [rsp+80h] [rbp-88h] BYREF
  _BYTE v23[20]; // [rsp+88h] [rbp-80h] BYREF
  __int64 v24; // [rsp+9Ch] [rbp-6Ch]
  __int64 v25; // [rsp+A4h] [rbp-64h]
  __int128 v26; // [rsp+B0h] [rbp-58h] BYREF
  __int128 v27; // [rsp+C0h] [rbp-48h] BYREF
  __int128 v28; // [rsp+D0h] [rbp-38h] BYREF
  __int64 v29; // [rsp+E0h] [rbp-28h]
  RTL_SRWLOCK *v30; // [rsp+E8h] [rbp-20h]
  char v31[16]; // [rsp+F0h] [rbp-18h] BYREF
  char v32[16]; // [rsp+100h] [rbp-8h] BYREF
  wmi::RefBase *v33; // [rsp+110h] [rbp+8h] BYREF
  unsigned __int16 v34[264]; // [rsp+118h] [rbp+10h] BYREF

  v29 = -2LL;
  v17 = 0LL;
  v20 = 0LL;
  v18 = 0LL;
  LODWORD(v16) = 0;
  v6 = 3;
  memset_0(v34, 0, 0x20AuLL);
  *(_QWORD *)v23 = 3LL;
  v24 = 0LL;
  *(_QWORD *)&v23[8] = 0LL;
  v25 = 0LL;
  *(_DWORD *)&v23[16] = 0;
  if ( a2 && a3 )
  {
    *a3 = 0LL;
    result = tsched::TaskPathCanonicalize((tsched *)v34, a2, v7);
    if ( (int)result < 0 )
      return result;
    if ( !tsched::IsRoot((tsched *)v34, v9) )
    {
      ClientToken = 0LL;
      CallerToken = GetCallerToken(L"GetTaskDynamicData", &ClientToken);
      if ( CallerToken < 0 )
      {
LABEL_46:
        wmi::AutoHandle::Close(&ClientToken);
        return (unsigned int)CallerToken;
      }
      v11 = this + 2;
      v30 = this + 2;
      AcquireSRWLockShared(this + 2);
      CallerToken = TaskAccessCheck(ClientToken, v34, 1u);
      if ( CallerToken < 0 )
      {
        if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
          && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x200) != 0
          && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
        {
          WPP_SF_SD(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x4Fu,
            (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids,
            v34);
        }
        goto LABEL_45;
      }
      JobMoniker::JobMoniker((JobMoniker *)v31, v34, 0LL);
      CallerToken = JobStore::LoadBucketFromRegistry((HKEY *)JobStore::m_pCommonStore, v34, 2, (__int64)v31, 0LL, 0LL);
      if ( CallerToken >= 0 )
      {
        v12 = *((_DWORD *)v33 + 4) & 0x400000;
        if ( (*((_DWORD *)v33 + 4) & 0x2000000) != 0 )
        {
          CallerToken = (*((__int64 (__fastcall **)(void ***, char *, __int64 *))UbpmProxySingleton::s_singleton[0] + 11))(
                          UbpmProxySingleton::s_singleton,
                          v31,
                          &v21);
          if ( CallerToken < 0 )
            goto LABEL_44;
          CallerToken = (*((__int64 (__fastcall **)(void ***, char *, __int64 *, __int64 *, __int64 *, __int64 *))UbpmProxySingleton::s_singleton[0]
                         + 12))(
                          UbpmProxySingleton::s_singleton,
                          v31,
                          &v17,
                          &v20,
                          &v18,
                          &v16);
          if ( tsched::IsErrorNotFound((tsched *)(unsigned int)CallerToken) )
            CallerToken = 0;
          if ( CallerToken < 0 )
            goto LABEL_44;
          v13 = v17;
        }
        else
        {
          CallerToken = JobStore::GetDynamicTaskInfo(
                          JobStore::m_pCommonStore,
                          (struct JobMoniker *)v31,
                          (struct DynamicTaskInfo *)v23,
                          0x20019u,
                          0LL);
          if ( tsched::IsErrorNotFound((tsched *)(unsigned int)CallerToken) )
            CallerToken = 0;
          if ( CallerToken < 0 )
            goto LABEL_44;
          v13 = *(_QWORD *)&v23[12];
          v17 = *(_QWORD *)&v23[12];
          v18 = *(_QWORD *)&v23[4];
          LODWORD(v16) = v24;
        }
        LOBYTE(v26) = 0;
        *((_QWORD *)&v26 + 1) = v13;
        LOBYTE(v19) = 0;
        *((_QWORD *)&v19 + 1) = 0LL;
        if ( TSTime::operator!=((__int64)&v19, &v26) )
          v17 = *((_QWORD *)TSTime::ToLocal(&v26, &v19) + 1);
        LOBYTE(v27) = 0;
        *((_QWORD *)&v27 + 1) = v20;
        LOBYTE(v19) = 0;
        *((_QWORD *)&v19 + 1) = 0LL;
        if ( TSTime::operator!=((__int64)&v19, &v27) )
          v20 = *((_QWORD *)TSTime::ToLocal(&v27, &v19) + 1);
        LOBYTE(v28) = 0;
        *((_QWORD *)&v28 + 1) = v18;
        LOBYTE(v19) = 0;
        *((_QWORD *)&v19 + 1) = 0LL;
        if ( TSTime::operator!=((__int64)&v19, &v28) )
          v18 = *((_QWORD *)TSTime::ToLocal(&v28, &v19) + 1);
        LODWORD(v21) = 4 - (v12 != 0);
        switch ( v12 != 0 )
        {
          case 4:
            v6 = 0;
            break;
          case 3:
            v6 = 2;
            break;
          case 2:
            v6 = 4;
            break;
          default:
            if ( v12 == 0 )
              v6 = 1;
            break;
        }
        v14 = (char *)operator new(0x24uLL);
        if ( v14 )
        {
          *(_DWORD *)v14 = v12 != 0;
          *((_DWORD *)v14 + 1) = v6;
          *((_DWORD *)v14 + 2) = v16;
          *(_QWORD *)(v14 + 12) = v17;
          *(_QWORD *)(v14 + 20) = v20;
          *(_QWORD *)(v14 + 28) = v18;
          *a3 = (struct _SCHRPC_TASK_INFO_OUT_2 *)v14;
        }
        else
        {
          LastError = GetLastError();
          CallerToken = LastError;
          if ( LastError > 0 )
            CallerToken = (unsigned __int16)LastError | 0x80070000;
        }
      }
      else if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
             && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x200) != 0
             && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
      {
        WPP_SF_SD(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x50u,
          (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids,
          v34);
      }
LABEL_44:
      wmi::AutoRef<JobBucket>::Release(&v33);
      _bstr_t::_Free((_bstr_t *)v32);
LABEL_45:
      ReleaseSRWLockShared(v11);
      goto LABEL_46;
    }
  }
  return 2147942487LL;
}
// 1800675FA: variable 'v7' is possibly undefined
// 18006760B: variable 'v9' is possibly undefined
// 1800747C8: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 1800AFFB0: using guessed type void **UbpmProxySingleton::s_singleton[2];
// 18006755C: using guessed type char var_268[16];

//----- (0000000180067A0C) ----------------------------------------------------
__int64 __fastcall RpcServer::MigrateTask(
        void **this,
        unsigned __int16 *a2,
        struct _EVENT_DESCRIPTOR *a3,
        unsigned int a4,
        const unsigned __int16 *a5,
        const unsigned __int16 *a6,
        struct _SCHRPC_DYNAMIC_TASK_INFO *a7)
{
  _QWORD *v11; // rdi
  __int128 v13; // [rsp+68h] [rbp-41h] BYREF
  __int128 v14; // [rsp+78h] [rbp-31h] BYREF
  __int64 v15[2]; // [rsp+88h] [rbp-21h] BYREF
  int v16; // [rsp+98h] [rbp-11h]
  _BYTE v17[20]; // [rsp+A0h] [rbp-9h] BYREF
  int v18; // [rsp+B4h] [rbp+Bh]
  int v19; // [rsp+B8h] [rbp+Fh]
  __int64 v20; // [rsp+BCh] [rbp+13h]

  if ( !a2 || !a3 || !a7 )
    return 2147942487LL;
  v11 = (_QWORD *)((char *)a7 + 4);
  *(_QWORD *)v17 = 3LL;
  *(_QWORD *)&v17[8] = 0LL;
  v20 = 0LL;
  *(_DWORD *)&v17[16] = 0;
  if ( *((_DWORD *)a7 + 2) || *(_DWORD *)v11 )
  {
    *((_QWORD *)&v13 + 1) = *v11;
    LOBYTE(v13) = 1;
    *(_QWORD *)&v17[12] = *((_QWORD *)TSTime::ToGMT(&v13, &v14) + 1);
    if ( *((_DWORD *)a7 + 2) || *(_DWORD *)v11 )
    {
      *((_QWORD *)&v13 + 1) = *v11;
      LOBYTE(v13) = 1;
      *(_QWORD *)&v17[12] = *((_QWORD *)TSTime::ToGMT(&v13, &v14) + 1);
    }
  }
  if ( *((_DWORD *)a7 + 6) || *((_DWORD *)a7 + 5) )
  {
    *((_QWORD *)&v13 + 1) = *(_QWORD *)((char *)a7 + 20);
    LOBYTE(v13) = 1;
    *(_QWORD *)&v17[4] = *((_QWORD *)TSTime::ToGMT(&v13, &v14) + 1);
  }
  if ( *((_DWORD *)a7 + 4) || *((_DWORD *)a7 + 3) )
  {
    *((_QWORD *)&v13 + 1) = *(_QWORD *)((char *)a7 + 12);
    LOBYTE(v13) = 1;
    v20 = *((_QWORD *)TSTime::ToGMT(&v13, &v14) + 1);
  }
  v18 = *(_DWORD *)a7;
  v19 = v18;
  v15[0] = (__int64)a5;
  v15[1] = (__int64)a6;
  v16 = 1;
  return RpcServer::RegisterTask(this, a2, a3, a4, 0LL, 0, 1u, (const struct _TASK_USER_CRED *)v15, v17, 0LL, 0LL);
}

//----- (0000000180067BB4) ----------------------------------------------------
__int64 __fastcall RpcServer::SavePasswords(
        const struct JobMoniker *a1,
        unsigned int a2,
        const struct _TASK_USER_CRED *a3)
{
  __int64 v4; // rsi
  int v5; // ebx
  struct _RTL_CRITICAL_SECTION *v6; // r15
  unsigned int v7; // ebp
  const struct _TASK_USER_CRED *v8; // rdi
  void **v9; // rdx
  __int64 v10; // r8
  _WORD *v11; // rdi
  __int64 v12; // rcx
  User::UserEntry *v14; // [rsp+60h] [rbp+8h] BYREF

  v14 = a1;
  v4 = a2;
  v5 = 0;
  v6 = CredStore::g_pCommonStore;
  v7 = 0;
  if ( a2 )
  {
    v8 = a3;
    while ( 1 )
    {
      v14 = 0LL;
      v5 = User::FromUsername(&v14, *(LPCWSTR *)v8);
      if ( v5 < 0 )
        break;
      v5 = CredStore::StoreNtCredential(v6, (const struct User *)&v14, *((unsigned __int16 **)v8 + 1));
      if ( v5 < 0 )
        break;
      wmi::AutoRef<User::UserEntry>::Release(&v14);
      ++v7;
      v8 = (const struct _TASK_USER_CRED *)((char *)v8 + 24);
      if ( v7 >= (unsigned int)v4 )
        goto LABEL_8;
    }
    wmi::AutoRef<User::UserEntry>::Release(&v14);
LABEL_8:
    v9 = (void **)((char *)a3 + 8);
    v10 = v4;
    do
    {
      v11 = *v9;
      if ( *v9 )
      {
        v12 = -1LL;
        do
          ++v12;
        while ( v11[v12] );
        memset(v11, 0, 2 * v12);
      }
      v9 += 3;
      --v10;
    }
    while ( v10 );
  }
  return (unsigned int)v5;
}
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);

//----- (0000000180067CA0) ----------------------------------------------------
__int64 __fastcall RpcServer::SetSecurity(RTL_SRWLOCK *this, char *a2, unsigned __int16 *a3, int a4)
{
  int v7; // r15d
  char v8; // r12
  unsigned __int16 *v10; // rbx
  const unsigned __int16 *v11; // r8
  int LastHrError; // r14d
  tsched *v13; // rcx
  RTL_SRWLOCK *v14; // rsi
  HKEY *v15; // r13
  User::UserEntry *v16; // rdi
  int v17; // r15d
  unsigned __int16 *v18; // rbx
  __int64 *Account; // rax
  const unsigned __int16 *v20; // rdx
  const struct JobMoniker *v21; // rax
  __int64 v22; // [rsp+28h] [rbp-E0h] BYREF
  HKEY v23; // [rsp+30h] [rbp-D8h] BYREF
  User::UserEntry *v24; // [rsp+38h] [rbp-D0h] BYREF
  HANDLE ClientToken; // [rsp+40h] [rbp-C8h] BYREF
  unsigned __int16 *v26; // [rsp+48h] [rbp-C0h] BYREF
  unsigned __int16 *v27; // [rsp+50h] [rbp-B8h] BYREF
  PSECURITY_DESCRIPTOR pSecurityDescriptor; // [rsp+58h] [rbp-B0h] BYREF
  ULONG SecurityDescriptorSize[2]; // [rsp+68h] [rbp-A0h] BYREF
  PSECURITY_DESCRIPTOR SecurityDescriptor[3]; // [rsp+70h] [rbp-98h] BYREF
  struct _FILETIME v31[7]; // [rsp+88h] [rbp-80h] BYREF
  char v32[16]; // [rsp+C0h] [rbp-48h] BYREF
  char v33[16]; // [rsp+D0h] [rbp-38h] BYREF
  User::UserEntry **v34; // [rsp+E0h] [rbp-28h] BYREF
  struct _GUID v35; // [rsp+E8h] [rbp-20h] BYREF
  unsigned __int16 v36[264]; // [rsp+F8h] [rbp-10h] BYREF

  SecurityDescriptor[1] = (PSECURITY_DESCRIPTOR)-2LL;
  v27 = a3;
  v7 = a4 | 0x60000000;
  v8 = 0;
  if ( (a4 & 0x60000000) != 0 )
    v7 = a4;
  if ( (v7 & 0x9FFFFFEF) != 0 )
    return 2147942487LL;
  v10 = 0LL;
  v26 = 0LL;
  memset_0(v36, 0, 0x20AuLL);
  LastHrError = tsched::TaskPathCanonicalize((tsched *)v36, a2, v11);
  if ( LastHrError >= 0 )
  {
    SecurityDescriptorSize[0] = 0;
    SecurityDescriptor[0] = 0LL;
    if ( a3 && !ConvertStringSecurityDescriptorToSecurityDescriptorW(a3, 1u, SecurityDescriptor, SecurityDescriptorSize) )
    {
      LastHrError = tsched::GetLastHrError(v13);
LABEL_66:
      tsched::AutoLocalPtr<unsigned short>::~AutoLocalPtr<unsigned short>(SecurityDescriptor);
      goto LABEL_67;
    }
    ClientToken = 0LL;
    LastHrError = GetCallerToken(L"SetSecurity", &ClientToken);
    if ( LastHrError < 0 )
    {
LABEL_65:
      wmi::AutoHandle::Close(&ClientToken);
      goto LABEL_66;
    }
    v14 = this + 2;
    SecurityDescriptor[2] = &this[2];
    AcquireSRWLockExclusive(this + 2);
    v15 = (HKEY *)JobStore::m_pCommonStore;
    v16 = 0LL;
    v24 = 0LL;
    JobSecurity::JobSecurity((JobSecurity *)&pSecurityDescriptor);
    LastHrError = JobStore::RegJobSecurityQuery(v15, v36, &pSecurityDescriptor);
    if ( LastHrError < 0 )
    {
LABEL_64:
      tsched::AutoLocalPtr<unsigned short>::~AutoLocalPtr<unsigned short>(&pSecurityDescriptor);
      wmi::AutoRef<User::UserEntry>::Release(&v24);
      ReleaseSRWLockExclusive(v14);
      goto LABEL_65;
    }
    if ( (int)JobStore::RegGetTreeInfo(v15, v36, &v35, 0LL) < 0 )
    {
      if ( (v7 & 0x20000000) == 0 )
      {
        LastHrError = -2147024894;
        goto LABEL_64;
      }
    }
    else
    {
      v8 = 1;
      if ( (v7 & 0x40000000) == 0 )
      {
        LastHrError = -2147024893;
        goto LABEL_64;
      }
    }
    LastHrError = JobAccessCheck(ClientToken, pSecurityDescriptor, 0xC0000u);
    if ( LastHrError < 0 )
      goto LABEL_64;
    v17 = v7 & 0x10;
    if ( !v17 && v8 )
    {
      LastHrError = JobAccessCheck(ClientToken, pSecurityDescriptor, 1u);
      if ( LastHrError < 0 )
        goto LABEL_64;
      JobMoniker::JobMoniker((JobMoniker *)v32, v36, &v35);
      v23 = 0LL;
      LastHrError = JobStore::RegOpenTaskKey(v15, (struct JobMoniker *)v32, &v23, 0x20019u);
      if ( LastHrError >= 0 )
      {
        Triggers::Trigulator::Trigulator(v31);
        LastHrError = Triggers::Trigulator::StreamIn((wmi::RefBase **)v31, v23, 2, 0LL);
        if ( LastHrError >= 0 )
        {
          LastHrError = Triggers::Trigulator::GetBucket((Triggers::Trigulator *)v31, (struct JobMoniker *)v32);
          if ( LastHrError >= 0 )
          {
            wmi::AutoRef<User::UserEntry>::operator=(&v24, v34[8]);
            Triggers::Trigulator::~Trigulator((Triggers::Trigulator *)v31);
            wmi::AutoRegKey::Close(&v23);
            wmi::AutoRef<JobBucket>::Release((wmi::RefBase **)&v34);
            _bstr_t::_Free((_bstr_t *)v33);
            v16 = v24;
            goto LABEL_24;
          }
        }
        Triggers::Trigulator::~Trigulator((Triggers::Trigulator *)v31);
      }
      wmi::AutoRegKey::Close(&v23);
      wmi::AutoRef<JobBucket>::Release((wmi::RefBase **)&v34);
      _bstr_t::_Free((_bstr_t *)v33);
      goto LABEL_64;
    }
LABEL_24:
    LastHrError = JobSecurity::GetSddl(&pSecurityDescriptor, 7u, &v26);
    if ( LastHrError < 0 )
      goto LABEL_63;
    RpcAutoImpersonate::RpcAutoImpersonate((RpcAutoImpersonate *)&v22, L"RpcServer::SetSecurity", 1);
    if ( qword_1800B0D38 )
    {
      v18 = v27;
      LastHrError = qword_1800B0D38(v36, v27);
    }
    else
    {
      LastHrError = 1;
      v18 = v27;
    }
    if ( (_DWORD)v22 )
      RpcRevertToSelf();
    if ( LastHrError < 0 )
      goto LABEL_59;
    RpcAutoImpersonate::RpcAutoImpersonate((RpcAutoImpersonate *)&v22, L"RpcServer::SetSecurity", 1);
    LastHrError = JobStore::FileSddlSet((JobStore *)v15, (char *)v36, v18);
    if ( LastHrError < 0 )
    {
      if ( (_DWORD)v22 )
        RpcRevertToSelf();
LABEL_58:
      if ( LastHrError < 0 )
        goto LABEL_59;
LABEL_63:
      v10 = v26;
      goto LABEL_64;
    }
    if ( (_DWORD)v22 )
      RpcRevertToSelf();
    LastHrError = JobSecurity::Update(&pSecurityDescriptor, SecurityDescriptor[0], ClientToken);
    if ( LastHrError < 0 )
      goto LABEL_59;
    if ( !v17 && v8 )
    {
      v23 = (HKEY)v16;
      if ( v16 )
        User::UserEntry::AddRef(v16);
      if ( User::IsAlias((User *)&v24) )
      {
        Account = User::GetAccount((__int64)&v24, (__int64 *)&v27);
        v20 = *Account ? *(const unsigned __int16 **)*Account : 0LL;
        LastHrError = CredStore::ResolveAlias((HKEY *)CredStore::g_pCommonStore, v20, (User::UserEntry **)&v23);
        _bstr_t::_Free((_bstr_t *)&v27);
        if ( LastHrError < 0 )
          goto LABEL_48;
      }
      RpcAutoImpersonate::RpcAutoImpersonate((RpcAutoImpersonate *)&v22, L"RpcServer::SetSecurity", 1);
      v21 = JobMoniker::JobMoniker((JobMoniker *)v32, v36, 0LL);
      LastHrError = JobStore::HammerAcl((JobStore *)v15, v21, (const struct User *)&v23, (const struct User *)&v23);
      wmi::AutoRef<JobBucket>::Release((wmi::RefBase **)&v34);
      _bstr_t::_Free((_bstr_t *)v33);
      if ( LastHrError < 0 )
      {
        if ( (_DWORD)v22 )
          RpcRevertToSelf();
LABEL_48:
        wmi::AutoRef<User::UserEntry>::Release(&v23);
        goto LABEL_58;
      }
      if ( (_DWORD)v22 )
        RpcRevertToSelf();
      LastHrError = JobSecurity::AddRemovePrincipalAce(&pSecurityDescriptor, *((void **)v23 + 4), 0LL);
      if ( LastHrError < 0 )
        goto LABEL_48;
      wmi::AutoRef<User::UserEntry>::Release(&v23);
    }
    LastHrError = JobStore::RegJobSecuritySet(v15, v36, (struct JobSecurity *)&pSecurityDescriptor);
    if ( LastHrError < 0 )
    {
LABEL_59:
      RpcAutoImpersonate::RpcAutoImpersonate((RpcAutoImpersonate *)&v22, L"RpcServer::SetSecurity", 1);
      v10 = v26;
      JobStore::FileSddlSet((JobStore *)v15, (char *)v36, v26);
      if ( qword_1800B0D38 )
        qword_1800B0D38(v36, v10);
      if ( (_DWORD)v22 )
        RpcRevertToSelf();
      goto LABEL_64;
    }
    LastHrError = 0;
    goto LABEL_58;
  }
LABEL_67:
  operator delete(v10);
  return (unsigned int)LastHrError;
}
// 180067D32: variable 'v11' is possibly undefined
// 180067D73: variable 'v13' is possibly undefined
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);
// 1800747C8: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 1800B0D38: using guessed type __int64 (__fastcall *qword_1800B0D38)(_QWORD, _QWORD);

//----- (000000018006834C) ----------------------------------------------------
__int64 __fastcall RpcServer::StopInstance(RpcServer *this, struct _GUID *a2, int a3)
{
  RTL_SRWLOCK *v6; // rbx
  int v7; // edi
  RTL_SRWLOCK *v8; // rcx
  unsigned int v9; // ebx
  char v10[8]; // [rsp+20h] [rbp-68h] BYREF
  char v11[8]; // [rsp+28h] [rbp-60h] BYREF
  void *v12[3]; // [rsp+30h] [rbp-58h] BYREF
  char v13[16]; // [rsp+48h] [rbp-40h] BYREF
  char v14[16]; // [rsp+58h] [rbp-30h] BYREF
  wmi::RefBase *v15; // [rsp+68h] [rbp-20h] BYREF

  v12[1] = (void *)-2LL;
  if ( a3 )
    return 2147942487LL;
  TaskAccessChecker::TaskAccessChecker((TaskAccessChecker *)v10);
  JobMoniker::JobMoniker((JobMoniker *)v13, 0LL, 0LL);
  v6 = (RTL_SRWLOCK *)((char *)this + 16);
  v12[2] = v6;
  AcquireSRWLockShared(v6);
  v7 = (*((__int64 (__fastcall **)(void ***, struct _GUID *, char *))UbpmProxySingleton::s_singleton[0] + 7))(
         UbpmProxySingleton::s_singleton,
         a2,
         v13);
  if ( v7 >= 0 )
  {
    v7 = TaskAccessChecker::AllowStopInstance((TaskAccessChecker *)v10, (const struct JobMoniker *)v13);
    v8 = v6;
    if ( v7 >= 0 )
    {
      ReleaseSRWLockShared(v6);
      v7 = (*((__int64 (__fastcall **)(void ***, char *, struct _GUID *))UbpmProxySingleton::s_singleton[0] + 6))(
             UbpmProxySingleton::s_singleton,
             v13,
             a2);
      goto LABEL_8;
    }
  }
  else
  {
    v8 = v6;
  }
  ReleaseSRWLockShared(v8);
LABEL_8:
  v9 = -2147216629;
  if ( v7 != -2147023728 )
    v9 = v7;
  wmi::AutoRef<JobBucket>::Release(&v15);
  _bstr_t::_Free((_bstr_t *)v14);
  wmi::AutoHandle::Close(v12);
  wmi::AutoRef<User::UserEntry>::Release(v11);
  return v9;
}
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);
// 1800747C8: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 1800AFFB0: using guessed type void **UbpmProxySingleton::s_singleton[2];
// 18006834C: using guessed type char var_68[8];
// 18006834C: using guessed type char var_30[16];
// 18006834C: using guessed type char var_60[8];

//----- (00000001800684C4) ----------------------------------------------------
void __fastcall RpcServer::StopServer(RPC_BINDING_VECTOR **BindingVector)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax

  if ( *((_DWORD *)BindingVector + 2) != 1 )
  {
    if ( *((_DWORD *)BindingVector + 2) != 2 )
    {
      if ( *((_DWORD *)BindingVector + 2) != 3 )
      {
        if ( *((_DWORD *)BindingVector + 2) != 4 )
          goto LABEL_27;
        if ( !*BindingVector )
          goto LABEL_17;
        v2 = RpcEpUnregister(&unk_180070230, *BindingVector, 0LL);
        if ( v2
          && WPP_GLOBAL_Control != &WPP_GLOBAL_Control
          && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x200) != 0
          && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
        {
          WPP_SF_D(
            *((_QWORD *)WPP_GLOBAL_Control + 2),
            0x16u,
            (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids,
            v2);
        }
      }
      if ( *BindingVector )
      {
        v3 = RpcEpUnregister(&unk_180070290, *BindingVector, 0LL);
        if ( v3 )
        {
          if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
            && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x200) != 0
            && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
          {
            WPP_SF_D(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              0x17u,
              (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids,
              v3);
          }
        }
      }
    }
LABEL_17:
    v4 = RpcServerUnregisterIf(&unk_180070230, 0LL, 1u);
    if ( v4
      && WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x200) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x18u,
        (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids,
        v4);
    }
  }
  v5 = RpcServerUnregisterIf(&unk_180070290, 0LL, 1u);
  if ( v5
    && WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x200) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
  {
    WPP_SF_D(*((_QWORD *)WPP_GLOBAL_Control + 2), 0x19u, (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids, v5);
  }
LABEL_27:
  if ( *BindingVector )
  {
    v6 = RpcBindingVectorFree(BindingVector);
    if ( v6
      && WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x200) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_D(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x1Au,
        (__int64)&WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids,
        v6);
    }
    *BindingVector = 0LL;
  }
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (00000001800686A8) ----------------------------------------------------
__int64 __fastcall RpcServer::StopTask(RTL_SRWLOCK *this, unsigned __int16 *a2, int a3)
{
  __int64 *v6; // r14
  const unsigned __int16 *v7; // r8
  __int64 v8; // rcx
  int CallerToken; // edi
  const unsigned __int16 *v10; // rdx
  tsched *v11; // rcx
  bool v12; // bl
  JobMoniker *v13; // rax
  RTL_SRWLOCK *v14; // rcx
  __int64 v15; // rcx
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 v19; // [rsp+38h] [rbp-D0h] BYREF
  HANDLE ClientToken; // [rsp+40h] [rbp-C8h] BYREF
  __int64 v21[2]; // [rsp+48h] [rbp-C0h] BYREF
  wmi::RefBase *v22[5]; // [rsp+58h] [rbp-B0h] BYREF
  wmi::RefBase *v23[5]; // [rsp+80h] [rbp-88h] BYREF
  unsigned __int16 v24[264]; // [rsp+A8h] [rbp-60h] BYREF

  v21[1] = -2LL;
  memset_0(v24, 0, 0x20AuLL);
  v6 = 0LL;
  v21[0] = 0LL;
  JobMoniker::JobMoniker((JobMoniker *)v22, 0LL, 0LL);
  if ( (unsigned int)dword_1800AFF68 > 5 && tlgKeywordOn((__int64)&dword_1800AFF68, 0LL) )
    _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<>(
      v8,
      byte_18007F18C);
  if ( a3 )
    goto LABEL_5;
  CallerToken = tsched::TaskPathCanonicalize((tsched *)v24, (char *)a2, v7);
  if ( CallerToken < 0 )
    goto LABEL_29;
  a2 = v24;
  if ( tsched::IsRoot((tsched *)v24, v10) )
  {
LABEL_5:
    CallerToken = -2147024809;
  }
  else
  {
    RpcAutoImpersonate::RpcAutoImpersonate((RpcAutoImpersonate *)&v19, L"RpcServer::StopTask", 1);
    v12 = (unsigned int)tsched::IsUserAdmin(v11) || IsImpersonatedAsLocalSystem();
    if ( (_DWORD)v19 )
      RpcRevertToSelf();
    ClientToken = 0LL;
    CallerToken = GetCallerToken(L"StopTask", &ClientToken);
    if ( CallerToken < 0 )
      goto LABEL_15;
    if ( !v12 && (int)TaskAccessCheck(ClientToken, v24, 0x20u) < 0 )
    {
      RpcAutoImpersonate::RpcAutoImpersonate((RpcAutoImpersonate *)&v19, L"RpcServer::StopTask", 1);
      CallerToken = User::FromImpersonationToken((struct User *)v21, 0LL);
      if ( CallerToken < 0 )
      {
        if ( (_DWORD)v19 )
          RpcRevertToSelf();
LABEL_15:
        wmi::AutoHandle::~AutoHandle((wmi::AutoHandle *)&ClientToken);
        goto LABEL_29;
      }
      v6 = v21;
      if ( (_DWORD)v19 )
        RpcRevertToSelf();
    }
    wmi::AutoHandle::~AutoHandle((wmi::AutoHandle *)&ClientToken);
    v13 = JobMoniker::JobMoniker((JobMoniker *)v23, v24, 0LL);
    JobMoniker::operator=((__int64)v22, (__int64)v13);
    JobMoniker::~JobMoniker(v23);
    ClientToken = &this[2];
    AcquireSRWLockShared(this + 2);
    CallerToken = JobStore::LoadBucketFromRegistry((HKEY *)JobStore::m_pCommonStore, v24, 2, (__int64)v22, 0LL, 0LL);
    v14 = this + 2;
    if ( CallerToken >= 0 )
    {
      ReleaseSRWLockShared(v14);
      if ( (*((_DWORD *)v22[4] + 4) & 0x2000000) != 0 )
      {
        CallerToken = (*((__int64 (__fastcall **)(void ***, wmi::RefBase **, __int64 *))UbpmProxySingleton::s_singleton[0]
                       + 5))(
                        UbpmProxySingleton::s_singleton,
                        v22,
                        v6);
        if ( CallerToken == -2147023728 )
          CallerToken = 1;
      }
      else
      {
        CallerToken = 0;
      }
    }
    else
    {
      ReleaseSRWLockShared(v14);
    }
  }
LABEL_29:
  if ( (unsigned int)dword_1800AFF68 > 4 && tlgKeywordOn((__int64)&dword_1800AFF68, 0LL) )
  {
    LODWORD(v19) = CallerToken;
    ClientToken = a2;
    _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapSz<unsigned short>,_tlgWrapperByVal<4>>(
      v15,
      byte_18007F1C6,
      v16,
      v17,
      (const WCHAR **)&ClientToken,
      (__int64)&v19);
  }
  JobMoniker::~JobMoniker(v22);
  wmi::AutoRef<User::UserEntry>::Release(v21);
  return (unsigned int)CallerToken;
}
// 180068738: variable 'v8' is possibly undefined
// 180068752: variable 'v7' is possibly undefined
// 180068769: variable 'v10' is possibly undefined
// 18006878A: variable 'v11' is possibly undefined
// 180068969: variable 'v15' is possibly undefined
// 180068969: variable 'v16' is possibly undefined
// 180068969: variable 'v17' is possibly undefined
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);
// 1800747C8: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 18007F18C: using guessed type unsigned __int8 byte_18007F18C[28];
// 18007F1C6: using guessed type unsigned __int8 byte_18007F1C6[43];
// 1800AFFB0: using guessed type void **UbpmProxySingleton::s_singleton[2];

//----- (0000000180068A04) ----------------------------------------------------
bool __fastcall RpcServer::UserGroupCheck(DWORD SessionId, const struct User *a2, const struct User *this)
{
  bool v6; // bl
  void *DuplicateTokenHandle; // [rsp+20h] [rbp-30h] BYREF
  void *phToken; // [rsp+28h] [rbp-28h] BYREF
  User::UserEntry *v10; // [rsp+30h] [rbp-20h] BYREF
  PSID SidToCheck[3]; // [rsp+38h] [rbp-18h] BYREF
  WINBOOL IsMember; // [rsp+88h] [rbp+38h] BYREF

  SidToCheck[1] = (PSID)-2LL;
  v6 = 0;
  v10 = 0LL;
  if ( (int)User::FromUserSession(&v10, SessionId, this) >= 0
    && User::operator==((User *)&v10, a2)
    && (int)User::LookupSid(this, SidToCheck) >= 0 )
  {
    phToken = 0LL;
    if ( WTSQueryUserToken(SessionId, &phToken) )
    {
      DuplicateTokenHandle = 0LL;
      if ( DuplicateToken(phToken, SecurityIdentification, &DuplicateTokenHandle)
        && CheckTokenMembership(DuplicateTokenHandle, SidToCheck[0], &IsMember) )
      {
        v6 = IsMember != 0;
      }
      wmi::AutoHandle::Close(&DuplicateTokenHandle);
    }
    wmi::AutoHandle::Close(&phToken);
  }
  wmi::AutoRef<User::UserEntry>::Release(&v10);
  return v6;
}
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);

//----- (0000000180068B1C) ----------------------------------------------------
__int64 __fastcall RpcServer::ValidatePasswords(unsigned int a1, const struct User *a2, const unsigned __int16 *a3)
{
  _QWORD *v6; // rbx
  _QWORD *v7; // rcx
  int v8; // ebx
  signed int LastError; // eax
  unsigned int v10; // ebx
  __int64 v12; // [rsp+60h] [rbp-18h] BYREF
  __int64 v13; // [rsp+68h] [rbp-10h] BYREF
  void *v14; // [rsp+98h] [rbp+20h] BYREF

  v14 = 0LL;
  v6 = (_QWORD *)*User::GetDomain((__int64)a2, &v13);
  if ( v6 )
    v6 = (_QWORD *)*v6;
  v7 = (_QWORD *)*User::GetAccount((__int64)a2, &v12);
  if ( v7 )
    v7 = (_QWORD *)*v7;
  v8 = LogonUserExExW(v7, v6, a3, a1, 0, 0LL, &v14, 0LL, 0LL, 0LL, 0LL);
  _bstr_t::_Free((_bstr_t *)&v12);
  _bstr_t::_Free((_bstr_t *)&v13);
  if ( v8 )
  {
    v10 = 0;
    goto LABEL_13;
  }
  LastError = GetLastError();
  if ( a1 == 4 )
  {
    if ( LastError == 1385 )
    {
      v10 = 267036;
      goto LABEL_13;
    }
    LastError = GetLastError();
  }
  v10 = LastError;
  if ( LastError > 0 )
    v10 = (unsigned __int16)LastError | 0x80070000;
LABEL_13:
  wmi::AutoHandle::Close(&v14);
  return v10;
}
// 1800B9068: using guessed type __int64 __fastcall LogonUserExExW(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000180068C38) ----------------------------------------------------
_QWORD *__fastcall std::_List_alloc<0,std::_List_base_types<UbpmInstance>>::_Buynode0(
        __int64 a1,
        _QWORD *a2,
        _QWORD *a3)
{
  _QWORD *result; // rax

  result = operator new(0x48uLL);
  if ( !result )
    std::_Xbad_alloc();
  if ( !a2 )
  {
    a2 = result;
    a3 = result;
  }
  *result = a2;
  result[1] = a3;
  return result;
}

//----- (0000000180068CB4) ----------------------------------------------------
_QWORD *__fastcall std::_List_alloc<0,std::_List_base_types<_GUID>>::_Buynode0(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *result; // rax

  result = operator new(0x20uLL);
  if ( !result )
    std::_Xbad_alloc();
  if ( !a2 )
  {
    a2 = result;
    a3 = result;
  }
  *result = a2;
  result[1] = a3;
  return result;
}

//----- (0000000180068D30) ----------------------------------------------------
void __fastcall std::list<UbpmInstance>::clear(__int64 a1)
{
  wmi::RefBase **v2; // rsi
  wmi::RefBase *v3; // rbx

  v2 = **(wmi::RefBase ****)a1;
  **(_QWORD **)a1 = *(_QWORD *)a1;
  *(_QWORD *)(*(_QWORD *)a1 + 8LL) = *(_QWORD *)a1;
  *(_QWORD *)(a1 + 8) = 0LL;
  if ( v2 != *(wmi::RefBase ***)a1 )
  {
    do
    {
      v3 = *v2;
      wmi::AutoRef<JobBucket>::Release(v2 + 6);
      _bstr_t::_Free((_bstr_t *)(v2 + 4));
      operator delete(v2);
      v2 = (wmi::RefBase **)v3;
    }
    while ( v3 != *(wmi::RefBase **)a1 );
  }
}

//----- (0000000180068D98) ----------------------------------------------------
__int64 __fastcall WPP_SF_SDddSS(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        const wchar_t *a4,
        char a5,
        char a6,
        char a7,
        __int64 a8,
        __int64 a9)
{
  __int64 v9; // rax
  __int64 v11; // rdx
  __int64 v12; // rcx
  bool v13; // zf

  v9 = -1LL;
  if ( a9 )
  {
    v11 = -1LL;
    do
      ++v11;
    while ( *(_WORD *)(a9 + 2 * v11) );
  }
  if ( a8 )
  {
    v12 = -1LL;
    do
      ++v12;
    while ( *(_WORD *)(a8 + 2 * v12) );
  }
  v13 = a4 == 0LL;
  if ( a4 )
  {
    do
      ++v9;
    while ( a4[v9] );
    v13 = a4 == 0LL;
  }
  if ( v13 )
    a4 = L"NULL";
  return EtwTraceMessage(a1, 43LL, &WPP_cbd7d4030fa03e9381397539a806cd05_Traceguids, 40LL, a4);
}
// 1800747B0: using guessed type __int64 __fastcall EtwTraceMessage(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 18007F5B8: using guessed type wchar_t aNull_1[5];

//----- (0000000180068ED8) ----------------------------------------------------
bool IsImpersonatedAsLocalSystem(void)
{
  bool IsLocalSystem; // bl
  __int64 v2; // [rsp+40h] [rbp+8h] BYREF

  IsLocalSystem = 0;
  v2 = 0LL;
  if ( User::FromImpersonationToken((struct User *)&v2, 0LL) >= 0 )
    IsLocalSystem = User::IsLocalSystem((User *)&v2);
  wmi::AutoRef<User::UserEntry>::Release(&v2);
  return IsLocalSystem;
}
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);

//----- (0000000180068F30) ----------------------------------------------------
signed int __fastcall IsPasswordManagedServiceAccount(unsigned __int16 *a1, unsigned __int16 *a2, bool *a3)
{
  int IsServiceAccount; // r9d
  __int64 v5; // rax
  signed int result; // eax
  unsigned __int16 *IsService; // [rsp+30h] [rbp+8h] BYREF

  IsService = a1;
  *a3 = 0;
  IsServiceAccount = 0;
  if ( a2 )
  {
    if ( *a2 )
    {
      v5 = -1LL;
      do
        ++v5;
      while ( a2[v5] );
      if ( a2[(unsigned int)v5 - 1] == 36 )
      {
        IsServiceAccount = NetIsServiceAccount(0LL, a2, (BOOL *)&IsService);
        if ( IsServiceAccount >= 0 )
          *a3 = (_DWORD)IsService != 0;
      }
    }
  }
  result = RtlNtStatusToDosError(IsServiceAccount);
  if ( result > 0 )
    return (unsigned __int16)result | 0x80070000;
  return result;
}

//----- (0000000180068FE0) ----------------------------------------------------
__int64 __fastcall I_pAcquireBackgroundExecutionMode(__int64 a1, unsigned int a2, unsigned int a3, _QWORD *a4)
{
  tsched *v7; // rcx
  signed int LastError; // ebx
  HANDLE ProcessHeap; // rax
  _QWORD *v11; // rax
  __int64 v12; // rcx
  int v13; // [rsp+20h] [rbp-18h] BYREF
  __int64 v14; // [rsp+28h] [rbp-10h] BYREF

  v14 = 0LL;
  RpcAutoImpersonate::RpcAutoImpersonate((RpcAutoImpersonate *)&v13, L"_I_pAcquireBackgroundExecutionMode", 1);
  if ( !IsImpersonatedAsLocalSystem() && !(unsigned int)tsched::IsUserAdmin(v7) )
  {
    if ( v13 )
      RpcRevertToSelf();
    return 2147942405LL;
  }
  if ( v13 )
    RpcRevertToSelf();
  LastError = UbpmAcquireJobBackgroundMode(a2, a3, 0xFFFFFFFFLL, &v14);
  if ( !LastError )
  {
    ProcessHeap = GetProcessHeap();
    v11 = HeapAlloc(ProcessHeap, 8u, 0x10uLL);
    if ( v11 )
    {
      *(_DWORD *)v11 = 1749893717;
      v11[1] = v14;
      *a4 = v11;
      v12 = 0LL;
      v14 = 0LL;
      goto LABEL_12;
    }
    LastError = GetLastError();
  }
  v12 = v14;
LABEL_12:
  if ( v12 )
    UbpmReleaseJobBackgroundMode();
  if ( LastError > 0 )
    return (unsigned __int16)LastError | 0x80070000;
  return (unsigned int)LastError;
}
// 18006901C: variable 'v7' is possibly undefined
// 180073D20: using guessed type __int64 __fastcall UbpmAcquireJobBackgroundMode(_QWORD, _QWORD, _QWORD, _QWORD);
// 180073D50: using guessed type __int64 UbpmReleaseJobBackgroundMode(void);

//----- (0000000180069110) ----------------------------------------------------
__int64 __fastcall I_pReleaseBackgroundExecutionMode(_QWORD **a1)
{
  _QWORD *v1; // rdi
  int v3; // ebx
  tsched *v4; // rcx
  HANDLE ProcessHeap; // rax
  int v7; // [rsp+30h] [rbp+8h] BYREF

  v1 = *a1;
  v3 = 0;
  RpcAutoImpersonate::RpcAutoImpersonate((RpcAutoImpersonate *)&v7, L"_I_pReleaseBackgroundExecutionMode", 1);
  if ( IsImpersonatedAsLocalSystem() || (unsigned int)tsched::IsUserAdmin(v4) )
  {
    if ( v7 )
      RpcRevertToSelf();
    if ( *(_DWORD *)v1 == 1749893717 )
    {
      if ( v1[1] )
        v3 = UbpmReleaseJobBackgroundMode();
      ProcessHeap = GetProcessHeap();
      HeapFree(ProcessHeap, 0, v1);
      *a1 = 0LL;
      if ( v3 <= 0 )
        return (unsigned int)v3;
    }
    else
    {
      LOWORD(v3) = 5;
    }
    return (unsigned __int16)v3 | 0x80070000;
  }
  if ( v7 )
    RpcRevertToSelf();
  return 2147942405LL;
}
// 180069145: variable 'v4' is possibly undefined
// 180073D50: using guessed type __int64 UbpmReleaseJobBackgroundMode(void);

//----- (00000001800691F0) ----------------------------------------------------
__int64 __fastcall I_pSchRpcAquireTaskStateNotificationsName(__int64 a1, char *a2, union _LARGE_INTEGER **a3)
{
  tsched *v5; // rcx
  __int64 v7[3]; // [rsp+48h] [rbp-18h] BYREF

  v7[1] = -2LL;
  RpcAutoImpersonate::RpcAutoImpersonate((RpcAutoImpersonate *)v7, L"_I_pSchRpcAquireTaskStateNotificationsName", 1);
  if ( IsImpersonatedAsLocalSystem() || (unsigned int)tsched::IsUserAdmin(v5) )
  {
    if ( LODWORD(v7[0]) )
      RpcRevertToSelf();
    if ( a3 )
      return RpcServer::AcquireStateChangeNotification((RTL_SRWLOCK *)&RpcServer::s_singleton, a2, a3);
    else
      return 2147942487LL;
  }
  else
  {
    if ( LODWORD(v7[0]) )
      RpcRevertToSelf();
    return 2147942405LL;
  }
}
// 1800691F0: could not find valid save-restore pair for rbp
// 18006922E: variable 'v5' is possibly undefined
// 1800B0D48: using guessed type __int64 RpcServer::s_singleton;

//----- (00000001800692E0) ----------------------------------------------------
__int64 __fastcall I_pSchRpcEnumTasks(
        __int64 a1,
        int a2,
        int *a3,
        unsigned int *a4,
        unsigned int a5,
        unsigned int *a6,
        unsigned __int16 ***a7)
{
  tsched *v10; // rcx
  __int64 v12[3]; // [rsp+48h] [rbp-18h] BYREF

  v12[1] = -2LL;
  RpcAutoImpersonate::RpcAutoImpersonate((RpcAutoImpersonate *)((char *)v12 + 4), L"I_pSchRpcEnumTasks", 1);
  if ( IsImpersonatedAsLocalSystem() || (unsigned int)tsched::IsUserAdmin(v10) )
  {
    if ( HIDWORD(v12[0]) )
      RpcRevertToSelf();
    if ( a2 == 1 )
      return RpcServer::EnumIndex((RpcServer *)&RpcServer::s_singleton, *a3, a4, a5, a6, a7);
    else
      return 2147942487LL;
  }
  else
  {
    if ( HIDWORD(v12[0]) )
      RpcRevertToSelf();
    return 2147942405LL;
  }
}
// 1800692E0: could not find valid save-restore pair for rbp
// 180069324: variable 'v10' is possibly undefined
// 1800B0D48: using guessed type __int64 RpcServer::s_singleton;

//----- (00000001800693F0) ----------------------------------------------------
int __fastcall I_pSchRpcGetTaskInfo(
        __int64 a1,
        int a2,
        const unsigned __int16 *a3,
        struct _SCHRPC_TASK_INFO_OUT_2 **a4)
{
  tsched *v7; // rcx
  int v9; // ebx
  __int64 v10[3]; // [rsp+48h] [rbp-18h] BYREF

  v10[1] = -2LL;
  RpcAutoImpersonate::RpcAutoImpersonate((RpcAutoImpersonate *)((char *)v10 + 4), L"_I_pSchRpcGetTaskInfo", 1);
  if ( IsImpersonatedAsLocalSystem() || (unsigned int)tsched::IsUserAdmin(v7) )
  {
    if ( HIDWORD(v10[0]) )
      RpcRevertToSelf();
    if ( a4 )
    {
      v9 = a2 - 1;
      if ( v9 )
      {
        if ( v9 == 1 )
          return RpcServer::GetTaskDynamicData((RpcServer *)&RpcServer::s_singleton, a3, a4);
        else
          return -2147024809;
      }
      else
      {
        return -2147467263;
      }
    }
    else
    {
      return -2147024809;
    }
  }
  else
  {
    if ( HIDWORD(v10[0]) )
      RpcRevertToSelf();
    return -2147024891;
  }
}
// 1800693F0: could not find valid save-restore pair for rbp
// 180069434: variable 'v7' is possibly undefined
// 1800B0D48: using guessed type __int64 RpcServer::s_singleton;

//----- (0000000180069500) ----------------------------------------------------
__int64 __fastcall I_pSchRpcRegisterTask(
        __int64 a1,
        int a2,
        const unsigned __int16 *a3,
        const unsigned __int16 *a4,
        unsigned int a5,
        unsigned __int16 *a6,
        unsigned __int16 *a7,
        struct _SCHRPC_DYNAMIC_TASK_INFO **a8)
{
  tsched *v11; // rcx
  int v13; // [rsp+6Ch] [rbp-14h] BYREF
  __int64 v14; // [rsp+70h] [rbp-10h]

  v14 = -2LL;
  RpcAutoImpersonate::RpcAutoImpersonate((RpcAutoImpersonate *)&v13, L"_I_pSchRpcRegisterTask", 1);
  if ( IsImpersonatedAsLocalSystem() || (unsigned int)tsched::IsUserAdmin(v11) )
  {
    if ( v13 )
      RpcRevertToSelf();
    if ( a2 == 1 && a3 && a4 && a8 )
      return RpcServer::MigrateTask((RpcServer *)&RpcServer::s_singleton, a3, a4, a5, a6, a7, *a8);
    else
      return 2147942487LL;
  }
  else
  {
    if ( v13 )
      RpcRevertToSelf();
    return 2147942405LL;
  }
}
// 180069500: could not find valid save-restore pair for rbp
// 180069544: variable 'v11' is possibly undefined
// 1800B0D48: using guessed type __int64 RpcServer::s_singleton;

//----- (0000000180069630) ----------------------------------------------------
__int64 __fastcall SchRpcCreateFolder(__int64 a1, unsigned __int16 *a2, const unsigned __int16 *a3, int a4)
{
  return RpcServer::CreateFolder((RTL_SRWLOCK *)&RpcServer::s_singleton, a2, a3, a4);
}
// 180069630: could not find valid save-restore pair for rbp
// 1800B0D48: using guessed type __int64 RpcServer::s_singleton;

//----- (0000000180069690) ----------------------------------------------------
__int64 __fastcall SchRpcEnumFolders(
        __int64 a1,
        char *a2,
        int a3,
        unsigned int *a4,
        unsigned int a5,
        unsigned int *a6,
        unsigned __int16 ***a7)
{
  return RpcServer::EnumFolder((RpcServer *)&RpcServer::s_singleton, a2, 1, a3, a4, a5, a6, a7);
}
// 180069690: could not find valid save-restore pair for rbp
// 1800B0D48: using guessed type __int64 RpcServer::s_singleton;

//----- (0000000180069720) ----------------------------------------------------
__int64 __fastcall SchRpcEnumInstances(__int64 a1, char *a2, int a3, unsigned int *a4, struct _GUID **a5)
{
  return RpcServer::EnumInstances((RpcServer *)&RpcServer::s_singleton, a2, a3, a4, a5);
}
// 180069720: could not find valid save-restore pair for rbp
// 1800B0D48: using guessed type __int64 RpcServer::s_singleton;

//----- (0000000180069790) ----------------------------------------------------
__int64 __fastcall SchRpcGetInstanceInfo(
        __int64 a1,
        struct _GUID *a2,
        unsigned __int16 **a3,
        unsigned int *a4,
        unsigned __int16 **a5,
        unsigned __int16 **a6,
        unsigned int *a7,
        struct _GUID **a8,
        unsigned int *a9)
{
  struct _GUID v10; // [rsp+98h] [rbp-18h] BYREF

  v10 = *a2;
  return RpcServer::GetInstanceInfo((RpcServer *)&RpcServer::s_singleton, &v10, a3, a4, a5, a6, a7, a8, a9);
}
// 180069790: could not find valid save-restore pair for rbp
// 1800B0D48: using guessed type __int64 RpcServer::s_singleton;
// 180069790: using guessed type struct _GUID var_18;

//----- (0000000180069850) ----------------------------------------------------
__int64 __fastcall SchRpcGetLastRunInfo(__int64 a1, char *a2, struct _SYSTEMTIME *a3, unsigned int *a4)
{
  return RpcServer::GetLastRunInfo((RTL_SRWLOCK *)&RpcServer::s_singleton, a2, a3, a4);
}
// 180069850: could not find valid save-restore pair for rbp
// 1800B0D48: using guessed type __int64 RpcServer::s_singleton;

//----- (00000001800698B0) ----------------------------------------------------
__int64 __fastcall SchRpcGetSecurity(__int64 a1, char *a2, SECURITY_INFORMATION a3, unsigned __int16 **a4)
{
  return RpcServer::GetSecurity((RTL_SRWLOCK *)&RpcServer::s_singleton, a2, a3, a4);
}
// 1800698B0: could not find valid save-restore pair for rbp
// 1800B0D48: using guessed type __int64 RpcServer::s_singleton;

//----- (0000000180069910) ----------------------------------------------------
__int64 __fastcall SchRpcSetSecurity(__int64 a1, char *a2, unsigned __int16 *a3, int a4)
{
  return RpcServer::SetSecurity((RTL_SRWLOCK *)&RpcServer::s_singleton, a2, a3, a4);
}
// 180069910: could not find valid save-restore pair for rbp
// 1800B0D48: using guessed type __int64 RpcServer::s_singleton;

//----- (0000000180069970) ----------------------------------------------------
__int64 __fastcall SchRpcStop(__int64 a1, unsigned __int16 *a2, int a3)
{
  return RpcServer::StopTask((RTL_SRWLOCK *)&RpcServer::s_singleton, a2, a3);
}
// 180069970: could not find valid save-restore pair for rbp
// 1800B0D48: using guessed type __int64 RpcServer::s_singleton;

//----- (00000001800699D0) ----------------------------------------------------
__int64 __fastcall SchRpcStopInstance(__int64 a1, struct _GUID *a2, int a3)
{
  struct _GUID v4; // [rsp+58h] [rbp-18h] BYREF

  v4 = *a2;
  return RpcServer::StopInstance((RpcServer *)&RpcServer::s_singleton, &v4, a3);
}
// 1800699D0: could not find valid save-restore pair for rbp
// 1800B0D48: using guessed type __int64 RpcServer::s_singleton;
// 1800699D0: using guessed type struct _GUID anonymous_0;

//----- (0000000180069A3C) ----------------------------------------------------
_QWORD *__fastcall std::_List_buy<UbpmInstance>::_Buynode<UbpmInstance const &>(
        __int64 a1,
        _QWORD *a2,
        _QWORD *a3,
        __int64 a4)
{
  __int64 v5; // r8
  _QWORD *v7; // [rsp+40h] [rbp+8h]

  v7 = std::_List_alloc<0,std::_List_base_types<UbpmInstance>>::_Buynode0(a1, a2, a3);
  JobMoniker::JobMoniker((JobMoniker *)(v7 + 2), (const struct JobMoniker *)a4, v5);
  *(_OWORD *)(v7 + 7) = *(_OWORD *)(a4 + 40);
  return v7;
}
// 180069A6F: variable 'v5' is possibly undefined

//----- (0000000180069AB8) ----------------------------------------------------
_QWORD *__fastcall std::list<UbpmInstance>::_Insert<UbpmInstance const &>(__int64 a1, __int64 a2, __int64 a3)
{
  _QWORD *v5; // r8
  __int64 v6; // rax
  _QWORD *result; // rax

  v5 = std::_List_buy<UbpmInstance>::_Buynode<UbpmInstance const &>(a1, (_QWORD *)a2, *(_QWORD **)(a2 + 8), a3);
  v6 = *(_QWORD *)(a1 + 8);
  if ( v6 == 0x38E38E38E38E38DLL )
    std::_Xlength_error("list<T> too long");
  *(_QWORD *)(a1 + 8) = v6 + 1;
  *(_QWORD *)(a2 + 8) = v5;
  result = (_QWORD *)v5[1];
  *result = v5;
  return result;
}

//----- (0000000180069B20) ----------------------------------------------------
char **__fastcall std::list<UbpmInstance>::assign<std::_List_const_iterator<std::_List_val<std::_List_simple_types<UbpmInstance>>>>(
        char *a1,
        __int64 *a2,
        __int64 *a3)
{
  __int64 *v6; // rdi
  char *v8; // [rsp+50h] [rbp+8h] BYREF

  v8 = a1;
  v6 = **(__int64 ***)a1;
  while ( a2 != a3 )
  {
    if ( v6 == *(__int64 **)a1 )
    {
      while ( a2 != a3 )
      {
        std::list<UbpmInstance>::_Insert<UbpmInstance const &>((__int64)a1, *(_QWORD *)a1, (__int64)(a2 + 2));
        a2 = (__int64 *)*a2;
      }
      return std::list<UbpmInstance>::erase((char **)a1, &v8, (char *)v6, *(char **)a1);
    }
    JobMoniker::operator=((__int64)(v6 + 2), (__int64)(a2 + 2));
    *(_OWORD *)(v6 + 7) = *(_OWORD *)(a2 + 7);
    a2 = (__int64 *)*a2;
    v6 = (__int64 *)*v6;
  }
  return std::list<UbpmInstance>::erase((char **)a1, &v8, (char *)v6, *(char **)a1);
}

//----- (0000000180069BEC) ----------------------------------------------------
void __fastcall AutoUbpmConsumerHandle::~AutoUbpmConsumerHandle(AutoUbpmConsumerHandle *this)
{
  if ( *(_QWORD *)this )
  {
    UbpmCloseTriggerConsumer();
    *(_QWORD *)this = 0LL;
  }
}
// 180073D60: using guessed type __int64 UbpmCloseTriggerConsumer(void);

//----- (0000000180069C1C) ----------------------------------------------------
void __fastcall UbpmFreeMe::~UbpmFreeMe(UbpmFreeMe *this)
{
  if ( **(_QWORD **)this )
  {
    UbpmApiBufferFree();
    **(_QWORD **)this = 0LL;
  }
}
// 180073D68: using guessed type __int64 UbpmApiBufferFree(void);

//----- (0000000180069C50) ----------------------------------------------------
__int64 __fastcall UbpmProxySingleton::AquireStateNotificationName(
        UbpmProxySingleton *this,
        const wchar_t **a2,
        struct _WNF_STATE_NAME *a3)
{
  __int64 v5; // rdx
  signed int v6; // ebx
  int v7; // eax
  struct _WNF_STATE_NAME *v9; // [rsp+30h] [rbp-18h] BYREF
  __int64 v10; // [rsp+38h] [rbp-10h] BYREF
  int v11; // [rsp+68h] [rbp+20h] BYREF

  v11 = 0;
  v9 = 0LL;
  v10 = 0LL;
  v6 = UbpmProxySingleton::OpenConsumer(this, (const struct JobMoniker *)a2, (struct AutoUbpmConsumerHandle *)&v10);
  if ( v6 >= 0 )
  {
    v11 = 3;
    v7 = UbpmTriggerConsumerControlNotifications(v10, &v11, &v9);
    v6 = v7;
    if ( v7 > 0 )
      v6 = (unsigned __int16)v7 | 0x80070000;
    if ( v6 >= 0 )
    {
      if ( v7 )
      {
        v6 = (unsigned __int16)v7 | 0x80070000;
        if ( v7 <= 0 )
          v6 = v7;
      }
      else if ( v9 )
      {
        *a3 = *v9;
        UbpmApiBufferFree();
        v9 = 0LL;
      }
      else
      {
        v6 = -2147418113;
      }
    }
  }
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
  {
    v5 = ((v6 >> 31) & 0xFFFFFFFE) + 4;
    if ( *((unsigned __int8 *)WPP_GLOBAL_Control + 25) >= (int)v5 )
      WPP_SF_SD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0xDu,
        (__int64)&WPP_ffeb42fce81a3445f9740a981b62c86a_Traceguids,
        a2[3]);
  }
  if ( v10 )
    UbpmCloseTriggerConsumer(v10, v5);
  return (unsigned int)v6;
}
// 180069CC6: conditional instruction was optimized away because ebx.4<0
// 180069D47: variable 'v5' is possibly undefined
// 180073D60: using guessed type __int64 __fastcall UbpmCloseTriggerConsumer(_QWORD, _QWORD);
// 180073D68: using guessed type __int64 UbpmApiBufferFree(void);
// 180073D98: using guessed type __int64 __fastcall UbpmTriggerConsumerControlNotifications(_QWORD, _QWORD, _QWORD);
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (0000000180069D70) ----------------------------------------------------
__int64 __fastcall UbpmProxySingleton::EnableTask(UbpmProxySingleton *this, const wchar_t **a2, int a3)
{
  __int64 v5; // rdx
  signed int v6; // ebx
  int v7; // eax
  __int64 v9[3]; // [rsp+30h] [rbp-18h] BYREF
  bool v10; // [rsp+68h] [rbp+20h] BYREF

  v9[0] = 0LL;
  v10 = 0;
  v6 = UbpmProxySingleton::OpenConsumer(this, (const struct JobMoniker *)a2, (struct AutoUbpmConsumerHandle *)v9);
  if ( v6 >= 0 )
  {
    v10 = a3 != 0;
    v7 = UbpmTriggerConsumerConfigure(v9[0], &v10);
    v6 = v7;
    if ( v7 > 0 )
      v6 = (unsigned __int16)v7 | 0x80070000;
  }
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
  {
    v5 = ((v6 >> 31) & 0xFFFFFFFE) + 4;
    if ( *((unsigned __int8 *)WPP_GLOBAL_Control + 25) >= (int)v5 )
      WPP_SF_SdD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x1Bu,
        (__int64)&WPP_ffeb42fce81a3445f9740a981b62c86a_Traceguids,
        a2[3]);
  }
  if ( v9[0] )
    UbpmCloseTriggerConsumer(v9[0], v5);
  return (unsigned int)v6;
}
// 180069E24: variable 'v5' is possibly undefined
// 180073D38: using guessed type __int64 __fastcall UbpmTriggerConsumerConfigure(_QWORD, _QWORD);
// 180073D60: using guessed type __int64 __fastcall UbpmCloseTriggerConsumer(_QWORD, _QWORD);
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 180069D70: using guessed type __int64 var_18[3];

//----- (0000000180069E50) ----------------------------------------------------
__int64 __fastcall UbpmProxySingleton::EnumAllInstances(__int64 a1, char *a2)
{
  HKEY *v4; // r14
  int v5; // edi
  tsched *BucketFromRegistry; // rbx
  int Next; // eax
  const unsigned __int16 *Path; // rax
  int v9; // ecx
  int v10; // ecx
  IndexEnumerator *v12; // [rsp+30h] [rbp-50h] BYREF
  void *lpMem[3]; // [rsp+38h] [rbp-48h] BYREF
  char v14[16]; // [rsp+50h] [rbp-30h] BYREF
  char v15[16]; // [rsp+60h] [rbp-20h] BYREF
  wmi::RefBase *v16; // [rsp+70h] [rbp-10h] BYREF

  lpMem[2] = (void *)-2LL;
  v4 = (HKEY *)JobStore::m_pCommonStore;
  v12 = 0LL;
  lpMem[1] = 0LL;
  lpMem[0] = std::_List_alloc<0,std::_List_base_types<UbpmInstance>>::_Buynode0(a1, 0LL, 0LL);
  v5 = 1;
  while ( 2 )
  {
    LODWORD(BucketFromRegistry) = JobStore::EnumStoredTasks((__int64)v4, v5, &v12);
    if ( (int)BucketFromRegistry >= 0 )
    {
      while ( 1 )
      {
        Next = IndexEnumerator::FindNext(v12);
        if ( Next < 0 || Next == 1 )
          break;
        JobMoniker::JobMoniker((JobMoniker *)v14, 0LL, 0LL);
        LODWORD(BucketFromRegistry) = IndexEnumerator::GetMoniker(v12, (struct JobMoniker *)v14);
        if ( tsched::IsErrorNotFound((tsched *)(unsigned int)BucketFromRegistry) )
          LODWORD(BucketFromRegistry) = 0;
        if ( (int)BucketFromRegistry < 0
          || (Path = JobMoniker::GetPath((JobMoniker *)v14),
              BucketFromRegistry = (tsched *)(unsigned int)JobStore::LoadBucketFromRegistry(
                                                             v4,
                                                             Path,
                                                             2,
                                                             (__int64)v14,
                                                             0LL,
                                                             0LL),
              !tsched::IsErrorNotFound(BucketFromRegistry))
          && (v9 < 0
           || (*((_DWORD *)v16 + 4) & 0x2000000) != 0
           && (LODWORD(BucketFromRegistry) = (*(__int64 (__fastcall **)(__int64, char *, void **))(*(_QWORD *)a1 + 64LL))(
                                               a1,
                                               v14,
                                               lpMem),
               !tsched::IsErrorNotFound((tsched *)(unsigned int)BucketFromRegistry))
           && v10 < 0) )
        {
          wmi::AutoRef<JobBucket>::Release(&v16);
          _bstr_t::_Free((_bstr_t *)v15);
          goto LABEL_17;
        }
        wmi::AutoRef<JobBucket>::Release(&v16);
        _bstr_t::_Free((_bstr_t *)v15);
      }
      if ( ++v5 <= 3 )
        continue;
      LODWORD(BucketFromRegistry) = 0;
      if ( a2 != (char *)lpMem )
        std::list<UbpmInstance>::assign<std::_List_const_iterator<std::_List_val<std::_List_simple_types<UbpmInstance>>>>(
          a2,
          *(__int64 **)lpMem[0],
          (__int64 *)lpMem[0]);
    }
    break;
  }
LABEL_17:
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0
    && *((unsigned __int8 *)WPP_GLOBAL_Control + 25) >= (int)((((int)BucketFromRegistry >> 31) & 0xFFFFFFFE) + 4) )
  {
    WPP_SF_D(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x17u,
      (__int64)&WPP_ffeb42fce81a3445f9740a981b62c86a_Traceguids,
      (int)BucketFromRegistry);
  }
  std::list<UbpmInstance>::clear((__int64)lpMem);
  operator delete(lpMem[0]);
  wmi::AutoRef<FolderEnumerator>::~AutoRef<FolderEnumerator>(&v12);
  return (unsigned int)BucketFromRegistry;
}
// 180069F4E: variable 'v9' is possibly undefined
// 180069F88: variable 'v10' is possibly undefined
// 1800090EC: using guessed type __int64 __fastcall wmi::AutoRef<FolderEnumerator>::~AutoRef<FolderEnumerator>(_QWORD);
// 1800747C8: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018006A0A0) ----------------------------------------------------
__int64 __fastcall UbpmProxySingleton::EnumInstances(UbpmProxySingleton *a1, const wchar_t **a2, __int64 *a3)
{
  signed int v5; // ebx
  int v6; // eax
  __int64 v7; // r8
  __int64 v8; // rdx
  unsigned int v9; // edi
  __int64 v10; // rsi
  __int64 v11; // r14
  __int64 v12; // rdx
  __int64 v14; // [rsp+38h] [rbp-29h] BYREF
  __int64 v15; // [rsp+40h] [rbp-21h] BYREF
  __int64 v16[2]; // [rsp+48h] [rbp-19h] BYREF
  char v17[16]; // [rsp+58h] [rbp-9h] BYREF
  char v18[16]; // [rsp+68h] [rbp+7h] BYREF
  wmi::RefBase *v19; // [rsp+78h] [rbp+17h] BYREF
  __int128 v20; // [rsp+80h] [rbp+1Fh]

  v16[1] = -2LL;
  v15 = 0LL;
  v14 = 0LL;
  v16[0] = (__int64)&v14;
  v5 = UbpmProxySingleton::OpenConsumer(a1, (const struct JobMoniker *)a2, (struct AutoUbpmConsumerHandle *)&v15);
  if ( v5 >= 0 )
  {
    v6 = UbpmTriggerConsumerQueryStatus(v15, &v14);
    v5 = v6;
    if ( v6 > 0 )
      v5 = (unsigned __int16)v6 | 0x80070000;
    if ( v5 >= 0 )
    {
      v8 = v14;
      if ( v14 )
      {
        v9 = 0;
        if ( *(_DWORD *)(v14 + 28) )
        {
          do
          {
            v10 = 56LL * v9;
            v11 = *(_QWORD *)(v8 + 32);
            if ( *(_BYTE *)(v10 + v11 + 32) == 1 )
            {
              JobMoniker::JobMoniker((JobMoniker *)v17, (const struct JobMoniker *)a2, v7);
              v20 = *(_OWORD *)(v10 + v11 + 16);
              std::list<UbpmInstance>::_Insert<UbpmInstance const &>((__int64)a3, *a3, (__int64)v17);
              wmi::AutoRef<JobBucket>::Release(&v19);
              _bstr_t::_Free((_bstr_t *)v18);
              v8 = v14;
            }
            ++v9;
          }
          while ( v9 < *(_DWORD *)(v8 + 28) );
        }
      }
      else
      {
        v5 = -2147418113;
      }
    }
  }
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0
    && *((unsigned __int8 *)WPP_GLOBAL_Control + 25) >= (int)(((v5 >> 31) & 0xFFFFFFFE) + 4) )
  {
    WPP_SF_SdD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x16u,
      (__int64)&WPP_ffeb42fce81a3445f9740a981b62c86a_Traceguids,
      a2[3]);
  }
  UbpmFreeMe::~UbpmFreeMe((UbpmFreeMe *)v16);
  if ( v15 )
    UbpmCloseTriggerConsumer(v15, v12);
  return (unsigned int)v5;
}
// 18006A156: variable 'v7' is possibly undefined
// 18006A20C: variable 'v12' is possibly undefined
// 180073D58: using guessed type __int64 __fastcall UbpmTriggerConsumerQueryStatus(_QWORD, _QWORD);
// 180073D60: using guessed type __int64 __fastcall UbpmCloseTriggerConsumer(_QWORD, _QWORD);
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 18006A0A0: using guessed type char var_50[16];

//----- (000000018006A270) ----------------------------------------------------
__int64 __fastcall UbpmProxySingleton::GetInstanceInfo(
        UbpmProxySingleton *this,
        const struct _GUID *a2,
        enum tsched::InternalTaskState *a3,
        struct JobMoniker *a4,
        _bstr_t::Data_t **a5,
        unsigned int *a6)
{
  int v6; // ebx
  int v7; // edi
  int v11; // eax

  v6 = 1;
  v7 = 1;
  while ( v6 == 1 )
  {
    v11 = UbpmProxySingleton::LookupTaskByIndex((__int64)this, a2, v7++, (__int64)a4, 0, a3, a5, a6);
    v6 = v11;
    if ( v7 > 3 )
    {
      if ( v11 == 1 )
        v6 = -2147023728;
      break;
    }
  }
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0
    && *((unsigned __int8 *)WPP_GLOBAL_Control + 25) >= (int)(((v6 >> 31) & 0xFFFFFFFE) + 4) )
  {
    WPP_SF__guid_D(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x18u,
      (__int64)&WPP_ffeb42fce81a3445f9740a981b62c86a_Traceguids,
      (__int64)a2);
  }
  return (unsigned int)v6;
}
// 18006A2CF: variable 'this' is possibly undefined
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018006A360) ----------------------------------------------------
__int64 __fastcall UbpmProxySingleton::GetLastRunInfo(
        UbpmProxySingleton *this,
        const wchar_t **a2,
        struct _FILETIME *a3,
        struct _FILETIME *a4,
        struct _FILETIME *a5,
        unsigned int *a6)
{
  signed int v9; // ebx
  int v10; // eax
  __int64 v11; // rdx
  int v12; // r8d
  unsigned int v13; // r11d
  unsigned int v14; // r9d
  __int64 v15; // rdx
  __int64 v16; // rdx
  __int64 v18; // [rsp+30h] [rbp-28h] BYREF
  __int64 v19; // [rsp+38h] [rbp-20h] BYREF
  __int64 *v20; // [rsp+40h] [rbp-18h] BYREF

  v19 = 0LL;
  v18 = 0LL;
  v20 = &v18;
  v9 = UbpmProxySingleton::OpenConsumer(this, (const struct JobMoniker *)a2, (struct AutoUbpmConsumerHandle *)&v19);
  if ( v9 < 0 )
    goto LABEL_21;
  v10 = UbpmTriggerConsumerQueryStatus(v19, &v18);
  v9 = v10;
  if ( v10 > 0 )
    v9 = (unsigned __int16)v10 | 0x80070000;
  if ( v9 < 0 )
    goto LABEL_21;
  v11 = v18;
  if ( !v18 )
  {
    v9 = -2147418113;
    goto LABEL_21;
  }
  *a3 = *(struct _FILETIME *)(v18 + 4);
  *a6 = *(_DWORD *)v11;
  *a4 = *(struct _FILETIME *)(v11 + 20);
  *a5 = *(struct _FILETIME *)(v11 + 12);
  v12 = *a6;
  if ( *a6 )
  {
    if ( v12 == -2147023605 )
      goto LABEL_16;
    goto LABEL_15;
  }
  v13 = *(_DWORD *)(v11 + 28);
  v14 = 0;
  if ( !v13 )
  {
LABEL_15:
    if ( v12 != 1291 )
    {
LABEL_17:
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
      {
        WPP_SF_SD(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          0x19u,
          (__int64)&WPP_ffeb42fce81a3445f9740a981b62c86a_Traceguids,
          a2[3]);
      }
      goto LABEL_21;
    }
LABEL_16:
    *a6 = 267014;
    goto LABEL_17;
  }
  v15 = *(_QWORD *)(v11 + 32);
  while ( *(_BYTE *)(56LL * v14 + v15 + 32) != 1 )
  {
    if ( ++v14 >= v13 )
      goto LABEL_15;
  }
  *a6 = 267009;
LABEL_21:
  UbpmFreeMe::~UbpmFreeMe((UbpmFreeMe *)&v20);
  if ( v19 )
    UbpmCloseTriggerConsumer(v19, v16);
  return (unsigned int)v9;
}
// 18006A4B5: variable 'v16' is possibly undefined
// 180073D58: using guessed type __int64 __fastcall UbpmTriggerConsumerQueryStatus(_QWORD, _QWORD);
// 180073D60: using guessed type __int64 __fastcall UbpmCloseTriggerConsumer(_QWORD, _QWORD);
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018006A4E0) ----------------------------------------------------
__int64 __fastcall UbpmProxySingleton::GetTaskState(
        UbpmProxySingleton *this,
        const wchar_t **a2,
        enum tsched::InternalTaskState *a3)
{
  signed int v5; // ebx
  int v6; // eax
  __int64 v7; // r8
  unsigned int v8; // r9d
  __int64 v9; // rdx
  __int64 v11; // [rsp+30h] [rbp-18h] BYREF
  __int64 *v12; // [rsp+38h] [rbp-10h] BYREF
  __int64 v13; // [rsp+68h] [rbp+20h] BYREF

  v11 = 0LL;
  v13 = 0LL;
  v12 = &v13;
  v5 = UbpmProxySingleton::OpenConsumer(this, (const struct JobMoniker *)a2, (struct AutoUbpmConsumerHandle *)&v11);
  if ( v5 >= 0 )
  {
    v6 = UbpmTriggerConsumerQueryStatus(v11, &v13);
    v5 = v6;
    if ( v6 > 0 )
      v5 = (unsigned __int16)v6 | 0x80070000;
    if ( v5 >= 0 )
    {
      v7 = v13;
      if ( v13 )
      {
        *(_DWORD *)a3 = 0;
        v8 = 0;
        if ( *(_DWORD *)(v7 + 28) )
        {
          while ( *(_BYTE *)(56LL * v8 + *(_QWORD *)(v7 + 32) + 32) != 1 )
          {
            if ( *(_BYTE *)(56LL * v8 + *(_QWORD *)(v7 + 32) + 32) == 2 )
            {
              if ( *(_DWORD *)a3 != 1 )
                *(_DWORD *)a3 = 0;
            }
            else if ( *(_BYTE *)(56LL * v8 + *(_QWORD *)(v7 + 32) + 32) == 3 )
            {
              *(_DWORD *)a3 = 1;
            }
            if ( ++v8 >= *(_DWORD *)(v7 + 28) )
              goto LABEL_15;
          }
          *(_DWORD *)a3 = 2;
        }
        else
        {
LABEL_15:
          if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
            && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0
            && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
          {
            WPP_SF_SD(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              0x1Au,
              (__int64)&WPP_ffeb42fce81a3445f9740a981b62c86a_Traceguids,
              a2[3]);
          }
        }
      }
      else
      {
        v5 = -2147418113;
      }
    }
  }
  UbpmFreeMe::~UbpmFreeMe((UbpmFreeMe *)&v12);
  if ( v11 )
    UbpmCloseTriggerConsumer(v11, v9);
  return (unsigned int)v5;
}
// 18006A5F5: variable 'v9' is possibly undefined
// 180073D58: using guessed type __int64 __fastcall UbpmTriggerConsumerQueryStatus(_QWORD, _QWORD);
// 180073D60: using guessed type __int64 __fastcall UbpmCloseTriggerConsumer(_QWORD, _QWORD);
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018006A630) ----------------------------------------------------
__int64 __fastcall UbpmProxySingleton::IsV2Compatible(
        UbpmProxySingleton *this,
        const struct JobMoniker *a2,
        struct Triggers::Trigulator *a3,
        struct Actions::ActionCollection *a4,
        int *a5)
{
  int *v7; // rbx
  TSTimePeriod *Periodicity; // rax
  TSTimePeriod *Deadline; // rax
  const OLECHAR *v10; // rdx
  _QWORD *v11; // rcx
  _QWORD *v12; // rax
  __int64 v13; // r8
  char v15[32]; // [rsp+38h] [rbp-20h] BYREF
  _bstr_t::Data_t *v16; // [rsp+68h] [rbp+10h] BYREF

  _bstr_t::_bstr_t((_bstr_t *)&v16, L"compatible");
  v7 = a5;
  *a5 = 1;
  Periodicity = (TSTimePeriod *)JobBucket::GetPeriodicity(*((_QWORD *)a2 + 4), (__int64)v15);
  if ( !TSTimePeriod::IsEmpty(Periodicity)
    || (Deadline = (TSTimePeriod *)JobBucket::GetDeadline(*((_QWORD *)a2 + 4), (__int64)v15),
        !TSTimePeriod::IsEmpty(Deadline)) )
  {
    v10 = L"v2 incompatible (Maintenance Task)";
    goto LABEL_12;
  }
  if ( Triggers::Trigulator::HasTrigger((__int64)a3, 26214) )
  {
    v10 = L"v2 incompatible (WNF State change trigger)";
LABEL_12:
    *v7 = 0;
    _bstr_t::operator=(&v16, v10);
    goto LABEL_13;
  }
  v11 = (_QWORD *)*((_QWORD *)a2 + 4);
  v12 = (_QWORD *)v11[22];
  if ( v12 )
    v12 = (_QWORD *)*v12;
  if ( v12 )
  {
    v10 = L"v2 incompatible (Package)";
    goto LABEL_12;
  }
  if ( (unsigned int)((__int64)(v11[24] - v11[23]) >> 3) )
  {
    v10 = L"v2 incompatible (Capabilities)";
    goto LABEL_12;
  }
LABEL_13:
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
  {
    if ( v16 )
      v13 = *(_QWORD *)v16;
    else
      v13 = 0LL;
    WPP_SF_SSD(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x11u,
      (__int64)&WPP_ffeb42fce81a3445f9740a981b62c86a_Traceguids,
      *((const wchar_t **)a2 + 3),
      v13);
  }
  _bstr_t::_Free((_bstr_t *)&v16);
  return 0LL;
}
// 180080CB0: using guessed type wchar_t aV2Incompatible_0[35];
// 180080CF8: using guessed type wchar_t aV2Incompatible_1[26];
// 180080D30: using guessed type wchar_t aV2Incompatible_2[43];
// 180080DD8: using guessed type wchar_t aV2Incompatible[31];
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018006A7A0) ----------------------------------------------------
__int64 __fastcall UbpmProxySingleton::LookupTask(
        UbpmProxySingleton *this,
        const struct _GUID *a2,
        struct JobMoniker *a3)
{
  int v3; // ebx
  int v5; // edi
  int v7; // eax

  v3 = 1;
  v5 = 1;
  while ( v3 == 1 )
  {
    v7 = UbpmProxySingleton::LookupTaskByIndex((__int64)this, a2, v5++, (__int64)a3, 1, 0LL, 0LL, 0LL);
    v3 = v7;
    if ( v5 > 3 )
    {
      if ( v7 == 1 )
        v3 = -2147023728;
      break;
    }
  }
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0
    && *((unsigned __int8 *)WPP_GLOBAL_Control + 25) >= (int)(((v3 >> 31) & 0xFFFFFFFE) + 4) )
  {
    WPP_SF__guid_D(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0x13u,
      (__int64)&WPP_ffeb42fce81a3445f9740a981b62c86a_Traceguids,
      (__int64)a2);
  }
  return (unsigned int)v3;
}
// 18006A7E5: variable 'this' is possibly undefined
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018006A868) ----------------------------------------------------
__int64 __fastcall UbpmProxySingleton::LookupTaskByIndex(
        __int64 a1,
        const struct _GUID *a2,
        int a3,
        __int64 a4,
        int a5,
        enum tsched::InternalTaskState *a6,
        _bstr_t::Data_t **a7,
        unsigned int *a8)
{
  int Moniker; // ebx
  __int64 v11; // r8
  int Next; // eax
  const unsigned __int16 *Path; // rax
  UbpmProxySingleton *v14; // rcx
  int matched; // eax
  __int64 v16; // rdx
  IndexEnumerator *v18; // [rsp+48h] [rbp-49h] BYREF
  HKEY *v19; // [rsp+50h] [rbp-41h]
  __int64 v20; // [rsp+58h] [rbp-39h]
  char v21[16]; // [rsp+60h] [rbp-31h] BYREF
  char v22[16]; // [rsp+70h] [rbp-21h] BYREF
  wmi::RefBase *v23; // [rsp+80h] [rbp-11h] BYREF

  v20 = -2LL;
  v19 = (HKEY *)JobStore::m_pCommonStore;
  v18 = 0LL;
  Moniker = JobStore::EnumStoredTasks((__int64)JobStore::m_pCommonStore, a3, &v18);
  if ( Moniker >= 0 )
  {
    while ( 1 )
    {
      Next = IndexEnumerator::FindNext(v18);
      Moniker = Next;
      if ( Next < 0 || Next == 1 )
        break;
      JobMoniker::JobMoniker((JobMoniker *)v21, 0LL, 0LL);
      Moniker = IndexEnumerator::GetMoniker(v18, (struct JobMoniker *)v21);
      if ( Moniker < 0 )
        goto LABEL_12;
      Path = JobMoniker::GetPath((JobMoniker *)v21);
      Moniker = JobStore::LoadBucketFromRegistry(v19, Path, 2, (__int64)v21, 0LL, 0LL);
      if ( !tsched::IsErrorNotFound((tsched *)(unsigned int)Moniker) )
      {
        if ( (int)v14 < 0 )
          goto LABEL_12;
        if ( (*((_DWORD *)v23 + 4) & 0x2000000) != 0 )
        {
          matched = UbpmProxySingleton::MatchConsumerWithInstance(v14, a2, (struct JobMoniker *)v21, a5, a6, a7, a8);
          Moniker = matched;
          if ( matched < 0 )
            goto LABEL_12;
          if ( !matched )
          {
            JobMoniker::operator=(a4, (__int64)v21);
LABEL_12:
            wmi::AutoRef<JobBucket>::Release(&v23);
            _bstr_t::_Free((_bstr_t *)v22);
            break;
          }
        }
      }
      wmi::AutoRef<JobBucket>::Release(&v23);
      _bstr_t::_Free((_bstr_t *)v22);
    }
  }
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
  {
    v16 = ((Moniker >> 31) & 0xFFFFFFFE) + 4;
    if ( *((unsigned __int8 *)WPP_GLOBAL_Control + 25) >= (int)v16 )
      WPP_SF__guid_dD(*((_QWORD *)WPP_GLOBAL_Control + 2), v16, v11, (__int64)a2);
  }
  wmi::AutoRef<FolderEnumerator>::~AutoRef<FolderEnumerator>(&v18);
  return (unsigned int)Moniker;
}
// 18006A954: variable 'v14' is possibly undefined
// 18006A9FE: variable 'v11' is possibly undefined
// 1800090EC: using guessed type __int64 __fastcall wmi::AutoRef<FolderEnumerator>::~AutoRef<FolderEnumerator>(_QWORD);
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018006AA58) ----------------------------------------------------
__int64 __fastcall UbpmProxySingleton::MatchConsumerWithInstance(
        UbpmProxySingleton *this,
        const struct _GUID *a2,
        struct JobMoniker *a3,
        int a4,
        enum tsched::InternalTaskState *a5,
        _bstr_t::Data_t **a6,
        unsigned int *a7)
{
  enum tsched::InternalTaskState *v10; // r8
  int v11; // eax
  int v12; // ebx
  __int64 v13; // r9
  unsigned int v14; // eax
  __int64 v15; // r10
  __int64 v16; // rdi
  __int64 v17; // rdx
  __int64 v18; // rcx
  __int64 v19; // rdx
  __int64 v20; // rdx
  User::UserEntry *v22; // [rsp+30h] [rbp-20h] BYREF
  __int64 v23; // [rsp+38h] [rbp-18h] BYREF
  __int64 v24[2]; // [rsp+40h] [rbp-10h] BYREF
  __int64 v25; // [rsp+70h] [rbp+20h] BYREF

  v24[1] = -2LL;
  v23 = 0LL;
  v25 = 0LL;
  v24[0] = (__int64)&v25;
  if ( (int)UbpmProxySingleton::OpenConsumer(this, a3, (struct AutoUbpmConsumerHandle *)&v23) < 0 )
    goto LABEL_28;
  v11 = UbpmTriggerConsumerQueryStatus(v23, &v25);
  v12 = v11;
  if ( v11 > 0 )
    v12 = (unsigned __int16)v11 | 0x80070000;
  if ( v12 < 0 )
    goto LABEL_28;
  v13 = v25;
  if ( !v25 )
    goto LABEL_28;
  v14 = 0;
  if ( !*(_DWORD *)(v25 + 28) )
    goto LABEL_28;
  v15 = *(_QWORD *)(v25 + 32);
  while ( 1 )
  {
    v16 = v14;
    v17 = 56LL * v14;
    v18 = *(_QWORD *)&a2->Data1 - *(_QWORD *)(v17 + v15 + 16);
    if ( *(_QWORD *)&a2->Data1 == *(_QWORD *)(v17 + v15 + 16) )
      v18 = *(_QWORD *)a2->Data4 - *(_QWORD *)(v17 + v15 + 24);
    if ( !v18 )
      break;
    if ( ++v14 >= *(_DWORD *)(v25 + 28) )
      goto LABEL_28;
  }
  if ( a4 )
  {
    v22 = 0LL;
    v12 = User::FromSid(&v22, *(void **)(56LL * v14 + v15 + 48), SidTypeUnknown);
    if ( v12 < 0 )
    {
      wmi::AutoRef<User::UserEntry>::Release(&v22);
      goto LABEL_27;
    }
    wmi::AutoRef<User::UserEntry>::operator=((User::UserEntry **)(*((_QWORD *)a3 + 4) + 64LL), v22);
    wmi::AutoRef<User::UserEntry>::Release(&v22);
    v13 = v25;
  }
  v10 = a5;
  if ( a5 )
  {
    if ( *(_BYTE *)(56 * v16 + *(_QWORD *)(v13 + 32) + 32) == 1 )
      *(_DWORD *)a5 = 2;
    else
      *(_DWORD *)a5 = *(unsigned __int8 *)(56 * v16 + *(_QWORD *)(v13 + 32) + 32) == 3;
  }
  if ( a6 )
  {
    _bstr_t::operator=(a6, *(const OLECHAR **)(56 * v16 + *(_QWORD *)(v13 + 32) + 8));
    v13 = v25;
  }
  if ( a7 )
    *a7 = *(_DWORD *)(56 * v16 + *(_QWORD *)(v13 + 32) + 36);
LABEL_27:
  if ( v12 == -2147023728 )
LABEL_28:
    v12 = 1;
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
  {
    v19 = ((v12 >> 31) & 0xFFFFFFFE) + 4;
    if ( *((unsigned __int8 *)WPP_GLOBAL_Control + 25) >= (int)v19 )
      WPP_SF__guid_SD(*((_QWORD *)WPP_GLOBAL_Control + 2), v19, (__int64)v10, (__int64)a2, *((_QWORD *)a3 + 3));
  }
  UbpmFreeMe::~UbpmFreeMe((UbpmFreeMe *)v24);
  if ( v23 )
    UbpmCloseTriggerConsumer(v23, v20);
  return (unsigned int)v12;
}
// 18006AC32: variable 'v10' is possibly undefined
// 18006AC4B: variable 'v20' is possibly undefined
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);
// 180073D58: using guessed type __int64 __fastcall UbpmTriggerConsumerQueryStatus(_QWORD, _QWORD);
// 180073D60: using guessed type __int64 __fastcall UbpmCloseTriggerConsumer(_QWORD, _QWORD);
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018006ACA0) ----------------------------------------------------
__int64 __fastcall UbpmProxySingleton::StopInstance(
        UbpmProxySingleton *this,
        const struct JobMoniker *a2,
        const struct _GUID *a3)
{
  return UbpmProxySingleton::StopInstances(this, a2, 0LL, a3);
}

//----- (000000018006ACB4) ----------------------------------------------------
__int64 __fastcall UbpmProxySingleton::StopInstances(
        UbpmProxySingleton *this,
        const struct JobMoniker *a2,
        const struct User *a3,
        const struct _GUID *a4)
{
  const wchar_t **v6; // rsi
  UbpmProxySingleton *v7; // rcx
  __int64 v8; // rdx
  int ClientUser; // ebx
  const struct _GUID *v10; // rax
  int v11; // eax
  int v12; // r12d
  int v13; // eax
  __int64 v14; // rcx
  unsigned int v15; // esi
  __int64 v16; // r15
  __int64 v17; // rcx
  __int64 v18; // rax
  int v19; // eax
  __int64 *v21; // [rsp+38h] [rbp-49h] BYREF
  __int64 v22; // [rsp+40h] [rbp-41h] BYREF
  __int64 v23; // [rsp+48h] [rbp-39h] BYREF
  int v24[4]; // [rsp+58h] [rbp-29h] BYREF
  DWORD LengthSid; // [rsp+68h] [rbp-19h]
  PSID v26; // [rsp+70h] [rbp-11h]
  const struct _GUID *v27; // [rsp+78h] [rbp-9h]
  __int64 v28; // [rsp+A8h] [rbp+27h]
  PSID pSid; // [rsp+E8h] [rbp+67h] BYREF
  const struct JobMoniker *v30; // [rsp+F0h] [rbp+6Fh]

  v30 = a2;
  pSid = this;
  v28 = -2LL;
  v6 = (const wchar_t **)a2;
  v23 = 0LL;
  memset_0(v24, 0, 0x48uLL);
  v22 = 0LL;
  ClientUser = UbpmProxySingleton::OpenConsumer(
                 v7,
                 (const struct JobMoniker *)v6,
                 (struct AutoUbpmConsumerHandle *)&v23);
  if ( ClientUser >= 0 )
  {
    v24[0] = 2;
    if ( a3 )
    {
      v12 = 0;
      v13 = UbpmTriggerConsumerQueryStatus(v23, &v22);
      ClientUser = v13;
      if ( v13 > 0 )
        ClientUser = (unsigned __int16)v13 | 0x80070000;
      if ( ClientUser >= 0 )
      {
        v14 = v22;
        if ( v22 )
        {
          v21 = &v22;
          v15 = 0;
          if ( *(_DWORD *)(v22 + 28) )
          {
            do
            {
              pSid = 0LL;
              v16 = 56LL * v15;
              ClientUser = User::FromSid(
                             (User::UserEntry **)&pSid,
                             *(void **)(*(_QWORD *)(v14 + 32) + v16 + 48),
                             SidTypeUnknown);
              if ( ClientUser < 0 )
              {
LABEL_43:
                wmi::AutoRef<User::UserEntry>::Release(&pSid);
                goto LABEL_35;
              }
              if ( User::operator==(a3, (User *)&pSid) )
              {
                if ( !a4 )
                  goto LABEL_26;
                v17 = *(_QWORD *)(v22 + 32);
                v18 = *(_QWORD *)&a4->Data1 - *(_QWORD *)(v17 + v16 + 16);
                if ( *(_QWORD *)&a4->Data1 == *(_QWORD *)(v17 + v16 + 16) )
                  v18 = *(_QWORD *)a4->Data4 - *(_QWORD *)(v17 + v16 + 24);
                if ( !v18 )
                {
LABEL_26:
                  v27 = (const struct _GUID *)(v16 + *(_QWORD *)(v22 + 32) + 16LL);
                  v26 = *(PSID *)(*(_QWORD *)(v22 + 32) + v16 + 48);
                  LengthSid = *(_DWORD *)(*(_QWORD *)(v22 + 32) + v16 + 40);
                  v19 = UbpmTriggerConsumerControl(v23, v24, 0LL);
                  ClientUser = v19;
                  if ( v19 == 1168 )
                  {
                    ClientUser = 0;
                  }
                  else
                  {
                    if ( v19 > 0 )
                      ClientUser = (unsigned __int16)v19 | 0x80070000;
                    if ( ClientUser < 0 )
                      goto LABEL_43;
                    v12 = 1;
                  }
                }
              }
              wmi::AutoRef<User::UserEntry>::Release(&pSid);
              ++v15;
              v14 = v22;
            }
            while ( v15 < *(_DWORD *)(v22 + 28) );
            if ( v12 )
              goto LABEL_35;
          }
          ClientUser = -2147023728;
LABEL_35:
          UbpmFreeMe::~UbpmFreeMe((UbpmFreeMe *)&v21);
          v6 = (const wchar_t **)v30;
        }
        else
        {
          ClientUser = -2147418113;
        }
      }
    }
    else
    {
      v21 = 0LL;
      v10 = v27;
      if ( a4 )
        v10 = a4;
      v27 = v10;
      RpcAutoImpersonate::RpcAutoImpersonate((RpcAutoImpersonate *)&pSid, L"UbpmProxySingleton::StopInstances", 1);
      ClientUser = RpcAutoImpersonate::GetClientUser((RpcAutoImpersonate *)&pSid, (struct User *)&v21);
      if ( ClientUser >= 0 )
      {
        if ( (_DWORD)pSid )
          RpcRevertToSelf();
        ClientUser = User::LookupSid((User *)&v21, &pSid);
        if ( ClientUser >= 0 )
        {
          v26 = pSid;
          LengthSid = GetLengthSid(pSid);
          v11 = UbpmTriggerConsumerControl(v23, v24, 0LL);
          ClientUser = v11;
          if ( v11 > 0 )
            ClientUser = (unsigned __int16)v11 | 0x80070000;
        }
      }
      else if ( (_DWORD)pSid )
      {
        RpcRevertToSelf();
      }
      wmi::AutoRef<User::UserEntry>::Release(&v21);
    }
  }
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
  {
    v8 = ((ClientUser >> 31) & 0xFFFFFFFE) + 4;
    if ( *((unsigned __int8 *)WPP_GLOBAL_Control + 25) >= (int)v8 )
      WPP_SF_SD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0x12u,
        (__int64)&WPP_ffeb42fce81a3445f9740a981b62c86a_Traceguids,
        v6[3]);
  }
  if ( v23 )
    UbpmCloseTriggerConsumer(v23, v8);
  return (unsigned int)ClientUser;
}
// 18006AD0C: variable 'v7' is possibly undefined
// 18006AF91: variable 'v8' is possibly undefined
// 180006E74: using guessed type __int64 __fastcall wmi::AutoRef<User::UserEntry>::Release(_QWORD);
// 180073D58: using guessed type __int64 __fastcall UbpmTriggerConsumerQueryStatus(_QWORD, _QWORD);
// 180073D60: using guessed type __int64 __fastcall UbpmCloseTriggerConsumer(_QWORD, _QWORD);
// 180073D70: using guessed type __int64 __fastcall UbpmTriggerConsumerControl(_QWORD, _QWORD, _QWORD);
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018006B010) ----------------------------------------------------
__int64 __fastcall UbpmProxySingleton::StopTask(
        UbpmProxySingleton *this,
        const struct JobMoniker *a2,
        const struct User *a3)
{
  return UbpmProxySingleton::StopInstances(this, a2, a3, 0LL);
}

//----- (000000018006B020) ----------------------------------------------------
__int64 __fastcall UbpmProxySingleton::UnregisterConsumer(UbpmProxySingleton *this, const wchar_t **a2, int a3)
{
  __int64 v4; // rdx
  signed int v5; // ebx
  __int64 v6; // r9
  int v7; // eax
  int v8; // eax
  char v10; // [rsp+20h] [rbp-28h]
  __int64 v11; // [rsp+50h] [rbp+8h] BYREF
  int v12; // [rsp+60h] [rbp+18h] BYREF

  v12 = a3;
  v11 = 0LL;
  v5 = UbpmProxySingleton::OpenConsumer(this, (const struct JobMoniker *)a2, (struct AutoUbpmConsumerHandle *)&v11);
  if ( v5 >= 0 )
  {
    v10 = 0;
    LOBYTE(v6) = 1;
    v7 = UbpmTriggerConsumerUnregister(v11, &v12, 0LL, v6, v10);
    v5 = v7;
    if ( v7 > 0 )
      v5 = (unsigned __int16)v7 | 0x80070000;
    if ( v5 >= 0 )
    {
      v5 = 0;
      v8 = (*(__int64 (__fastcall **)(EventTrapMap *, const wchar_t **))(*(_QWORD *)g_pEventTrapMap + 8LL))(
             g_pEventTrapMap,
             a2);
      if ( v8 < 0 )
        v5 = v8;
    }
  }
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x100) != 0 )
  {
    v4 = ((v5 >> 31) & 0xFFFFFFFE) + 4;
    if ( *((unsigned __int8 *)WPP_GLOBAL_Control + 25) >= (int)v4 )
      WPP_SF_SD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0xCu,
        (__int64)&WPP_ffeb42fce81a3445f9740a981b62c86a_Traceguids,
        a2[3]);
  }
  if ( v11 )
    UbpmCloseTriggerConsumer(v11, v4);
  return (unsigned int)v5;
}
// 18006B068: variable 'v6' is possibly undefined
// 18006B0FC: variable 'v4' is possibly undefined
// 180073D60: using guessed type __int64 __fastcall UbpmCloseTriggerConsumer(_QWORD, _QWORD);
// 180073D90: using guessed type __int64 __fastcall UbpmTriggerConsumerUnregister(_QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 1800747C8: using guessed type __int64 (__fastcall *_guard_dispatch_icall_fptr)();
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018006B140) ----------------------------------------------------
__int64 __fastcall UbpmProxySingleton::UpdateTaskNotificationSecurity(
        UbpmProxySingleton *this,
        struct JobMoniker *a2,
        __int64 a3,
        int a4)
{
  __int64 v6; // rdx
  signed int v7; // ebx
  int v8; // eax
  __int64 v10; // [rsp+20h] [rbp-28h] BYREF
  int v11; // [rsp+28h] [rbp-20h] BYREF
  __int64 v12; // [rsp+30h] [rbp-18h]

  v10 = 0LL;
  v7 = UbpmProxySingleton::OpenConsumer(this, a2, (struct AutoUbpmConsumerHandle *)&v10);
  if ( v7 >= 0 )
  {
    v12 = a3;
    v11 = a4;
    v8 = UbpmTriggerConsumerSetStatePublishingSecurity(v10, &v11);
    v7 = v8;
    if ( v8 > 0 )
      v7 = (unsigned __int16)v8 | 0x80070000;
  }
  if ( v10 )
    UbpmCloseTriggerConsumer(v10, v6);
  return (unsigned int)v7;
}
// 18006B1A2: variable 'v6' is possibly undefined
// 180073D60: using guessed type __int64 __fastcall UbpmCloseTriggerConsumer(_QWORD, _QWORD);
// 180073D80: using guessed type __int64 __fastcall UbpmTriggerConsumerSetStatePublishingSecurity(_QWORD, _QWORD);

//----- (000000018006B1C8) ----------------------------------------------------
char **__fastcall std::list<UbpmInstance>::erase(char **a1, char **a2, char *a3, char *a4)
{
  char *v5; // rbx
  char *v8; // rsi

  v5 = a3;
  if ( a3 == *(char **)*a1 && a4 == *a1 )
  {
    std::list<UbpmInstance>::clear((__int64)a1);
    *a2 = *a1;
  }
  else
  {
    while ( v5 != a4 )
    {
      v8 = *(char **)v5;
      if ( v5 != *a1 )
      {
        **((_QWORD **)v5 + 1) = v8;
        *(_QWORD *)(*(_QWORD *)v5 + 8LL) = *((_QWORD *)v5 + 1);
        wmi::AutoRef<JobBucket>::Release((wmi::RefBase **)v5 + 6);
        _bstr_t::_Free((_bstr_t *)(v5 + 32));
        operator delete(v5);
        --a1[1];
      }
      v5 = v8;
    }
    *a2 = a4;
  }
  return a2;
}

//----- (000000018006B274) ----------------------------------------------------
__int64 __fastcall WPP_SF_SdD(__int64 a1, unsigned __int16 a2, __int64 a3, const wchar_t *a4)
{
  __int64 v4; // rax

  if ( a4 )
  {
    v4 = -1LL;
    do
      ++v4;
    while ( a4[v4] );
  }
  if ( !a4 )
    a4 = L"NULL";
  return EtwTraceMessage(a1, 43LL, a3, a2, a4);
}
// 1800747B0: using guessed type __int64 __fastcall EtwTraceMessage(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 18007F5B8: using guessed type wchar_t aNull_1[5];

//----- (000000018006B304) ----------------------------------------------------
__int64 __fastcall WPP_SF__guid_D(__int64 a1, unsigned __int16 a2, __int64 a3, __int64 a4)
{
  return EtwTraceMessage(a1, 43LL, a3, a2, a4);
}
// 1800747B0: using guessed type __int64 __fastcall EtwTraceMessage(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000018006B350) ----------------------------------------------------
__int64 __fastcall WPP_SF__guid_SD(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // rax

  if ( a5 )
  {
    v5 = -1LL;
    do
      ++v5;
    while ( *(_WORD *)(a5 + 2 * v5) );
  }
  return EtwTraceMessage(a1, 43LL, &WPP_ffeb42fce81a3445f9740a981b62c86a_Traceguids, 21LL, a4);
}
// 1800747B0: using guessed type __int64 __fastcall EtwTraceMessage(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000018006B3F0) ----------------------------------------------------
__int64 __fastcall WPP_SF__guid_dD(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  return EtwTraceMessage(a1, 43LL, &WPP_ffeb42fce81a3445f9740a981b62c86a_Traceguids, 20LL, a4);
}
// 1800747B0: using guessed type __int64 __fastcall EtwTraceMessage(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000018006B454) ----------------------------------------------------
__int64 __fastcall UbpmParams::NewHostedObject<std::list<std::vector<unsigned char> *,std::allocator<std::vector<unsigned char> *>>,std::vector<unsigned char>>(
        _QWORD *a1,
        __int64 a2)
{
  _QWORD *v4; // rax
  __int64 v5; // rcx
  _QWORD *v6; // r8
  _QWORD *v7; // rdi
  _QWORD *v8; // rdx
  __int64 v9; // rax
  _QWORD *v11; // [rsp+50h] [rbp+8h] BYREF
  _QWORD *v12; // [rsp+60h] [rbp+18h]

  v4 = operator new(0x18uLL);
  v12 = v4;
  v6 = 0LL;
  if ( v4 )
    v6 = std::vector<unsigned char>::vector<unsigned char>(v4, a2);
  v11 = v6;
  v7 = (_QWORD *)*a1;
  v8 = std::_List_buy<wmi::AutoVectorPtr<_SID_AND_ATTRIBUTES> *,std::allocator<wmi::AutoVectorPtr<_SID_AND_ATTRIBUTES> *>>::_Buynode<wmi::AutoVectorPtr<_SID_AND_ATTRIBUTES> * const &>(
         v5,
         (_QWORD *)*a1,
         *(_QWORD **)(*a1 + 8LL),
         &v11);
  v9 = a1[1];
  if ( v9 == 0xAAAAAAAAAAAAAA9LL )
    std::_Xlength_error("list<T> too long");
  a1[1] = v9 + 1;
  v7[1] = v8;
  *(_QWORD *)v8[1] = v8;
  return (__int64)v11;
}
// 18006B4B6: variable 'v5' is possibly undefined

//----- (000000018006B524) ----------------------------------------------------
__int64 __fastcall UbpmParams::NewHostedObject<std::vector<_DAB_REGISTRATION_TRIGGER_PARAMS *>,_DAB_REGISTRATION_TRIGGER_PARAMS>(
        __int64 *a1,
        _OWORD *a2)
{
  _OWORD *v4; // rax
  char v5; // dl
  __int64 *v6; // rcx
  __int64 v7; // rax
  __int64 v8; // rdi
  _OWORD *v10; // [rsp+50h] [rbp+8h] BYREF

  v4 = operator new(0x10uLL);
  if ( v4 )
    *v4 = *a2;
  v10 = v4;
  v5 = 1;
  v6 = (__int64 *)a1[1];
  if ( &v10 >= (_OWORD **)v6 || *a1 > (unsigned __int64)&v10 )
    v5 = 0;
  if ( v5 )
  {
    v7 = *a1;
    v8 = ((__int64)&v10 - *a1) >> 3;
    if ( v6 == (__int64 *)a1[2] )
    {
      std::vector<_DAB_REGISTRATION_TRIGGER_PARAMS *>::_Reserve(a1);
      v7 = *a1;
      v6 = (__int64 *)a1[1];
    }
    v4 = *(_OWORD **)(v7 + 8 * v8);
  }
  else if ( v6 == (__int64 *)a1[2] )
  {
    std::vector<_DAB_REGISTRATION_TRIGGER_PARAMS *>::_Reserve(a1);
    v6 = (__int64 *)a1[1];
    v4 = v10;
  }
  *v6 = (__int64)v4;
  a1[1] += 8LL;
  return (__int64)v10;
}

//----- (000000018006B5F4) ----------------------------------------------------
__int64 __fastcall UbpmParams::NewHostedObject<std::vector<_DAB_SCHEDULE_BY_MONTH *>,_DAB_SCHEDULE_BY_MONTH>(
        __int64 *a1,
        _QWORD *a2)
{
  _QWORD *v4; // rax
  char v5; // dl
  __int64 *v6; // rcx
  __int64 v7; // rax
  __int64 v8; // rdi
  _QWORD *v10; // [rsp+50h] [rbp+8h] BYREF

  v4 = operator new(8uLL);
  if ( v4 )
    *v4 = *a2;
  v10 = v4;
  v5 = 1;
  v6 = (__int64 *)a1[1];
  if ( &v10 >= (_QWORD **)v6 || *a1 > (unsigned __int64)&v10 )
    v5 = 0;
  if ( v5 )
  {
    v7 = *a1;
    v8 = ((__int64)&v10 - *a1) >> 3;
    if ( v6 == (__int64 *)a1[2] )
    {
      std::vector<_DAB_REGISTRATION_TRIGGER_PARAMS *>::_Reserve(a1);
      v7 = *a1;
      v6 = (__int64 *)a1[1];
    }
    v4 = *(_QWORD **)(v7 + 8 * v8);
  }
  else if ( v6 == (__int64 *)a1[2] )
  {
    std::vector<_DAB_REGISTRATION_TRIGGER_PARAMS *>::_Reserve(a1);
    v6 = (__int64 *)a1[1];
    v4 = v10;
  }
  *v6 = (__int64)v4;
  a1[1] += 8LL;
  return (__int64)v10;
}

//----- (000000018006B6C4) ----------------------------------------------------
__int64 __fastcall UbpmParams::NewHostedObject<std::vector<_DAB_SCHEDULE_BY_MONTHLY_DAY_OF_WEEK *>,_DAB_SCHEDULE_BY_MONTHLY_DAY_OF_WEEK>(
        __int64 *a1,
        _DWORD *a2)
{
  _DWORD *v4; // rax
  char v5; // dl
  __int64 *v6; // rcx
  __int64 v7; // rax
  __int64 v8; // rdi
  _DWORD *v10; // [rsp+50h] [rbp+8h] BYREF

  v4 = operator new(4uLL);
  if ( v4 )
    *v4 = *a2;
  v10 = v4;
  v5 = 1;
  v6 = (__int64 *)a1[1];
  if ( &v10 >= (_DWORD **)v6 || *a1 > (unsigned __int64)&v10 )
    v5 = 0;
  if ( v5 )
  {
    v7 = *a1;
    v8 = ((__int64)&v10 - *a1) >> 3;
    if ( v6 == (__int64 *)a1[2] )
    {
      std::vector<_DAB_REGISTRATION_TRIGGER_PARAMS *>::_Reserve(a1);
      v7 = *a1;
      v6 = (__int64 *)a1[1];
    }
    v4 = *(_DWORD **)(v7 + 8 * v8);
  }
  else if ( v6 == (__int64 *)a1[2] )
  {
    std::vector<_DAB_REGISTRATION_TRIGGER_PARAMS *>::_Reserve(a1);
    v6 = (__int64 *)a1[1];
    v4 = v10;
  }
  *v6 = (__int64)v4;
  a1[1] += 8LL;
  return (__int64)v10;
}

//----- (000000018006B790) ----------------------------------------------------
void __fastcall std::vector<unsigned char>::_Insert<unsigned char *>(__int64 a1, _BYTE *a2, _BYTE *a3, _BYTE *a4)
{
  size_t v7; // r14
  __int64 v8; // r9
  void *v9; // rcx
  SIZE_T v10; // r12
  unsigned __int64 v11; // r9
  SIZE_T v12; // rdx
  char *v13; // r15
  size_t v14; // rdi
  char *v15; // rax
  char *v16; // rax
  size_t v17; // r14
  char *v18; // rax
  _BYTE *v19; // rdx
  _BYTE *v20; // r8
  _BYTE *v21; // rax

  v7 = a4 - a3;
  if ( a4 != a3 )
  {
    v8 = *(_QWORD *)(a1 + 16);
    v9 = *(void **)(a1 + 8);
    if ( v8 - (__int64)v9 >= v7 )
    {
      memmove_0(v9, a3, v7);
      v19 = *(_BYTE **)(a1 + 8);
      v20 = &v19[v7];
      v21 = v19;
      if ( a2 != v19 && v19 != v20 )
      {
        std::_Rotate<unsigned char *,__int64,unsigned char>(a2, v19, v20);
        v21 = *(_BYTE **)(a1 + 8);
      }
      v18 = &v21[v7];
    }
    else
    {
      if ( *(_QWORD *)a1 - (_QWORD)v9 - 1LL < v7 )
        std::_Xlength_error("vector<T> too long");
      v10 = (SIZE_T)v9 + v7 - *(_QWORD *)a1;
      v11 = v8 - *(_QWORD *)a1;
      v12 = 0LL;
      if ( ~(v11 >> 1) >= v11 )
        v12 = v11 + (v11 >> 1);
      if ( v12 >= v10 )
        v10 = v12;
      v13 = 0LL;
      if ( v10 )
      {
        v13 = (char *)operator new(v10);
        if ( !v13 )
          std::_Xbad_alloc();
      }
      v14 = (size_t)&a2[-*(_QWORD *)a1];
      v15 = (char *)memmove_0(v13, *(const void **)a1, v14);
      v16 = (char *)memmove_0(&v15[v14], a3, v7);
      memmove_0(&v16[v7], a2, *(_QWORD *)(a1 + 8) - (_QWORD)a2);
      v17 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1 + v7;
      if ( *(_QWORD *)a1 )
        operator delete(*(void **)a1);
      *(_QWORD *)(a1 + 16) = &v13[v10];
      v18 = &v13[v17];
      *(_QWORD *)a1 = v13;
    }
    *(_QWORD *)(a1 + 8) = v18;
  }
}

//----- (000000018006B924) ----------------------------------------------------
__int64 __fastcall std::_Rotate<unsigned char *,__int64,unsigned char>(_BYTE *a1, _BYTE *a2, _BYTE *a3)
{
  __int64 result; // rax
  __int64 v4; // r11
  __int64 v8; // r9
  __int64 v9; // rbx
  __int64 v10; // rax
  __int64 v11; // rt2
  _BYTE *v12; // r8
  char v13; // bp
  __int64 v14; // rcx
  _BYTE *v15; // rbx
  __int64 v16; // rdx
  void *retaddr; // [rsp+8h] [rbp+0h] BYREF

  result = (__int64)&retaddr;
  v4 = a2 - a1;
  v8 = a3 - a1;
  v9 = a2 - a1;
  if ( a2 != a1 )
  {
    do
    {
      v10 = v8;
      v8 = v9;
      v11 = v10 % v9;
      result = v10 / v9;
      v9 = v11;
    }
    while ( v11 );
    if ( v8 < a3 - a1 && v8 > 0 )
    {
      v12 = &a1[v8];
      do
      {
        v13 = *v12;
        v14 = (__int64)&v12[v4];
        v15 = v12;
        if ( &v12[v4] == a3 )
          v14 = (__int64)a1;
        v16 = -v14;
        do
        {
          *v15 = *(_BYTE *)v14;
          result = (__int64)&a3[v16];
          *(_BYTE *)v14 = v13;
          v15 = (_BYTE *)v14;
          if ( v4 >= (__int64)&a3[v16] )
          {
            result = a2 - a3;
            v14 += a2 - a3;
            v16 += a3 - a2;
          }
          else
          {
            v14 += v4;
            v16 -= v4;
          }
        }
        while ( (_BYTE *)v14 != v12 );
        --v12;
        --v8;
      }
      while ( v8 );
    }
  }
  return result;
}

//----- (000000018006B9F0) ----------------------------------------------------
_BYTE *__fastcall std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char>>>,unsigned char *,std::allocator<unsigned char>>(
        _BYTE *a1,
        _BYTE *a2,
        _BYTE *a3)
{
  while ( a1 != a2 )
    *a3++ = *a1++;
  return a3;
}

//----- (000000018006BA38) ----------------------------------------------------
_QWORD *__fastcall std::vector<unsigned char>::vector<unsigned char>(_QWORD *a1, __int64 a2)
{
  SIZE_T v4; // rdi
  _BYTE *v5; // rax

  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  v4 = *(_QWORD *)(a2 + 8) - *(_QWORD *)a2;
  if ( v4 )
  {
    v5 = operator new(v4);
    if ( !v5 )
      std::_Xbad_alloc();
    *a1 = v5;
    a1[1] = v5;
    a1[2] = &v5[v4];
    a1[1] = std::_Uninit_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char>>>,unsigned char *,std::allocator<unsigned char>>(
              *(_BYTE **)a2,
              *(_BYTE **)(a2 + 8),
              v5);
  }
  return a1;
}
// 180056ACC: using guessed type __int64 __fastcall std::vector<_DAB_SCHEDULE_BY_DAY *>::~vector<_DAB_SCHEDULE_BY_DAY *>(_QWORD);

//----- (000000018006BAE0) ----------------------------------------------------
void __fastcall UbpmParams::_unnamed_type_m_actionAccountInfo_::~_unnamed_type_m_actionAccountInfo_(
        UbpmParams::_unnamed_type_m_actionAccountInfo_ *this)
{
  void *v2; // rcx

  v2 = (void *)*((_QWORD *)this + 14);
  if ( v2 )
  {
    CredFree(v2);
    *((_QWORD *)this + 14) = 0LL;
  }
}

//----- (000000018006BB10) ----------------------------------------------------
void __fastcall tsched::DeleteMe<_DAB_SCHEDULE_BY_MONTHLY_DAY_OF_WEEK>::~DeleteMe<_DAB_SCHEDULE_BY_MONTHLY_DAY_OF_WEEK>(
        __int64 a1)
{
  void *v1; // rcx

  if ( *(_BYTE *)(a1 + 8) )
  {
    v1 = **(void ***)a1;
    if ( v1 )
      operator delete(v1);
  }
}

//----- (000000018006BB38) ----------------------------------------------------
void ***__fastcall tsched::DeleteMe<wmi::AutoVectorPtr<_DAB_SID_INFO *>>::~DeleteMe<wmi::AutoVectorPtr<_DAB_SID_INFO *>>(
        __int64 a1)
{
  void ***result; // rax
  void **v2; // rcx

  if ( *(_BYTE *)(a1 + 8) )
  {
    result = *(void ****)a1;
    v2 = **(void ****)a1;
    if ( v2 )
      return (void ***)wmi::AutoVectorPtr<_SID_AND_ATTRIBUTES>::`scalar deleting destructor'(v2);
  }
  return result;
}

//----- (000000018006BB60) ----------------------------------------------------
void **__fastcall tsched::DeleteMe<std::vector<unsigned char>>::~DeleteMe<std::vector<unsigned char>>(void ***a1)
{
  void **result; // rax
  void *v2; // rcx

  if ( *((_BYTE *)a1 + 8) )
  {
    result = *a1;
    v2 = **a1;
    if ( v2 )
      return (void **)std::vector<unsigned char>::`scalar deleting destructor'(v2);
  }
  return result;
}

//----- (000000018006BB88) ----------------------------------------------------
void __fastcall std::list<wmi::AutoVectorPtr<_SID_AND_ATTRIBUTES> *,std::allocator<wmi::AutoVectorPtr<_SID_AND_ATTRIBUTES> *>>::~list<wmi::AutoVectorPtr<_SID_AND_ATTRIBUTES> *,std::allocator<wmi::AutoVectorPtr<_SID_AND_ATTRIBUTES> *>>(
        void **a1)
{
  std::list<std::vector<unsigned char> *,std::allocator<std::vector<unsigned char> *>>::clear((__int64)a1);
  operator delete(*a1);
}

//----- (000000018006BBB8) ----------------------------------------------------
void __fastcall tsched::FreeSidGuard::~FreeSidGuard(void ***this)
{
  void *v1; // rcx

  if ( *((_BYTE *)this + 8) )
  {
    v1 = **this;
    if ( v1 )
      FreeSid(v1);
  }
}

//----- (000000018006BBF0) ----------------------------------------------------
void **__fastcall wmi::AutoVectorPtr<_SID_AND_ATTRIBUTES>::`scalar deleting destructor'(void **lpMem)
{
  operator delete(*lpMem);
  operator delete(lpMem);
  return lpMem;
}

//----- (000000018006BC1C) ----------------------------------------------------
void *__fastcall std::vector<unsigned char>::`scalar deleting destructor'(void *lpMem)
{
  std::vector<_DAB_SCHEDULE_BY_DAY *>::~vector<_DAB_SCHEDULE_BY_DAY *>(lpMem);
  operator delete(lpMem);
  return lpMem;
}
// 180056ACC: using guessed type __int64 __fastcall std::vector<_DAB_SCHEDULE_BY_DAY *>::~vector<_DAB_SCHEDULE_BY_DAY *>(_QWORD);

//----- (000000018006BC44) ----------------------------------------------------
struct _SID_AND_ATTRIBUTES *__fastcall UbpmParams::CreateHostedCapabilitiesSidArray(
        UbpmParams *this,
        const struct JobMoniker *a2)
{
  LPVOID v4; // rbx
  __int64 v5; // rdi
  __int64 v6; // r15
  __int64 v7; // rsi
  __int64 v8; // rdi
  const unsigned __int16 **v9; // rax
  const unsigned __int16 *v10; // rdx
  __int64 HostedSidFromCapabilityName; // rax
  _QWORD *v12; // rcx
  __int64 v13; // rdi
  _QWORD *v14; // rax
  __int64 v15; // rdx
  __int64 *v17; // [rsp+28h] [rbp-28h] BYREF
  char v18; // [rsp+30h] [rbp-20h]
  LPVOID *v19; // [rsp+38h] [rbp-18h] BYREF
  char v20; // [rsp+40h] [rbp-10h]
  char *v21; // [rsp+88h] [rbp+38h] BYREF
  _QWORD *v22; // [rsp+90h] [rbp+40h] BYREF

  v4 = 0LL;
  v21 = 0LL;
  v22 = 0LL;
  v19 = (LPVOID *)&v21;
  v20 = 1;
  v17 = (__int64 *)&v22;
  v18 = 1;
  v5 = (__int64)(*(_QWORD *)(*((_QWORD *)a2 + 4) + 192LL) - *(_QWORD *)(*((_QWORD *)a2 + 4) + 184LL)) >> 3;
  if ( (_DWORD)v5 )
  {
    v6 = (unsigned int)v5;
    v21 = (char *)operator new(saturated_mul((unsigned int)v5, 0x10uLL));
    v7 = 0LL;
    v8 = 0LL;
    do
    {
      v9 = *(const unsigned __int16 ***)(v8 + *(_QWORD *)(*((_QWORD *)a2 + 4) + 184LL));
      if ( v9 )
        v10 = *v9;
      else
        v10 = 0LL;
      HostedSidFromCapabilityName = UbpmParams::CreateHostedSidFromCapabilityName(this, v10);
      *(_QWORD *)&v21[v7] = HostedSidFromCapabilityName;
      *(_DWORD *)&v21[v7 + 8] = 4;
      v8 += 8LL;
      v7 += 16LL;
      --v6;
    }
    while ( v6 );
    v12 = operator new(8uLL);
    v22 = v12;
    if ( v12 )
      *v12 = v21;
    else
      v12 = 0LL;
    v22 = v12;
    v20 = 0;
    v13 = *((_QWORD *)this + 31);
    v14 = std::_List_buy<wmi::AutoVectorPtr<_SID_AND_ATTRIBUTES> *,std::allocator<wmi::AutoVectorPtr<_SID_AND_ATTRIBUTES> *>>::_Buynode<wmi::AutoVectorPtr<_SID_AND_ATTRIBUTES> * const &>(
            (__int64)v12,
            (_QWORD *)v13,
            *(_QWORD **)(v13 + 8),
            &v22);
    v15 = *((_QWORD *)this + 32);
    if ( v15 == 0xAAAAAAAAAAAAAA9LL )
      std::_Xlength_error("list<T> too long");
    *((_QWORD *)this + 32) = v15 + 1;
    *(_QWORD *)(v13 + 8) = v14;
    *(_QWORD *)v14[1] = v14;
    v18 = 0;
    v4 = v21;
  }
  tsched::DeleteMe<wmi::AutoVectorPtr<_DAB_SID_INFO *>>::~DeleteMe<wmi::AutoVectorPtr<_DAB_SID_INFO *>>((__int64)&v17);
  tsched::DeleteMe<_DAB_SCHEDULE_BY_MONTHLY_DAY_OF_WEEK>::~DeleteMe<_DAB_SCHEDULE_BY_MONTHLY_DAY_OF_WEEK>((__int64)&v19);
  return (struct _SID_AND_ATTRIBUTES *)v4;
}
// 18006BCCB: conditional instruction was optimized away because edi.4!=0

//----- (000000018006BDEC) ----------------------------------------------------
__int64 __fastcall UbpmParams::CreateHostedPackageSid(UbpmParams *this, const struct JobMoniker *a2)
{
  _QWORD *v3; // rcx
  NTSTATUS v5; // eax
  __int64 HostedSid; // rbx
  void **v7; // [rsp+28h] [rbp-48h] BYREF
  char v8; // [rsp+30h] [rbp-40h]
  void **pExceptionObject; // [rsp+38h] [rbp-38h] BYREF
  char v10; // [rsp+40h] [rbp-30h]
  const unsigned __int16 *v11; // [rsp+48h] [rbp-28h]
  __int64 v12; // [rsp+50h] [rbp-20h]
  int v13; // [rsp+58h] [rbp-18h]
  int v14; // [rsp+5Ch] [rbp-14h]
  ULONG v15; // [rsp+60h] [rbp-10h]
  int v16; // [rsp+64h] [rbp-Ch]
  int v17; // [rsp+68h] [rbp-8h]
  void *v18; // [rsp+88h] [rbp+18h] BYREF

  v18 = 0LL;
  v7 = &v18;
  v8 = 1;
  v3 = *(_QWORD **)(*((_QWORD *)a2 + 4) + 176LL);
  if ( v3 )
    v3 = (_QWORD *)*v3;
  if ( v3 )
  {
    v5 = DeriveAppContainerSidFromAppContainerName(v3, &v18);
    if ( v5 < 0 )
    {
      v10 = 0;
      pExceptionObject = &wmi::GenericException::`vftable';
      v11 = &word_18007630E;
      v12 = 0LL;
      v13 = 0;
      v14 = 0;
      v15 = RtlNtStatusToDosError(v5);
      v16 = -1;
      v17 = -1;
      CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
    }
    HostedSid = UbpmParams::CreateHostedSid(this, v18);
    tsched::FreeSidGuard::~FreeSidGuard(&v7);
    return HostedSid;
  }
  else
  {
    tsched::FreeSidGuard::~FreeSidGuard(&v7);
    return 0LL;
  }
}
// 1800716D8: using guessed type void *wmi::GenericException::`vftable';
// 1800B9088: using guessed type __int64 __fastcall DeriveAppContainerSidFromAppContainerName(_QWORD, _QWORD);

//----- (000000018006BEE0) ----------------------------------------------------
__int64 __fastcall UbpmParams::CreateHostedSid(UbpmParams *this, _BYTE *a2)
{
  DWORD LengthSid; // eax
  __int64 *v5; // rax
  __int64 v6; // rbx
  __int128 v8; // [rsp+38h] [rbp-20h] BYREF
  __int64 v9; // [rsp+48h] [rbp-10h]

  v8 = 0LL;
  v9 = 0LL;
  std::vector<unsigned char>::resize((char **)&v8);
  LengthSid = GetLengthSid(a2);
  std::vector<unsigned char>::_Insert<unsigned char *>((__int64)&v8, *((_BYTE **)&v8 + 1), a2, &a2[LengthSid]);
  v5 = (__int64 *)UbpmParams::NewHostedObject<std::list<std::vector<unsigned char> *,std::allocator<std::vector<unsigned char> *>>,std::vector<unsigned char>>(
                    (_QWORD *)this + 29,
                    (__int64)&v8);
  v6 = *v5;
  if ( v5[1] == *v5 )
    std::_Xout_of_range("invalid vector<T> subscript");
  std::vector<_DAB_SCHEDULE_BY_DAY *>::~vector<_DAB_SCHEDULE_BY_DAY *>(&v8);
  return v6;
}
// 180056ACC: using guessed type __int64 __fastcall std::vector<_DAB_SCHEDULE_BY_DAY *>::~vector<_DAB_SCHEDULE_BY_DAY *>(_QWORD);

//----- (000000018006BF8C) ----------------------------------------------------
__int64 __fastcall UbpmParams::CreateHostedSidFromCapabilityName(UbpmParams *this, const unsigned __int16 *a2)
{
  NTSTATUS v3; // eax
  void **pExceptionObject; // [rsp+20h] [rbp-59h] BYREF
  char v6; // [rsp+28h] [rbp-51h]
  const unsigned __int16 *v7; // [rsp+30h] [rbp-49h]
  __int64 v8; // [rsp+38h] [rbp-41h]
  int v9; // [rsp+40h] [rbp-39h]
  int v10; // [rsp+44h] [rbp-35h]
  ULONG v11; // [rsp+48h] [rbp-31h]
  int v12; // [rsp+4Ch] [rbp-2Dh]
  int v13; // [rsp+50h] [rbp-29h]
  struct _UNICODE_STRING DestinationString; // [rsp+58h] [rbp-21h] BYREF
  char v15[48]; // [rsp+68h] [rbp-11h] BYREF
  char v16[48]; // [rsp+98h] [rbp+1Fh] BYREF

  RtlInitUnicodeString(&DestinationString, a2);
  v3 = RtlDeriveCapabilitySidsFromName(&DestinationString, v16, v15);
  if ( v3 < 0 )
  {
    v8 = 0LL;
    v9 = 0;
    v10 = 0;
    v12 = -1;
    v13 = -1;
    pExceptionObject = &wmi::GenericException::`vftable';
    v7 = &word_18007630E;
    v6 = 0;
    v11 = RtlNtStatusToDosError(v3);
    CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI3_AVGenericException_wmi__);
  }
  return UbpmParams::CreateHostedSid(this, v15);
}
// 1800716D8: using guessed type void *wmi::GenericException::`vftable';
// 180074620: using guessed type __int64 __fastcall RtlDeriveCapabilitySidsFromName(_QWORD, _QWORD, _QWORD);
// 18006BF8C: using guessed type char var_38[48];

//----- (000000018006C05C) ----------------------------------------------------
char *__fastcall UbpmParams::CreateHostedSidInfoArray(UbpmParams *this, void *const **a2)
{
  void *const *v4; // rbx
  __int64 v5; // rsi
  _QWORD *v6; // rax
  __int64 v7; // rcx
  __int64 v8; // rbx
  _QWORD *v9; // rdx
  __int64 v10; // rax
  char *v12; // [rsp+70h] [rbp+20h]
  _QWORD *v13; // [rsp+78h] [rbp+28h] BYREF

  v13 = 0LL;
  v12 = (char *)operator new(saturated_mul(a2[1] - *a2, 8uLL));
  v4 = *a2;
  v5 = 0LL;
  while ( v4 != a2[1] )
  {
    *(_QWORD *)&v12[v5] = UbpmParams::CreateHostedSidInfo(this, *v4++);
    v5 += 8LL;
  }
  v6 = operator new(8uLL);
  v13 = v6;
  if ( v6 )
  {
    v7 = (__int64)v12;
    *v6 = v12;
  }
  v13 = v6;
  v8 = *((_QWORD *)this + 27);
  v9 = std::_List_buy<wmi::AutoVectorPtr<_SID_AND_ATTRIBUTES> *,std::allocator<wmi::AutoVectorPtr<_SID_AND_ATTRIBUTES> *>>::_Buynode<wmi::AutoVectorPtr<_SID_AND_ATTRIBUTES> * const &>(
         v7,
         (_QWORD *)v8,
         *(_QWORD **)(v8 + 8),
         &v13);
  v10 = *((_QWORD *)this + 28);
  if ( v10 == 0xAAAAAAAAAAAAAA9LL )
    std::_Xlength_error("list<T> too long");
  *((_QWORD *)this + 28) = v10 + 1;
  *(_QWORD *)(v8 + 8) = v9;
  *(_QWORD *)v9[1] = v9;
  return v12;
}
// 18006C128: variable 'v7' is possibly undefined

//----- (000000018006C1B0) ----------------------------------------------------
const unsigned __int16 *__fastcall UbpmParams::GetPath(JobMoniker **this)
{
  return JobMoniker::GetPath(this[1]);
}

//----- (000000018006C1C0) ----------------------------------------------------
char **__fastcall std::vector<unsigned char>::erase(_QWORD *a1, char **a2, char *a3, char *a4)
{
  size_t v7; // rdi
  char **result; // rax

  if ( a3 == (char *)*a1 && a4 == (char *)a1[1] )
  {
    a1[1] = *a1;
  }
  else if ( a3 != a4 )
  {
    v7 = a1[1] - (_QWORD)a4;
    memmove_0(a3, a4, v7);
    a1[1] = &a3[v7];
  }
  result = a2;
  *a2 = a3;
  return result;
}

//----- (000000018006C238) ----------------------------------------------------
__int64 __fastcall std::vector<void *>::push_back(__int64 *a1, __int64 *a2)
{
  __int64 *v4; // rcx
  __int64 v6; // rax
  __int64 v7; // rdi
  __int64 result; // rax

  v4 = (__int64 *)a1[1];
  if ( a2 < v4 && *a1 <= (unsigned __int64)a2 )
  {
    v6 = *a1;
    v7 = ((__int64)a2 - *a1) >> 3;
    if ( v4 == (__int64 *)a1[2] )
    {
      std::vector<_DAB_REGISTRATION_TRIGGER_PARAMS *>::_Reserve(a1);
      v6 = *a1;
      v4 = (__int64 *)a1[1];
    }
    result = *(_QWORD *)(v6 + 8 * v7);
  }
  else
  {
    if ( v4 == (__int64 *)a1[2] )
    {
      std::vector<_DAB_REGISTRATION_TRIGGER_PARAMS *>::_Reserve(a1);
      v4 = (__int64 *)a1[1];
    }
    result = *a2;
  }
  *v4 = result;
  a1[1] += 8LL;
  return result;
}

//----- (000000018006C2B4) ----------------------------------------------------
char **__fastcall std::vector<unsigned char>::resize(char **a1)
{
  char *v1; // r9
  char **result; // rax
  char *v3; // [rsp+38h] [rbp+10h] BYREF

  v1 = a1[1];
  if ( v1 != *a1 )
    return std::vector<unsigned char>::erase(a1, &v3, *a1, v1);
  return result;
}

//----- (000000018006C2DC) ----------------------------------------------------
__int64 __fastcall WPP_SF_SSSD(__int64 a1, unsigned __int16 a2, __int64 a3, const wchar_t *a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r8
  __int64 v7; // rax
  __int64 v8; // rax
  bool v9; // zf

  v6 = -1LL;
  if ( a6 )
  {
    v7 = -1LL;
    do
      ++v7;
    while ( *(_WORD *)(a6 + 2 * v7) );
  }
  if ( a5 )
  {
    v8 = -1LL;
    do
      ++v8;
    while ( *(_WORD *)(a5 + 2 * v8) );
  }
  v9 = a4 == 0LL;
  if ( a4 )
  {
    do
      ++v6;
    while ( a4[v6] );
    v9 = a4 == 0LL;
  }
  if ( v9 )
    a4 = L"NULL";
  return EtwTraceMessage(a1, 43LL, &WPP_f0f7296807f33a7e423f6d049324e537_Traceguids, a2, a4);
}
// 1800747B0: using guessed type __int64 __fastcall EtwTraceMessage(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 18007F5B8: using guessed type wchar_t aNull_1[5];

//----- (000000018006C3FC) ----------------------------------------------------
__int64 __fastcall WPP_SF__guid_SSD(__int64 a1, unsigned __int16 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // r8
  __int64 v7; // rax

  v6 = -1LL;
  if ( a6 )
  {
    v7 = -1LL;
    do
      ++v7;
    while ( *(_WORD *)(a6 + 2 * v7) );
  }
  if ( a5 )
  {
    do
      ++v6;
    while ( *(_WORD *)(a5 + 2 * v6) );
  }
  return EtwTraceMessage(a1, 43LL, &WPP_f0f7296807f33a7e423f6d049324e537_Traceguids, a2, a4);
}
// 1800747B0: using guessed type __int64 __fastcall EtwTraceMessage(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000018006C4F0) ----------------------------------------------------
ULONG __fastcall _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapSz<char>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>>(
        __int64 a1,
        unsigned __int8 *a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        const unsigned __int16 **a9,
        __int64 a10,
        __int64 a11,
        __int64 a12,
        __int64 a13)
{
  const unsigned __int16 *v13; // rcx
  __int64 v14; // rax
  int v15; // eax
  struct _EVENT_DATA_DESCRIPTOR v17; // [rsp+30h] [rbp-B1h] BYREF
  __int64 v18; // [rsp+50h] [rbp-91h]
  __int64 v19; // [rsp+58h] [rbp-89h]
  __int64 v20; // [rsp+60h] [rbp-81h]
  __int64 v21; // [rsp+68h] [rbp-79h]
  __int64 v22; // [rsp+70h] [rbp-71h]
  __int64 v23; // [rsp+78h] [rbp-69h]
  __int64 v24; // [rsp+80h] [rbp-61h]
  __int64 v25; // [rsp+88h] [rbp-59h]
  const unsigned __int16 *v26; // [rsp+90h] [rbp-51h]
  int v27; // [rsp+98h] [rbp-49h]
  int v28; // [rsp+9Ch] [rbp-45h]
  __int64 v29; // [rsp+A0h] [rbp-41h]
  __int64 v30; // [rsp+A8h] [rbp-39h]
  __int64 v31; // [rsp+B0h] [rbp-31h]
  __int64 v32; // [rsp+B8h] [rbp-29h]
  __int64 v33; // [rsp+C0h] [rbp-21h]
  __int64 v34; // [rsp+C8h] [rbp-19h]
  __int64 v35; // [rsp+D0h] [rbp-11h]
  __int64 v36; // [rsp+D8h] [rbp-9h]

  v35 = a13;
  v33 = a12;
  v31 = a11;
  v29 = a10;
  v36 = 4LL;
  v34 = 4LL;
  v32 = 4LL;
  v13 = *a9;
  v30 = 4LL;
  if ( v13 )
  {
    v14 = -1LL;
    do
      ++v14;
    while ( *((_BYTE *)v13 + v14) );
    v15 = v14 + 1;
  }
  else
  {
    v13 = &word_18007630E;
    v15 = 1;
  }
  v27 = v15;
  v24 = a8;
  v22 = a7;
  v20 = a6;
  v18 = a5;
  v26 = v13;
  v28 = 0;
  v25 = 4LL;
  v23 = 4LL;
  v21 = 4LL;
  v19 = 4LL;
  return tlgWriteTransfer_EventWriteTransfer((__int64)&dword_1800AFDD0, a2, 0LL, 0LL, 0xBu, &v17);
}

//----- (000000018006C604) ----------------------------------------------------
DWORD __fastcall GetImageTuple(__int64 a1, CHAR *a2, __int64 a3, _DWORD *a4, _DWORD *a5)
{
  int v6; // ecx
  int v7; // edx
  DWORD result; // eax
  DWORD v9; // ecx
  DWORD v10; // edx

  if ( *(__int16 *)((char *)&word_180000018 + (int)off_18000003C) == 267
    || *(__int16 *)((char *)&word_180000018 + (int)off_18000003C) == 523 )
  {
    v6 = *(_DWORD *)&byte_180000040[(int)off_18000003C + 16];
    v7 = *(_DWORD *)((char *)&word_180000008 + (int)off_18000003C);
  }
  else
  {
    v6 = 0;
    v7 = 0;
  }
  *a4 = v7;
  *a5 = v6;
  result = GetModuleFileNameA((HMODULE)&_ImageBase, a2, 0x104u);
  if ( result )
  {
    v9 = result - 1;
    v10 = result - 1;
    if ( result != 1 )
    {
      while ( a2[v10] != 92 )
      {
        if ( !--v10 )
          goto LABEL_11;
      }
      v9 = v10;
    }
LABEL_11:
    if ( v9 != 259 )
      memmove_0(a2, &a2[v9 + 1], 259 - v9);
    return 1;
  }
  return result;
}
// 180000008: using guessed type __int16;
// 180000018: using guessed type __int16;
// 18000003C: using guessed type int *__ptr32 off_18000003C;

//----- (000000018006C6B0) ----------------------------------------------------
void MicrosoftTelemetryAssertTriggeredNoArgs()
{
  unsigned __int64 retaddr; // [rsp+38h] [rbp+0h]

  MicrosoftTelemetryAssertTriggeredWorker(retaddr);
}

//----- (000000018006C6CC) ----------------------------------------------------
void __fastcall MicrosoftTelemetryAssertTriggeredWorker(unsigned __int64 a1)
{
  DWORD v2; // esi
  int v3; // r15d
  struct MicrosoftTelemetryAssertTriggeredNode *v4; // rbx
  struct MicrosoftTelemetryAssertTriggeredNode *v5; // rax
  DWORD TickCount; // eax
  struct MicrosoftTelemetryAssertTriggeredNode *v7; // rcx
  __int64 v8; // rcx
  __int64 v9; // r8
  DWORD v10; // r14d
  char *v11; // rdx
  int v12; // edi
  CHAR v13; // dl
  unsigned int v14; // r13d
  __int64 v15; // r14
  CHAR *v16; // r12
  unsigned int v17; // ecx
  REGHANDLE v18; // rcx
  unsigned int v19; // edx
  __int64 v20; // r8
  const char *v21; // r9
  __int64 v22; // rcx
  REGHANDLE v23; // rcx
  unsigned int v24; // [rsp+78h] [rbp-90h] BYREF
  DWORD ImageTuple; // [rsp+7Ch] [rbp-8Ch] BYREF
  int v26; // [rsp+80h] [rbp-88h] BYREF
  ULONGLONG RegHandle; // [rsp+88h] [rbp-80h] BYREF
  int v28; // [rsp+90h] [rbp-78h] BYREF
  int v29; // [rsp+94h] [rbp-74h] BYREF
  int v30; // [rsp+98h] [rbp-70h] BYREF
  int v31; // [rsp+9Ch] [rbp-6Ch] BYREF
  GUID ProviderId; // [rsp+A0h] [rbp-68h] BYREF
  CHAR v33[272]; // [rsp+B8h] [rbp-50h] BYREF

  v2 = 0;
  v3 = 0;
  AcquireSRWLockExclusive(&g_MicrosoftTelemetryAssertLock);
  v4 = g_MicrosoftTelemetryAssertsTriggeredList;
  if ( !g_MicrosoftTelemetryAssertsTriggeredList )
    goto LABEL_5;
  do
  {
    if ( *(_QWORD *)v4 == a1 )
      break;
    v4 = (struct MicrosoftTelemetryAssertTriggeredNode *)*((_QWORD *)v4 + 3);
  }
  while ( v4 );
  if ( !v4 )
  {
LABEL_5:
    v5 = (struct MicrosoftTelemetryAssertTriggeredNode *)LocalAlloc(0x40u, 0x20uLL);
    v4 = v5;
    if ( !v5 )
      goto LABEL_38;
    *(_QWORD *)v5 = a1;
    TickCount = GetTickCount();
    v7 = g_MicrosoftTelemetryAssertsTriggeredList;
    *((_DWORD *)v4 + 2) = TickCount - 60001;
    *(_QWORD *)((char *)v4 + 12) = 0LL;
    *((_QWORD *)v4 + 3) = v7;
    g_MicrosoftTelemetryAssertsTriggeredList = v4;
  }
  ++*((_DWORD *)v4 + 3);
  ++*((_DWORD *)v4 + 4);
  if ( GetTickCount() - *((_DWORD *)v4 + 2) > 0xEA60 )
  {
    *((_DWORD *)v4 + 2) = GetTickCount();
    ImageTuple = GetImageTuple(v8, v33, v9, &v26, &v24);
    v10 = ImageTuple;
    if ( ImageTuple
      && a1 >= (unsigned __int64)&_ImageBase
      && (v11 = (char *)&_ImageBase + v24, v11 > (char *)&_ImageBase)
      && a1 <= (unsigned __int64)v11 )
    {
      v12 = a1 - (unsigned int)&_ImageBase;
    }
    else
    {
      v12 = 0;
    }
    if ( *((_DWORD *)v4 + 4) == 1
      && !(unsigned int)TraceLoggingRegisterEx_EventRegister_EventSetInformation((ULONGLONG *)&dword_1800AFD98) )
    {
      if ( dword_1800AFD98 )
      {
        v13 = v33[0];
        v2 = 1;
        ProviderId.Data1 = 488056742;
        v3 = 1;
        *(_DWORD *)&ProviderId.Data2 = 1311216328;
        v14 = 0;
        *(_DWORD *)ProviderId.Data4 = -1961924164;
        *(_DWORD *)&ProviderId.Data4[4] = -1655403451;
        if ( v33[0] )
        {
          v15 = 0LL;
          v16 = v33;
          do
          {
            *((_BYTE *)&ProviderId.Data1 + v15) += toupper(v13);
            ++v16;
            v17 = v14 + 1;
            v13 = *v16;
            v14 = v17 < 0x10 ? v17 : 0;
            v15 = (v15 + 1) & -(__int64)(v17 < 0x10);
          }
          while ( *v16 );
          v10 = ImageTuple;
        }
        if ( !EventRegister_0(&ProviderId, 0LL, 0LL, &RegHandle) )
        {
          if ( EventProviderEnabled(RegHandle, 0, 0LL) )
            v2 = 0;
          EventUnregister_0(RegHandle);
        }
      }
      v18 = qword_1800AFDB8;
      qword_1800AFDB8 = 0LL;
      dword_1800AFD98 = 0;
      EventUnregister(v18);
    }
    if ( !(unsigned int)TraceLoggingRegisterEx_EventRegister_EventSetInformation((ULONGLONG *)&dword_1800AFDD0) )
    {
      if ( (unsigned int)dword_1800AFDD0 > 5
        && (qword_1800AFDE0 & 0x400000000000LL) != 0
        && (qword_1800AFDE8 & 0x400000000000LL) == qword_1800AFDE8 )
      {
        v19 = *((_DWORD *)v4 + 4);
        v20 = *((unsigned int *)v4 + 3);
        v21 = v33;
        ImageTuple = v2;
        v28 = v20;
        if ( !v10 )
          v21 = "<unknown>";
        v31 = v12;
        *(_QWORD *)&ProviderId.Data1 = v21;
        LODWORD(RegHandle) = 10;
        v22 = v10 != 0 ? v24 : 0;
        v24 = v19;
        v29 = v22;
        v30 = v10 != 0 ? v26 : 0;
        v26 = v3;
        _tlgWriteTemplate<long (_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),&long _tlgWriteTransfer_EventWriteTransfer(_tlgProvider_t const *,void const *,_GUID const *,_GUID const *,unsigned int,_EVENT_DATA_DESCRIPTOR *),_GUID const *,_GUID const *>::Write<_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapSz<char>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>,_tlgWrapperByVal<4>>(
          v22,
          byte_18007F226,
          v20,
          (__int64)v21,
          (__int64)&RegHandle,
          (__int64)&v31,
          (__int64)&v30,
          (__int64)&v29,
          (const unsigned __int16 **)&ProviderId,
          (__int64)&v28,
          (__int64)&v24,
          (__int64)&ImageTuple,
          (__int64)&v26);
      }
      v23 = qword_1800AFDF0;
      qword_1800AFDF0 = 0LL;
      dword_1800AFDD0 = 0;
      EventUnregister(v23);
    }
    if ( v3 && v2 )
      Sleep(0x3E8u);
    *((_DWORD *)v4 + 3) = 0;
  }
LABEL_38:
  ReleaseSRWLockExclusive(&g_MicrosoftTelemetryAssertLock);
}
// 18006C7D0: variable 'v8' is possibly undefined
// 18006C7D0: variable 'v9' is possibly undefined
// 18007F226: using guessed type unsigned __int8 byte_18007F226[145];
// 1800AFD98: using guessed type int dword_1800AFD98;
// 1800AFDE0: using guessed type __int64 qword_1800AFDE0;
// 1800AFDE8: using guessed type __int64 qword_1800AFDE8;
// 1800B09F0: using guessed type struct MicrosoftTelemetryAssertTriggeredNode *g_MicrosoftTelemetryAssertsTriggeredList;

//----- (000000018006CA8C) ----------------------------------------------------
void tlgDefineProvider_annotation__Tlgmtaum_hTelemetryAssertDiagTrackProv()
{
  ;
}

//----- (000000018006CA98) ----------------------------------------------------
char *__fastcall _bstr_t::Data_t::GetString(_bstr_t::Data_t *this)
{
  char *result; // rax
  void **pExceptionObject; // [rsp+20h] [rbp-28h] BYREF
  int v4; // [rsp+28h] [rbp-20h]
  __int128 v5; // [rsp+30h] [rbp-18h]

  result = (char *)*((_QWORD *)this + 1);
  if ( !result )
  {
    result = _com_util::ConvertBSTRToString(*(LPCWCH *)this);
    *((_QWORD *)this + 1) = result;
    if ( !result )
    {
      if ( *(_QWORD *)this )
      {
        v4 = -2147024882;
        pExceptionObject = &_com_error::`vftable';
        v5 = 0LL;
        CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI1_AV_com_error__);
      }
    }
  }
  return result;
}
// 180071858: using guessed type void *_com_error::`vftable';

//----- (000000018006CAFC) ----------------------------------------------------
void __fastcall __noreturn tsched::KnownExceptionToHResult(tsched *this, char *a2, __int64 a3, char *a4)
{
  CxxThrowException_0(0LL, 0LL);
}
// 18006CAFC: could not find valid save-restore pair for rbx
// 18006CAFC: could not find valid save-restore pair for rbp

//----- (000000018006CD3C) ----------------------------------------------------
__int64 __fastcall tsched::SetJobFileSecurityByName(
        wchar_t *String2,
        const unsigned __int16 *a2,
        const WCHAR *a3,
        const unsigned __int16 *a4)
{
  signed int v5; // eax
  unsigned int LastHrError; // ebx
  SECURITY_INFORMATION v7; // edi
  unsigned int v8; // ebx
  HANDLE CurrentThread; // rax
  signed int LastError; // eax
  __int64 FileSafe; // rax
  tsched *v12; // rcx
  HANDLE v13; // r12
  signed int v14; // eax
  __int64 v15; // rdx
  __int64 v16; // r8
  int v17; // eax
  struct _SECURITY_ATTRIBUTES *PreviousState; // [rsp+20h] [rbp-89h]
  PTOKEN_PRIVILEGES PreviousStatea; // [rsp+20h] [rbp-89h]
  WORD pControl[2]; // [rsp+50h] [rbp-59h] BYREF
  WINBOOL bOwnerDefaulted; // [rsp+54h] [rbp-55h] BYREF
  WINBOOL bDaclPresent; // [rsp+58h] [rbp-51h] BYREF
  PSECURITY_DESCRIPTOR SecurityDescriptor; // [rsp+60h] [rbp-49h] BYREF
  PSID pGroup; // [rsp+68h] [rbp-41h] BYREF
  PSID pOwner; // [rsp+70h] [rbp-39h] BYREF
  void *TokenHandle; // [rsp+78h] [rbp-31h] BYREF
  ULONG SecurityDescriptorSize; // [rsp+80h] [rbp-29h] BYREF
  PACL pSacl; // [rsp+88h] [rbp-21h] BYREF
  PACL pDacl; // [rsp+90h] [rbp-19h] BYREF
  HANDLE handle[2]; // [rsp+98h] [rbp-11h] BYREF
  DWORD dwRevision; // [rsp+A8h] [rbp-1h] BYREF
  struct _TOKEN_PRIVILEGES NewState; // [rsp+B0h] [rbp+7h] BYREF

  SecurityDescriptor = 0LL;
  SecurityDescriptorSize = 0;
  if ( ConvertStringSecurityDescriptorToSecurityDescriptorW(a3, 1u, &SecurityDescriptor, &SecurityDescriptorSize) )
  {
    bDaclPresent = 0;
    v7 = 0;
    bOwnerDefaulted = 1;
    pOwner = 0LL;
    v8 = 917504;
    pGroup = 0LL;
    pDacl = 0LL;
    pSacl = 0LL;
    pControl[0] = 0;
    GetSecurityDescriptorControl(SecurityDescriptor, pControl, &dwRevision);
    if ( GetSecurityDescriptorOwner(SecurityDescriptor, &pOwner, &bOwnerDefaulted) )
      v7 = pOwner != 0LL;
    if ( GetSecurityDescriptorGroup(SecurityDescriptor, &pGroup, &bOwnerDefaulted) && pGroup )
      v7 |= 2u;
    if ( GetSecurityDescriptorDacl(SecurityDescriptor, &bDaclPresent, &pDacl, &bOwnerDefaulted) && bDaclPresent )
    {
      if ( (pControl[0] & 0x1000) != 0 )
        v7 |= 0x80000004;
      else
        v7 |= 0x20000004u;
    }
    TokenHandle = 0LL;
    NewState = 0LL;
    if ( GetSecurityDescriptorSacl(SecurityDescriptor, &bDaclPresent, &pSacl, &bOwnerDefaulted) && bDaclPresent )
    {
      CurrentThread = GetCurrentThread();
      if ( OpenThreadToken(CurrentThread, 0x28u, 1, &TokenHandle) )
      {
        handle[0] = (HANDLE)8;
        NewState.Privileges[0].Luid = (LUID)8LL;
        NewState.PrivilegeCount = 1;
        NewState.Privileges[0].Attributes = 2;
        if ( !AdjustTokenPrivileges(TokenHandle, 0, &NewState, 0, 0LL, 0LL) )
        {
          LastError = GetLastError();
          LastHrError = LastError;
          if ( LastError > 0 )
            LastHrError = (unsigned __int16)LastError | 0x80070000;
          if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
            && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) != 0
            && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
          {
            WPP_SF_D(
              *((_QWORD *)WPP_GLOBAL_Control + 2),
              0xAu,
              (__int64)&WPP_cb202d2a42b13414d5ff4ecf77487b4e_Traceguids,
              LastHrError);
          }
LABEL_49:
          wmi::AutoHandle::Close(&TokenHandle);
          goto LABEL_50;
        }
      }
      v8 = 17694720;
      if ( (pControl[0] & 0x2000) != 0 )
        v7 |= 0x40000008u;
      else
        v7 |= 0x10000008u;
    }
    LODWORD(PreviousState) = 3;
    *(_OWORD *)handle = 0LL;
    FileSafe = tsched::CreateFileSafe(String2, (const unsigned __int16 *)v8, 1u, 0LL, PreviousState, 0x2000000u);
    tsched::JobsAutoHandle::operator=((tsched::JobsAutoHandle *)handle, FileSafe);
    v12 = (tsched *)WPP_GLOBAL_Control;
    v13 = handle[0];
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
    {
      WPP_SF_Sq(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0xBu,
        (__int64)&WPP_cb202d2a42b13414d5ff4ecf77487b4e_Traceguids,
        String2);
    }
    if ( v13 == (HANDLE)-1LL )
    {
      LastHrError = tsched::GetLastHrError(v12);
    }
    else
    {
      handle[1] = String2;
      v14 = SetSecurityInfo(v13, SE_FILE_OBJECT, v7, pOwner, pGroup, pDacl, pSacl);
      LastHrError = v14;
      if ( v14 > 0 )
        LastHrError = (unsigned __int16)v14 | 0x80070000;
      if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
        && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) != 0
        && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 4u )
      {
        LODWORD(PreviousStatea) = v7;
        WPP_SF_qDqqqqD(
          *((_QWORD *)WPP_GLOBAL_Control + 2),
          v15,
          v16,
          v13,
          PreviousStatea,
          pOwner,
          pGroup,
          pDacl,
          pSacl,
          LastHrError);
      }
      if ( TokenHandle )
      {
        if ( NewState.PrivilegeCount )
        {
          NewState.Privileges[0].Attributes = 0;
          if ( !AdjustTokenPrivileges(TokenHandle, 0, &NewState, 0, 0LL, 0LL) )
          {
            v17 = GetLastError();
            if ( v17 > 0 )
              v17 = (unsigned __int16)v17 | 0x80070000;
            if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
              && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) != 0
              && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
            {
              WPP_SF_D(
                *((_QWORD *)WPP_GLOBAL_Control + 2),
                0xDu,
                (__int64)&WPP_cb202d2a42b13414d5ff4ecf77487b4e_Traceguids,
                v17);
            }
          }
        }
      }
    }
    tsched::JobsAutoHandle::Close((tsched::JobsAutoHandle *)handle);
    goto LABEL_49;
  }
  v5 = GetLastError();
  LastHrError = v5;
  if ( v5 > 0 )
    LastHrError = (unsigned __int16)v5 | 0x80070000;
LABEL_50:
  tsched::AutoLocalPtr<unsigned short>::~AutoLocalPtr<unsigned short>(&SecurityDescriptor);
  return LastHrError;
}
// 18006CFD6: variable 'PreviousState' is possibly undefined
// 18006D033: variable 'v12' is possibly undefined
// 18006D0D4: variable 'v15' is possibly undefined
// 18006D0D4: variable 'v16' is possibly undefined
// 18006D0D4: variable 'PreviousStatea' is possibly undefined
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;
// 18006CD3C: using guessed type WORD pControl[2];

//----- (000000018006D1A0) ----------------------------------------------------
__int64 WPP_SF_qDqqqqD(__int64 a1, __int64 a2, __int64 a3, ...)
{
  va_list va; // [rsp+C8h] [rbp+20h] BYREF

  va_start(va, a3);
  return EtwTraceMessage(a1, 43LL, &WPP_cb202d2a42b13414d5ff4ecf77487b4e_Traceguids, 12LL, (__int64 *)va);
}
// 1800747B0: using guessed type __int64 __fastcall EtwTraceMessage(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000018006D240) ----------------------------------------------------
ATL::CAtlStringMgr *__fastcall ATL::CAtlStringMgr::`scalar deleting destructor'(ATL::CAtlStringMgr *this, char a2)
{
  *(_QWORD *)this = &ATL::CAtlStringMgr::`vftable';
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}
// 180071800: using guessed type void *ATL::CAtlStringMgr::`vftable';

//----- (000000018006D270) ----------------------------------------------------
ATL::CWin32Heap *__fastcall ATL::CWin32Heap::`vector deleting destructor'(ATL::CWin32Heap *this, char a2)
{
  ATL::CWin32Heap::~CWin32Heap(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (000000018006D2B0) ----------------------------------------------------
SIZE_T __fastcall ATL::CWin32Heap::GetSize(HANDLE *this, void *a2)
{
  return HeapSize(this[1], 0, a2);
}

//----- (000000018006D2D0) ----------------------------------------------------
struct ATL::CStringData *__fastcall ATL::CAtlStringMgr::Reallocate(
        ATL::CAtlStringMgr *this,
        struct ATL::CStringData *a2,
        int a3,
        unsigned int a4)
{
  unsigned int v5; // ebx
  unsigned __int64 v6; // rcx
  struct ATL::CStringData *result; // rax

  if ( a3 < 0 )
    return 0LL;
  if ( 0x7FFFFFFF - a3 < 1 )
    return 0LL;
  v5 = (a3 + 8) & 0xFFFFFFF8;
  if ( a3 >= (int)v5 )
    return 0LL;
  v6 = a4 * (unsigned __int64)v5;
  if ( v6 > 0xFFFFFFFF )
    return 0LL;
  if ( (unsigned int)v6 > 0xFFFFFFE7 )
    return 0LL;
  result = (struct ATL::CStringData *)(*(__int64 (__fastcall **)(_QWORD, struct ATL::CStringData *, _QWORD))(**((_QWORD **)this + 1) + 16LL))(
                                        *((_QWORD *)this + 1),
                                        a2,
                                        (unsigned int)(v6 + 24));
  if ( !result )
    return 0LL;
  *((_DWORD *)result + 3) = v5 - 1;
  return result;
}

//----- (000000018006D340) ----------------------------------------------------
LPVOID __fastcall ATL::CWin32Heap::Reallocate(HANDLE *this, void *a2, SIZE_T a3)
{
  if ( !a2 )
    return (LPVOID)(*(__int64 (__fastcall **)(HANDLE *, SIZE_T))*this)(this, a3);
  if ( a3 )
    return HeapReAlloc(this[1], 0, a2, a3);
  (*((void (__fastcall **)(HANDLE *))*this + 1))(this);
  return 0LL;
}

//----- (000000018006D39C) ----------------------------------------------------
void __fastcall __noreturn _com_issue_error(int a1)
{
  void **pExceptionObject; // [rsp+20h] [rbp-28h] BYREF
  int v2; // [rsp+28h] [rbp-20h]
  __int128 v3; // [rsp+30h] [rbp-18h]

  v2 = a1;
  pExceptionObject = &_com_error::`vftable';
  v3 = 0LL;
  CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI1_AV_com_error__);
}
// 180071858: using guessed type void *_com_error::`vftable';

//----- (000000018006D3D4) ----------------------------------------------------
char *__fastcall _com_util::ConvertBSTRToString(LPCWCH lpWideCharStr)
{
  __int64 v3; // rax
  int v4; // eax
  int cbMultiByte; // esi
  CHAR *lpMultiByteStr; // rax
  CHAR *v7; // rdi
  signed int LastError; // eax
  void **pExceptionObject; // [rsp+40h] [rbp-28h] BYREF
  int v10; // [rsp+48h] [rbp-20h]
  __int128 v11; // [rsp+50h] [rbp-18h]

  if ( !lpWideCharStr )
    return 0LL;
  v3 = -1LL;
  do
    ++v3;
  while ( lpWideCharStr[v3] );
  v4 = 2 * v3;
  cbMultiByte = v4 + 2;
  lpMultiByteStr = (CHAR *)operator new(v4 + 2LL);
  v7 = lpMultiByteStr;
  if ( !lpMultiByteStr )
  {
    v10 = -2147024882;
    pExceptionObject = &_com_error::`vftable';
    v11 = 0LL;
    CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI1_AV_com_error__);
  }
  *lpMultiByteStr = 0;
  if ( !WideCharToMultiByte(0, 0, lpWideCharStr, -1, lpMultiByteStr, cbMultiByte, 0LL, 0LL) )
  {
    LastError = GetLastError();
    if ( LastError > 0 )
      LastError = (unsigned __int16)LastError | 0x80070000;
    v10 = LastError;
    pExceptionObject = &_com_error::`vftable';
    v11 = 0LL;
    CxxThrowException_0(&pExceptionObject, (_ThrowInfo *)&TI1_AV_com_error__);
  }
  return v7;
}
// 180071858: using guessed type void *_com_error::`vftable';

//----- (000000018006D4E4) ----------------------------------------------------
_com_error *__fastcall _com_error::_com_error(_com_error *this, const struct _com_error *a2)
{
  __int64 v3; // rcx

  *(_QWORD *)this = &_com_error::`vftable';
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  v3 = *((_QWORD *)a2 + 2);
  *((_QWORD *)this + 3) = 0LL;
  *((_QWORD *)this + 2) = v3;
  if ( v3 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v3 + 8LL))(v3);
  return this;
}
// 180071858: using guessed type void *_com_error::`vftable';

//----- (000000018006D52C) ----------------------------------------------------
void __fastcall _com_error::~_com_error(_com_error *this)
{
  __int64 v2; // rcx
  void *v3; // rcx

  *(_QWORD *)this = &_com_error::`vftable';
  v2 = *((_QWORD *)this + 2);
  if ( v2 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v2 + 16LL))(v2);
  v3 = (void *)*((_QWORD *)this + 3);
  if ( v3 )
    LocalFree(v3);
}
// 180071858: using guessed type void *_com_error::`vftable';

//----- (000000018006D580) ----------------------------------------------------
_com_error *__fastcall _com_error::`scalar deleting destructor'(_com_error *this, char a2)
{
  _com_error::~_com_error(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (000000018006D5B8) ----------------------------------------------------
__int64 __fastcall TaskXmlWriter::ElementLogonType(__int64 a1, int a2, int a3)
{
  int v3; // r8d
  const unsigned __int16 *v5; // r8

  v3 = a3 & 0xFC000;
  switch ( v3 )
  {
    case 0x4000:
      v5 = L"S4U";
      break;
    case 0x10000:
      v5 = L"InteractiveToken";
      break;
    case 0x40000:
      v5 = L"Password";
      break;
    case 0x80000:
      v5 = L"InteractiveTokenOrPassword";
      break;
    default:
      return 2147942487LL;
  }
  return TaskXmlWriter::Element(a1, a2, (__int64)v5);
}

//----- (000000018006D618) ----------------------------------------------------
__int64 __fastcall TaskXmlWriter::ElementLogonType(__int64 a1, __int64 a2, int a3)
{
  int v3; // r8d
  int v4; // r8d
  int v5; // r8d
  const unsigned __int16 *v7; // r8

  v3 = a3 - 1;
  if ( v3 )
  {
    v4 = v3 - 1;
    if ( v4 )
    {
      v5 = v4 - 1;
      if ( v5 )
      {
        if ( v5 != 3 )
          return 2147942487LL;
        v7 = L"InteractiveTokenOrPassword";
      }
      else
      {
        v7 = L"InteractiveToken";
      }
    }
    else
    {
      v7 = L"S4U";
    }
  }
  else
  {
    v7 = L"Password";
  }
  return TaskXmlWriter::Element(a1, 100, (__int64)v7);
}

//----- (000000018006D66C) ----------------------------------------------------
__int64 __fastcall TaskXmlWriter::ElementProcessTokenSidType(__int64 a1, int a2, int a3)
{
  const unsigned __int16 *v4; // r8

  if ( a3 )
  {
    if ( a3 != 1 )
      return 2147942487LL;
    v4 = L"Unrestricted";
  }
  else
  {
    v4 = L"None";
  }
  return TaskXmlWriter::Element(a1, a2, (__int64)v4);
}

//----- (000000018006D69C) ----------------------------------------------------
__int64 __fastcall TaskXmlWriter::ElementWithAttribute(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  int v7; // edx
  const struct SchemaEntry * near *Entry; // rsi
  __int64 result; // rax
  __int64 v10; // rax
  const struct SchemaEntry * near *v11; // rax
  __int64 v12; // r11
  __int64 v13; // rax

  Entry = Schema::GetEntry((int *)a1, 33);
  if ( !*(_DWORD *)Entry )
    return (unsigned int)(v7 - 32);
  v10 = _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::operator->((__int64 *)(a1 + 16));
  result = (*(__int64 (__fastcall **)(__int64, const WCHAR *, const struct SchemaEntry *, wchar_t *const))(*(_QWORD *)v10 + 216LL))(
             v10,
             &ChannelPath,
             Entry[1],
             Schema::namespaceUri);
  if ( (int)result >= 0 )
  {
    if ( !*(_DWORD *)Schema::GetEntry((int *)a1, 34)
      || !a5
      || (_com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::operator->((__int64 *)(a1 + 16)),
          v11 = Schema::GetEntry((int *)a1, 34),
          result = (*(__int64 (__fastcall **)(__int64, const WCHAR *, const struct SchemaEntry *, _QWORD, __int64))(*(_QWORD *)v12 + 56LL))(
                     v12,
                     &ChannelPath,
                     v11[1],
                     0LL,
                     a5),
          (int)result >= 0) )
    {
      if ( !a3 )
        return TaskXmlWriter::EndElement(a1);
      v13 = _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::operator->((__int64 *)(a1 + 16));
      result = (*(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v13 + 224LL))(v13, a3);
      if ( (int)result >= 0 )
        return TaskXmlWriter::EndElement(a1);
    }
  }
  return result;
}
// 18006D6C8: variable 'v7' is possibly undefined
// 18006D740: variable 'v12' is possibly undefined

//----- (000000018006D7B8) ----------------------------------------------------
__int64 __fastcall TaskXmlWriter::SectionDaysOfMonth(TaskXmlWriter *this, int a2)
{
  __int64 result; // rax
  int v5; // esi
  unsigned int v6; // ebx

  result = TaskXmlWriter::StartElement((int *)this, 67);
  if ( (int)result >= 0 )
  {
    v5 = 1;
    v6 = 1;
    while ( 1 )
    {
      if ( (v5 & a2) != 0 )
      {
        result = v6 == 32
               ? TaskXmlWriter::Element((__int64)this, 68, (__int64)L"Last")
               : TaskXmlWriter::ElementInt((__int64)this, 68, v6);
        if ( (int)result < 0 )
          break;
      }
      v5 *= 2;
      if ( (int)++v6 > 32 )
        return TaskXmlWriter::EndElement((__int64)this);
    }
  }
  return result;
}

//----- (000000018006D840) ----------------------------------------------------
__int64 __fastcall TaskXmlWriter::SectionDaysOfWeek(TaskXmlWriter *this, unsigned __int16 a2)
{
  __int64 result; // rax
  int v5; // edi
  int *i; // rbx

  result = TaskXmlWriter::StartElement((int *)this, 44);
  if ( (int)result >= 0 )
  {
    v5 = 0;
    for ( i = (int *)&unk_180080F3C; ; i += 2 )
    {
      if ( (*(_WORD *)(i - 1) & a2) != 0 )
      {
        result = TaskXmlWriter::Element((__int64)this, *i, 0LL);
        if ( (int)result < 0 )
          break;
      }
      if ( (unsigned int)++v5 >= 7 )
        return TaskXmlWriter::EndElement((__int64)this);
    }
  }
  return result;
}

//----- (000000018006D8B8) ----------------------------------------------------
__int64 __fastcall TaskXmlWriter::SectionMonths(TaskXmlWriter *this, unsigned __int16 a2)
{
  __int64 result; // rax
  int v5; // edi
  int *i; // rbx

  result = TaskXmlWriter::StartElement((int *)this, 53);
  if ( (int)result >= 0 )
  {
    v5 = 0;
    for ( i = (int *)&unk_180080F74; ; i += 2 )
    {
      if ( (*(_WORD *)(i - 1) & a2) != 0 )
      {
        result = TaskXmlWriter::Element((__int64)this, *i, 0LL);
        if ( (int)result < 0 )
          break;
      }
      if ( (unsigned int)++v5 >= 0xC )
        return TaskXmlWriter::EndElement((__int64)this);
    }
  }
  return result;
}

//----- (000000018006D930) ----------------------------------------------------
__int64 __fastcall TaskXmlWriter::SectionWeeks(TaskXmlWriter *this, int a2)
{
  __int64 result; // rax
  int v5; // esi
  unsigned int v6; // ebx

  result = TaskXmlWriter::StartElement((int *)this, 69);
  if ( (int)result >= 0 )
  {
    v5 = 1;
    v6 = 1;
    while ( 1 )
    {
      if ( (v5 & a2) != 0 )
      {
        result = v6 == 5
               ? TaskXmlWriter::Element((__int64)this, 70, (__int64)L"Last")
               : TaskXmlWriter::ElementInt((__int64)this, 70, v6);
        if ( (int)result < 0 )
          break;
      }
      v5 *= 2;
      if ( (int)++v6 > 5 )
        return TaskXmlWriter::EndElement((__int64)this);
    }
  }
  return result;
}

//----- (000000018006D9B8) ----------------------------------------------------
__int64 __fastcall TaskXmlWriter::WriteStringValue(TaskXmlWriter *this, const unsigned __int16 *a2)
{
  __int64 v3; // rax

  v3 = _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::operator->((__int64 *)this + 2);
  return (*(__int64 (__fastcall **)(__int64, const unsigned __int16 *))(*(_QWORD *)v3 + 224LL))(v3, a2);
}

//----- (000000018006D9F0) ----------------------------------------------------
__int64 __fastcall _Seek__QIStream__StringReader__EEAAJT_LARGE_INTEGER__KPEAT_ULARGE_INTEGER___Z(
        __int64 a1,
        __int64 a2,
        int a3,
        _QWORD *a4)
{
  if ( a3 || a2 )
    return 2147500033LL;
  *(_QWORD *)(a1 + 16) = -1LL;
  if ( a4 )
    *a4 = 0LL;
  return 0LL;
}

//----- (000000018006DA18) ----------------------------------------------------
void __fastcall ITaskXmlHandler::Data::~Data(void **this)
{
  operator delete(this[7]);
}

//----- (000000018006DA28) ----------------------------------------------------
void __fastcall tsched::LibLock::~LibLock(HMODULE *this)
{
  HMODULE v1; // rcx

  v1 = *this;
  if ( v1 )
    FreeLibrary(v1);
}

//----- (000000018006DA4C) ----------------------------------------------------
__int64 __fastcall TaskXmlReader::LoadDayOfMonth(TaskXmlReader *this, unsigned __int16 *a2)
{
  const wchar_t **v2; // rdi
  __int64 result; // rax
  int v6; // ebx
  unsigned __int16 v7; // ax

  v2 = (const wchar_t **)((char *)this + 64);
  result = TaskXmlReader::LoadRawValue(this, (TaskXmlReader *)((char *)this + 64));
  if ( (int)result >= 0 )
  {
    if ( XmlParserTempString::IsEqualTo(v2, L"Last", 4uLL) )
    {
      *a2 = 32;
      return 0LL;
    }
    else
    {
      *a2 = 0;
      v6 = 0;
      if ( *(_DWORD *)v2 )
      {
        while ( iswdigit(*(_WORD *)(*((_QWORD *)this + 9) + 2LL * v6)) )
        {
          v7 = 10 * *a2 - 48 + *(_WORD *)(*((_QWORD *)this + 9) + 2LL * v6);
          *a2 = v7;
          if ( v7 > 0x1Fu )
            break;
          if ( (unsigned int)++v6 >= *(_DWORD *)v2 )
          {
            if ( !v7 )
              return 2147750680LL;
            return 0LL;
          }
        }
      }
      return 2147750680LL;
    }
  }
  return result;
}

//----- (000000018006DB28) ----------------------------------------------------
__int64 __fastcall TaskXmlReader::LoadPrivilege(const WCHAR **this, unsigned __int64 *a2)
{
  __int64 result; // rax
  const WCHAR *v5; // rcx
  struct _LUID Luid; // [rsp+30h] [rbp+8h] BYREF

  *a2 = 0LL;
  result = TaskXmlReader::LoadRawValue((TaskXmlReader *)this, (struct XmlParserTempString *)(this + 8));
  if ( (int)result >= 0 )
  {
    if ( *((_DWORD *)this + 16) && (v5 = this[9], Luid = 0LL, (unsigned int)User::LookupPrivilege(v5, &Luid)) )
    {
      *a2 = 1LL << SLOBYTE(Luid.LowPart);
      return 0LL;
    }
    else
    {
      return 2147750680LL;
    }
  }
  return result;
}

//----- (000000018006DB9C) ----------------------------------------------------
__int64 __fastcall TaskXmlReader::LoadProcessTokenSidType(TaskXmlReader *this, enum JobFlags::JobFlag *a2)
{
  const wchar_t **v2; // rbx
  __int64 result; // rax
  int v5; // eax

  *(_DWORD *)a2 = 0;
  v2 = (const wchar_t **)((char *)this + 64);
  result = TaskXmlReader::LoadRawValue(this, (TaskXmlReader *)((char *)this + 64));
  if ( (int)result >= 0 )
  {
    if ( *(_DWORD *)v2 )
    {
      if ( XmlParserTempString::IsEqualTo(v2, L"None", 4uLL) )
      {
        v5 = 0x8000000;
LABEL_7:
        *(_DWORD *)a2 = v5;
        return 0LL;
      }
      if ( XmlParserTempString::IsEqualTo(v2, L"Unrestricted", 0xCuLL) )
      {
        v5 = 0x10000000;
        goto LABEL_7;
      }
    }
    return 2147750680LL;
  }
  return result;
}

//----- (000000018006DC1C) ----------------------------------------------------
__int64 __fastcall TaskXmlReader::LoadWeek(TaskXmlReader *this, unsigned __int16 *a2)
{
  const wchar_t **v2; // rdi
  __int64 result; // rax
  unsigned __int16 v5; // ax

  v2 = (const wchar_t **)((char *)this + 64);
  result = TaskXmlReader::LoadRawValue(this, (TaskXmlReader *)((char *)this + 64));
  if ( (int)result >= 0 )
  {
    if ( XmlParserTempString::IsEqualTo(v2, L"1", 1uLL) )
    {
      *a2 = 1;
      return 0LL;
    }
    if ( XmlParserTempString::IsEqualTo(v2, L"2", 1uLL) )
    {
      v5 = 2;
LABEL_12:
      *a2 = v5;
      return 0LL;
    }
    if ( XmlParserTempString::IsEqualTo(v2, L"3", 1uLL) )
    {
      v5 = 3;
      goto LABEL_12;
    }
    if ( XmlParserTempString::IsEqualTo(v2, L"4", 1uLL) )
    {
      *a2 = 4;
      return 0LL;
    }
    if ( XmlParserTempString::IsEqualTo(v2, L"Last", 4uLL) )
    {
      v5 = 5;
      goto LABEL_12;
    }
    return 2147750680LL;
  }
  return result;
}

//----- (000000018006DCFC) ----------------------------------------------------
__int64 __fastcall TaskXmlReader::SetErrorInfo(
        TaskXmlReader *this,
        int a2,
        char *a3,
        unsigned int a4,
        unsigned __int16 *a5,
        unsigned int a6)
{
  unsigned __int64 v6; // r13
  __int64 *v9; // rbx
  __int64 v11; // rax
  __int64 v12; // rax
  unsigned int v13; // esi
  unsigned int v14; // eax
  unsigned int v15; // r12d
  void *v16; // rcx
  __int64 v17; // rbx
  char *v18; // rcx
  char *v19; // rcx
  int v20; // [rsp+48h] [rbp-48h] BYREF
  int v21; // [rsp+4Ch] [rbp-44h] BYREF
  unsigned int v22; // [rsp+50h] [rbp-40h]
  int v23; // [rsp+54h] [rbp-3Ch]
  __int64 v24; // [rsp+58h] [rbp-38h]

  v24 = -2LL;
  v6 = a4;
  if ( a2 < 0 && *((_QWORD *)this + 6) )
  {
    v23 = 0;
    v9 = (__int64 *)((char *)this + 56);
    if ( !*((_QWORD *)this + 7) )
      return (unsigned int)a2;
    v21 = 0;
    v20 = 0;
    v11 = _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::operator->((__int64 *)this + 7);
    (*(void (__fastcall **)(__int64, int *))(*(_QWORD *)v11 + 168LL))(v11, &v21);
    v12 = _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::operator->(v9);
    (*(void (__fastcall **)(__int64, int *))(*(_QWORD *)v12 + 176LL))(v12, &v20);
    ++v20;
    if ( (_DWORD)v6 )
      v13 = (2 * v6 + 9) & 0xFFFFFFF8;
    else
      v13 = 0;
    if ( a6 )
      v14 = (2 * a6 + 9) & 0xFFFFFFF8;
    else
      v14 = 0;
    v22 = v13 + v14;
    v15 = v13 + v14 + 24;
    v16 = (void *)**((_QWORD **)this + 6);
    if ( v16 )
      operator delete(v16);
    **((_QWORD **)this + 6) = operator new(v15);
    memset_0(**((void ***)this + 6), 0, v15);
    v17 = **((_QWORD **)this + 6);
    *(_DWORD *)v17 = v21;
    *(_DWORD *)(v17 + 4) = v20;
    if ( a3 && (_DWORD)v6 )
    {
      v18 = (char *)(**((_QWORD **)this + 6) + 24LL);
      *(_QWORD *)(v17 + 8) = v18;
      StringCchCopyNW(v18, (unsigned __int64)v22 >> 1, a3, v6);
    }
    if ( a5 )
    {
      if ( a6 )
      {
        v19 = (char *)(**((_QWORD **)this + 6) + 24LL + v13);
        *(_QWORD *)(v17 + 16) = v19;
        StringCchCopyNW(v19, (unsigned __int64)(v15 - v13 - 24) >> 1, (char *)a5, a6);
      }
    }
  }
  return (unsigned int)a2;
}
// 18006DCFC: could not find valid save-restore pair for rbp

//----- (000000018006DEE8) ----------------------------------------------------
__int64 __fastcall TaskXmlReader::SetErrorInfo(int *a1, int a2, int a3)
{
  unsigned int v3; // r9d
  char *v4; // r8
  const struct SchemaEntry * near *Entry; // rax
  int v6; // r11d
  int *v7; // r10

  if ( a3 )
  {
    Entry = Schema::GetEntry(a1 + 279, a3);
    a2 = v6;
    a1 = v7;
    v3 = *((_DWORD *)Entry + 4);
    v4 = (char *)Entry[1];
  }
  else
  {
    v3 = 0;
    v4 = 0LL;
  }
  return TaskXmlReader::SetErrorInfo((TaskXmlReader *)a1, a2, v4, v3, 0LL, 0);
}
// 18006DF0E: variable 'v6' is possibly undefined
// 18006DF11: variable 'v7' is possibly undefined

//----- (000000018006DF38) ----------------------------------------------------
__int64 __fastcall TaskXmlReader::SetErrorInfo(int *a1, int a2, int a3, __int64 a4)
{
  const struct SchemaEntry * near *Entry; // rax
  __int64 v7; // r10
  TaskXmlReader *v8; // r11

  if ( !a3 )
    return TaskXmlReader::SetErrorInfo((TaskXmlReader *)a1, a2, 0LL, 0, *(unsigned __int16 **)(a4 + 8), *(_DWORD *)a4);
  Entry = Schema::GetEntry(a1 + 279, a3);
  return TaskXmlReader::SetErrorInfo(
           v8,
           a2,
           (char *)Entry[1],
           *((_DWORD *)Entry + 4),
           *(unsigned __int16 **)(v7 + 8),
           *(_DWORD *)v7);
}
// 18006DF92: variable 'v8' is possibly undefined
// 18006DF72: variable 'v7' is possibly undefined

//----- (000000018006DFA4) ----------------------------------------------------
__int64 __fastcall TaskXmlReader::SetErrorInfoXmlLite(TaskXmlReader *this, int a2)
{
  __int64 v4; // rax
  _DWORD *v5; // rcx
  UINT v6; // edi
  int StringW; // eax
  unsigned __int16 *v8; // rdi
  __int64 v9; // rax
  _DWORD *v10; // rcx
  __int64 v11; // rax
  HMODULE phModule; // [rsp+30h] [rbp-228h] BYREF
  WCHAR Buffer[256]; // [rsp+40h] [rbp-218h] BYREF

  if ( (unsigned int)(a2 + 1072894464) > 0x1FF )
    return TaskXmlReader::SetErrorInfo(this, a2, 0LL, 0, 0LL, 0);
  memset_0(Buffer, 0, sizeof(Buffer));
  v4 = 0LL;
  v5 = dword_1800822B0;
  while ( a2 != *v5 )
  {
    v4 = (unsigned int)(v4 + 1);
    v5 += 2;
    if ( (unsigned int)v4 >= 0x3C )
      goto LABEL_10;
  }
  v6 = dword_1800822B0[2 * v4 + 1];
  if ( GetModuleHandleExW(4u, &_ImageBase, &phModule) )
  {
    StringW = LoadStringW(phModule, v6, Buffer, 256);
    v8 = Buffer;
    if ( !StringW )
      v8 = 0LL;
    FreeLibrary(phModule);
    if ( v8 )
      goto LABEL_16;
  }
LABEL_10:
  v9 = 0LL;
  v10 = &unk_180073870;
  while ( a2 != *v10 )
  {
    v9 = (unsigned int)(v9 + 1);
    v10 += 4;
    if ( (unsigned int)v9 >= 0x3C )
    {
      v8 = 0LL;
      goto LABEL_15;
    }
  }
  v8 = (unsigned __int16 *)*((_QWORD *)&unk_180073870 + 2 * v9 + 1);
LABEL_15:
  if ( !v8 )
  {
    LODWORD(v11) = 0;
    return TaskXmlReader::SetErrorInfo(this, -2147216614, 0LL, 0, v8, v11);
  }
LABEL_16:
  v11 = -1LL;
  do
    ++v11;
  while ( v8[v11] );
  return TaskXmlReader::SetErrorInfo(this, -2147216614, 0LL, 0, v8, v11);
}
// 1800822B0: using guessed type _DWORD dword_1800822B0[120];

//----- (000000018006E110) ----------------------------------------------------
__int64 __fastcall TaskXmlReader::SkipElement(TaskXmlReader *this)
{
  int v2; // ebx
  __int64 v3; // rax
  int v4; // eax
  __int64 v6; // rax
  int v7; // [rsp+30h] [rbp+8h] BYREF

  v2 = 1;
  while ( 1 )
  {
    v3 = _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::operator->((__int64 *)this + 7);
    v4 = (*(__int64 (__fastcall **)(__int64, int *))(*(_QWORD *)v3 + 48LL))(v3, &v7);
    if ( v4 )
      break;
    if ( v7 == 1 )
    {
      v6 = _com_ptr_t<_com_IIID<IXmlReader,&__s_GUID const _GUID_7279fc81_709d_4095_b63d_69fe4b0d9030>>::operator->((__int64 *)this + 7);
      if ( !(*(unsigned int (__fastcall **)(__int64))(*(_QWORD *)v6 + 160LL))(v6) )
        ++v2;
    }
    else if ( v7 == 15 && !--v2 )
    {
      return 0LL;
    }
  }
  if ( v4 >= 0 )
    return 0LL;
  return TaskXmlReader::SetErrorInfoXmlLite(this, v4);
}

//----- (000000018006E1AC) ----------------------------------------------------
__int64 __fastcall XmlParserTempString::Trim(XmlParserTempString *this)
{
  __int64 result; // rax
  XmlParserTempString *v2; // r11

  if ( !*(_DWORD *)this )
    return 0LL;
  if ( !*((_QWORD *)this + 1) )
    return 0LL;
  result = XmlParserTempString::TrimLeft(this);
  if ( (int)result >= 0 )
  {
    result = XmlParserTempString::TrimRight(v2);
    if ( (int)result >= 0 )
      return 0LL;
  }
  return result;
}
// 18006E1CB: variable 'v2' is possibly undefined

//----- (000000018006E1E4) ----------------------------------------------------
__int64 __fastcall XmlParserTempString::TrimRight(XmlParserTempString *this)
{
  int v1; // eax
  __int64 v2; // r9
  __int64 v3; // rdx
  __int64 v4; // r10

  v1 = *(_DWORD *)this;
  if ( *(_DWORD *)this && *((_QWORD *)this + 1) )
  {
    while ( v1 )
    {
      v2 = *((_QWORD *)this + 1);
      v3 = (unsigned int)(v1 - 1);
      if ( *(_WORD *)(v2 + 2 * v3) > 0x20u )
        break;
      v4 = 0x100002600LL;
      if ( !_bittest64(&v4, *(unsigned __int16 *)(v2 + 2 * v3)) )
        break;
      *(_DWORD *)this = v3;
      *(_WORD *)(v2 + 2 * v3) = 0;
      v1 = *(_DWORD *)this;
    }
  }
  return 0LL;
}

//----- (000000018006E230) ----------------------------------------------------
__int64 __fastcall IsNetworkAvailable(struct _GUID *a1)
{
  unsigned __int64 v2; // rcx
  int v4; // ebx
  __int64 v5; // rcx
  __int64 v6; // [rsp+30h] [rbp-30h] BYREF
  char v7[8]; // [rsp+38h] [rbp-28h] BYREF
  __int64 v8; // [rsp+40h] [rbp-20h]
  LPVOID ppv[2]; // [rsp+48h] [rbp-18h] BYREF

  v8 = -2LL;
  *(_OWORD *)ppv = 0LL;
  v2 = *(_QWORD *)&a1->Data1;
  if ( !v2 )
    v2 = *(_QWORD *)a1->Data4 - (unsigned __int64)ppv[1];
  if ( !v2 )
    return IsNetworkAvailable();
  if ( !IsNetworkServiceRunning() )
    return 1LL;
  ppv[0] = 0LL;
  if ( CoCreateInstance(&CLSID_CNetworkListManager, 0LL, 4u, &IID_INetworkListManagerPrivate, ppv) >= 0 )
  {
    v6 = 0LL;
    v4 = (*(__int64 (__fastcall **)(LPVOID, struct _GUID *, __int64 *))(*(_QWORD *)ppv[0] + 48LL))(ppv[0], a1, &v6);
    if ( v4 >= 0 )
    {
      v5 = v6;
      if ( !v6 )
      {
LABEL_14:
        if ( v5 )
          (*(void (__fastcall **)(__int64))(*(_QWORD *)v5 + 16LL))(v5);
        v6 = 0LL;
        goto LABEL_17;
      }
      v4 = (*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)v6 + 96LL))(v6, v7);
      if ( v4 >= 0 )
      {
        v5 = v6;
        v4 = (v7[0] & 1) == 0;
        goto LABEL_14;
      }
    }
    v5 = v6;
    goto LABEL_14;
  }
  v4 = 0;
LABEL_17:
  if ( ppv[0] )
    (*(void (__fastcall **)(LPVOID))(*(_QWORD *)ppv[0] + 16LL))(ppv[0]);
  return (unsigned int)v4;
}
// 18006E230: using guessed type char var_28[8];

//----- (000000018006E38C) ----------------------------------------------------
__int64 IsNetworkAvailable()
{
  unsigned int v1; // ebx
  int v2; // eax
  __int64 v3; // rcx
  int v4; // eax
  int v5; // [rsp+60h] [rbp+18h] BYREF
  __int64 v6; // [rsp+68h] [rbp+20h] BYREF
  __int64 v7; // [rsp+70h] [rbp+28h] BYREF
  LPVOID ppv; // [rsp+78h] [rbp+30h] BYREF

  if ( !IsNetworkServiceRunning() )
    return 1LL;
  ppv = 0LL;
  if ( CoCreateInstance(&CLSID_CNetworkListManager, 0LL, 4u, &IID_INetworkListManagerPrivate, &ppv) >= 0 )
  {
    v6 = 0LL;
    v1 = 1;
    v2 = (*(__int64 (__fastcall **)(LPVOID, __int64, __int64 *))(*(_QWORD *)ppv + 32LL))(ppv, 1LL, &v6);
    v3 = v6;
    if ( v2 >= 0 && v6 )
    {
      v7 = 0LL;
      v4 = (*(__int64 (__fastcall **)(__int64, __int64, __int64 *, int *))(*(_QWORD *)v6 + 24LL))(v6, 1LL, &v7, &v5);
      if ( v4 < 0 || v4 != 1 && v5 )
        v1 = 0;
      if ( v7 )
        (*(void (__fastcall **)(__int64))(*(_QWORD *)v7 + 16LL))(v7);
      v7 = 0LL;
      v3 = v6;
    }
    else
    {
      v1 = 0;
    }
    if ( v3 )
      (*(void (__fastcall **)(__int64))(*(_QWORD *)v3 + 16LL))(v3);
    v6 = 0LL;
  }
  else
  {
    v1 = 0;
  }
  if ( ppv )
    (*(void (__fastcall **)(LPVOID, _QWORD))(*(_QWORD *)ppv + 16LL))(ppv, *(_QWORD *)ppv);
  return v1;
}

//----- (000000018006E4CC) ----------------------------------------------------
bool IsNetworkServiceRunning()
{
  bool v0; // bl
  SC_HANDLE v1; // rax
  SC_HANDLE v2; // rdi
  SC_HANDLE v3; // rax
  SC_HANDLE v4; // rsi
  struct _SERVICE_STATUS ServiceStatus; // [rsp+20h] [rbp-38h] BYREF

  v0 = 0;
  v1 = OpenSCManagerW(0LL, L"ServicesActive", 0x20001u);
  v2 = v1;
  if ( v1 )
  {
    v3 = OpenServiceW(v1, L"netprofm", 4u);
    v4 = v3;
    if ( v3 )
    {
      if ( QueryServiceStatus(v3, &ServiceStatus) )
        v0 = ServiceStatus.dwCurrentState == 4;
      CloseServiceHandle(v4);
    }
    CloseServiceHandle(v2);
  }
  return v0;
}

//----- (000000018006E598) ----------------------------------------------------
signed int __fastcall MarshalCredential(__int64 a1, LPWSTR *a2)
{
  signed int result; // eax
  __int64 Credential; // [rsp+30h] [rbp+8h] BYREF

  Credential = a1;
  if ( CredMarshalCredentialW(UsernameTargetCredential, &Credential, a2) )
    return 0;
  result = GetLastError();
  if ( result > 0 )
    return (unsigned __int16)result | 0x80070000;
  return result;
}

//----- (000000018006E5E8) ----------------------------------------------------
void __fastcall ComHandlerTask::Grip::~Grip(ComHandlerTask::Grip *this)
{
  void *v2; // rcx

  *(_QWORD *)this = &ComHandlerTask::Grip::`vftable';
  v2 = (void *)*((_QWORD *)this + 2);
  if ( v2 )
  {
    CloseHandle(v2);
    *((_QWORD *)this + 2) = -1LL;
  }
  *(_QWORD *)this = &wmi::RefBase::`vftable';
}
// 180070980: using guessed type void *wmi::RefBase::`vftable';
// 180071860: using guessed type void *ComHandlerTask::Grip::`vftable';

//----- (000000018006E630) ----------------------------------------------------
ComHandlerTask::Grip *__fastcall ComHandlerTask::Grip::`vector deleting destructor'(
        ComHandlerTask::Grip *this,
        char a2)
{
  ComHandlerTask::Grip::~Grip(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (000000018006E670) ----------------------------------------------------
struct ComHandlerGrip *__fastcall ComHandlerTask::CreateNewGrip(ComHandlerTask *this)
{
  struct ComHandlerGrip *result; // rax

  result = (struct ComHandlerGrip *)operator new(0x18uLL);
  if ( result )
  {
    *((_QWORD *)result + 2) = 0LL;
    *(_QWORD *)result = &wmi::RefBase::`vftable';
    *(_QWORD *)result = &ComHandlerTask::Grip::`vftable';
    *((_DWORD *)result + 2) = 0;
  }
  return result;
}
// 180070980: using guessed type void *wmi::RefBase::`vftable';
// 180071860: using guessed type void *ComHandlerTask::Grip::`vftable';

//----- (000000018006E6C0) ----------------------------------------------------
__int64 __fastcall ComHandlerTask::Grip::Init(ComHandlerTask::Grip *this, void **a2)
{
  unsigned int v4; // edi
  HANDLE EventW; // rax
  signed int LastError; // eax

  v4 = 0;
  EventW = CreateEventW(0LL, 1, 0, 0LL);
  *((_QWORD *)this + 2) = EventW;
  if ( EventW )
  {
    *a2 = EventW;
  }
  else
  {
    LastError = GetLastError();
    if ( LastError > 0 )
      return (unsigned __int16)LastError | 0x80070000;
    else
      return (unsigned int)LastError;
  }
  return v4;
}

//----- (000000018006E740) ----------------------------------------------------
__int64 __fastcall ComHandlerTask::Grip::Stop(HANDLE *this)
{
  SetEvent(this[2]);
  return 0LL;
}

//----- (000000018006E770) ----------------------------------------------------
__int64 __fastcall ComHandlerTask::Grip::TaskCompleted(ComHandlerTask::Grip *this)
{
  return (*(__int64 (__fastcall **)(ComHandlerTask::Grip *))(*(_QWORD *)this + 24LL))(this);
}

//----- (000000018006E790) ----------------------------------------------------
ComHandlerBase *__fastcall ComHandlerBase::`vector deleting destructor'(ComHandlerBase *this, char a2)
{
  ComHandlerBase::~ComHandlerBase(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (000000018006E7D0) ----------------------------------------------------
__int64 __fastcall ServerXMLUpdateHandler::EnableHandler::EndElement(__int64 a1, const struct Schema *a2, int a3)
{
  if ( !*(_BYTE *)(a1 + 10) )
  {
    if ( a3 == 71 )
    {
      ServerXMLUpdateHandler::WriteEnabled(*(ServerXMLUpdateHandler **)(a1 + 16), a2);
LABEL_7:
      *(_BYTE *)(a1 + 8) = 0;
      return 0LL;
    }
    if ( a3 == 1 )
      ServerXMLUpdateHandler::WriteEnabledAndSettings(*(ServerXMLUpdateHandler **)(a1 + 16), a2);
  }
  if ( a3 == 71 )
    goto LABEL_7;
  return 0LL;
}

//----- (000000018006E824) ----------------------------------------------------
__int64 __fastcall ServerXMLUpdateHandler::NetworkId2Name(
        ServerXMLUpdateHandler *this,
        const struct _GUID *a2,
        _bstr_t::Data_t **a3)
{
  __int64 v5; // rcx
  __int64 v6; // rdx
  int Instance; // ebx
  _QWORD *v8; // rcx
  unsigned __int16 v9; // dx
  __int64 v11; // [rsp+30h] [rbp-40h] BYREF
  LPVOID pv; // [rsp+38h] [rbp-38h] BYREF
  LPVOID ppv[2]; // [rsp+40h] [rbp-30h] BYREF
  __int128 v14; // [rsp+50h] [rbp-20h]

  ppv[1] = (LPVOID)-2LL;
  v14 = 0LL;
  pv = 0LL;
  ppv[0] = 0LL;
  v5 = 0LL;
  v11 = 0LL;
  v6 = *(_QWORD *)&a2->Data1;
  if ( !v6 )
    v6 = *(_QWORD *)a2->Data4 - *((_QWORD *)&v14 + 1);
  if ( !v6 )
  {
    Instance = -2147216616;
    goto LABEL_24;
  }
  Instance = CoCreateInstance(&CLSID_CNetworkListManager, 0LL, 4u, &IID_INetworkListManagerPrivate, ppv);
  if ( Instance < 0 )
  {
    v8 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
      || *((char *)WPP_GLOBAL_Control + 28) >= 0
      || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
    {
      goto LABEL_23;
    }
    v9 = 13;
    goto LABEL_10;
  }
  Instance = (*(__int64 (__fastcall **)(LPVOID, const struct _GUID *, __int64 *))(*(_QWORD *)ppv[0] + 48LL))(
               ppv[0],
               a2,
               &v11);
  v5 = v11;
  if ( Instance >= 0 && v11 )
  {
    Instance = (*(__int64 (__fastcall **)(__int64, LPVOID *))(*(_QWORD *)v11 + 24LL))(v11, &pv);
    if ( Instance >= 0 )
    {
      _bstr_t::operator=(a3, (const OLECHAR *)pv);
      CoTaskMemFree(pv);
      goto LABEL_23;
    }
    v8 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
      || *((char *)WPP_GLOBAL_Control + 28) >= 0
      || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
    {
      goto LABEL_23;
    }
    v9 = 15;
LABEL_10:
    WPP_SF_D(v8[2], v9, (__int64)&WPP_6a02f12a6b2c3ac58024ebcfa94f3c9a_Traceguids, Instance);
LABEL_23:
    v5 = v11;
    goto LABEL_24;
  }
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && *((char *)WPP_GLOBAL_Control + 28) < 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
  {
    WPP_SF__guid_D(
      *((_QWORD *)WPP_GLOBAL_Control + 2),
      0xEu,
      (__int64)&WPP_6a02f12a6b2c3ac58024ebcfa94f3c9a_Traceguids,
      (__int64)a2);
    goto LABEL_23;
  }
LABEL_24:
  if ( v5 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v5 + 16LL))(v5);
  v11 = 0LL;
  if ( ppv[0] )
    (*(void (__fastcall **)(LPVOID))(*(_QWORD *)ppv[0] + 16LL))(ppv[0]);
  return (unsigned int)Instance;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018006EA34) ----------------------------------------------------
__int64 __fastcall ServerXMLUpdateHandler::NetworkName2Id(
        ServerXMLUpdateHandler *this,
        const wchar_t ***a2,
        struct _GUID *a3)
{
  __int64 v5; // rcx
  BSTR *v6; // rax
  UINT v7; // eax
  int Instance; // ebx
  unsigned __int16 v9; // dx
  __int64 v10; // rcx
  const wchar_t *v11; // rdx
  const wchar_t *v12; // rcx
  _QWORD *v13; // rcx
  unsigned __int16 v14; // dx
  LPVOID pv; // [rsp+30h] [rbp-20h] BYREF
  const wchar_t **v17; // [rsp+38h] [rbp-18h] BYREF
  LPVOID ppv[2]; // [rsp+40h] [rbp-10h] BYREF
  ServerXMLUpdateHandler *v19; // [rsp+70h] [rbp+20h] BYREF
  __int64 v20; // [rsp+78h] [rbp+28h] BYREF
  __int64 v21; // [rsp+88h] [rbp+38h] BYREF

  v19 = this;
  ppv[1] = (LPVOID)-2LL;
  ppv[0] = 0LL;
  v21 = 0LL;
  v5 = 0LL;
  v20 = 0LL;
  v6 = (BSTR *)*a2;
  if ( *a2 && *v6 )
  {
    v7 = SysStringLen(*v6);
    v5 = v20;
  }
  else
  {
    v7 = 0;
  }
  if ( !v7 )
  {
    Instance = -2147216616;
    goto LABEL_46;
  }
  Instance = CoCreateInstance(&CLSID_CNetworkListManager, 0LL, 4u, &IID_INetworkListManagerPrivate, ppv);
  if ( Instance < 0 )
  {
    if ( WPP_GLOBAL_Control == &WPP_GLOBAL_Control
      || *((char *)WPP_GLOBAL_Control + 28) >= 0
      || *((_BYTE *)WPP_GLOBAL_Control + 25) < 2u )
    {
      goto LABEL_45;
    }
    v9 = 16;
    v10 = *((_QWORD *)WPP_GLOBAL_Control + 2);
LABEL_44:
    WPP_SF_D(v10, v9, (__int64)&WPP_6a02f12a6b2c3ac58024ebcfa94f3c9a_Traceguids, Instance);
LABEL_45:
    v5 = v20;
    goto LABEL_46;
  }
  Instance = (*(__int64 (__fastcall **)(LPVOID, __int64, __int64 *))(*(_QWORD *)ppv[0] + 32LL))(ppv[0], 3LL, &v20);
  v5 = v20;
  if ( Instance >= 0 && v20 )
  {
    LODWORD(v19) = 0;
    pv = 0LL;
    v17 = 0LL;
    while ( 1 )
    {
      Instance = (*(__int64 (__fastcall **)(__int64, __int64, __int64 *, ServerXMLUpdateHandler **))(*(_QWORD *)v5 + 24LL))(
                   v5,
                   1LL,
                   &v21,
                   &v19);
      if ( Instance < 0 )
        goto LABEL_39;
      if ( Instance == 1 || !(_DWORD)v19 )
      {
        Instance = 1;
        goto LABEL_39;
      }
      Instance = (*(__int64 (__fastcall **)(__int64, LPVOID *))(*(_QWORD *)v21 + 24LL))(v21, &pv);
      _bstr_t::operator=((_bstr_t::Data_t **)&v17, (const OLECHAR *)pv);
      CoTaskMemFree(pv);
      pv = 0LL;
      if ( Instance < 0 )
        break;
      if ( v17 )
        v11 = *v17;
      else
        v11 = 0LL;
      if ( *a2 )
        v12 = **a2;
      else
        v12 = 0LL;
      if ( !_wcsicmp(v12, v11) )
      {
        Instance = (*(__int64 (__fastcall **)(__int64, struct _GUID *))(*(_QWORD *)v21 + 48LL))(v21, a3);
        if ( Instance < 0 )
        {
          v13 = WPP_GLOBAL_Control;
          if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
            && *((char *)WPP_GLOBAL_Control + 28) < 0
            && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
          {
            v14 = 19;
LABEL_33:
            WPP_SF_D(v13[2], v14, (__int64)&WPP_6a02f12a6b2c3ac58024ebcfa94f3c9a_Traceguids, Instance);
            goto LABEL_39;
          }
        }
        goto LABEL_39;
      }
      v5 = v20;
    }
    v13 = WPP_GLOBAL_Control;
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && *((char *)WPP_GLOBAL_Control + 28) < 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      v14 = 18;
      goto LABEL_33;
    }
LABEL_39:
    _bstr_t::_Free((_bstr_t *)&v17);
    goto LABEL_45;
  }
  if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
    && *((char *)WPP_GLOBAL_Control + 28) < 0
    && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
  {
    v9 = 17;
    v10 = *((_QWORD *)WPP_GLOBAL_Control + 2);
    goto LABEL_44;
  }
LABEL_46:
  if ( v5 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v5 + 16LL))(v5);
  v20 = 0LL;
  if ( v21 )
    (*(void (__fastcall **)(__int64))(*(_QWORD *)v21 + 16LL))(v21);
  v21 = 0LL;
  if ( ppv[0] )
    (*(void (__fastcall **)(LPVOID, _QWORD))(*(_QWORD *)ppv[0] + 16LL))(ppv[0], *(_QWORD *)ppv[0]);
  return (unsigned int)Instance;
}
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

//----- (000000018006ED50) ----------------------------------------------------
__int64 __fastcall ServerXMLUpdateHandler::EnableHandler::Process(__int64 a1, const struct Schema *a2, int a3)
{
  if ( a3 == 71 )
  {
    *(_BYTE *)(a1 + 8) = 1;
    return 0LL;
  }
  if ( !*(_BYTE *)(a1 + 8) || a3 != 19 )
    return 0LL;
  ServerXMLUpdateHandler::WriteEnabled(*(ServerXMLUpdateHandler **)(a1 + 16), a2);
  return 1LL;
}

//----- (000000018006ED88) ----------------------------------------------------
void __fastcall ServerXMLUpdateHandler::WriteContext(__int64 a1, int *a2, int a3, __int64 a4)
{
  __int64 v8; // rbx
  char v9[48]; // [rsp+40h] [rbp-C0h] BYREF
  int *v10; // [rsp+70h] [rbp-90h]
  void *lpMem; // [rsp+78h] [rbp-88h]
  int v12; // [rsp+90h] [rbp-70h] BYREF
  __int64 v13; // [rsp+98h] [rbp-68h]
  __int16 v14; // [rsp+A0h] [rbp-60h]
  char v15; // [rsp+4A2h] [rbp+3A2h]

  ITaskXmlHandler::Data::Data((ITaskXmlHandler::Data *)v9);
  memset_0(v9, 0, 0x48uLL);
  v8 = -1LL;
  do
    ++v8;
  while ( *(_WORD *)(a4 + 2 * v8) );
  v15 &= 0xFCu;
  v12 = 0;
  v13 = 0LL;
  v14 = 0;
  XmlParserTempString::Clear((XmlParserTempString *)&v12);
  v12 = v8;
  v13 = a4;
  v10 = &v12;
  ServerXMLUpdateHandler::WriteContext(a1, a2, a3, a4, (__int64)v9);
  XmlParserTempString::Clear((XmlParserTempString *)&v12);
  operator delete(lpMem);
}

//----- (000000018006EE8C) ----------------------------------------------------
void __fastcall ServerXMLUpdateHandler::WriteEnabled(ServerXMLUpdateHandler *this, const struct Schema *a2)
{
  const unsigned __int16 *v4; // rsi
  int v5; // eax
  int v6; // eax
  char v7[56]; // [rsp+40h] [rbp-58h] BYREF
  void *lpMem; // [rsp+78h] [rbp-20h]

  *((_BYTE *)this + 898) = 1;
  ITaskXmlHandler::Data::Data((ITaskXmlHandler::Data *)v7);
  memset_0(v7, 0, 0x48uLL);
  v4 = L"true";
  if ( !*((_BYTE *)this + 897) )
    v4 = L"false";
  v7[32] = *((_BYTE *)this + 897);
  v5 = _ProcessValue__QITaskXmlHandler__TriggersXmlHandler__MEAAJAEBUSchema__W4TaskXmlNodeId__AEBUData_1__N_Z(
         this,
         (int *)a2,
         19,
         (__int64)v7);
  if ( v5 < 0 && *((int *)this + 268) >= 0 )
    *((_DWORD *)this + 268) = v5;
  v6 = TaskXmlWriter::Element(*((_QWORD *)this + 131), 19, (__int64)v4);
  if ( v6 < 0 && *((int *)this + 268) >= 0 )
    *((_DWORD *)this + 268) = v6;
  operator delete(lpMem);
}

//----- (000000018006EF74) ----------------------------------------------------
void __fastcall ServerXMLUpdateHandler::WriteEnabledAndSettings(ServerXMLUpdateHandler *this, const struct Schema *a2)
{
  int v4; // eax
  int started; // eax
  int v6; // eax
  int v7; // eax

  v4 = _ProcessElement__QITaskXmlHandler__TriggersXmlHandler__MEAAJAEBUSchema__W4TaskXmlNodeId___Z(
         (__int64)this,
         (int *)a2,
         71);
  if ( v4 < 0 && *((int *)this + 268) >= 0 )
    *((_DWORD *)this + 268) = v4;
  started = TaskXmlWriter::StartElement(*((int **)this + 131), 71);
  if ( started < 0 && *((int *)this + 268) >= 0 )
    *((_DWORD *)this + 268) = started;
  ServerXMLUpdateHandler::WriteEnabled(this, a2);
  v6 = _ProcessElementEnd__QITaskXmlHandler__TriggersXmlHandler__MEAAJAEBUSchema__W4TaskXmlNodeId___Z(
         (__int64)this,
         (int *)a2,
         71);
  if ( v6 < 0 && *((int *)this + 268) >= 0 )
    *((_DWORD *)this + 268) = v6;
  v7 = TaskXmlWriter::EndElement(*((_QWORD *)this + 131));
  if ( v7 < 0 && *((int *)this + 268) >= 0 )
    *((_DWORD *)this + 268) = v7;
}

//----- (000000018006F028) ----------------------------------------------------
void __fastcall ServerXMLUpdateHandler::WriteNetworkSettings(
        ServerXMLUpdateHandler *this,
        const struct Schema *a2,
        const struct _GUID *a3,
        __int64 **a4)
{
  __int64 v8; // rbx
  int v9; // eax
  int v10; // eax
  int v11; // eax
  __int64 *v12; // rax
  UINT v13; // eax
  BSTR *v14; // rax
  OLECHAR *v15; // rsi
  UINT v16; // ebx
  int v17; // eax
  __int64 v18; // r8
  int v19; // eax
  int v20; // eax
  char v21[48]; // [rsp+30h] [rbp-D0h] BYREF
  int *v22; // [rsp+60h] [rbp-A0h]
  void *lpMem; // [rsp+68h] [rbp-98h]
  __int64 v24; // [rsp+80h] [rbp-80h]
  int v25; // [rsp+90h] [rbp-70h] BYREF
  OLECHAR *v26; // [rsp+98h] [rbp-68h]
  __int16 v27; // [rsp+A0h] [rbp-60h]
  char v28; // [rsp+4A2h] [rbp+3A2h]
  OLECHAR sz[40]; // [rsp+4B0h] [rbp+3B0h] BYREF

  v24 = -2LL;
  memset_0(sz, 0, sizeof(sz));
  StringFromGUID2(a3, sz, 40);
  ITaskXmlHandler::Data::Data((ITaskXmlHandler::Data *)v21);
  memset_0(v21, 0, 0x48uLL);
  v8 = -1LL;
  do
    ++v8;
  while ( sz[v8] );
  v28 &= 0xFCu;
  v25 = 0;
  v26 = 0LL;
  v27 = 0;
  XmlParserTempString::Clear((XmlParserTempString *)&v25);
  v25 = v8;
  v26 = sz;
  v22 = &v25;
  v9 = _ProcessValue__QITaskXmlHandler__TriggersXmlHandler__MEAAJAEBUSchema__W4TaskXmlNodeId__AEBUData_1__N_Z(
         this,
         (int *)a2,
         92,
         (__int64)v21);
  if ( v9 < 0 && *((int *)this + 268) >= 0 )
    *((_DWORD *)this + 268) = v9;
  v10 = TaskXmlWriter::Element(*((_QWORD *)this + 131), 92, (__int64)sz);
  if ( v10 < 0 && *((int *)this + 268) >= 0 )
    *((_DWORD *)this + 268) = v10;
  v11 = _ProcessElementEnd__QITaskXmlHandler__TriggersXmlHandler__MEAAJAEBUSchema__W4TaskXmlNodeId___Z(
          (__int64)this,
          (int *)a2,
          92);
  if ( v11 < 0 && *((int *)this + 268) >= 0 )
    *((_DWORD *)this + 268) = v11;
  XmlParserTempString::Clear((XmlParserTempString *)&v25);
  operator delete(lpMem);
  v12 = *a4;
  if ( *a4 && *v12 )
    v13 = SysStringLen((BSTR)*v12);
  else
    v13 = 0;
  if ( v13 )
  {
    ITaskXmlHandler::Data::Data((ITaskXmlHandler::Data *)v21);
    memset_0(v21, 0, 0x48uLL);
    v14 = (BSTR *)*a4;
    if ( *a4 )
      v15 = *v14;
    else
      v15 = 0LL;
    if ( v14 && *v14 )
      v16 = SysStringLen(*v14);
    else
      v16 = 0;
    v28 &= 0xFCu;
    v25 = 0;
    v26 = 0LL;
    v27 = 0;
    XmlParserTempString::Clear((XmlParserTempString *)&v25);
    v25 = v16;
    v26 = v15;
    v22 = &v25;
    v17 = _ProcessValue__QITaskXmlHandler__TriggersXmlHandler__MEAAJAEBUSchema__W4TaskXmlNodeId__AEBUData_1__N_Z(
            this,
            (int *)a2,
            91,
            (__int64)v21);
    if ( v17 < 0 && *((int *)this + 268) >= 0 )
      *((_DWORD *)this + 268) = v17;
    if ( *a4 )
      v18 = **a4;
    else
      v18 = 0LL;
    v19 = TaskXmlWriter::Element(*((_QWORD *)this + 131), 91, v18);
    if ( v19 < 0 && *((int *)this + 268) >= 0 )
      *((_DWORD *)this + 268) = v19;
    v20 = _ProcessElementEnd__QITaskXmlHandler__TriggersXmlHandler__MEAAJAEBUSchema__W4TaskXmlNodeId___Z(
            (__int64)this,
            (int *)a2,
            91);
    if ( v20 < 0 && *((int *)this + 268) >= 0 )
      *((_DWORD *)this + 268) = v20;
    XmlParserTempString::Clear((XmlParserTempString *)&v25);
    operator delete(lpMem);
  }
}
// 18006F028: using guessed type OLECHAR sz[40];

//----- (000000018006F31C) ----------------------------------------------------
void __fastcall ServerXMLUpdateHandler::WritePrincipals(
        ServerXMLUpdateHandler *this,
        const struct Schema *a2,
        const unsigned __int16 *a3,
        const unsigned __int16 *a4,
        int a5)
{
  int v8; // eax
  int started; // eax
  int v10; // eax
  int v11; // eax

  v8 = _ProcessElement__QITaskXmlHandler__TriggersXmlHandler__MEAAJAEBUSchema__W4TaskXmlNodeId___Z(
         (__int64)this,
         (int *)a2,
         97);
  if ( v8 < 0 && *((int *)this + 268) >= 0 )
    *((_DWORD *)this + 268) = v8;
  started = TaskXmlWriter::StartElement(*((int **)this + 131), 97);
  if ( started < 0 && *((int *)this + 268) >= 0 )
    *((_DWORD *)this + 268) = started;
  ServerXMLUpdateHandler::WritePrincipal(this, a2, 1, L"Author", a4, a5, 1, 1);
  v10 = _ProcessElementEnd__QITaskXmlHandler__TriggersXmlHandler__MEAAJAEBUSchema__W4TaskXmlNodeId___Z(
          (__int64)this,
          (int *)a2,
          97);
  if ( v10 < 0 && *((int *)this + 268) >= 0 )
    *((_DWORD *)this + 268) = v10;
  v11 = TaskXmlWriter::EndElement(*((_QWORD *)this + 131));
  if ( v11 < 0 && *((int *)this + 268) >= 0 )
    *((_DWORD *)this + 268) = v11;
}

//----- (000000018006F3FC) ----------------------------------------------------
void __fastcall ServerXMLUpdateHandler::WritedRegistraionInfoAndOverrides(
        ServerXMLUpdateHandler *this,
        const struct Schema *a2)
{
  int v4; // eax
  int started; // eax
  int v6; // eax
  int v7; // eax

  if ( JobMoniker::GetPath((ServerXMLUpdateHandler *)((char *)this + 8)) )
  {
    v4 = _ProcessElement__QITaskXmlHandler__TriggersXmlHandler__MEAAJAEBUSchema__W4TaskXmlNodeId___Z(
           (__int64)this,
           (int *)a2,
           3);
    if ( v4 < 0 && *((int *)this + 268) >= 0 )
      *((_DWORD *)this + 268) = v4;
    started = TaskXmlWriter::StartElement(*((int **)this + 131), 3);
    if ( started < 0 && *((int *)this + 268) >= 0 )
      *((_DWORD *)this + 268) = started;
    ServerXMLUpdateHandler::WriteURI(this, a2, 0LL);
    ServerXMLUpdateHandler::WriteSecurityDescriptor(this, a2, 0LL);
    v6 = _ProcessElementEnd__QITaskXmlHandler__TriggersXmlHandler__MEAAJAEBUSchema__W4TaskXmlNodeId___Z(
           (__int64)this,
           (int *)a2,
           3);
    if ( v6 < 0 && *((int *)this + 268) >= 0 )
      *((_DWORD *)this + 268) = v6;
    v7 = TaskXmlWriter::EndElement(*((_QWORD *)this + 131));
    if ( v7 < 0 && *((int *)this + 268) >= 0 )
      *((_DWORD *)this + 268) = v7;
  }
}

//----- (000000018006F4D8) ----------------------------------------------------
__int64 __fastcall JobSecurity::Assign(void **this, void *a2)
{
  SIZE_T v4; // rsi
  HLOCAL v5; // rax
  void *v6; // rcx

  if ( a2 )
  {
    v4 = RtlLengthSecurityDescriptor(a2);
    v5 = LocalAlloc(0, v4);
    tsched::AutoLocalPtr<_SECURITY_DESCRIPTOR>::Attach(this, v5);
    v6 = *this;
    if ( !*this )
      return 2147942414LL;
    *((_DWORD *)this + 2) = v4;
    memcpy_0(v6, a2, v4);
  }
  else
  {
    tsched::AutoLocalPtr<_SECURITY_DESCRIPTOR>::Attach(this, 0LL);
    *((_DWORD *)this + 2) = 0;
  }
  return 0LL;
}

//----- (000000018006F56C) ----------------------------------------------------
int __fastcall JobSecurity::StreamOut(JobSecurity *this, HKEY a2)
{
  int result; // eax

  if ( !*(_QWORD *)this )
    return -2147023537;
  result = RegSetValueExW(a2, L"SD", 0, 3u, *(const BYTE **)this, *((_DWORD *)this + 2));
  if ( !result )
    return 0;
  if ( result > 0 )
    return (unsigned __int16)result | 0x80070000;
  return result;
}

//----- (000000018006F5CC) ----------------------------------------------------
int __fastcall JobSecurity::Update(
        PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
        PSECURITY_DESCRIPTOR ModificationDescriptor,
        HANDLE Token)
{
  NTSTATUS ControlSecurityDescriptor; // eax
  SECURITY_INFORMATION v8; // ebx
  unsigned __int8 OwnerDefaulted; // [rsp+30h] [rbp-40h] BYREF
  unsigned __int8 DaclPresent[3]; // [rsp+31h] [rbp-3Fh] BYREF
  WORD Control; // [rsp+34h] [rbp-3Ch] BYREF
  PSID Owner; // [rsp+38h] [rbp-38h] BYREF
  ULONG Revision; // [rsp+40h] [rbp-30h] BYREF
  PACL Dacl; // [rsp+48h] [rbp-28h] BYREF
  struct _GENERIC_MAPPING GenericMapping; // [rsp+50h] [rbp-20h] BYREF

  Control = 0;
  ControlSecurityDescriptor = RtlGetControlSecurityDescriptor(ModificationDescriptor, &Control, &Revision);
  if ( ControlSecurityDescriptor < 0 )
    return ControlSecurityDescriptor | 0x10000000;
  ControlSecurityDescriptor = RtlGetOwnerSecurityDescriptor(ModificationDescriptor, &Owner, &OwnerDefaulted);
  if ( ControlSecurityDescriptor < 0 )
    return ControlSecurityDescriptor | 0x10000000;
  v8 = Owner != 0LL;
  ControlSecurityDescriptor = RtlGetGroupSecurityDescriptor(ModificationDescriptor, &Owner, &OwnerDefaulted);
  if ( ControlSecurityDescriptor < 0 )
    return ControlSecurityDescriptor | 0x10000000;
  if ( Owner )
    v8 |= 2u;
  ControlSecurityDescriptor = RtlGetDaclSecurityDescriptor(ModificationDescriptor, DaclPresent, &Dacl, &OwnerDefaulted);
  if ( ControlSecurityDescriptor < 0 )
    return ControlSecurityDescriptor | 0x10000000;
  if ( DaclPresent[0] )
  {
    if ( (Control & 0x1000) != 0 )
      v8 |= 0x80000004;
    else
      v8 |= 0x20000004u;
  }
  GenericMapping.GenericRead = 1179785;
  GenericMapping.GenericWrite = 1179926;
  GenericMapping.GenericExecute = 1179808;
  GenericMapping.GenericAll = 2032127;
  ControlSecurityDescriptor = RtlSetSecurityObjectEx(
                                v8,
                                ModificationDescriptor,
                                ObjectsSecurityDescriptor,
                                3u,
                                &GenericMapping,
                                Token);
  if ( ControlSecurityDescriptor < 0 )
    return ControlSecurityDescriptor | 0x10000000;
  *((_DWORD *)ObjectsSecurityDescriptor + 2) = RtlLengthSecurityDescriptor(*ObjectsSecurityDescriptor);
  return 0;
}
// 18006F5CC: using guessed type unsigned __int8 DaclPresent[3];

//----- (000000018006F738) ----------------------------------------------------
__int64 __fastcall TriggersXmlHandler::CheckEventSubscription(TriggersXmlHandler *this, const unsigned __int16 *a2)
{
  EVT_HANDLE v4; // rax
  signed int LastError; // edi
  int v6; // esi
  unsigned int v7; // ebx
  const unsigned __int16 *Path; // rax
  EventManager *v9; // rcx

  v4 = EvtSubscribe(0LL, 0LL, &ChannelPath, a2, 0LL, 0LL, (EVT_SUBSCRIBE_CALLBACK)tsched::EvtNopCallback, 1u);
  if ( v4 )
  {
    EvtClose(v4);
    return 0LL;
  }
  else
  {
    LastError = GetLastError();
    if ( WPP_GLOBAL_Control != &WPP_GLOBAL_Control
      && (*((_DWORD *)WPP_GLOBAL_Control + 7) & 0x10000) != 0
      && *((_BYTE *)WPP_GLOBAL_Control + 25) >= 2u )
    {
      WPP_SF_SD(
        *((_QWORD *)WPP_GLOBAL_Control + 2),
        0xAu,
        (__int64)&WPP_7017595665aa327ef55a7f0df9945125_Traceguids,
        a2);
    }
    v6 = LastError;
    v7 = (unsigned __int16)LastError | 0x80070000;
    if ( LastError > 0 )
      v6 = (unsigned __int16)LastError | 0x80070000;
    Path = JobMoniker::GetPath((TriggersXmlHandler *)((char *)this + 8));
    EventManager::EvtReport(v9, &TASK_EVENT_SUBSCRIPTION_FAILED, Path, v6);
    if ( LastError <= 0 )
      return (unsigned int)LastError;
    return v7;
  }
}
// 18006F805: variable 'v9' is possibly undefined
// 1800AF900: using guessed type void *WPP_GLOBAL_Control;

// nfuncs=1876 queued=1783 decompiled=1783 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 1783 function(s)"
